{"version":3,"sources":["webpack:///./src/js/SOS.js","webpack:///./src/js/XML.js"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA,2CAA2C,yBAAyB;;AAE5C;;AAET;AACf;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,uBAAuB;AACpC,aAAa,cAAc;AAC3B,aAAa,WAAW,GAAG,4CAAG;AAC9B;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,mBAAmB;AAC7C;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,eAAe;AACzC;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC,EAAC;;;;;;;;;;;;;ACjJF;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;;AAEA;AACA;AACA,kCAAkC;AAClC,uCAAuC;AACvC,2BAA2B,4BAA4B;AACvD,qBAAqB,OAAO;AAC5B,qBAAqB,QAAQ;AAC7B;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA,yCAAyC,GAAG;AAC5C;AACA;AACA,eAAe;AACf;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,GAAG;AAChD,yCAAyC;AACzC;AACA,mBAAmB,6BAA6B;AAChD;AACA,mBAAmB;AACnB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA,eAAe;AACf;AACA,eAAe;AACf;AACA;AACA,aAAa,sBAAsB;AACnC;AACA;AACA,eAAe;AACf;AACA;AACA,aAAa,uBAAuB;AACpC;AACA;AACA,eAAe;AACf,6CAA6C,GAAG;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,gCAAgC;AACzC;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,mDAAmD,cAAc;AACjE;;AAEA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,uBAAuB,WAAW;AAClC,6BAA6B,yBAAyB;AACtD,uBAAuB,OAAO;AAC9B;AACA,yBAAyB,KAAK,IAAI,iBAAiB;AACnD;AACA;AACA;AACA,0CAA0C,GAAG;AAC7C;AACA;AACA,0BAA0B,WAAW;AACrC,eAAe;AACf;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb,+BAA+B,YAAY;AAC3C;AACA;AACA;;AAEA,uCAAuC,GAAG;AAC1C;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,OAAO;;AAEP;AACA;AACA,kCAAkC,GAAG;AACrC,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW,6BAA6B;AACxC;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,qCAAqC,OAAO;AAC5C,oBAAoB,2BAA2B,IAAI,KAAK;AACxD;AACA,OAAO;AACP;AACA,kBAAkB,IAAI,GAAG,KAAK;AAC9B;AACA;AACA,uBAAuB,YAAY,IAAI,gBAAgB;AACvD,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,iCAAiC,KAAK;AACtC,aAAa;AACb,uCAAuC,IAAI;AAC3C;AACA,WAAW;AACX,oBAAoB,+CAA+C,IAAI,KAAK;AAC5E;AACA,OAAO;AACP,kBAAkB,IAAI,GAAG,KAAK,GAAG,aAAa,IAAI,KAAK;AACvD;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH,CAAC,EAAC","file":"SensorWidgets~widget-compass-js~widget-gauge-js~widget-jqgrid-js~widget-map-js~widget-panel-js~widge~45b60b0c.chunk.js","sourcesContent":["/* eslint no-underscore-dangle: [\"error\", { \"allowAfterThis\": true }] */\n\nimport XML from './XML';\n\nexport default {\n  _url: null,\n\n  setUrl(url) {\n    this._url = url;\n  },\n\n  getCapabilities(callback, errorHandler) {\n    const request = {\n      request: 'GetCapabilities',\n      sections: ['Contents'],\n    };\n\n    this._send(request, (response) => {\n      callback(response.contents);\n    }, errorHandler);\n  },\n\n  describeSensor(procedure, callback, errorHandler) {\n    const request = {\n      request: 'DescribeSensor',\n      procedure,\n      procedureDescriptionFormat: 'http://www.opengis.net/sensorML/1.0.1',\n    };\n\n    this._send(request, (response) => {\n      // Convert the SensorML description to a JSON object\n      const { procedureDescription } = response;\n      const { description } = procedureDescription;\n      const { SensorML } = XML.read(description || procedureDescription, true);\n      callback(SensorML.member);\n    }, errorHandler);\n  },\n\n  getFeatureOfInterest(procedure, callback, errorHandler) {\n    const request = {\n      request: 'GetFeatureOfInterest',\n      procedure,\n    };\n\n    this._send(request, (response) => {\n      callback(response.featureOfInterest);\n    }, errorHandler);\n  },\n\n  getDataAvailability(procedure, offering, features, properties, callback, errorHandler) {\n    const request = {\n      request: 'GetDataAvailability',\n    };\n    if (procedure) {\n      request.procedure = procedure;\n    }\n    if (offering) {\n      request.offering = offering;\n    }\n    if (features && features.length) {\n      request.featureOfInterest = features;\n    }\n    if (properties && properties.length) {\n      request.observedProperty = properties;\n    }\n\n    this._send(request, ({ dataAvailability }) => {\n      callback(dataAvailability);\n    }, errorHandler);\n  },\n\n  getObservation(offering, features, properties, time, callback, errorHandler) {\n    const request = {\n      request: 'GetObservation',\n    };\n\n    if (offering) {\n      request.offering = offering;\n    }\n\n    if (features && features.length) {\n      request.featureOfInterest = features;\n    }\n\n    if (properties && properties.length) {\n      request.observedProperty = properties;\n    }\n\n    if (time) {\n      let operation;\n      if (time.length && time.length === 2) {\n        // Time Range\n        operation = 'during';\n      } else {\n        // Time Instant\n        operation = 'equals';\n      }\n      const filter = {};\n      filter[operation] = {\n        ref: 'om:resultTime',\n        value: time,\n      };\n      request.temporalFilter = [filter];\n    }\n\n    this._send(request, ({ observations }) => {\n      callback(observations);\n    }, errorHandler);\n  },\n\n  _send(request, onSuccess, onError) {\n    request.service = 'SOS';\n    request.version = '2.0.0';\n\n    const xhr = new XMLHttpRequest();\n\n    xhr.onreadystatechange = () => {\n      if (xhr.readyState === 4) {\n        let response = xhr.responseText;\n        try {\n          response = JSON.parse(response);\n        } catch (e) {\n          // OK, not JSON\n        }\n        if (xhr.status === 200) {\n          onSuccess.call(this, response);\n        } else {\n          const e = {\n            status: xhr.statusText,\n            url: this._url,\n            request,\n            response,\n          };\n          if (onError) {\n            onError.call(this, e.status, e.url, e.request, e.response);\n          }\n        }\n      }\n    };\n\n    xhr.open('POST', this._url, true);\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    xhr.setRequestHeader('Accept', 'application/json');\n    xhr.send(JSON.stringify(request));\n  },\n};\n","/* This work is licensed under Creative Commons GNU LGPL License.\n\n License: http://creativecommons.org/licenses/LGPL/2.1/\n Version: 0.9\n Author:  Stefan Goessner/2006\n See:     http://goessner.net/download/prj/jsonxml/\n */\nexport default {\n  read(xml, clean) {\n    const X = {\n      at: (clean ? '' : '@'),\n\n      toObj(elem) {\n        let o = {};\n        if (elem.nodeType === 1) { // element node\n          if (elem.attributes.length) { // element with attributes\n            for (let i = 0; i < elem.attributes.length; i += 1) {\n              const { name } = elem.attributes[i];\n              const { value } = elem.attributes[i];\n              const isNs = name.lastIndexOf('xmlns:', 0) === 0;\n              if (!(clean && isNs)) { // Hide xmlns attributes\n                o[X.at + name] = (value || '').toString();\n              }\n            }\n          }\n          if (elem.firstChild) { // element has child nodes\n            let textChild = 0;\n            let cdataChild = 0;\n            let hasElementChild = false;\n            for (let n = elem.firstChild; n; n = n.nextSibling) {\n              if (n.nodeType === 1) {\n                hasElementChild = true;\n              } else if (n.nodeType === 3 && n.nodeValue.match(/[^ \\f\\n\\r\\t\\v]/)) {\n                textChild += 1;\n                // non-whitespace text\n              } else if (n.nodeType === 4) {\n                cdataChild += 1;\n                // cdata section node\n              }\n            }\n            if (hasElementChild) {\n              if (textChild < 2 && cdataChild < 2) {\n                // structured element with evtl.\n                // a single text or/and cdata node\n                X.removeWhite(elem);\n                for (let n = elem.firstChild; n; n = n.nextSibling) {\n                  if (n.nodeType === 3) { // text node\n                    o['#text'] = X.escape(n.nodeValue);\n                  } else if (n.nodeType === 4) { // cdata node\n                    o['#cdata'] = X.escape(n.nodeValue);\n                  } else if (o[n.nodeName]) {\n                    // multiple occurence of element\n                    if (o[n.nodeName] instanceof Array) {\n                      o[n.nodeName][o[n.nodeName].length] = X.toObj(n);\n                    } else {\n                      o[n.nodeName] = [o[n.nodeName], X.toObj(n)];\n                    }\n                  } else { // first occurence of element\n                    o[n.nodeName] = X.toObj(n);\n                  }\n                }\n              } else if (!elem.attributes.length) {\n                o = X.escape(X.innerXml(elem));\n              } else {\n                o['#text'] = X.escape(X.innerXml(elem));\n              }\n            } else if (textChild) { // pure text\n              if (!elem.attributes.length) {\n                o = X.escape(X.innerXml(elem));\n              } else {\n                o['#text'] = X.escape(X.innerXml(elem));\n              }\n            } else if (cdataChild) { // cdata\n              if (cdataChild > 1) {\n                o = X.escape(X.innerXml(elem));\n              } else {\n                for (let n = elem.firstChild; n; n = n.nextSibling) {\n                  o['#cdata'] = X.escape(n.nodeValue);\n                }\n              }\n            }\n          }\n          if (!elem.attributes.length && !elem.firstChild) {\n            o = null;\n          }\n        } else if (elem.nodeType === 9) { // document.node\n          o = X.toObj(elem.documentElement);\n        } else if (elem.nodeType === 8) {\n          return elem.data;\n          // A comment\n        } else {\n          // console.error(`unhandled node type: ${elem.nodeType}`);\n        }\n\n        return o;\n      },\n\n      innerXml(node) {\n        let str = '';\n        if ('innerHTML' in node) {\n          str = node.innerHTML;\n        } else {\n          const asXml = (n) => {\n            let s = '';\n            if (n.nodeType === 1) {\n              s += `<${n.nodeName}`;\n              for (let i = 0; i < n.attributes.length; i += 1) {\n                const { name } = n.attributes[i];\n                const value = n.attributes[i].value || '';\n                s += ` ${name}=\"${value.toString()}\"`;\n              }\n              if (n.firstChild) {\n                s += '>';\n                for (let c = n.firstChild; c; c = c.nextSibling) {\n                  s += asXml(c);\n                }\n                s += `</${n.nodeName}>`;\n              } else {\n                s += '/>';\n              }\n            } else if (n.nodeType === 3) {\n              s += n.nodeValue;\n            } else if (n.nodeType === 4) {\n              s += `<![CDATA[${n.nodeValue}]]>`;\n            }\n            return s;\n          };\n\n          for (let c = node.firstChild; c; c = c.nextSibling) {\n            str += asXml(c);\n          }\n        }\n        return str;\n      },\n\n      escape(txt) {\n        return txt.replace(/[\\\\]/g, '\\\\\\\\').replace(/[\"]/g, '\\\\\"').replace(/[\\n]/g, '\\\\n').replace(/[\\r]/g, '\\\\r');\n      },\n\n      removeWhite(e) {\n        e.normalize();\n        for (let n = e.firstChild; n;) {\n          if (n.nodeType === 3) { // text node\n            if (!n.nodeValue.match(/[^ \\f\\n\\r\\t\\v]/)) {\n              // pure whitespace text node\n              const nxt = n.nextSibling;\n              e.removeChild(n);\n              n = nxt;\n            } else {\n              n = n.nextSibling;\n            }\n          } else if (n.nodeType === 1) { // element node\n            X.removeWhite(n);\n            n = n.nextSibling;\n          } else { // any other node\n            n = n.nextSibling;\n          }\n        }\n        return e;\n      },\n    };\n\n    // Strip namespaces from XML tags\n    const cleanXml = clean ? xml.replace(/<(\\/?)([^:>\\s]*:)?([^>]+)>/g, '<$1$3>') : xml;\n\n    // Convert to an XML DOM Document\n    const domRoot = (new DOMParser()).parseFromString(cleanXml, 'text/xml');\n\n    // Start from document's root element\n    const domElem = (domRoot.nodeType === 9) ? domRoot.documentElement : domRoot;\n\n    const ret = {};\n    ret[domElem.nodeName] = X.toObj(X.removeWhite(domElem));\n    return ret;\n  },\n\n  write(object) {\n    const toXml = (v, name, ind) => {\n      let xml = '';\n      if (v instanceof Array) {\n        for (let i = 0, n = v.length; i < n; i += 1) {\n          xml += `${ind + toXml(v[i], name, `${ind}\\t`)}\\n`;\n        }\n      } else if (typeof (v) === 'object') {\n        let hasChild = false;\n        xml += `${ind}<${name}`;\n        Object.keys(v).forEach((m) => {\n          if (m.charAt(0) === '@') {\n            xml += ` ${m.substr(1)}=\"${v[m].toString()}\"`;\n          } else {\n            hasChild = true;\n          }\n        });\n        xml += hasChild ? '>' : '/>';\n        if (hasChild) {\n          Object.keys(v).forEach((m) => {\n            if (m === '#text') {\n              xml += v[m];\n            } else if (m === '#cdata') {\n              xml += `<![CDATA[${v[m]}]]>`;\n            } else if (m.charAt(0) !== '@') {\n              xml += toXml(v[m], m, `${ind}\\t`);\n            }\n          });\n          xml += `${xml.charAt(xml.length - 1) === '\\n' ? ind : ''}</${name}>`;\n        }\n      } else {\n        xml += `${ind}<${name}>${v.toString()}</${name}>`;\n      }\n      return xml;\n    };\n\n    let xml = '';\n    Object.keys(object).forEach((i) => {\n      xml += toXml(object[i], i, '');\n    });\n    return xml;\n  },\n};\n"],"sourceRoot":""}