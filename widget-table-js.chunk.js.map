{"version":3,"sources":["webpack:///./src/js/sos-data-access.js","webpack:///./src/js/widget/table.js"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AACwB;;AAExB;AACA;AACA;;AAEe;AACf,EAAE,4CAAG;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,4CAAG;AACP;;AAEA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;ACjHF;AAAA;AAAA;AAAA;AAAA;AAC4C;AACZ;AACM;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe;AACf,UAAU,sDAAM;AAChB,mBAAmB,sDAAM;AACzB,oBAAoB,iBAAiB;;AAErC;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI,sDAAM;;AAEV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,uBAAuB,KAAK,IAAI,IAAI;AACpC,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oDAAE,uCAAuC;AAC7E;AACA,yBAAyB,uBAAuB;AAChD,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA,iBAAiB,gEAAU;AAC3B;AACA,GAAG;AACH,CAAC,EAAC","file":"widget-table-js.chunk.js","sourcesContent":["/* eslint-disable no-nested-ternary, camelcase */\nimport SOS from './SOS';\n\nconst propertyNames = {};\nconst waitingDescribeResponse = {};\nconst propertyCallbackQueue = {};\n\nexport default (config, redraw, errorHandler) => {\n  SOS.setUrl(config.service);\n\n  function isArray(obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n  }\n\n  function getPropertyName(procedure, id, callback, context) {\n    if (!propertyNames[procedure]) {\n      // Queue callback call\n      if (!propertyCallbackQueue[procedure]) {\n        propertyCallbackQueue[procedure] = [];\n      }\n\n      propertyCallbackQueue[procedure].push({\n        callback,\n        id,\n        context,\n      });\n\n      if (!waitingDescribeResponse[procedure]) {\n        waitingDescribeResponse[procedure] = true;\n        // Trigger a DescribeSensor, cache all property names for this procedure\n        SOS.describeSensor(procedure, (description) => {\n          let properties = Object.prototype.hasOwnProperty.call(description, 'ProcessModel')\n            ? description.ProcessModel.outputs.OutputList.output\n            : description.System.outputs.OutputList.output;\n          properties = properties instanceof Array ? properties : [properties];\n          const types = ['Quantity', 'Count', 'Boolean', 'Category', 'Text', 'ObservableProperty'];\n\n          const names = [];\n          Object.values(properties).forEach((property) => {\n            Object.values(types).forEach((type) => {\n              if (Object.prototype.hasOwnProperty.call(property, type)) {\n                // eslint-disable-next-line no-param-reassign\n                property.id = property[type].definition;\n              }\n            });\n            names[property.id] = property.name;\n          });\n          propertyNames[procedure] = names;\n\n          // Clear propertyCallbackQueue\n          while (propertyCallbackQueue[procedure].length) {\n            const elem = propertyCallbackQueue[procedure].shift();\n            elem.callback.call(undefined, propertyNames[procedure][elem.id], elem.context);\n          }\n        }, errorHandler);\n      }\n    } else {\n      callback(propertyNames[procedure][id], context);\n    }\n  }\n\n  function parse(observations) {\n    if (!observations.length) {\n      redraw([]);\n    }\n\n    // Get tabular data from observations\n    const data = [];\n\n    function addObservation(property, observation) {\n      const foi = observation.featureOfInterest;\n      data.push({\n        time: new Date(observation.resultTime),\n        value: Object.prototype.hasOwnProperty.call(observation.result, 'value') ? observation.result.value : observation.result,\n        feature: foi.name ? foi.name.value : (foi.identifier ? foi.identifier.value : foi),\n        property,\n        uom: Object.prototype.hasOwnProperty.call(observation.result, 'uom') ? observation.result.uom : '(N/A)',\n      });\n      if (data.length === observations.length) {\n        redraw(data);\n      }\n    }\n    Object.values(observations).forEach((observation) => {\n      getPropertyName(observation.procedure, observation.observableProperty,\n        addObservation, observation);\n    });\n  }\n\n  function read() {\n    const {\n      offering, feature, property, features, properties, time_start, time_end,\n    } = config;\n    const getFeatures = feature\n      ? [feature]\n      : isArray(features)\n        ? features\n        : features\n          ? JSON.parse(features)\n          : undefined;\n    const getProperties = property\n      ? [property]\n      : isArray(properties)\n        ? properties\n        : properties\n          ? JSON.parse(properties)\n          : undefined;\n    const time = (time_start && time_end) ? [time_start, time_end] : 'latest';\n    SOS.getObservation(offering, getFeatures, getProperties, time, parse, errorHandler);\n  }\n\n  return {\n    read,\n  };\n};\n","/* eslint-disable no-param-reassign */\nimport dataAccess from '../sos-data-access';\nimport ld from '../locale-date';\nimport common from '../widget-common';\n\nconst template = [\n  '<div class=\"table widget\">',\n  '<h3></h3>',\n  '<div class=\"table-responsive\"></div>',\n  '<div><span class=\"footnote\"></span></div>',\n  '</div>',\n].join('');\n\nexport default {\n  inputs: common.inputs.concat(['feature', 'properties', 'time_start', 'time_end', 'title']),\n  optional_inputs: common.optional_inputs,\n  preferredSizes: [{ w: 400, h: 400 }],\n\n  init(config, el, errorHandler) {\n    // Render template\n    el.innerHTML = template;\n    el.querySelector('h3').innerHTML = config.title;\n    const table = el.querySelector('.table-responsive');\n\n    // load widget common features\n    common.init(config, el);\n\n    // Update view\n    function createTable(measures, properties) {\n      let html = '<table class=\"table table-striped table-condensed table-hover table-bordered\">';\n      html += '<thead>';\n      html += '<tr>';\n      html += '<th>Result Time</th>';\n\n      const sortedNames = Object.keys(properties).sort();\n      Object.keys(sortedNames).forEach((i) => {\n        const name = sortedNames[i];\n        const { uom } = properties[name];\n        html += `<th>${name} (${uom})</th>`;\n      });\n      html += '</tr>';\n      html += '</thead>';\n\n      const times = Object.keys(measures);\n      times.sort().reverse();\n      Object.keys(times).forEach((i) => {\n        const time = times[i];\n        const values = measures[time];\n        html += '<tr>';\n        html += `<th class=\"time\">${ld.display(new Date(parseInt(time, 10)))}</th>`;\n        Object.keys(sortedNames).forEach((j) => {\n          html += `<td>${values[sortedNames[j]]}</td>`;\n        });\n        html += '</tr>';\n      });\n      html += '</table>';\n      table.innerHTML = html;\n    }\n\n    function redraw(data) {\n      // Get tabular data from observations\n      const measures = {};\n      const properties = {};\n      Object.keys(data).forEach((i) => {\n        const measure = data[i];\n\n        // Add value in a time-indexed \"measures\" object\n        const time = measure.time.getTime();\n        if (!measures[time]) {\n          measures[time] = {};\n        }\n        measures[time][measure.property] = measure.value;\n\n        // Add property to a \"properties\" object, including uom\n        if (!properties[measure.property]) {\n          properties[measure.property] = {\n            name: measure.property,\n            uom: measure.uom,\n          };\n        }\n      });\n\n      createTable(measures, properties);\n    }\n\n    // Setup SOS data access\n    const data = dataAccess(config, redraw, errorHandler);\n    data.read();\n  },\n};\n"],"sourceRoot":""}