{"version":3,"sources":["webpack:///./node_modules/flot-plugins/dist/source/misc/jquery.flot.tooltip.js","webpack:///./node_modules/flot/lib/jquery.mousewheel.js","webpack:///./node_modules/flot/source/jquery.canvaswrapper.js","webpack:///./node_modules/flot/source/jquery.colorhelpers.js","webpack:///./node_modules/flot/source/jquery.flot.axislabels.js","webpack:///./node_modules/flot/source/jquery.flot.browser.js","webpack:///./node_modules/flot/source/jquery.flot.categories.js","webpack:///./node_modules/flot/source/jquery.flot.composeImages.js","webpack:///./node_modules/flot/source/jquery.flot.crosshair.js","webpack:///./node_modules/flot/source/jquery.flot.drawSeries.js","webpack:///./node_modules/flot/source/jquery.flot.errorbars.js","webpack:///./node_modules/flot/source/jquery.flot.fillbetween.js","webpack:///./node_modules/flot/source/jquery.flot.flatdata.js","webpack:///./node_modules/flot/source/jquery.flot.hover.js","webpack:///./node_modules/flot/source/jquery.flot.image.js","webpack:///./node_modules/flot/source/jquery.flot.js","webpack:///./node_modules/flot/source/jquery.flot.legend.js","webpack:///./node_modules/flot/source/jquery.flot.logaxis.js","webpack:///./node_modules/flot/source/jquery.flot.navigate.js","webpack:///./node_modules/flot/source/jquery.flot.pie.js","webpack:///./node_modules/flot/source/jquery.flot.resize.js","webpack:///./node_modules/flot/source/jquery.flot.saturated.js","webpack:///./node_modules/flot/source/jquery.flot.selection.js","webpack:///./node_modules/flot/source/jquery.flot.stack.js","webpack:///./node_modules/flot/source/jquery.flot.symbol.js","webpack:///./node_modules/flot/source/jquery.flot.threshold.js","webpack:///./node_modules/flot/source/jquery.flot.time.js","webpack:///./node_modules/flot/source/jquery.flot.touch.js","webpack:///./node_modules/flot/source/jquery.flot.touchNavigate.js","webpack:///./node_modules/flot/source/jquery.flot.uiConstants.js"],"names":[],"mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,uDAAuD;;AAEvD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,4BAA4B;;AAE5B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oGAAoG,KAAK;AACzG;AACA;AACA;AACA,+DAA+D;AAC/D,oEAAoE;;AAEpE;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,wBAAwB;AAC3D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qCAAqC,mEAAmE;AACxG,qCAAqC;;AAErC;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,+CAA+C;AACpF;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kDAAkD,qBAAqB;;AAEvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;AACA;AACA,mCAAmC,IAAI,IAAI,GAAG;AAC9C;AACA;AACA,kCAAkC;AAClC,kCAAkC;AAClC,6BAA6B,IAAI,IAAI,GAAG;AACxC,6BAA6B,IAAI,IAAI,GAAG;AACxC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL,CAAC;;;;;;;;;;;;AC7lBD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,6BAA6B,GAAG;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA,qCAAqC,GAAG;AACxC;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA;AACA,qCAAqC,GAAG;AACxC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,iCAAiC;AACjE,gCAAgC,4BAA4B;;AAE5D;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,+CAA+C,mCAAmC;AAClF,+CAA+C,sCAAsC;;AAErF;AACA;;AAEA;AACA;;AAEA,CAAC;;;;;;;;;;;;ACrFD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB;AACvB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,mEAAmE;AACnE;AACA,mCAAmC;;AAEnC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yDAAyD,cAAc;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;;AAEA,kEAAkE;AAClE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA,sCAAsC;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;;AAEA,iCAAiC,cAAc;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,oDAAoD;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;ACpiBD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,cAAc;AACzC;AACA;;AAEA;AACA;;AAEA;AACA,2BAA2B,cAAc;AACzC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,IAAI,eAAe,IAAI,eAAe,IAAI;AACxE;AACA;AACA;;AAEA;AACA,+BAA+B,IAAI,eAAe,IAAI,eAAe,IAAI;AACzE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,EAAE,cAAc,EAAE,cAAc,EAAE;AAC/D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;ACtMD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC;;AAEnC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;;;;;;;;;;;ACnND;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,6DAA6D,EAAE;AAChJ,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,+BAA+B,MAAK;AACpC,SAAS;;AAET;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;ACjGD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kCAAkC,SAAS,qBAAqB,EAAE;;AAElE;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB,2DAA2D;AACpF,yBAAyB,4DAA4D;;AAErF;AACA;AACA,6BAA6B,mFAAmF;AAChH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC,oBAAoB,EAAE;;AAExD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;;AAEA,2BAA2B,QAAQ;AACnC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;;;;;;;;;;;ACzMD;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6CAA6C;AAC7C;;AAEA;AACA;AACA;AACA,6CAA6C;AAC7C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,uCAAuC,qBAAqB,eAAe;AAC3E;AACA;AACA;AACA;;AAEA;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,mCAAmC;AACnC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8CAA8C;AAC9C,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C;AAC3C,aAAa;AACb;AACA;;AAEA,2BAA2B,oBAAoB;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;;;;;;;;;;;ACzUD;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,UAAU,mBAAmB;AAC7B;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,4CAA4C,aAAa,YAAY,EAAE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gDAAgD;;AAEhD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC;AACjC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;;;;;;;;;;;ACzMD;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB;;AAExB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,mBAAmB;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,mBAAmB;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;ACrpBD;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,mBAAmB;AACnB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kGAAkG;AACzH,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,wCAAwC;AACrD,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA6B,wCAAwC;AACrE,6BAA6B,wCAAwC;AACrE,aAAa;AACb,6BAA6B,wCAAwC;AACrE;AACA;AACA;AACA;AACA;AACA,6BAA6B,wCAAwC;AACrE,6BAA6B,wCAAwC;AACrE,aAAa;AACb,6BAA6B,wCAAwC;AACrE;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,gCAAgC;AACvD;AACA;;AAEA;AACA,2BAA2B,gBAAgB;AAC3C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;;;;;;;;;;;ACtXD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS,2BAA2B;AACpC,SAAS,oCAAoC;AAC7C;;AAEA,wCAAwC,SAAS,0BAA0B;;AAE3E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,qBAAqB;AACpD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA,+BAA+B,QAAQ;AACvC;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,QAAQ;AAC3C;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mCAAmC,QAAQ;AAC3C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;;;;;;;;;;;AC7PD;;AAEA;AACA;AACA;;AAEA;;AAEA,iDAAiD;AACjD,mBAAmB,mCAAmC,GAAG;;AAEzD;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kCAAkC,iBAAiB;AACnD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL,CAAC;;;;;;;;;;;;AC9CD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA;;AAEA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA,+BAA+B,uBAAuB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;;;;;;;;;;;ACtWD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,uBAAuB;AACvB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,iBAAiB;AAC9B,aAAa,wCAAwC;AACrD,aAAa,wCAAwC;AACrD,aAAa,wCAAwC;AACrD,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;;;;;;;;;;;ACxPD;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;;AAEf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,qBAAqB;AAClD,kCAAkC,yBAAyB;AAC3D,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,qBAAqB;AAClD,kCAAkC,yBAAyB;AAC3D,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,qCAAqC;;AAErC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;;AAEA,+CAA+C;AAC/C;;AAEA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;;AAEA,+CAA+C;AAC/C;;AAEA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,0BAA0B;AACjD;AACA;;AAEA,uBAAuB,0BAA0B;AACjD;AACA;;AAEA;AACA;AACA,gEAAgE;AAChE,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,cAAc;AACzC,yCAAyC;;AAEzC;AACA,uCAAuC;AACvC;;AAEA;;AAEA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB;AACtB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB;AACxB;;AAEA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,kBAAkB;AACzC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uBAAuB,mBAAmB;AAC1C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;;AAEA;;AAEA,6DAA6D;;AAE7D;AACA;AACA;;AAEA,+BAA+B,iBAAiB;AAChD;;AAEA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;;AAEA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC;AAClC;;AAEA;AACA,uBAAuB,mBAAmB;AAC1C;;AAEA;AACA;;AAEA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;;AAEA,+CAA+C,wBAAwB,EAAE;AACzE;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA,wDAAwD;AACxD;;AAEA;AACA,iEAAiE;;AAEjE;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4BAA4B,qFAAqF;AACjH;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,kBAAkB;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;;AAEA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;;AAEb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA,kDAAkD,QAAQ;AAC1D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,0CAA0C;AAC1C;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mCAAmC,4BAA4B;AAC/D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2BAA2B,qBAAqB;AAChD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,mBAAmB;AAClD;AACA;AACA,2CAA2C;AAC3C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,2CAA2C;AAC3C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,2BAA2B,iBAAiB;AAC5C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wCAAwC;AACvE;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,2CAA2C;AAC3C,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,2CAA2C;AAC3C;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,2BAA2B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,2BAA2B;AAC9D;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+BAA+B,qCAAqC;AACpE;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yCAAyC,eAAe;;AAExD,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC,QAAQ;AAC/C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,oCAAoC,uEAAuE;AAC3G;AACA;AACA;;AAEA,iDAAiD;AACjD;AACA;AACA,oCAAoC,oEAAoE;AACxG;AACA;AACA;;AAEA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC;AACzC,yCAAyC;;AAEzC;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb,kDAAkD;AAClD;AACA;AACA;;AAEA,uDAAuD,OAAO;AAC9D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;ACjwFD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mEAAmE,eAAe;AAClF;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,0DAA0D;AAC1D,SAAS;AACT,gEAAgE;AAChE;;AAEA;AACA,8DAA8D;AAC9D,SAAS;AACT,4DAA4D;AAC5D;;AAEA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;;AAEA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;;;;;;;;;;;ACpbD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oCAAoC,mBAAmB;AACvD;AACA,8BAA8B,UAAU;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC,eAAe;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,CAAC;;;;;;;;;;;;ACzSD;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,sCAAsC,SAAS;AAC/C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,eAAe,UAAU,oBAAoB,EAAE;;AAE/C;AACA,kBAAkB,UAAU,oBAAoB,EAAE;;AAElD;AACA,eAAe,qBAAqB,oBAAoB,EAAE;;AAE1D;AACA,cAAc,sBAAsB;AACpC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA,gCAAgC,aAAa;AAC7C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,8DAA8D;AAC9D;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0CAA0C,QAAQ;;AAElD;AACA;;AAEA,2BAA2B,8BAA8B;;AAEzD;AACA,kDAAkD;AAClD;AACA,kBAAkB;AAClB,aAAa;AACb,kDAAkD,YAAY;AAC9D;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,qBAAqB;AACrB,+CAA+C;AAC/C;AACA,iBAAiB;AACjB,2CAA2C;AAC3C;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;;AAEA;AACA,wBAAwB;AACxB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B;AAC5B;AACA,4BAA4B;AAC5B;AACA,4BAA4B;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;;;;;;;;;;;ACj0BD;;AAEA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,uBAAuB,iBAAiB;AACxC;;AAEA;AACA;;AAEA;AACA,2BAA2B;AAC3B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;;AAEA;;AAEA,uBAAuB,iBAAiB;AACxC;AACA;;AAEA;AACA,yBAAyB;;AAEzB,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yEAAyE;AACzE;;AAEA;AACA;AACA;AACA,qCAAqC;AACrC;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B;AAC3B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+BAA+B,WAAW;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yCAAyC,iBAAiB;;AAE1D;AACA;;AAEA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mBAAmB;AAClD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA,yCAAyC;AACzC;;AAEA,6DAA6D;AAC7D;AACA;AACA;AACA,wCAAwC;AACxC;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mCAAmC,mBAAmB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+GAA+G,gBAAgB,iBAAiB;AAChJ;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,8DAA8D,yBAAyB;AACvF,wFAAwF,8BAA8B,gCAAgC,sCAAsC;AAC5L;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb,SAAS;;AAET;;AAEA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,mEAAmE,SAAS;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA,qCAAqC;AACrC,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,uBAAuB;AACtD;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,uBAAuB;AACvB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,iCAAiC,wBAAwB;AACzD;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2BAA2B,uBAAuB;AAClD;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qGAAqG;AACrG;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,8DAA8D,kBAAkB,YAAY,0BAA0B;AACtH,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;;;;;;;;;;;ACzxBD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY,wCAAwC,+GAA+G,SAAS,QAAQ,UAAU,oBAAoB,iBAAiB,mBAAmB,aAAa,cAAc,aAAa,UAAU,yBAAyB,EAAE,iBAAiB,IAAI,KAAK,qBAAqB,mBAAmB,aAAa,cAAc,qBAAqB,KAAK,KAAK,eAAe,cAAc,OAAO,gBAAgB,cAAc,MAAM,wBAAwB,KAAK,gBAAgB,QAAQ,iBAAiB,mBAAmB,aAAa,MAAM,kBAAkB,8BAA8B,sBAAsB,uBAAuB,wBAAwB,oBAAoB,IAAI,SAAS,KAAK,YAAY,eAAe,cAAc,aAAa,OAAO,qBAAqB,KAAK,KAAK,cAAc,8BAA8B,yCAAyC,0BAA0B,2BAA2B,WAAW,KAAK,YAAY,MAAM,OAAO,aAAa,0BAA0B,6BAA6B,KAAK,qBAAqB,UAAU,6BAA6B,mCAAmC,qIAAqI,+BAA+B,wBAAwB,QAAQ,GAAG,4BAA4B,kCAAkC,4JAA4J,IAAI;;AAE3nD;AACA;AACA,mBAAmB,GAAG;;AAEtB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;;;;;;;;;;;AC3DD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA,+BAA+B,UAAU;AACzC;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;AC1CD;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,SAAS,kBAAkB,UAAU,mBAAmB,EAAE;;AAE5E;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC,qBAAqB,aAAa;AAClC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,sDAAsD,cAAc;AACpE;AACA;AACA;AACA,+CAA+C,cAAc;AAC7D;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,sBAAsB;AACtB,sBAAsB,2CAA2C;AACjE,sBAAsB;;AAEtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,6DAA6D,qEAAqE;AAClI;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB;AACpB;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL,CAAC;;;;;;;;;;;;AC9gBD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,iBAAiB,cAAc;AAC/B;;AAEA;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,2BAA2B,8BAA8B;AACzD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA,+BAA+B,QAAQ;AACvC;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,QAAQ;AAC3C;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;;AAEA,mCAAmC,QAAQ;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;;;;;;;;;;;AC3ND;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;;;;;;;;;;;ACjGD;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,oBAAoB;AACpB,KAAK;;AAEL;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,iBAAiB,kBAAkB,QAAQ;AAC3C;;AAEA;AACA;AACA;AACA,yCAAyC,KAAK;;AAE9C,sCAAsC;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,uBAAuB;AAC9C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;;AAEA,iCAAiC;AACjC;AACA,+BAA+B,QAAQ;AACvC;AACA;;AAEA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;;;;;;;;;;;AC9ID;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,6DAA6D,oCAAoC;;AAEjG,iDAAiD,+BAA+B;;AAEhF;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;AACA,uBAAuB,gBAAgB;AACvC;;AAEA;AACA;AACA,aAAa;AACb;AACA,4DAA4D;AAC5D,gEAAgE;AAChE,uDAAuD;AACvD,4DAA4D;AAC5D,0DAA0D;AAC1D,iDAAiD;AACjD,mDAAmD;AACnD,wDAAwD;AACxD,4DAA4D;AAC5D,0DAA0D;AAC1D;AACA;AACA,oEAAoE;AACpE,0DAA0D;AAC1D,4GAA4G;AAC5G,iEAAiE;AACjE,uDAAuD;AACvD,qEAAqE;AACrE,qEAAqE;AACrE,kDAAkD;AAClD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,uBAAuB,kBAAkB;AACzC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB;AACzB;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB;AACA;AACA,yBAAyB;AACzB;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,yBAAyB;AACzB;AACA,yBAAyB;AACzB;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,yBAAyB;AACzB;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACzkBD;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC,aAAa;AAC/C,gCAAgC,aAAa;AAC7C,0BAA0B,aAAa;AACvC,6BAA6B,aAAa;AAC1C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yEAAyE,YAAY;;AAErF;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,2EAA2E,YAAY;AACvF,aAAa;;AAEb;AACA;;AAEA;AACA;;AAEA;AACA,8EAA8E,YAAY;AAC1F;AACA,aAAa;;AAEb;AACA;;AAEA;AACA,+EAA+E,YAAY;AAC3F,+EAA+E,YAAY;AAC3F,iBAAiB;AACjB,6EAA6E,YAAY;AACzF;AACA;AACA;;AAEA;AACA;AACA,6EAA6E,YAAY;AACzF,aAAa;;AAEb;AACA;AACA;AACA;AACA,gFAAgF,YAAY;AAC5F;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4EAA4E,YAAY;AACxF;AACA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,kFAAkF,YAAY;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;AACA,aAAa;;AAEb;AACA;AACA,0EAA0E,YAAY;AACtF;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;;;;;;;;;;;AC/TD;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kCAAkC,aAAa;AAC/C,kCAAkC;AAClC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,oCAAoC;;AAE/D;AACA,kDAAkD,UAAU,2CAA2C,EAAE;AACzG,aAAa;AACb,kDAAkD,YAAY;AAC9D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;ACvWD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","file":"vendors~widget-timechart-js.chunk.js","sourcesContent":["/*\n * jquery.flot.tooltip\n * \n * description: easy-to-use tooltips for Flot charts\n * version: 0.9.0\n * authors: Krzysztof Urbas @krzysu [myviews.pl],Evan Steinkerchner @Roundaround\n * website: https://github.com/krzysu/flot.tooltip\n * \n * build on 2016-07-26\n * released under MIT License, 2012\n*/ \n(function ($) {\n    // plugin options, default values\n    var defaultOptions = {\n        tooltip: {\n            show: false,\n            cssClass: \"flotTip\",\n            content: \"%s | X: %x | Y: %y\",\n            // allowed templates are:\n            // %s -> series label,\n            // %c -> series color,\n            // %lx -> x axis label (requires flot-axislabels plugin https://github.com/markrcote/flot-axislabels),\n            // %ly -> y axis label (requires flot-axislabels plugin https://github.com/markrcote/flot-axislabels),\n            // %x -> X value,\n            // %y -> Y value,\n            // %x.2 -> precision of X value,\n            // %p -> percent\n            // %n -> value (not percent) of pie chart\n            xDateFormat: null,\n            yDateFormat: null,\n            monthNames: null,\n            dayNames: null,\n            shifts: {\n                x: 10,\n                y: 20\n            },\n            defaultTheme: true,\n            snap: true,\n            lines: false,\n            clickTips: false,\n\n            // callbacks\n            onHover: function (flotItem, $tooltipEl) {},\n\n            $compat: false\n        }\n    };\n\n    // dummy default options object for legacy code (<0.8.5) - is deleted later\n    defaultOptions.tooltipOpts = defaultOptions.tooltip;\n\n    // object\n    var FlotTooltip = function (plot) {\n        // variables\n        this.tipPosition = {x: 0, y: 0};\n\n        this.init(plot);\n    };\n\n    // main plugin function\n    FlotTooltip.prototype.init = function (plot) {\n        var that = this;\n\n        // detect other flot plugins\n        var plotPluginsLength = $.plot.plugins.length;\n        this.plotPlugins = [];\n\n        if (plotPluginsLength) {\n            for (var p = 0; p < plotPluginsLength; p++) {\n                this.plotPlugins.push($.plot.plugins[p].name);\n            }\n        }\n\n        plot.hooks.bindEvents.push(function (plot, eventHolder) {\n\n            // get plot options\n            that.plotOptions = plot.getOptions();\n\n            // for legacy (<0.8.5) implementations\n            if (typeof(that.plotOptions.tooltip) === 'boolean') {\n                that.plotOptions.tooltipOpts.show = that.plotOptions.tooltip;\n                that.plotOptions.tooltip = that.plotOptions.tooltipOpts;\n                delete that.plotOptions.tooltipOpts;\n            }\n\n            // if not enabled return\n            if (that.plotOptions.tooltip.show === false || typeof that.plotOptions.tooltip.show === 'undefined') return;\n\n            // shortcut to access tooltip options\n            that.tooltipOptions = that.plotOptions.tooltip;\n\n            if (that.tooltipOptions.$compat) {\n                that.wfunc = 'width';\n                that.hfunc = 'height';\n            } else {\n                that.wfunc = 'innerWidth';\n                that.hfunc = 'innerHeight';\n            }\n\n            // create tooltip DOM element\n            var $tip = that.getDomElement();\n\n            // bind event\n            $( plot.getPlaceholder() ).bind(\"plothover\", plothover);\n            if (that.tooltipOptions.clickTips) {\n                $( plot.getPlaceholder() ).bind(\"plotclick\", plotclick);\n            }\n            that.clickmode = false;\n\n            $(eventHolder).bind('mousemove', mouseMove);\n        });\n\n        plot.hooks.shutdown.push(function (plot, eventHolder){\n            $(plot.getPlaceholder()).unbind(\"plothover\", plothover);\n            $(plot.getPlaceholder()).unbind(\"plotclick\", plotclick);\n            plot.removeTooltip();\n            $(eventHolder).unbind(\"mousemove\", mouseMove);\n        });\n\n        function mouseMove(e){\n            var pos = {};\n            pos.x = e.pageX;\n            pos.y = e.pageY;\n            plot.setTooltipPosition(pos);\n        }\n\n        /**\n         *  open the tooltip (if not already open) and freeze it on the current position till the next click\n         */\n        function plotclick(event, pos, item) {\n            if (! that.clickmode) {\n                // it is the click activating the clicktip\n                plothover(event, pos, item);\n                if (that.getDomElement().is(\":visible\")) {\n                    $(plot.getPlaceholder()).unbind(\"plothover\", plothover);\n                    that.clickmode = true;\n                }\n            } else {\n                // it is the click deactivating the clicktip\n                $( plot.getPlaceholder() ).bind(\"plothover\", plothover);\n                plot.hideTooltip();\n                that.clickmode = false;\n            }\n        }\n\n        function plothover(event, pos, item) {\n            // Simple distance formula.\n            var lineDistance = function (p1x, p1y, p2x, p2y) {\n                return Math.sqrt((p2x - p1x) * (p2x - p1x) + (p2y - p1y) * (p2y - p1y));\n            };\n\n            // Here is some voodoo magic for determining the distance to a line form a given point {x, y}.\n            var dotLineLength = function (x, y, x0, y0, x1, y1, o) {\n                if (o && !(o =\n                    function (x, y, x0, y0, x1, y1) {\n                        if (typeof x0 !== 'undefined') return { x: x0, y: y };\n                        else if (typeof y0 !== 'undefined') return { x: x, y: y0 };\n\n                        var left,\n                            tg = -1 / ((y1 - y0) / (x1 - x0));\n\n                        return {\n                            x: left = (x1 * (x * tg - y + y0) + x0 * (x * -tg + y - y1)) / (tg * (x1 - x0) + y0 - y1),\n                            y: tg * left - tg * x + y\n                        };\n                    } (x, y, x0, y0, x1, y1),\n                    o.x >= Math.min(x0, x1) && o.x <= Math.max(x0, x1) && o.y >= Math.min(y0, y1) && o.y <= Math.max(y0, y1))\n                ) {\n                    var l1 = lineDistance(x, y, x0, y0), l2 = lineDistance(x, y, x1, y1);\n                    return l1 > l2 ? l2 : l1;\n                } else {\n                    var a = y0 - y1, b = x1 - x0, c = x0 * y1 - y0 * x1;\n                    return Math.abs(a * x + b * y + c) / Math.sqrt(a * a + b * b);\n                }\n            };\n\n            if (item && !isNaN(item.dataIndex)) {\n                plot.showTooltip(item, that.tooltipOptions.snap ? item : pos);\n            } else if (that.plotOptions.series.lines.show && that.tooltipOptions.lines === true) {\n                var maxDistance = that.plotOptions.grid.mouseActiveRadius;\n\n                var closestTrace = {\n                    distance: maxDistance + 1\n                };\n\n                var ttPos = pos;\n\n                $.each(plot.getData(), function (i, series) {\n                    var xBeforeIndex = 0,\n                        xAfterIndex = -1;\n\n                    // Our search here assumes our data is sorted via the x-axis.\n                    // TODO: Improve efficiency somehow - search smaller sets of data.\n                    for (var j = 1; j < series.data.length; j++) {\n                        if (series.data[j - 1][0] <= pos.x && series.data[j][0] >= pos.x) {\n                            xBeforeIndex = j - 1;\n                            xAfterIndex = j;\n                        }\n                    }\n\n                    if (xAfterIndex === -1) {\n                        plot.hideTooltip();\n                        return;\n                    }\n\n                    var pointPrev = { x: series.data[xBeforeIndex][0], y: series.data[xBeforeIndex][1] },\n                        pointNext = { x: series.data[xAfterIndex][0], y: series.data[xAfterIndex][1] };\n\n                    var distToLine = dotLineLength(series.xaxis.p2c(pos.x), series.yaxis.p2c(pos.y), series.xaxis.p2c(pointPrev.x),\n                        series.yaxis.p2c(pointPrev.y), series.xaxis.p2c(pointNext.x), series.yaxis.p2c(pointNext.y), false);\n\n                    if (distToLine < closestTrace.distance) {\n\n                        var closestIndex = lineDistance(pointPrev.x, pointPrev.y, pos.x, pos.y) <\n                            lineDistance(pos.x, pos.y, pointNext.x, pointNext.y) ? xBeforeIndex : xAfterIndex;\n\n                        var pointSize = series.datapoints.pointsize;\n\n                        // Calculate the point on the line vertically closest to our cursor.\n                        var pointOnLine = [\n                            pos.x,\n                            pointPrev.y + ((pointNext.y - pointPrev.y) * ((pos.x - pointPrev.x) / (pointNext.x - pointPrev.x)))\n                        ];\n\n                        var item = {\n                            datapoint: pointOnLine,\n                            dataIndex: closestIndex,\n                            series: series,\n                            seriesIndex: i\n                        };\n\n                        closestTrace = {\n                            distance: distToLine,\n                            item: item\n                        };\n\n                        if (that.tooltipOptions.snap) {\n                            ttPos = {\n                                pageX: series.xaxis.p2c(pointOnLine[0]),\n                                pageY: series.yaxis.p2c(pointOnLine[1])\n                            };\n                        }\n                    }\n                });\n\n                if (closestTrace.distance < maxDistance + 1)\n                    plot.showTooltip(closestTrace.item, ttPos);\n                else\n                    plot.hideTooltip();\n            } else {\n                plot.hideTooltip();\n            }\n        }\n\n        // Quick little function for setting the tooltip position.\n        plot.setTooltipPosition = function (pos) {\n            var $tip = that.getDomElement();\n\n            var totalTipWidth = $tip.outerWidth() + that.tooltipOptions.shifts.x;\n            var totalTipHeight = $tip.outerHeight() + that.tooltipOptions.shifts.y;\n            if ((pos.x - $(window).scrollLeft()) > ($(window)[that.wfunc]() - totalTipWidth)) {\n                pos.x -= totalTipWidth;\n                pos.x = Math.max(pos.x, 0);\n            }\n            if ((pos.y - $(window).scrollTop()) > ($(window)[that.hfunc]() - totalTipHeight)) {\n                pos.y -= totalTipHeight;\n            }\n\n\t    /*\n\t       The section applies the new positioning ONLY if pos.x and pos.y\n\t       are numbers. If they are undefined or not a number, use the last\n\t       known numerical position. This hack fixes a bug that kept pie\n\t       charts from keeping their tooltip positioning.\n\t     */\n\n            if (isNaN(pos.x)) {\n\t\tthat.tipPosition.x = that.tipPosition.xPrev;\n\t    }\n\t    else {\n\t\tthat.tipPosition.x = pos.x;\n\t\tthat.tipPosition.xPrev = pos.x;\n\t    }\n\t    if (isNaN(pos.y)) {\n\t\tthat.tipPosition.y = that.tipPosition.yPrev;\n\t    }\n\t    else {\n\t\tthat.tipPosition.y = pos.y;\n\t\tthat.tipPosition.yPrev = pos.y;\n\t    }\n\n        };\n\n        // Quick little function for showing the tooltip.\n        plot.showTooltip = function (target, position, targetPosition) {\n            var $tip = that.getDomElement();\n\n            // convert tooltip content template to real tipText\n            var tipText = that.stringFormat(that.tooltipOptions.content, target);\n            if (tipText === '')\n                return;\n\n            $tip.html(tipText);\n            plot.setTooltipPosition({ x: that.tipPosition.x, y: that.tipPosition.y });\n            $tip.css({\n                left: that.tipPosition.x + that.tooltipOptions.shifts.x,\n                top: that.tipPosition.y + that.tooltipOptions.shifts.y\n            }).show();\n\n            // run callback\n            if (typeof that.tooltipOptions.onHover === 'function') {\n                that.tooltipOptions.onHover(target, $tip);\n            }\n        };\n\n        // Quick little function for hiding the tooltip.\n        plot.hideTooltip = function () {\n            that.getDomElement().hide().html('');\n        };\n\n        plot.removeTooltip = function() {\n            that.getDomElement().remove();\n        };\n    };\n\n    /**\n     * get or create tooltip DOM element\n     * @return jQuery object\n     */\n    FlotTooltip.prototype.getDomElement = function () {\n        var $tip = $('<div>');\n        if (this.tooltipOptions && this.tooltipOptions.cssClass) {\n            $tip = $('.' + this.tooltipOptions.cssClass);\n\n            if( $tip.length === 0 ){\n                $tip = $('<div />').addClass(this.tooltipOptions.cssClass);\n                $tip.appendTo('body').hide().css({position: 'absolute'});\n\n                if(this.tooltipOptions.defaultTheme) {\n                    $tip.css({\n                        'background': '#fff',\n                        'z-index': '1040',\n                        'padding': '0.4em 0.6em',\n                        'border-radius': '0.5em',\n                        'font-size': '0.8em',\n                        'border': '1px solid #111',\n                        'display': 'none',\n                        'white-space': 'nowrap'\n                    });\n                }\n            }\n        }\n\n        return $tip;\n    };\n\n    /**\n     * core function, create tooltip content\n     * @param  {string} content - template with tooltip content\n     * @param  {object} item - Flot item\n     * @return {string} real tooltip content for current item\n     */\n    FlotTooltip.prototype.stringFormat = function (content, item) {\n        var percentPattern = /%p\\.{0,1}(\\d{0,})/;\n        var seriesPattern = /%s/;\n        var colorPattern = /%c/;\n        var xLabelPattern = /%lx/; // requires flot-axislabels plugin https://github.com/markrcote/flot-axislabels, will be ignored if plugin isn't loaded\n        var yLabelPattern = /%ly/; // requires flot-axislabels plugin https://github.com/markrcote/flot-axislabels, will be ignored if plugin isn't loaded\n        var xPattern = /%x\\.{0,1}(\\d{0,})/;\n        var yPattern = /%y\\.{0,1}(\\d{0,})/;\n        var xPatternWithoutPrecision = \"%x\";\n        var yPatternWithoutPrecision = \"%y\";\n        var customTextPattern = \"%ct\";\n\tvar nPiePattern = \"%n\";\n\n        var x, y, customText, p, n;\n\n        // for threshold plugin we need to read data from different place\n        if (typeof item.series.threshold !== \"undefined\") {\n            x = item.datapoint[0];\n            y = item.datapoint[1];\n            customText = item.datapoint[2];\n\t}\n\n\t// for CurvedLines plugin we need to read data from different place\n\t    else if (typeof item.series.curvedLines !== \"undefined\") {\n\t\tx = item.datapoint[0];\n\t\ty = item.datapoint[1];\n\t    }\n\n        else if (typeof item.series.lines !== \"undefined\" && item.series.lines.steps) {\n            x = item.series.datapoints.points[item.dataIndex * 2];\n            y = item.series.datapoints.points[item.dataIndex * 2 + 1];\n            // TODO: where to find custom text in this variant?\n            customText = \"\";\n        } else {\n            x = item.series.data[item.dataIndex][0];\n            y = item.series.data[item.dataIndex][1];\n            customText = item.series.data[item.dataIndex][2];\n        }\n\n        // I think this is only in case of threshold plugin\n        if (item.series.label === null && item.series.originSeries) {\n            item.series.label = item.series.originSeries.label;\n        }\n\n        // if it is a function callback get the content string\n        if (typeof(content) === 'function') {\n            content = content(item.series.label, x, y, item);\n        }\n\n        // the case where the passed content is equal to false\n        if (typeof(content) === 'boolean' && !content) {\n            return '';\n        }\n\n        /* replacement of %ct and other multi-character templates must\n           precede the replacement of single-character templates\n           to avoid conflict between '%c' and '%ct'  and similar substrings\n        */\n        if (customText) {\n            content = content.replace(customTextPattern, customText);\n        }\n\n        // percent match for pie charts and stacked percent\n        if (typeof (item.series.percent) !== 'undefined') {\n            p = item.series.percent;\n        } else if (typeof (item.series.percents) !== 'undefined') {\n            p = item.series.percents[item.dataIndex];\n        }\n        if (typeof p === 'number') {\n            content = this.adjustValPrecision(percentPattern, content, p);\n        }\n\n        // replace %n with number of items represented by slice in pie charts\n        if (item.series.hasOwnProperty('pie')) {\n            if (typeof item.series.data[0][1] !== 'undefined') {\n                n = item.series.data[0][1];\n            }\n        }\n        if (typeof n === 'number') {\n            content = content.replace(nPiePattern, n);\n        }\n\n        // series match\n        if (typeof(item.series.label) !== 'undefined') {\n            content = content.replace(seriesPattern, item.series.label);\n        } else {\n            //remove %s if label is undefined\n            content = content.replace(seriesPattern, \"\");\n        }\n\n        // color match\n        if (typeof(item.series.color) !== 'undefined') {\n            content = content.replace(colorPattern, item.series.color);\n        } else {\n            //remove %s if color is undefined\n            content = content.replace(colorPattern, \"\");\n        }\n\n        // x axis label match\n        if (this.hasAxisLabel('xaxis', item)) {\n            content = content.replace(xLabelPattern, item.series.xaxis.options.axisLabel);\n        } else {\n            //remove %lx if axis label is undefined or axislabels plugin not present\n            content = content.replace(xLabelPattern, \"\");\n        }\n\n        // y axis label match\n        if (this.hasAxisLabel('yaxis', item)) {\n            content = content.replace(yLabelPattern, item.series.yaxis.options.axisLabel);\n        } else {\n            //remove %ly if axis label is undefined or axislabels plugin not present\n            content = content.replace(yLabelPattern, \"\");\n        }\n\n        // time mode axes with custom dateFormat\n        if (this.isTimeMode('xaxis', item) && this.isXDateFormat(item)) {\n            content = content.replace(xPattern, this.timestampToDate(x, this.tooltipOptions.xDateFormat, item.series.xaxis.options));\n        }\n        if (this.isTimeMode('yaxis', item) && this.isYDateFormat(item)) {\n            content = content.replace(yPattern, this.timestampToDate(y, this.tooltipOptions.yDateFormat, item.series.yaxis.options));\n        }\n\n        // set precision if defined\n        if (typeof x === 'number') {\n            content = this.adjustValPrecision(xPattern, content, x);\n        }\n        if (typeof y === 'number') {\n            content = this.adjustValPrecision(yPattern, content, y);\n        }\n\n        // change x from number to given label, if given\n        if (typeof item.series.xaxis.ticks !== 'undefined') {\n\n            var ticks;\n            if (this.hasRotatedXAxisTicks(item)) {\n                // xaxis.ticks will be an empty array if tickRotor is being used, but the values are available in rotatedTicks\n                ticks = 'rotatedTicks';\n            } else {\n                ticks = 'ticks';\n            }\n\n            // see https://github.com/krzysu/flot.tooltip/issues/65\n            var tickIndex = item.dataIndex + item.seriesIndex;\n\n            for (var xIndex in item.series.xaxis[ticks]) {\n                if (item.series.xaxis[ticks].hasOwnProperty(tickIndex) && !this.isTimeMode('xaxis', item)) {\n                    var valueX = (this.isCategoriesMode('xaxis', item)) ? item.series.xaxis[ticks][tickIndex].label : item.series.xaxis[ticks][tickIndex].v;\n                    if (valueX === x) {\n                        content = content.replace(xPattern, item.series.xaxis[ticks][tickIndex].label.replace(/\\$/g, '$$$$'));\n                    }\n                }\n            }\n        }\n\n        // change y from number to given label, if given\n        if (typeof item.series.yaxis.ticks !== 'undefined') {\n            for (var yIndex in item.series.yaxis.ticks) {\n                if (item.series.yaxis.ticks.hasOwnProperty(yIndex)) {\n                    var valueY = (this.isCategoriesMode('yaxis', item)) ? item.series.yaxis.ticks[yIndex].label : item.series.yaxis.ticks[yIndex].v;\n                    if (valueY === y) {\n                        content = content.replace(yPattern, item.series.yaxis.ticks[yIndex].label.replace(/\\$/g, '$$$$'));\n                    }\n                }\n            }\n        }\n\n        // if no value customization, use tickFormatter by default\n        if (typeof item.series.xaxis.tickFormatter !== 'undefined') {\n            //escape dollar\n            content = content.replace(xPatternWithoutPrecision, item.series.xaxis.tickFormatter(x, item.series.xaxis).replace(/\\$/g, '$$'));\n        }\n        if (typeof item.series.yaxis.tickFormatter !== 'undefined') {\n            //escape dollar\n            content = content.replace(yPatternWithoutPrecision, item.series.yaxis.tickFormatter(y, item.series.yaxis).replace(/\\$/g, '$$'));\n        }\n\n        return content;\n    };\n\n    // helpers just for readability\n    FlotTooltip.prototype.isTimeMode = function (axisName, item) {\n        return (typeof item.series[axisName].options.mode !== 'undefined' && item.series[axisName].options.mode === 'time');\n    };\n\n    FlotTooltip.prototype.isXDateFormat = function (item) {\n        return (typeof this.tooltipOptions.xDateFormat !== 'undefined' && this.tooltipOptions.xDateFormat !== null);\n    };\n\n    FlotTooltip.prototype.isYDateFormat = function (item) {\n        return (typeof this.tooltipOptions.yDateFormat !== 'undefined' && this.tooltipOptions.yDateFormat !== null);\n    };\n\n    FlotTooltip.prototype.isCategoriesMode = function (axisName, item) {\n        return (typeof item.series[axisName].options.mode !== 'undefined' && item.series[axisName].options.mode === 'categories');\n    };\n\n    //\n    FlotTooltip.prototype.timestampToDate = function (tmst, dateFormat, options) {\n        var theDate = $.plot.dateGenerator(tmst, options);\n        return $.plot.formatDate(theDate, dateFormat, this.tooltipOptions.monthNames, this.tooltipOptions.dayNames);\n    };\n\n    //\n    FlotTooltip.prototype.adjustValPrecision = function (pattern, content, value) {\n\n        var precision;\n        var matchResult = content.match(pattern);\n        if( matchResult !== null ) {\n            if(RegExp.$1 !== '') {\n                precision = RegExp.$1;\n                value = value.toFixed(precision);\n\n                // only replace content if precision exists, in other case use thickformater\n                content = content.replace(pattern, value);\n            }\n        }\n        return content;\n    };\n\n    // other plugins detection below\n\n    // check if flot-axislabels plugin (https://github.com/markrcote/flot-axislabels) is used and that an axis label is given\n    FlotTooltip.prototype.hasAxisLabel = function (axisName, item) {\n        return ($.inArray('axisLabels', this.plotPlugins) !== -1 && typeof item.series[axisName].options.axisLabel !== 'undefined' && item.series[axisName].options.axisLabel.length > 0);\n    };\n\n    // check whether flot-tickRotor, a plugin which allows rotation of X-axis ticks, is being used\n    FlotTooltip.prototype.hasRotatedXAxisTicks = function (item) {\n        return ($.inArray('tickRotor',this.plotPlugins) !== -1 && typeof item.series.xaxis.rotatedTicks !== 'undefined');\n    };\n\n    //\n    var init = function (plot) {\n      new FlotTooltip(plot);\n    };\n\n    // define Flot plugin\n    $.plot.plugins.push({\n        init: init,\n        options: defaultOptions,\n        name: 'tooltip',\n        version: '0.8.5'\n    });\n\n})(jQuery);\n","// Source: https://github.com/jquery/jquery-mousewheel/blob/a06ef4e1a127795606642c55e22d4f2945edc061/jquery.mousewheel.js\n\n/*! Copyright (c) 2011 Brandon Aaron (http://brandonaaron.net)\n * Licensed under the MIT License (LICENSE.txt).\n *\n * Thanks to: http://adomas.org/javascript-mouse-wheel/ for some pointers.\n * Thanks to: Mathias Bank(http://www.mathias-bank.de) for a scope bug fix.\n * Thanks to: Seamus Leahy for adding deltaX and deltaY\n *\n * Version: 3.0.6\n *\n * Requires: 1.2.2+\n */\n\n(function($) {\n\nvar types = ['DOMMouseScroll', 'mousewheel'];\n\nif ($.event.fixHooks) {\n    for ( var i=types.length; i; ) {\n        $.event.fixHooks[ types[--i] ] = $.event.mouseHooks;\n    }\n}\n\n$.event.special.mousewheel = {\n    setup: function() {\n        if ( this.addEventListener ) {\n            for ( var i=types.length; i; ) {\n                this.addEventListener( types[--i], handler, false );\n            }\n        } else {\n            this.onmousewheel = handler;\n        }\n    },\n\n    teardown: function() {\n        if ( this.removeEventListener ) {\n            for ( var i=types.length; i; ) {\n                this.removeEventListener( types[--i], handler, false );\n            }\n        } else {\n            this.onmousewheel = null;\n        }\n    }\n};\n\n$.fn.extend({\n    mousewheel: function(fn) {\n        return fn ? this.bind(\"mousewheel\", fn) : this.trigger(\"mousewheel\");\n    },\n\n    unmousewheel: function(fn) {\n        return this.unbind(\"mousewheel\", fn);\n    }\n});\n\n\nfunction handler(event) {\n    var orgEvent = event || window.event, args = [].slice.call( arguments, 1 ), delta = 0, returnValue = true, deltaX = 0, deltaY = 0;\n    event = $.event.fix(orgEvent);\n    event.type = \"mousewheel\";\n\n    // Old school scrollwheel delta\n    if ( orgEvent.wheelDelta ) { delta = orgEvent.wheelDelta/120; }\n    if ( orgEvent.detail     ) { delta = -orgEvent.detail/3; }\n\n    // New school multidimensional scroll (touchpads) deltas\n    deltaY = delta;\n\n    // Gecko\n    if ( orgEvent.axis !== undefined && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {\n        deltaY = 0;\n        deltaX = -1*delta;\n    }\n\n    // Webkit\n    if ( orgEvent.wheelDeltaY !== undefined ) { deltaY = orgEvent.wheelDeltaY/120; }\n    if ( orgEvent.wheelDeltaX !== undefined ) { deltaX = -1*orgEvent.wheelDeltaX/120; }\n\n    // Add event and delta to the front of the arguments\n    args.unshift(event, delta, deltaX, deltaY);\n\n    return ($.event.dispatch || $.event.handle).apply(this, args);\n}\n\n})(jQuery);\n","/** ## jquery.flot.canvaswrapper\n\nThis plugin contains the function for creating and manipulating both the canvas\nlayers and svg layers.\n\nThe Canvas object is a wrapper around an HTML5 canvas tag.\nThe constructor Canvas(cls, container) takes as parameters cls,\nthe list of classes to apply to the canvas adnd the containter,\nelement onto which to append the canvas. The canvas operations\ndon't work unless the canvas is attached to the DOM.\n\n### jquery.canvaswrapper.js API functions\n*/\n\n(function($) {\n    var Canvas = function(cls, container) {\n        var element = container.getElementsByClassName(cls)[0];\n\n        if (!element) {\n            element = document.createElement('canvas');\n            element.className = cls;\n            element.style.direction = 'ltr';\n            element.style.position = 'absolute';\n            element.style.left = '0px';\n            element.style.top = '0px';\n\n            container.appendChild(element);\n\n            // If HTML5 Canvas isn't available, throw\n\n            if (!element.getContext) {\n                throw new Error('Canvas is not available.');\n            }\n        }\n\n        this.element = element;\n\n        var context = this.context = element.getContext('2d');\n        this.pixelRatio = $.plot.browser.getPixelRatio(context);\n\n        // Size the canvas to match the internal dimensions of its container\n        var width = $(container).width();\n        var height = $(container).height();\n        this.resize(width, height);\n\n        // Collection of HTML div layers for text overlaid onto the canvas\n\n        this.SVGContainer = null;\n        this.SVG = {};\n\n        // Cache of text fragments and metrics, so we can avoid expensively\n        // re-calculating them when the plot is re-rendered in a loop.\n\n        this._textCache = {};\n    }\n\n    /**\n    - resize(width, height)\n\n     Resizes the canvas to the given dimensions.\n     The width represents the new width of the canvas, meanwhile the height\n     is the new height of the canvas, both of them in pixels.\n    */\n\n    Canvas.prototype.resize = function(width, height) {\n        var minSize = 10;\n        width = width < minSize ? minSize : width;\n        height = height < minSize ? minSize : height;\n\n        var element = this.element,\n            context = this.context,\n            pixelRatio = this.pixelRatio;\n\n        // Resize the canvas, increasing its density based on the display's\n        // pixel ratio; basically giving it more pixels without increasing the\n        // size of its element, to take advantage of the fact that retina\n        // displays have that many more pixels in the same advertised space.\n\n        // Resizing should reset the state (excanvas seems to be buggy though)\n\n        if (this.width !== width) {\n            element.width = width * pixelRatio;\n            element.style.width = width + 'px';\n            this.width = width;\n        }\n\n        if (this.height !== height) {\n            element.height = height * pixelRatio;\n            element.style.height = height + 'px';\n            this.height = height;\n        }\n\n        // Save the context, so we can reset in case we get replotted.  The\n        // restore ensure that we're really back at the initial state, and\n        // should be safe even if we haven't saved the initial state yet.\n\n        context.restore();\n        context.save();\n\n        // Scale the coordinate space to match the display density; so even though we\n        // may have twice as many pixels, we still want lines and other drawing to\n        // appear at the same size; the extra pixels will just make them crisper.\n\n        context.scale(pixelRatio, pixelRatio);\n    };\n\n    /**\n    - clear()\n\n     Clears the entire canvas area, not including any overlaid HTML text\n    */\n    Canvas.prototype.clear = function() {\n        this.context.clearRect(0, 0, this.width, this.height);\n    };\n\n    /**\n    - render()\n\n     Finishes rendering the canvas, including managing the text overlay.\n    */\n    Canvas.prototype.render = function() {\n        var cache = this._textCache;\n\n        // For each text layer, add elements marked as active that haven't\n        // already been rendered, and remove those that are no longer active.\n\n        for (var layerKey in cache) {\n            if (hasOwnProperty.call(cache, layerKey)) {\n                var layer = this.getSVGLayer(layerKey),\n                    layerCache = cache[layerKey];\n\n                var display = layer.style.display;\n                layer.style.display = 'none';\n\n                for (var styleKey in layerCache) {\n                    if (hasOwnProperty.call(layerCache, styleKey)) {\n                        var styleCache = layerCache[styleKey];\n                        for (var key in styleCache) {\n                            if (hasOwnProperty.call(styleCache, key)) {\n                                var val = styleCache[key],\n                                    positions = val.positions;\n\n                                for (var i = 0, position; positions[i]; i++) {\n                                    position = positions[i];\n                                    if (position.active) {\n                                        if (!position.rendered) {\n                                            layer.appendChild(position.element);\n                                            position.rendered = true;\n                                        }\n                                    } else {\n                                        positions.splice(i--, 1);\n                                        if (position.rendered) {\n                                            while (position.element.firstChild) {\n                                                position.element.removeChild(position.element.firstChild);\n                                            }\n                                            position.element.parentNode.removeChild(position.element);\n                                        }\n                                    }\n                                }\n\n                                if (positions.length === 0) {\n                                    if (val.measured) {\n                                        val.measured = false;\n                                    } else {\n                                        delete styleCache[key];\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n\n                layer.style.display = display;\n            }\n        }\n    };\n\n    /**\n    - getSVGLayer(classes)\n\n     Creates (if necessary) and returns the SVG overlay container.\n     The classes string represents the string of space-separated CSS classes\n     used to uniquely identify the text layer. It return the svg-layer div.\n    */\n    Canvas.prototype.getSVGLayer = function(classes) {\n        var layer = this.SVG[classes];\n\n        // Create the SVG layer if it doesn't exist\n\n        if (!layer) {\n            // Create the svg layer container, if it doesn't exist\n\n            var svgElement;\n\n            if (!this.SVGContainer) {\n                this.SVGContainer = document.createElement('div');\n                this.SVGContainer.className = 'flot-svg';\n                this.SVGContainer.style.position = 'absolute';\n                this.SVGContainer.style.top = '0px';\n                this.SVGContainer.style.left = '0px';\n                this.SVGContainer.style.height = '100%';\n                this.SVGContainer.style.width = '100%';\n                this.SVGContainer.style.pointerEvents = 'none';\n                this.element.parentNode.appendChild(this.SVGContainer);\n\n                svgElement = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n                svgElement.style.width = '100%';\n                svgElement.style.height = '100%';\n\n                this.SVGContainer.appendChild(svgElement);\n            } else {\n                svgElement = this.SVGContainer.firstChild;\n            }\n\n            layer = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n            layer.setAttribute('class', classes);\n            layer.style.position = 'absolute';\n            layer.style.top = '0px';\n            layer.style.left = '0px';\n            layer.style.bottom = '0px';\n            layer.style.right = '0px';\n            svgElement.appendChild(layer);\n            this.SVG[classes] = layer;\n        }\n\n        return layer;\n    };\n\n    /**\n    - getTextInfo(layer, text, font, angle, width)\n\n     Creates (if necessary) and returns a text info object.\n     The object looks like this:\n     ```js\n     {\n         width //Width of the text's wrapper div.\n         height //Height of the text's wrapper div.\n         element //The HTML div containing the text.\n         positions //Array of positions at which this text is drawn.\n      }\n      ```\n      The positions array contains objects that look like this:\n      ```js\n      {\n         active //Flag indicating whether the text should be visible.\n         rendered //Flag indicating whether the text is currently visible.\n         element //The HTML div containing the text.\n         text //The actual text and is identical with element[0].textContent.\n         x //X coordinate at which to draw the text.\n         y //Y coordinate at which to draw the text.\n      }\n      ```\n      Each position after the first receives a clone of the original element.\n      The idea is that that the width, height, and general 'identity' of the\n      text is constant no matter where it is placed; the placements are a\n      secondary property.\n\n      Canvas maintains a cache of recently-used text info objects; getTextInfo\n      either returns the cached element or creates a new entry.\n\n     The layer parameter is string of space-separated CSS classes uniquely\n     identifying the layer containing this text.\n     Text is the text string to retrieve info for.\n     Font is either a string of space-separated CSS classes or a font-spec object,\n     defining the text's font and style.\n     Angle is the angle at which to rotate the text, in degrees. Angle is currently unused,\n     it will be implemented in the future.\n     The last parameter is the Maximum width of the text before it wraps.\n     The method returns a text info object.\n    */\n    Canvas.prototype.getTextInfo = function(layer, text, font, angle, width) {\n        var textStyle, layerCache, styleCache, info;\n\n        // Cast the value to a string, in case we were given a number or such\n\n        text = '' + text;\n\n        // If the font is a font-spec object, generate a CSS font definition\n\n        if (typeof font === 'object') {\n            textStyle = font.style + ' ' + font.variant + ' ' + font.weight + ' ' + font.size + 'px/' + font.lineHeight + 'px ' + font.family;\n        } else {\n            textStyle = font;\n        }\n\n        // Retrieve (or create) the cache for the text's layer and styles\n\n        layerCache = this._textCache[layer];\n\n        if (layerCache == null) {\n            layerCache = this._textCache[layer] = {};\n        }\n\n        styleCache = layerCache[textStyle];\n\n        if (styleCache == null) {\n            styleCache = layerCache[textStyle] = {};\n        }\n\n        var key = generateKey(text);\n        info = styleCache[key];\n\n        // If we can't find a matching element in our cache, create a new one\n\n        if (!info) {\n            var element = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n            if (text.indexOf('<br>') !== -1) {\n                addTspanElements(text, element, -9999);\n            } else {\n                var textNode = document.createTextNode(text);\n                element.appendChild(textNode);\n            }\n\n            element.style.position = 'absolute';\n            element.style.maxWidth = width;\n            element.setAttributeNS(null, 'x', -9999);\n            element.setAttributeNS(null, 'y', -9999);\n\n            if (typeof font === 'object') {\n                element.style.font = textStyle;\n                element.style.fill = font.fill;\n            } else if (typeof font === 'string') {\n                element.setAttribute('class', font);\n            }\n\n            this.getSVGLayer(layer).appendChild(element);\n            var elementRect = element.getBBox();\n\n            info = styleCache[key] = {\n                width: elementRect.width,\n                height: elementRect.height,\n                measured: true,\n                element: element,\n                positions: []\n            };\n\n            //remove elements from dom\n            while (element.firstChild) {\n                element.removeChild(element.firstChild);\n            }\n            element.parentNode.removeChild(element);\n        }\n\n        info.measured = true;\n        return info;\n    };\n\n    function updateTransforms (element, transforms) {\n        element.transform.baseVal.clear();\n        if (transforms) {\n            transforms.forEach(function(t) {\n                element.transform.baseVal.appendItem(t);\n            });\n        }\n    }\n\n    /**\n    - addText (layer, x, y, text, font, angle, width, halign, valign, transforms)\n\n     Adds a text string to the canvas text overlay.\n     The text isn't drawn immediately; it is marked as rendering, which will\n     result in its addition to the canvas on the next render pass.\n\n     The layer is string of space-separated CSS classes uniquely\n     identifying the layer containing this text.\n     X and Y represents the X and Y coordinate at which to draw the text.\n     and text is the string to draw\n    */\n    Canvas.prototype.addText = function(layer, x, y, text, font, angle, width, halign, valign, transforms) {\n        var info = this.getTextInfo(layer, text, font, angle, width),\n            positions = info.positions;\n\n        // Tweak the div's position to match the text's alignment\n\n        if (halign === 'center') {\n            x -= info.width / 2;\n        } else if (halign === 'right') {\n            x -= info.width;\n        }\n\n        if (valign === 'middle') {\n            y -= info.height / 2;\n        } else if (valign === 'bottom') {\n            y -= info.height;\n        }\n\n        y += 0.75 * info.height;\n\n        // Determine whether this text already exists at this position.\n        // If so, mark it for inclusion in the next render pass.\n\n        for (var i = 0, position; positions[i]; i++) {\n            position = positions[i];\n            if (position.x === x && position.y === y && position.text === text) {\n                position.active = true;\n                // update the transforms\n                updateTransforms(position.element, transforms);\n\n                return;\n            } else if (position.active === false) {\n                position.active = true;\n                position.text = text;\n                if (text.indexOf('<br>') !== -1) {\n                    y -= 0.25 * info.height;\n                    addTspanElements(text, position.element, x);\n                } else {\n                    position.element.textContent = text;\n                }\n                position.element.setAttributeNS(null, 'x', x);\n                position.element.setAttributeNS(null, 'y', y);\n                position.x = x;\n                position.y = y;\n                // update the transforms\n                updateTransforms(position.element, transforms);\n\n                return;\n            }\n        }\n\n        // If the text doesn't exist at this position, create a new entry\n\n        // For the very first position we'll re-use the original element,\n        // while for subsequent ones we'll clone it.\n\n        position = {\n            active: true,\n            rendered: false,\n            element: positions.length ? info.element.cloneNode() : info.element,\n            text: text,\n            x: x,\n            y: y\n        };\n\n        positions.push(position);\n\n        if (text.indexOf('<br>') !== -1) {\n            y -= 0.25 * info.height;\n            addTspanElements(text, position.element, x);\n        } else {\n            position.element.textContent = text;\n        }\n\n        // Move the element to its final position within the container\n        position.element.setAttributeNS(null, 'x', x);\n        position.element.setAttributeNS(null, 'y', y);\n        position.element.style.textAlign = halign;\n        // update the transforms\n        updateTransforms(position.element, transforms);\n    };\n\n    var addTspanElements = function(text, element, x) {\n        var lines = text.split('<br>'),\n            tspan, i, offset;\n\n        for (i = 0; i < lines.length; i++) {\n            if (!element.childNodes[i]) {\n                tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');\n                element.appendChild(tspan);\n            } else {\n                tspan = element.childNodes[i];\n            }\n            tspan.textContent = lines[i];\n            offset = (i === 0 ? 0 : 1) + 'em';\n            tspan.setAttributeNS(null, 'dy', offset);\n            tspan.setAttributeNS(null, 'x', x);\n        }\n    }\n\n    /**\n    - removeText (layer, x, y, text, font, angle)\n\n      The function removes one or more text strings from the canvas text overlay.\n      If no parameters are given, all text within the layer is removed.\n\n      Note that the text is not immediately removed; it is simply marked as\n      inactive, which will result in its removal on the next render pass.\n      This avoids the performance penalty for 'clear and redraw' behavior,\n      where we potentially get rid of all text on a layer, but will likely\n      add back most or all of it later, as when redrawing axes, for example.\n\n      The layer is a string of space-separated CSS classes uniquely\n      identifying the layer containing this text. The following parameter are\n      X and Y coordinate of the text.\n      Text is the string to remove, while the font is either a string of space-separated CSS\n      classes or a font-spec object, defining the text's font and style.\n     */\n    Canvas.prototype.removeText = function(layer, x, y, text, font, angle) {\n        var info, htmlYCoord;\n        if (text == null) {\n            var layerCache = this._textCache[layer];\n            if (layerCache != null) {\n                for (var styleKey in layerCache) {\n                    if (hasOwnProperty.call(layerCache, styleKey)) {\n                        var styleCache = layerCache[styleKey];\n                        for (var key in styleCache) {\n                            if (hasOwnProperty.call(styleCache, key)) {\n                                var positions = styleCache[key].positions;\n                                positions.forEach(function(position) {\n                                    position.active = false;\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n        } else {\n            info = this.getTextInfo(layer, text, font, angle);\n            positions = info.positions;\n            positions.forEach(function(position) {\n                htmlYCoord = y + 0.75 * info.height;\n                if (position.x === x && position.y === htmlYCoord && position.text === text) {\n                    position.active = false;\n                }\n            });\n        }\n    };\n\n    /**\n    - clearCache()\n\n     Clears the cache used to speed up the text size measurements.\n     As an (unfortunate) side effect all text within the text Layer is removed.\n     Use this function before plot.setupGrid() and plot.draw() if the plot just\n     became visible or the styles changed.\n    */\n    Canvas.prototype.clearCache = function() {\n        var cache = this._textCache;\n        for (var layerKey in cache) {\n            if (hasOwnProperty.call(cache, layerKey)) {\n                var layer = this.getSVGLayer(layerKey);\n                while (layer.firstChild) {\n                    layer.removeChild(layer.firstChild);\n                }\n            }\n        };\n\n        this._textCache = {};\n    };\n\n    function generateKey(text) {\n        return text.replace(/0|1|2|3|4|5|6|7|8|9/g, '0');\n    }\n\n    if (!window.Flot) {\n        window.Flot = {};\n    }\n\n    window.Flot.Canvas = Canvas;\n})(jQuery);\n","/* Plugin for jQuery for working with colors.\n *\n * Version 1.1.\n *\n * Inspiration from jQuery color animation plugin by John Resig.\n *\n * Released under the MIT license by Ole Laursen, October 2009.\n *\n * Examples:\n *\n *   $.color.parse(\"#fff\").scale('rgb', 0.25).add('a', -0.5).toString()\n *   var c = $.color.extract($(\"#mydiv\"), 'background-color');\n *   console.log(c.r, c.g, c.b, c.a);\n *   $.color.make(100, 50, 25, 0.4).toString() // returns \"rgba(100,50,25,0.4)\"\n *\n * Note that .scale() and .add() return the same modified object\n * instead of making a new one.\n *\n * V. 1.1: Fix error handling so e.g. parsing an empty string does\n * produce a color rather than just crashing.\n */\n\n(function($) {\n    $.color = {};\n\n    // construct color object with some convenient chainable helpers\n    $.color.make = function (r, g, b, a) {\n        var o = {};\n        o.r = r || 0;\n        o.g = g || 0;\n        o.b = b || 0;\n        o.a = a != null ? a : 1;\n\n        o.add = function (c, d) {\n            for (var i = 0; i < c.length; ++i) {\n                o[c.charAt(i)] += d;\n            }\n\n            return o.normalize();\n        };\n\n        o.scale = function (c, f) {\n            for (var i = 0; i < c.length; ++i) {\n                o[c.charAt(i)] *= f;\n            }\n\n            return o.normalize();\n        };\n\n        o.toString = function () {\n            if (o.a >= 1.0) {\n                return \"rgb(\" + [o.r, o.g, o.b].join(\",\") + \")\";\n            } else {\n                return \"rgba(\" + [o.r, o.g, o.b, o.a].join(\",\") + \")\";\n            }\n        };\n\n        o.normalize = function () {\n            function clamp(min, value, max) {\n                return value < min ? min : (value > max ? max : value);\n            }\n\n            o.r = clamp(0, parseInt(o.r), 255);\n            o.g = clamp(0, parseInt(o.g), 255);\n            o.b = clamp(0, parseInt(o.b), 255);\n            o.a = clamp(0, o.a, 1);\n            return o;\n        };\n\n        o.clone = function () {\n            return $.color.make(o.r, o.b, o.g, o.a);\n        };\n\n        return o.normalize();\n    }\n\n    // extract CSS color property from element, going up in the DOM\n    // if it's \"transparent\"\n    $.color.extract = function (elem, css) {\n        var c;\n\n        do {\n            c = elem.css(css).toLowerCase();\n            // keep going until we find an element that has color, or\n            // we hit the body or root (have no parent)\n            if (c !== '' && c !== 'transparent') {\n                break;\n            }\n\n            elem = elem.parent();\n        } while (elem.length && !$.nodeName(elem.get(0), \"body\"));\n\n        // catch Safari's way of signalling transparent\n        if (c === \"rgba(0, 0, 0, 0)\") {\n            c = \"transparent\";\n        }\n\n        return $.color.parse(c);\n    }\n\n    // parse CSS color string (like \"rgb(10, 32, 43)\" or \"#fff\"),\n    // returns color object, if parsing failed, you get black (0, 0,\n    // 0) out\n    $.color.parse = function (str) {\n        var res, m = $.color.make;\n\n        // Look for rgb(num,num,num)\n        res = /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/.exec(str);\n        if (res) {\n            return m(parseInt(res[1], 10), parseInt(res[2], 10), parseInt(res[3], 10));\n        }\n\n        // Look for rgba(num,num,num,num)\n        res = /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\s*\\)/.exec(str)\n        if (res) {\n            return m(parseInt(res[1], 10), parseInt(res[2], 10), parseInt(res[3], 10), parseFloat(res[4]));\n        }\n\n        // Look for rgb(num%,num%,num%)\n        res = /rgb\\(\\s*([0-9]+(?:\\.[0-9]+)?)%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)%\\s*\\)/.exec(str);\n        if (res) {\n            return m(parseFloat(res[1]) * 2.55, parseFloat(res[2]) * 2.55, parseFloat(res[3]) * 2.55);\n        }\n\n        // Look for rgba(num%,num%,num%,num)\n        res = /rgba\\(\\s*([0-9]+(?:\\.[0-9]+)?)%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\s*\\)/.exec(str);\n        if (res) {\n            return m(parseFloat(res[1]) * 2.55, parseFloat(res[2]) * 2.55, parseFloat(res[3]) * 2.55, parseFloat(res[4]));\n        }\n\n        // Look for #a0b1c2\n        res = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(str);\n        if (res) {\n            return m(parseInt(res[1], 16), parseInt(res[2], 16), parseInt(res[3], 16));\n        }\n\n        // Look for #fff\n        res = /#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(str);\n        if (res) {\n            return m(parseInt(res[1] + res[1], 16), parseInt(res[2] + res[2], 16), parseInt(res[3] + res[3], 16));\n        }\n\n        // Otherwise, we're most likely dealing with a named color\n        var name = $.trim(str).toLowerCase();\n        if (name === \"transparent\") {\n            return m(255, 255, 255, 0);\n        } else {\n            // default to black\n            res = lookupColors[name] || [0, 0, 0];\n            return m(res[0], res[1], res[2]);\n        }\n    }\n\n    var lookupColors = {\n        aqua: [0, 255, 255],\n        azure: [240, 255, 255],\n        beige: [245, 245, 220],\n        black: [0, 0, 0],\n        blue: [0, 0, 255],\n        brown: [165, 42, 42],\n        cyan: [0, 255, 255],\n        darkblue: [0, 0, 139],\n        darkcyan: [0, 139, 139],\n        darkgrey: [169, 169, 169],\n        darkgreen: [0, 100, 0],\n        darkkhaki: [189, 183, 107],\n        darkmagenta: [139, 0, 139],\n        darkolivegreen: [85, 107, 47],\n        darkorange: [255, 140, 0],\n        darkorchid: [153, 50, 204],\n        darkred: [139, 0, 0],\n        darksalmon: [233, 150, 122],\n        darkviolet: [148, 0, 211],\n        fuchsia: [255, 0, 255],\n        gold: [255, 215, 0],\n        green: [0, 128, 0],\n        indigo: [75, 0, 130],\n        khaki: [240, 230, 140],\n        lightblue: [173, 216, 230],\n        lightcyan: [224, 255, 255],\n        lightgreen: [144, 238, 144],\n        lightgrey: [211, 211, 211],\n        lightpink: [255, 182, 193],\n        lightyellow: [255, 255, 224],\n        lime: [0, 255, 0],\n        magenta: [255, 0, 255],\n        maroon: [128, 0, 0],\n        navy: [0, 0, 128],\n        olive: [128, 128, 0],\n        orange: [255, 165, 0],\n        pink: [255, 192, 203],\n        purple: [128, 0, 128],\n        violet: [128, 0, 128],\n        red: [255, 0, 0],\n        silver: [192, 192, 192],\n        white: [255, 255, 255],\n        yellow: [255, 255, 0]\n    };\n})(jQuery);\n","/*\nAxis label plugin for flot\n\nDerived from:\nAxis Labels Plugin for flot.\nhttp://github.com/markrcote/flot-axislabels\n\nOriginal code is Copyright (c) 2010 Xuan Luo.\nOriginal code was released under the GPLv3 license by Xuan Luo, September 2010.\nOriginal code was rereleased under the MIT license by Xuan Luo, April 2012.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n(function($) {\n    \"use strict\";\n\n    var options = {\n        axisLabels: {\n            show: true\n        }\n    };\n\n    function AxisLabel(axisName, position, padding, placeholder, axisLabel, surface) {\n        this.axisName = axisName;\n        this.position = position;\n        this.padding = padding;\n        this.placeholder = placeholder;\n        this.axisLabel = axisLabel;\n        this.surface = surface;\n        this.width = 0;\n        this.height = 0;\n        this.elem = null;\n    }\n\n    AxisLabel.prototype.calculateSize = function() {\n        var axisId = this.axisName + 'Label',\n            layerId = axisId + 'Layer',\n            className = axisId + ' axisLabels';\n\n        var info = this.surface.getTextInfo(layerId, this.axisLabel, className);\n        this.labelWidth = info.width;\n        this.labelHeight = info.height;\n\n        if (this.position === 'left' || this.position === 'right') {\n            this.width = this.labelHeight + this.padding;\n            this.height = 0;\n        } else {\n            this.width = 0;\n            this.height = this.labelHeight + this.padding;\n        }\n    };\n\n    AxisLabel.prototype.transforms = function(degrees, x, y, svgLayer) {\n        var transforms = [], translate, rotate;\n        if (x !== 0 || y !== 0) {\n            translate = svgLayer.createSVGTransform();\n            translate.setTranslate(x, y);\n            transforms.push(translate);\n        }\n        if (degrees !== 0) {\n            rotate = svgLayer.createSVGTransform();\n            var centerX = Math.round(this.labelWidth / 2),\n                centerY = 0;\n            rotate.setRotate(degrees, centerX, centerY);\n            transforms.push(rotate);\n        }\n\n        return transforms;\n    };\n\n    AxisLabel.prototype.calculateOffsets = function(box) {\n        var offsets = {\n            x: 0,\n            y: 0,\n            degrees: 0\n        };\n        if (this.position === 'bottom') {\n            offsets.x = box.left + box.width / 2 - this.labelWidth / 2;\n            offsets.y = box.top + box.height - this.labelHeight;\n        } else if (this.position === 'top') {\n            offsets.x = box.left + box.width / 2 - this.labelWidth / 2;\n            offsets.y = box.top;\n        } else if (this.position === 'left') {\n            offsets.degrees = -90;\n            offsets.x = box.left - this.labelWidth / 2;\n            offsets.y = box.height / 2 + box.top;\n        } else if (this.position === 'right') {\n            offsets.degrees = 90;\n            offsets.x = box.left + box.width - this.labelWidth / 2;\n            offsets.y = box.height / 2 + box.top;\n        }\n        offsets.x = Math.round(offsets.x);\n        offsets.y = Math.round(offsets.y);\n\n        return offsets;\n    };\n\n    AxisLabel.prototype.cleanup = function() {\n        var axisId = this.axisName + 'Label',\n            layerId = axisId + 'Layer',\n            className = axisId + ' axisLabels';\n        this.surface.removeText(layerId, 0, 0, this.axisLabel, className);\n    };\n\n    AxisLabel.prototype.draw = function(box) {\n        var axisId = this.axisName + 'Label',\n            layerId = axisId + 'Layer',\n            className = axisId + ' axisLabels',\n            offsets = this.calculateOffsets(box),\n            style = {\n                position: 'absolute',\n                bottom: '',\n                right: '',\n                display: 'inline-block',\n                'white-space': 'nowrap'\n            };\n\n        var layer = this.surface.getSVGLayer(layerId);\n        var transforms = this.transforms(offsets.degrees, offsets.x, offsets.y, layer.parentNode);\n\n        this.surface.addText(layerId, 0, 0, this.axisLabel, className, undefined, undefined, undefined, undefined, transforms);\n        this.surface.render();\n        Object.keys(style).forEach(function(key) {\n            layer.style[key] = style[key];\n        });\n    };\n\n    function init(plot) {\n        plot.hooks.processOptions.push(function(plot, options) {\n            if (!options.axisLabels.show) {\n                return;\n            }\n\n            var axisLabels = {};\n            var defaultPadding = 2; // padding between axis and tick labels\n\n            plot.hooks.axisReserveSpace.push(function(plot, axis) {\n                var opts = axis.options;\n                var axisName = axis.direction + axis.n;\n\n                axis.labelHeight += axis.boxPosition.centerY;\n                axis.labelWidth += axis.boxPosition.centerX;\n\n                if (!opts || !opts.axisLabel || !axis.show) {\n                    return;\n                }\n\n                var padding = opts.axisLabelPadding === undefined\n                    ? defaultPadding\n                    : opts.axisLabelPadding;\n\n                var axisLabel = axisLabels[axisName];\n                if (!axisLabel) {\n                    axisLabel = new AxisLabel(axisName,\n                        opts.position, padding,\n                        plot.getPlaceholder()[0], opts.axisLabel, plot.getSurface());\n                    axisLabels[axisName] = axisLabel;\n                }\n\n                axisLabel.calculateSize();\n\n                // Incrementing the sizes of the tick labels.\n                axis.labelHeight += axisLabel.height;\n                axis.labelWidth += axisLabel.width;\n            });\n\n            // TODO - use the drawAxis hook\n            plot.hooks.draw.push(function(plot, ctx) {\n                $.each(plot.getAxes(), function(flotAxisName, axis) {\n                    var opts = axis.options;\n                    if (!opts || !opts.axisLabel || !axis.show) {\n                        return;\n                    }\n\n                    var axisName = axis.direction + axis.n;\n                    axisLabels[axisName].draw(axis.box);\n                });\n            });\n\n            plot.hooks.shutdown.push(function(plot, eventHolder) {\n                for (var axisName in axisLabels) {\n                    axisLabels[axisName].cleanup();\n                }\n            });\n        });\n    };\n\n    $.plot.plugins.push({\n        init: init,\n        options: options,\n        name: 'axisLabels',\n        version: '3.0'\n    });\n})(jQuery);\n","/** ## jquery.flot.browser.js\n\nThis plugin is used to make available some browser-related utility functions.\n\n### Methods\n*/\n\n(function ($) {\n    'use strict';\n\n    var browser = {\n        /**\n        - getPageXY(e)\n\n         Calculates the pageX and pageY using the screenX, screenY properties of the event\n         and the scrolling of the page. This is needed because the pageX and pageY\n         properties of the event are not correct while running tests in Edge. */\n        getPageXY: function (e) {\n            // This code is inspired from https://stackoverflow.com/a/3464890\n            var doc = document.documentElement,\n                pageX = e.clientX + (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0),\n                pageY = e.clientY + (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);\n            return { X: pageX, Y: pageY };\n        },\n\n        /**\n        - getPixelRatio(context)\n\n         This function returns the current pixel ratio defined by the product of desktop\n         zoom and page zoom.\n         Additional info: https://www.html5rocks.com/en/tutorials/canvas/hidpi/\n        */\n        getPixelRatio: function(context) {\n            var devicePixelRatio = window.devicePixelRatio || 1,\n                backingStoreRatio =\n                context.webkitBackingStorePixelRatio ||\n                context.mozBackingStorePixelRatio ||\n                context.msBackingStorePixelRatio ||\n                context.oBackingStorePixelRatio ||\n                context.backingStorePixelRatio || 1;\n            return devicePixelRatio / backingStoreRatio;\n        },\n\n        /**\n        - isSafari, isMobileSafari, isOpera, isFirefox, isIE, isEdge, isChrome, isBlink\n\n         This is a collection of functions, used to check if the code is running in a\n         particular browser or Javascript engine.\n        */\n        isSafari: function() {\n            // *** https://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser\n            // Safari 3.0+ \"[object HTMLElementConstructor]\"\n            return /constructor/i.test(window.top.HTMLElement) || (function (p) { return p.toString() === \"[object SafariRemoteNotification]\"; })(!window.top['safari'] || (typeof window.top.safari !== 'undefined' && window.top.safari.pushNotification));\n        },\n\n        isMobileSafari: function() {\n            //isMobileSafari adapted from https://stackoverflow.com/questions/3007480/determine-if-user-navigated-from-mobile-safari\n            return navigator.userAgent.match(/(iPod|iPhone|iPad)/) && navigator.userAgent.match(/AppleWebKit/);\n        },\n\n        isOpera: function() {\n            // *** https://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser\n            //Opera 8.0+\n            return (!!window.opr && !!opr.addons) || !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;\n        },\n\n        isFirefox: function() {\n            // *** https://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser\n            // Firefox 1.0+\n            return typeof InstallTrigger !== 'undefined';\n        },\n\n        isIE: function() {\n            // *** https://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser\n            // Internet Explorer 6-11\n            return /*@cc_on!@*/false || !!document.documentMode;\n        },\n\n        isEdge: function() {\n            // *** https://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser\n            // Edge 20+\n            return !browser.isIE() && !!window.StyleMedia;\n        },\n\n        isChrome: function() {\n            // *** https://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser\n            // Chrome 1+\n            return !!window.chrome && !!window.chrome.webstore;\n        },\n\n        isBlink: function() {\n            // *** https://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser\n            return (browser.isChrome() || browser.isOpera()) && !!window.CSS;\n        }\n    };\n\n    $.plot.browser = browser;\n})(jQuery);\n","/* Flot plugin for plotting textual data or categories.\n\nCopyright (c) 2007-2014 IOLA and Ole Laursen.\nLicensed under the MIT license.\n\nConsider a dataset like [[\"February\", 34], [\"March\", 20], ...]. This plugin\nallows you to plot such a dataset directly.\n\nTo enable it, you must specify mode: \"categories\" on the axis with the textual\nlabels, e.g.\n\n    $.plot(\"#placeholder\", data, { xaxis: { mode: \"categories\" } });\n\nBy default, the labels are ordered as they are met in the data series. If you\nneed a different ordering, you can specify \"categories\" on the axis options\nand list the categories there:\n\n    xaxis: {\n        mode: \"categories\",\n        categories: [\"February\", \"March\", \"April\"]\n    }\n\nIf you need to customize the distances between the categories, you can specify\n\"categories\" as an object mapping labels to values\n\n    xaxis: {\n        mode: \"categories\",\n        categories: { \"February\": 1, \"March\": 3, \"April\": 4 }\n    }\n\nIf you don't specify all categories, the remaining categories will be numbered\nfrom the max value plus 1 (with a spacing of 1 between each).\n\nInternally, the plugin works by transforming the input data through an auto-\ngenerated mapping where the first category becomes 0, the second 1, etc.\nHence, a point like [\"February\", 34] becomes [0, 34] internally in Flot (this\nis visible in hover and click events that return numbers rather than the\ncategory labels). The plugin also overrides the tick generator to spit out the\ncategories as ticks instead of the values.\n\nIf you need to map a value back to its label, the mapping is always accessible\nas \"categories\" on the axis object, e.g. plot.getAxes().xaxis.categories.\n\n*/\n\n(function ($) {\n    var options = {\n        xaxis: {\n            categories: null\n        },\n        yaxis: {\n            categories: null\n        }\n    };\n\n    function processRawData(plot, series, data, datapoints) {\n        // if categories are enabled, we need to disable\n        // auto-transformation to numbers so the strings are intact\n        // for later processing\n\n        var xCategories = series.xaxis.options.mode === \"categories\",\n            yCategories = series.yaxis.options.mode === \"categories\";\n\n        if (!(xCategories || yCategories)) {\n            return;\n        }\n\n        var format = datapoints.format;\n\n        if (!format) {\n            // FIXME: auto-detection should really not be defined here\n            var s = series;\n            format = [];\n            format.push({ x: true, number: true, required: true, computeRange: true});\n            format.push({ y: true, number: true, required: true, computeRange: true });\n\n            if (s.bars.show || (s.lines.show && s.lines.fill)) {\n                var autoScale = !!((s.bars.show && s.bars.zero) || (s.lines.show && s.lines.zero));\n                format.push({ y: true, number: true, required: false, defaultValue: 0, computeRange: autoScale });\n                if (s.bars.horizontal) {\n                    delete format[format.length - 1].y;\n                    format[format.length - 1].x = true;\n                }\n            }\n\n            datapoints.format = format;\n        }\n\n        for (var m = 0; m < format.length; ++m) {\n            if (format[m].x && xCategories) {\n                format[m].number = false;\n            }\n\n            if (format[m].y && yCategories) {\n                format[m].number = false;\n                format[m].computeRange = false;\n            }\n        }\n    }\n\n    function getNextIndex(categories) {\n        var index = -1;\n\n        for (var v in categories) {\n            if (categories[v] > index) {\n                index = categories[v];\n            }\n        }\n\n        return index + 1;\n    }\n\n    function categoriesTickGenerator(axis) {\n        var res = [];\n        for (var label in axis.categories) {\n            var v = axis.categories[label];\n            if (v >= axis.min && v <= axis.max) {\n                res.push([v, label]);\n            }\n        }\n\n        res.sort(function (a, b) { return a[0] - b[0]; });\n\n        return res;\n    }\n\n    function setupCategoriesForAxis(series, axis, datapoints) {\n        if (series[axis].options.mode !== \"categories\") {\n            return;\n        }\n\n        if (!series[axis].categories) {\n            // parse options\n            var c = {}, o = series[axis].options.categories || {};\n            if ($.isArray(o)) {\n                for (var i = 0; i < o.length; ++i) {\n                    c[o[i]] = i;\n                }\n            } else {\n                for (var v in o) {\n                    c[v] = o[v];\n                }\n            }\n\n            series[axis].categories = c;\n        }\n\n        // fix ticks\n        if (!series[axis].options.ticks) {\n            series[axis].options.ticks = categoriesTickGenerator;\n        }\n\n        transformPointsOnAxis(datapoints, axis, series[axis].categories);\n    }\n\n    function transformPointsOnAxis(datapoints, axis, categories) {\n        // go through the points, transforming them\n        var points = datapoints.points,\n            ps = datapoints.pointsize,\n            format = datapoints.format,\n            formatColumn = axis.charAt(0),\n            index = getNextIndex(categories);\n\n        for (var i = 0; i < points.length; i += ps) {\n            if (points[i] == null) {\n                continue;\n            }\n\n            for (var m = 0; m < ps; ++m) {\n                var val = points[i + m];\n\n                if (val == null || !format[m][formatColumn]) {\n                    continue;\n                }\n\n                if (!(val in categories)) {\n                    categories[val] = index;\n                    ++index;\n                }\n\n                points[i + m] = categories[val];\n            }\n        }\n    }\n\n    function processDatapoints(plot, series, datapoints) {\n        setupCategoriesForAxis(series, \"xaxis\", datapoints);\n        setupCategoriesForAxis(series, \"yaxis\", datapoints);\n    }\n\n    function init(plot) {\n        plot.hooks.processRawData.push(processRawData);\n        plot.hooks.processDatapoints.push(processDatapoints);\n    }\n\n    $.plot.plugins.push({\n        init: init,\n        options: options,\n        name: 'categories',\n        version: '1.0'\n    });\n})(jQuery);\n","/** ## jquery.flot.composeImages.js\n\nThis plugin is used to expose a function used to overlap several canvases and\nSVGs, for the purpose of creating a snaphot out of them.\n\n### When composeImages is used:\nWhen multiple canvases and SVGs have to be overlapped into a single image\nand their offset on the page, must be preserved.\n\n### Where can be used:\nIn creating a downloadable snapshot of the plots, axes, cursors etc of a graph.\n\n### How it works:\nThe entry point is composeImages function. It expects an array of objects,\nwhich should be either canvases or SVGs (or a mix). It does a prevalidation\nof them, by verifying if they will be usable or not, later in the flow.\nAfter selecting only usable sources, it passes them to getGenerateTempImg\nfunction, which generates temporary images out of them. This function\nexpects that some of the passed sources (canvas or SVG) may still have\nproblems being converted to an image and makes sure the promises system,\nused by composeImages function, moves forward. As an example, SVGs with\nmissing information from header or with unsupported content, may lead to\nfailure in generating the temporary image. Temporary images are required\nmostly on extracting content from SVGs, but this is also where the x/y\noffsets are extracted for each image which will be added. For SVGs in\nparticular, their CSS rules have to be applied.\nAfter all temporary images are generated, they are overlapped using\ngetExecuteImgComposition function. This is where the destination canvas\nis set to the proper dimensions. It is then output by composeImages.\nThis function returns a promise, which can be used to wait for the whole\ncomposition process. It requires to be asynchronous, because this is how\ntemporary images load their data.\n*/\n\n(function($) {\n    \"use strict\";\n    const GENERALFAILURECALLBACKERROR = -100; //simply a negative number\n    const SUCCESSFULIMAGEPREPARATION = 0;\n    const EMPTYARRAYOFIMAGESOURCES = -1;\n    const NEGATIVEIMAGESIZE = -2;\n    var pixelRatio = 1;\n    var browser = $.plot.browser;\n    var getPixelRatio = browser.getPixelRatio;\n\n    function composeImages(canvasOrSvgSources, destinationCanvas) {\n        var validCanvasOrSvgSources = canvasOrSvgSources.filter(isValidSource);\n        pixelRatio = getPixelRatio(destinationCanvas.getContext('2d'));\n\n        var allImgCompositionPromises = validCanvasOrSvgSources.map(function(validCanvasOrSvgSource) {\n            var tempImg = new Image();\n            var currentPromise = new Promise(getGenerateTempImg(tempImg, validCanvasOrSvgSource));\n            return currentPromise;\n        });\n\n        var lastPromise = Promise.all(allImgCompositionPromises).then(getExecuteImgComposition(destinationCanvas), failureCallback);\n        return lastPromise;\n    }\n\n    function isValidSource(canvasOrSvgSource) {\n        var isValidFromCanvas = true;\n        var isValidFromContent = true;\n        if ((canvasOrSvgSource === null) || (canvasOrSvgSource === undefined)) {\n            isValidFromContent = false;\n        } else {\n            if (canvasOrSvgSource.tagName === 'CANVAS') {\n                if ((canvasOrSvgSource.getBoundingClientRect().right === canvasOrSvgSource.getBoundingClientRect().left) ||\n                    (canvasOrSvgSource.getBoundingClientRect().bottom === canvasOrSvgSource.getBoundingClientRect().top)) {\n                    isValidFromCanvas = false;\n                }\n            }\n        }\n        return isValidFromContent && isValidFromCanvas && (window.getComputedStyle(canvasOrSvgSource).visibility === 'visible');\n    }\n\n    function getGenerateTempImg(tempImg, canvasOrSvgSource) {\n        tempImg.sourceDescription = '<info className=\"' + canvasOrSvgSource.className + '\" tagName=\"' + canvasOrSvgSource.tagName + '\" id=\"' + canvasOrSvgSource.id + '\">';\n        tempImg.sourceComponent = canvasOrSvgSource;\n\n        return function doGenerateTempImg(successCallbackFunc, failureCallbackFunc) {\n            tempImg.onload = function(evt) {\n                tempImg.successfullyLoaded = true;\n                successCallbackFunc(tempImg);\n            };\n\n            tempImg.onabort = function(evt) {\n                tempImg.successfullyLoaded = false;\n                console.log('Can\\'t generate temp image from ' + tempImg.sourceDescription + '. It is possible that it is missing some properties or its content is not supported by this browser. Source component:', tempImg.sourceComponent);\n                successCallbackFunc(tempImg); //call successCallback, to allow snapshot of all working images\n            };\n\n            tempImg.onerror = function(evt) {\n                tempImg.successfullyLoaded = false;\n                console.log('Can\\'t generate temp image from ' + tempImg.sourceDescription + '. It is possible that it is missing some properties or its content is not supported by this browser. Source component:', tempImg.sourceComponent);\n                successCallbackFunc(tempImg); //call successCallback, to allow snapshot of all working images\n            };\n\n            generateTempImageFromCanvasOrSvg(canvasOrSvgSource, tempImg);\n        };\n    }\n\n    function getExecuteImgComposition(destinationCanvas) {\n        return function executeImgComposition(tempImgs) {\n            var compositionResult = copyImgsToCanvas(tempImgs, destinationCanvas);\n            return compositionResult;\n        };\n    }\n\n    function copyCanvasToImg(canvas, img) {\n        img.src = canvas.toDataURL('image/png');\n    }\n\n    function getCSSRules(document) {\n        var styleSheets = document.styleSheets,\n            rulesList = [];\n        for (var i = 0; i < styleSheets.length; i++) {\n            // CORS requests for style sheets throw and an exception on Chrome > 64\n            try {\n                // in Chrome, the external CSS files are empty when the page is directly loaded from disk\n                var rules = styleSheets[i].cssRules || [];\n                for (var j = 0; j < rules.length; j++) {\n                    var rule = rules[j];\n                    rulesList.push(rule.cssText);\n                }\n            } catch (e) {\n                console.log('Failed to get some css rules');\n            }\n        }\n        return rulesList;\n    }\n\n    function embedCSSRulesInSVG(rules, svg) {\n        var text = [\n            '<svg class=\"snapshot ' + svg.classList + '\" width=\"' + svg.width.baseVal.value * pixelRatio + '\" height=\"' + svg.height.baseVal.value * pixelRatio + '\" viewBox=\"0 0 ' + svg.width.baseVal.value + ' ' + svg.height.baseVal.value + '\" xmlns=\"http://www.w3.org/2000/svg\">',\n            '<style>',\n            '/* <![CDATA[ */',\n            rules.join('\\n'),\n            '/* ]]> */',\n            '</style>',\n            svg.innerHTML,\n            '</svg>'\n        ].join('\\n');\n        return text;\n    }\n\n    function copySVGToImgMostBrowsers(svg, img) {\n        var rules = getCSSRules(document),\n            source = embedCSSRulesInSVG(rules, svg);\n\n        source = patchSVGSource(source);\n\n        var blob = new Blob([source], {type: \"image/svg+xml;charset=utf-8\"}),\n            domURL = self.URL || self.webkitURL || self,\n            url = domURL.createObjectURL(blob);\n        img.src = url;\n    }\n\n    function copySVGToImgSafari(svg, img) {\n        // Use this method to convert a string buffer array to a binary string.\n        // Do so by breaking up large strings into smaller substrings; this is necessary to avoid the\n        // \"maximum call stack size exceeded\" exception that can happen when calling 'String.fromCharCode.apply'\n        // with a very long array.\n        function buildBinaryString (arrayBuffer) {\n            var binaryString = \"\";\n            const utf8Array = new Uint8Array(arrayBuffer);\n            const blockSize = 16384;\n            for (var i = 0; i < utf8Array.length; i = i + blockSize) {\n                const binarySubString = String.fromCharCode.apply(null, utf8Array.subarray(i, i + blockSize));\n                binaryString = binaryString + binarySubString;\n            }\n            return binaryString;\n        };\n\n        var rules = getCSSRules(document),\n            source = embedCSSRulesInSVG(rules, svg),\n            data,\n            utf8BinaryString;\n\n        source = patchSVGSource(source);\n\n        // Encode the string as UTF-8 and convert it to a binary string. The UTF-8 encoding is required to\n        // capture unicode characters correctly.\n        utf8BinaryString = buildBinaryString(new (TextEncoder || TextEncoderLite)('utf-8').encode(source));\n\n        data = \"data:image/svg+xml;base64,\" + btoa(utf8BinaryString);\n        img.src = data;\n    }\n\n    function patchSVGSource(svgSource) {\n        var source = '';\n        //add name spaces.\n        if (!svgSource.match(/^<svg[^>]+xmlns=\"http:\\/\\/www\\.w3\\.org\\/2000\\/svg\"/)) {\n            source = svgSource.replace(/^<svg/, '<svg xmlns=\"http://www.w3.org/2000/svg\"');\n        }\n        if (!svgSource.match(/^<svg[^>]+\"http:\\/\\/www\\.w3\\.org\\/1999\\/xlink\"/)) {\n            source = svgSource.replace(/^<svg/, '<svg xmlns:xlink=\"http://www.w3.org/1999/xlink\"');\n        }\n\n        //add xml declaration\n        return '<?xml version=\"1.0\" standalone=\"no\"?>\\r\\n' + source;\n    }\n\n    function copySVGToImg(svg, img) {\n        if (browser.isSafari() || browser.isMobileSafari()) {\n            copySVGToImgSafari(svg, img);\n        } else {\n            copySVGToImgMostBrowsers(svg, img);\n        }\n    }\n\n    function adaptDestSizeToZoom(destinationCanvas, sources) {\n        function containsSVGs(source) {\n            return source.srcImgTagName === 'svg';\n        }\n\n        if (sources.find(containsSVGs) !== undefined) {\n            if (pixelRatio < 1) {\n                destinationCanvas.width = destinationCanvas.width * pixelRatio;\n                destinationCanvas.height = destinationCanvas.height * pixelRatio;\n            }\n        }\n    }\n\n    function prepareImagesToBeComposed(sources, destination) {\n        var result = SUCCESSFULIMAGEPREPARATION;\n        if (sources.length === 0) {\n            result = EMPTYARRAYOFIMAGESOURCES; //nothing to do if called without sources\n        } else {\n            var minX = sources[0].genLeft;\n            var minY = sources[0].genTop;\n            var maxX = sources[0].genRight;\n            var maxY = sources[0].genBottom;\n            var i = 0;\n\n            for (i = 1; i < sources.length; i++) {\n                if (minX > sources[i].genLeft) {\n                    minX = sources[i].genLeft;\n                }\n\n                if (minY > sources[i].genTop) {\n                    minY = sources[i].genTop;\n                }\n            }\n\n            for (i = 1; i < sources.length; i++) {\n                if (maxX < sources[i].genRight) {\n                    maxX = sources[i].genRight;\n                }\n\n                if (maxY < sources[i].genBottom) {\n                    maxY = sources[i].genBottom;\n                }\n            }\n\n            if ((maxX - minX <= 0) || (maxY - minY <= 0)) {\n                result = NEGATIVEIMAGESIZE; //this might occur on hidden images\n            } else {\n                destination.width = Math.round(maxX - minX);\n                destination.height = Math.round(maxY - minY);\n\n                for (i = 0; i < sources.length; i++) {\n                    sources[i].xCompOffset = sources[i].genLeft - minX;\n                    sources[i].yCompOffset = sources[i].genTop - minY;\n                }\n\n                adaptDestSizeToZoom(destination, sources);\n            }\n        }\n        return result;\n    }\n\n    function copyImgsToCanvas(sources, destination) {\n        var prepareImagesResult = prepareImagesToBeComposed(sources, destination);\n        if (prepareImagesResult === SUCCESSFULIMAGEPREPARATION) {\n            var destinationCtx = destination.getContext('2d');\n\n            for (var i = 0; i < sources.length; i++) {\n                if (sources[i].successfullyLoaded === true) {\n                    destinationCtx.drawImage(sources[i], sources[i].xCompOffset * pixelRatio, sources[i].yCompOffset * pixelRatio);\n                }\n            }\n        }\n        return prepareImagesResult;\n    }\n\n    function adnotateDestImgWithBoundingClientRect(srcCanvasOrSvg, destImg) {\n        destImg.genLeft = srcCanvasOrSvg.getBoundingClientRect().left;\n        destImg.genTop = srcCanvasOrSvg.getBoundingClientRect().top;\n\n        if (srcCanvasOrSvg.tagName === 'CANVAS') {\n            destImg.genRight = destImg.genLeft + srcCanvasOrSvg.width;\n            destImg.genBottom = destImg.genTop + srcCanvasOrSvg.height;\n        }\n\n        if (srcCanvasOrSvg.tagName === 'svg') {\n            destImg.genRight = srcCanvasOrSvg.getBoundingClientRect().right;\n            destImg.genBottom = srcCanvasOrSvg.getBoundingClientRect().bottom;\n        }\n    }\n\n    function generateTempImageFromCanvasOrSvg(srcCanvasOrSvg, destImg) {\n        if (srcCanvasOrSvg.tagName === 'CANVAS') {\n            copyCanvasToImg(srcCanvasOrSvg, destImg);\n        }\n\n        if (srcCanvasOrSvg.tagName === 'svg') {\n            copySVGToImg(srcCanvasOrSvg, destImg);\n        }\n\n        destImg.srcImgTagName = srcCanvasOrSvg.tagName;\n        adnotateDestImgWithBoundingClientRect(srcCanvasOrSvg, destImg);\n    }\n\n    function failureCallback() {\n        return GENERALFAILURECALLBACKERROR;\n    }\n\n    // used for testing\n    $.plot.composeImages = composeImages;\n\n    function init(plot) {\n        // used to extend the public API of the plot\n        plot.composeImages = composeImages;\n    }\n\n    $.plot.plugins.push({\n        init: init,\n        name: 'composeImages',\n        version: '1.0'\n    });\n})(jQuery);\n","/* Flot plugin for showing crosshairs when the mouse hovers over the plot.\n\nCopyright (c) 2007-2014 IOLA and Ole Laursen.\nLicensed under the MIT license.\n\nThe plugin supports these options:\n\n    crosshair: {\n        mode: null or \"x\" or \"y\" or \"xy\"\n        color: color\n        lineWidth: number\n    }\n\nSet the mode to one of \"x\", \"y\" or \"xy\". The \"x\" mode enables a vertical\ncrosshair that lets you trace the values on the x axis, \"y\" enables a\nhorizontal crosshair and \"xy\" enables them both. \"color\" is the color of the\ncrosshair (default is \"rgba(170, 0, 0, 0.80)\"), \"lineWidth\" is the width of\nthe drawn lines (default is 1).\n\nThe plugin also adds four public methods:\n\n  - setCrosshair( pos )\n\n    Set the position of the crosshair. Note that this is cleared if the user\n    moves the mouse. \"pos\" is in coordinates of the plot and should be on the\n    form { x: xpos, y: ypos } (you can use x2/x3/... if you're using multiple\n    axes), which is coincidentally the same format as what you get from a\n    \"plothover\" event. If \"pos\" is null, the crosshair is cleared.\n\n  - clearCrosshair()\n\n    Clear the crosshair.\n\n  - lockCrosshair(pos)\n\n    Cause the crosshair to lock to the current location, no longer updating if\n    the user moves the mouse. Optionally supply a position (passed on to\n    setCrosshair()) to move it to.\n\n    Example usage:\n\n    var myFlot = $.plot( $(\"#graph\"), ..., { crosshair: { mode: \"x\" } } };\n    $(\"#graph\").bind( \"plothover\", function ( evt, position, item ) {\n        if ( item ) {\n            // Lock the crosshair to the data point being hovered\n            myFlot.lockCrosshair({\n                x: item.datapoint[ 0 ],\n                y: item.datapoint[ 1 ]\n            });\n        } else {\n            // Return normal crosshair operation\n            myFlot.unlockCrosshair();\n        }\n    });\n\n  - unlockCrosshair()\n\n    Free the crosshair to move again after locking it.\n*/\n\n(function ($) {\n    var options = {\n        crosshair: {\n            mode: null, // one of null, \"x\", \"y\" or \"xy\",\n            color: \"rgba(170, 0, 0, 0.80)\",\n            lineWidth: 1\n        }\n    };\n\n    function init(plot) {\n        // position of crosshair in pixels\n        var crosshair = {x: -1, y: -1, locked: false, highlighted: false};\n\n        plot.setCrosshair = function setCrosshair(pos) {\n            if (!pos) {\n                crosshair.x = -1;\n            } else {\n                var o = plot.p2c(pos);\n                crosshair.x = Math.max(0, Math.min(o.left, plot.width()));\n                crosshair.y = Math.max(0, Math.min(o.top, plot.height()));\n            }\n\n            plot.triggerRedrawOverlay();\n        };\n\n        plot.clearCrosshair = plot.setCrosshair; // passes null for pos\n\n        plot.lockCrosshair = function lockCrosshair(pos) {\n            if (pos) {\n                plot.setCrosshair(pos);\n            }\n\n            crosshair.locked = true;\n        };\n\n        plot.unlockCrosshair = function unlockCrosshair() {\n            crosshair.locked = false;\n            crosshair.rect = null;\n        };\n\n        function onMouseOut(e) {\n            if (crosshair.locked) {\n                return;\n            }\n\n            if (crosshair.x !== -1) {\n                crosshair.x = -1;\n                plot.triggerRedrawOverlay();\n            }\n        }\n\n        function onMouseMove(e) {\n            var offset = plot.offset();\n            if (crosshair.locked) {\n                var mouseX = Math.max(0, Math.min(e.pageX - offset.left, plot.width()));\n                var mouseY = Math.max(0, Math.min(e.pageY - offset.top, plot.height()));\n\n                if ((mouseX > crosshair.x - 4) && (mouseX < crosshair.x + 4) && (mouseY > crosshair.y - 4) && (mouseY < crosshair.y + 4)) {\n                    if (!crosshair.highlighted) {\n                        crosshair.highlighted = true;\n                        plot.triggerRedrawOverlay();\n                    }\n                } else {\n                    if (crosshair.highlighted) {\n                        crosshair.highlighted = false;\n                        plot.triggerRedrawOverlay();\n                    }\n                }\n                return;\n            }\n\n            if (plot.getSelection && plot.getSelection()) {\n                crosshair.x = -1; // hide the crosshair while selecting\n                return;\n            }\n\n            crosshair.x = Math.max(0, Math.min(e.pageX - offset.left, plot.width()));\n            crosshair.y = Math.max(0, Math.min(e.pageY - offset.top, plot.height()));\n            plot.triggerRedrawOverlay();\n        }\n\n        plot.hooks.bindEvents.push(function (plot, eventHolder) {\n            if (!plot.getOptions().crosshair.mode) {\n                return;\n            }\n\n            eventHolder.mouseout(onMouseOut);\n            eventHolder.mousemove(onMouseMove);\n        });\n\n        plot.hooks.drawOverlay.push(function (plot, ctx) {\n            var c = plot.getOptions().crosshair;\n            if (!c.mode) {\n                return;\n            }\n\n            var plotOffset = plot.getPlotOffset();\n\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            if (crosshair.x !== -1) {\n                var adj = plot.getOptions().crosshair.lineWidth % 2 ? 0.5 : 0;\n\n                ctx.strokeStyle = c.color;\n                ctx.lineWidth = c.lineWidth;\n                ctx.lineJoin = \"round\";\n\n                ctx.beginPath();\n                if (c.mode.indexOf(\"x\") !== -1) {\n                    var drawX = Math.floor(crosshair.x) + adj;\n                    ctx.moveTo(drawX, 0);\n                    ctx.lineTo(drawX, plot.height());\n                }\n                if (c.mode.indexOf(\"y\") !== -1) {\n                    var drawY = Math.floor(crosshair.y) + adj;\n                    ctx.moveTo(0, drawY);\n                    ctx.lineTo(plot.width(), drawY);\n                }\n                if (crosshair.locked) {\n                    if (crosshair.highlighted) ctx.fillStyle = 'orange';\n                    else ctx.fillStyle = c.color;\n                    ctx.fillRect(Math.floor(crosshair.x) + adj - 4, Math.floor(crosshair.y) + adj - 4, 8, 8);\n                }\n                ctx.stroke();\n            }\n            ctx.restore();\n        });\n\n        plot.hooks.shutdown.push(function (plot, eventHolder) {\n            eventHolder.unbind(\"mouseout\", onMouseOut);\n            eventHolder.unbind(\"mousemove\", onMouseMove);\n        });\n    }\n\n    $.plot.plugins.push({\n        init: init,\n        options: options,\n        name: 'crosshair',\n        version: '1.0'\n    });\n})(jQuery);\n","/**\n## jquery.flot.drawSeries.js\n\nThis plugin is used by flot for drawing lines, plots, bars or area.\n\n### Public methods\n*/\n\n(function($) {\n    \"use strict\";\n\n    function DrawSeries() {\n        function plotLine(datapoints, xoffset, yoffset, axisx, axisy, ctx, steps) {\n            var points = datapoints.points,\n                ps = datapoints.pointsize,\n                prevx = null,\n                prevy = null;\n            var x1 = 0.0,\n                y1 = 0.0,\n                x2 = 0.0,\n                y2 = 0.0,\n                mx = null,\n                my = null,\n                i = 0;\n\n            ctx.beginPath();\n            for (i = ps; i < points.length; i += ps) {\n                x1 = points[i - ps];\n                y1 = points[i - ps + 1];\n                x2 = points[i];\n                y2 = points[i + 1];\n\n                if (x1 === null || x2 === null) {\n                    mx = null;\n                    my = null;\n                    continue;\n                }\n\n                if (isNaN(x1) || isNaN(x2) || isNaN(y1) || isNaN(y2)) {\n                    prevx = null;\n                    prevy = null;\n                    continue;\n                }\n\n                if (steps) {\n                    if (mx !== null && my !== null) {\n                        // if middle point exists, transfer p2 -> p1 and p1 -> mp\n                        x2 = x1;\n                        y2 = y1;\n                        x1 = mx;\n                        y1 = my;\n\n                        // 'remove' middle point\n                        mx = null;\n                        my = null;\n\n                        // subtract pointsize from i to have current point p1 handled again\n                        i -= ps;\n                    } else if (y1 !== y2 && x1 !== x2) {\n                        // create a middle point\n                        y2 = y1;\n                        mx = x2;\n                        my = y1;\n                    }\n                }\n\n                // clip with ymin\n                if (y1 <= y2 && y1 < axisy.min) {\n                    if (y2 < axisy.min) {\n                        // line segment is outside\n                        continue;\n                    }\n                    // compute new intersection point\n                    x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n                    y1 = axisy.min;\n                } else if (y2 <= y1 && y2 < axisy.min) {\n                    if (y1 < axisy.min) {\n                        continue;\n                    }\n\n                    x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n                    y2 = axisy.min;\n                }\n\n                // clip with ymax\n                if (y1 >= y2 && y1 > axisy.max) {\n                    if (y2 > axisy.max) {\n                        continue;\n                    }\n\n                    x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n                    y1 = axisy.max;\n                } else if (y2 >= y1 && y2 > axisy.max) {\n                    if (y1 > axisy.max) {\n                        continue;\n                    }\n\n                    x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n                    y2 = axisy.max;\n                }\n\n                // clip with xmin\n                if (x1 <= x2 && x1 < axisx.min) {\n                    if (x2 < axisx.min) {\n                        continue;\n                    }\n\n                    y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n                    x1 = axisx.min;\n                } else if (x2 <= x1 && x2 < axisx.min) {\n                    if (x1 < axisx.min) {\n                        continue;\n                    }\n\n                    y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n                    x2 = axisx.min;\n                }\n\n                // clip with xmax\n                if (x1 >= x2 && x1 > axisx.max) {\n                    if (x2 > axisx.max) {\n                        continue;\n                    }\n\n                    y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n                    x1 = axisx.max;\n                } else if (x2 >= x1 && x2 > axisx.max) {\n                    if (x1 > axisx.max) {\n                        continue;\n                    }\n\n                    y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n                    x2 = axisx.max;\n                }\n\n                if (x1 !== prevx || y1 !== prevy) {\n                    ctx.moveTo(axisx.p2c(x1) + xoffset, axisy.p2c(y1) + yoffset);\n                }\n\n                prevx = x2;\n                prevy = y2;\n                ctx.lineTo(axisx.p2c(x2) + xoffset, axisy.p2c(y2) + yoffset);\n            }\n            ctx.stroke();\n        }\n\n        function plotLineArea(datapoints, axisx, axisy, fillTowards, ctx, steps) {\n            var points = datapoints.points,\n                ps = datapoints.pointsize,\n                bottom = fillTowards > axisy.min ? Math.min(axisy.max, fillTowards) : axisy.min,\n                i = 0,\n                ypos = 1,\n                areaOpen = false,\n                segmentStart = 0,\n                segmentEnd = 0,\n                mx = null,\n                my = null;\n\n            // we process each segment in two turns, first forward\n            // direction to sketch out top, then once we hit the\n            // end we go backwards to sketch the bottom\n            while (true) {\n                if (ps > 0 && i > points.length + ps) {\n                    break;\n                }\n\n                i += ps; // ps is negative if going backwards\n\n                var x1 = points[i - ps],\n                    y1 = points[i - ps + ypos],\n                    x2 = points[i],\n                    y2 = points[i + ypos];\n\n                if (ps === -2) {\n                    /* going backwards and no value for the bottom provided in the series*/\n                    y1 = y2 = bottom;\n                }\n\n                if (areaOpen) {\n                    if (ps > 0 && x1 != null && x2 == null) {\n                        // at turning point\n                        segmentEnd = i;\n                        ps = -ps;\n                        ypos = 2;\n                        continue;\n                    }\n\n                    if (ps < 0 && i === segmentStart + ps) {\n                        // done with the reverse sweep\n                        ctx.fill();\n                        areaOpen = false;\n                        ps = -ps;\n                        ypos = 1;\n                        i = segmentStart = segmentEnd + ps;\n                        continue;\n                    }\n                }\n\n                if (x1 == null || x2 == null) {\n                    mx = null;\n                    my = null;\n                    continue;\n                }\n\n                if (steps) {\n                    if (mx !== null && my !== null) {\n                        // if middle point exists, transfer p2 -> p1 and p1 -> mp\n                        x2 = x1;\n                        y2 = y1;\n                        x1 = mx;\n                        y1 = my;\n\n                        // 'remove' middle point\n                        mx = null;\n                        my = null;\n\n                        // subtract pointsize from i to have current point p1 handled again\n                        i -= ps;\n                    } else if (y1 !== y2 && x1 !== x2) {\n                        // create a middle point\n                        y2 = y1;\n                        mx = x2;\n                        my = y1;\n                    }\n                }\n\n                // clip x values\n\n                // clip with xmin\n                if (x1 <= x2 && x1 < axisx.min) {\n                    if (x2 < axisx.min) {\n                        continue;\n                    }\n\n                    y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n                    x1 = axisx.min;\n                } else if (x2 <= x1 && x2 < axisx.min) {\n                    if (x1 < axisx.min) {\n                        continue;\n                    }\n\n                    y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n                    x2 = axisx.min;\n                }\n\n                // clip with xmax\n                if (x1 >= x2 && x1 > axisx.max) {\n                    if (x2 > axisx.max) {\n                        continue;\n                    }\n\n                    y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n                    x1 = axisx.max;\n                } else if (x2 >= x1 && x2 > axisx.max) {\n                    if (x1 > axisx.max) {\n                        continue;\n                    }\n\n                    y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n                    x2 = axisx.max;\n                }\n\n                if (!areaOpen) {\n                    // open area\n                    ctx.beginPath();\n                    ctx.moveTo(axisx.p2c(x1), axisy.p2c(bottom));\n                    areaOpen = true;\n                }\n\n                // now first check the case where both is outside\n                if (y1 >= axisy.max && y2 >= axisy.max) {\n                    ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.max));\n                    ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.max));\n                    continue;\n                } else if (y1 <= axisy.min && y2 <= axisy.min) {\n                    ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.min));\n                    ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.min));\n                    continue;\n                }\n\n                // else it's a bit more complicated, there might\n                // be a flat maxed out rectangle first, then a\n                // triangular cutout or reverse; to find these\n                // keep track of the current x values\n                var x1old = x1,\n                    x2old = x2;\n\n                // clip the y values, without shortcutting, we\n                // go through all cases in turn\n\n                // clip with ymin\n                if (y1 <= y2 && y1 < axisy.min && y2 >= axisy.min) {\n                    x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n                    y1 = axisy.min;\n                } else if (y2 <= y1 && y2 < axisy.min && y1 >= axisy.min) {\n                    x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n                    y2 = axisy.min;\n                }\n\n                // clip with ymax\n                if (y1 >= y2 && y1 > axisy.max && y2 <= axisy.max) {\n                    x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n                    y1 = axisy.max;\n                } else if (y2 >= y1 && y2 > axisy.max && y1 <= axisy.max) {\n                    x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n                    y2 = axisy.max;\n                }\n\n                // if the x value was changed we got a rectangle\n                // to fill\n                if (x1 !== x1old) {\n                    ctx.lineTo(axisx.p2c(x1old), axisy.p2c(y1));\n                    // it goes to (x1, y1), but we fill that below\n                }\n\n                // fill triangular section, this sometimes result\n                // in redundant points if (x1, y1) hasn't changed\n                // from previous line to, but we just ignore that\n                ctx.lineTo(axisx.p2c(x1), axisy.p2c(y1));\n                ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));\n\n                // fill the other rectangle if it's there\n                if (x2 !== x2old) {\n                    ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));\n                    ctx.lineTo(axisx.p2c(x2old), axisy.p2c(y2));\n                }\n            }\n        }\n\n        /**\n        - drawSeriesLines(series, ctx, plotOffset, plotWidth, plotHeight, drawSymbol, getColorOrGradient)\n\n         This function is used for drawing lines or area fill.  In case the series has line decimation function\n         attached, before starting to draw, as an optimization the points will first be decimated.\n\n         The series parameter contains the series to be drawn on ctx context. The plotOffset, plotWidth and\n         plotHeight are the corresponding parameters of flot used to determine the drawing surface.\n         The function getColorOrGradient is used to compute the fill style of lines and area.\n        */\n        function drawSeriesLines(series, ctx, plotOffset, plotWidth, plotHeight, drawSymbol, getColorOrGradient) {\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n            ctx.lineJoin = \"round\";\n\n            if (series.lines.dashes && ctx.setLineDash) {\n                ctx.setLineDash(series.lines.dashes);\n            }\n\n            var datapoints = {\n                format: series.datapoints.format,\n                points: series.datapoints.points,\n                pointsize: series.datapoints.pointsize\n            };\n\n            if (series.decimate) {\n                datapoints.points = series.decimate(series, series.xaxis.min, series.xaxis.max, plotWidth, series.yaxis.min, series.yaxis.max, plotHeight);\n            }\n\n            var lw = series.lines.lineWidth;\n\n            ctx.lineWidth = lw;\n            ctx.strokeStyle = series.color;\n            var fillStyle = getFillStyle(series.lines, series.color, 0, plotHeight, getColorOrGradient);\n            if (fillStyle) {\n                ctx.fillStyle = fillStyle;\n                plotLineArea(datapoints, series.xaxis, series.yaxis, series.lines.fillTowards || 0, ctx, series.lines.steps);\n            }\n\n            if (lw > 0) {\n                plotLine(datapoints, 0, 0, series.xaxis, series.yaxis, ctx, series.lines.steps);\n            }\n\n            ctx.restore();\n        }\n\n        /**\n        - drawSeriesPoints(series, ctx, plotOffset, plotWidth, plotHeight, drawSymbol, getColorOrGradient)\n\n         This function is used for drawing points using a given symbol. In case the series has points decimation\n         function attached, before starting to draw, as an optimization the points will first be decimated.\n\n         The series parameter contains the series to be drawn on ctx context. The plotOffset, plotWidth and\n         plotHeight are the corresponding parameters of flot used to determine the drawing surface.\n         The function drawSymbol is used to compute and draw the symbol chosen for the points.\n        */\n        function drawSeriesPoints(series, ctx, plotOffset, plotWidth, plotHeight, drawSymbol, getColorOrGradient) {\n            function drawCircle(ctx, x, y, radius, shadow, fill) {\n                ctx.moveTo(x + radius, y);\n                ctx.arc(x, y, radius, 0, shadow ? Math.PI : Math.PI * 2, false);\n            }\n            drawCircle.fill = true;\n            function plotPoints(datapoints, radius, fill, offset, shadow, axisx, axisy, drawSymbolFn) {\n                var points = datapoints.points,\n                    ps = datapoints.pointsize;\n\n                ctx.beginPath();\n                for (var i = 0; i < points.length; i += ps) {\n                    var x = points[i],\n                        y = points[i + 1];\n                    if (x == null || x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max) {\n                        continue;\n                    }\n\n                    x = axisx.p2c(x);\n                    y = axisy.p2c(y) + offset;\n\n                    drawSymbolFn(ctx, x, y, radius, shadow, fill);\n                }\n                if (drawSymbolFn.fill && !shadow) {\n                    ctx.fill();\n                }\n                ctx.stroke();\n            }\n\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            var datapoints = {\n                format: series.datapoints.format,\n                points: series.datapoints.points,\n                pointsize: series.datapoints.pointsize\n            };\n\n            if (series.decimatePoints) {\n                datapoints.points = series.decimatePoints(series, series.xaxis.min, series.xaxis.max, plotWidth, series.yaxis.min, series.yaxis.max, plotHeight);\n            }\n\n            var lw = series.points.lineWidth,\n                radius = series.points.radius,\n                symbol = series.points.symbol,\n                drawSymbolFn;\n\n            if (symbol === 'circle') {\n                drawSymbolFn = drawCircle;\n            } else if (typeof symbol === 'string' && drawSymbol && drawSymbol[symbol]) {\n                drawSymbolFn = drawSymbol[symbol];\n            } else if (typeof drawSymbol === 'function') {\n                drawSymbolFn = drawSymbol;\n            }\n\n            // If the user sets the line width to 0, we change it to a very\n            // small value. A line width of 0 seems to force the default of 1.\n\n            if (lw === 0) {\n                lw = 0.0001;\n            }\n\n            ctx.lineWidth = lw;\n            ctx.fillStyle = getFillStyle(series.points, series.color, null, null, getColorOrGradient);\n            ctx.strokeStyle = series.color;\n            plotPoints(datapoints, radius,\n                true, 0, false,\n                series.xaxis, series.yaxis, drawSymbolFn);\n            ctx.restore();\n        }\n\n        function drawBar(x, y, b, barLeft, barRight, fillStyleCallback, axisx, axisy, c, horizontal, lineWidth) {\n            var left = x + barLeft,\n                right = x + barRight,\n                bottom = b, top = y,\n                drawLeft, drawRight, drawTop, drawBottom = false,\n                tmp;\n\n            drawLeft = drawRight = drawTop = true;\n\n            // in horizontal mode, we start the bar from the left\n            // instead of from the bottom so it appears to be\n            // horizontal rather than vertical\n            if (horizontal) {\n                drawBottom = drawRight = drawTop = true;\n                drawLeft = false;\n                left = b;\n                right = x;\n                top = y + barLeft;\n                bottom = y + barRight;\n\n                // account for negative bars\n                if (right < left) {\n                    tmp = right;\n                    right = left;\n                    left = tmp;\n                    drawLeft = true;\n                    drawRight = false;\n                }\n            } else {\n                drawLeft = drawRight = drawTop = true;\n                drawBottom = false;\n                left = x + barLeft;\n                right = x + barRight;\n                bottom = b;\n                top = y;\n\n                // account for negative bars\n                if (top < bottom) {\n                    tmp = top;\n                    top = bottom;\n                    bottom = tmp;\n                    drawBottom = true;\n                    drawTop = false;\n                }\n            }\n\n            // clip\n            if (right < axisx.min || left > axisx.max ||\n                top < axisy.min || bottom > axisy.max) {\n                return;\n            }\n\n            if (left < axisx.min) {\n                left = axisx.min;\n                drawLeft = false;\n            }\n\n            if (right > axisx.max) {\n                right = axisx.max;\n                drawRight = false;\n            }\n\n            if (bottom < axisy.min) {\n                bottom = axisy.min;\n                drawBottom = false;\n            }\n\n            if (top > axisy.max) {\n                top = axisy.max;\n                drawTop = false;\n            }\n\n            left = axisx.p2c(left);\n            bottom = axisy.p2c(bottom);\n            right = axisx.p2c(right);\n            top = axisy.p2c(top);\n\n            // fill the bar\n            if (fillStyleCallback) {\n                c.fillStyle = fillStyleCallback(bottom, top);\n                c.fillRect(left, top, right - left, bottom - top)\n            }\n\n            // draw outline\n            if (lineWidth > 0 && (drawLeft || drawRight || drawTop || drawBottom)) {\n                c.beginPath();\n\n                // FIXME: inline moveTo is buggy with excanvas\n                c.moveTo(left, bottom);\n                if (drawLeft) {\n                    c.lineTo(left, top);\n                } else {\n                    c.moveTo(left, top);\n                }\n\n                if (drawTop) {\n                    c.lineTo(right, top);\n                } else {\n                    c.moveTo(right, top);\n                }\n\n                if (drawRight) {\n                    c.lineTo(right, bottom);\n                } else {\n                    c.moveTo(right, bottom);\n                }\n\n                if (drawBottom) {\n                    c.lineTo(left, bottom);\n                } else {\n                    c.moveTo(left, bottom);\n                }\n\n                c.stroke();\n            }\n        }\n\n        /**\n        - drawSeriesBars(series, ctx, plotOffset, plotWidth, plotHeight, drawSymbol, getColorOrGradient)\n\n         This function is used for drawing series represented as bars. In case the series has decimation\n         function attached, before starting to draw, as an optimization the points will first be decimated.\n\n         The series parameter contains the series to be drawn on ctx context. The plotOffset, plotWidth and\n         plotHeight are the corresponding parameters of flot used to determine the drawing surface.\n         The function getColorOrGradient is used to compute the fill style of bars.\n        */\n        function drawSeriesBars(series, ctx, plotOffset, plotWidth, plotHeight, drawSymbol, getColorOrGradient) {\n            function plotBars(datapoints, barLeft, barRight, fillStyleCallback, axisx, axisy) {\n                var points = datapoints.points,\n                    ps = datapoints.pointsize,\n                    fillTowards = series.bars.fillTowards || 0,\n                    defaultBottom = fillTowards > axisy.min ? Math.min(axisy.max, fillTowards) : axisy.min;\n\n                for (var i = 0; i < points.length; i += ps) {\n                    if (points[i] == null) {\n                        continue;\n                    }\n\n                    // Use third point as bottom if pointsize is 3\n                    var bottom = ps === 3 ? points[i + 2] : defaultBottom;\n                    drawBar(points[i], points[i + 1], bottom, barLeft, barRight, fillStyleCallback, axisx, axisy, ctx, series.bars.horizontal, series.bars.lineWidth);\n                }\n            }\n\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            var datapoints = {\n                format: series.datapoints.format,\n                points: series.datapoints.points,\n                pointsize: series.datapoints.pointsize\n            };\n\n            if (series.decimate) {\n                datapoints.points = series.decimate(series, series.xaxis.min, series.xaxis.max, plotWidth);\n            }\n\n            ctx.lineWidth = series.bars.lineWidth;\n            ctx.strokeStyle = series.color;\n\n            var barLeft;\n            var barWidth = series.bars.barWidth[0] || series.bars.barWidth;\n            switch (series.bars.align) {\n                case \"left\":\n                    barLeft = 0;\n                    break;\n                case \"right\":\n                    barLeft = -barWidth;\n                    break;\n                default:\n                    barLeft = -barWidth / 2;\n            }\n\n            var fillStyleCallback = series.bars.fill ? function(bottom, top) {\n                return getFillStyle(series.bars, series.color, bottom, top, getColorOrGradient);\n            } : null;\n\n            plotBars(datapoints, barLeft, barLeft + barWidth, fillStyleCallback, series.xaxis, series.yaxis);\n            ctx.restore();\n        }\n\n        function getFillStyle(filloptions, seriesColor, bottom, top, getColorOrGradient) {\n            var fill = filloptions.fill;\n            if (!fill) {\n                return null;\n            }\n\n            if (filloptions.fillColor) {\n                return getColorOrGradient(filloptions.fillColor, bottom, top, seriesColor);\n            }\n\n            var c = $.color.parse(seriesColor);\n            c.a = typeof fill === \"number\" ? fill : 0.4;\n            c.normalize();\n            return c.toString();\n        }\n\n        this.drawSeriesLines = drawSeriesLines;\n        this.drawSeriesPoints = drawSeriesPoints;\n        this.drawSeriesBars = drawSeriesBars;\n        this.drawBar = drawBar;\n    };\n\n    $.plot.drawSeries = new DrawSeries();\n})(jQuery);\n","/* Flot plugin for plotting error bars.\n\nCopyright (c) 2007-2014 IOLA and Ole Laursen.\nLicensed under the MIT license.\n\nError bars are used to show standard deviation and other statistical\nproperties in a plot.\n\n* Created by Rui Pereira  -  rui (dot) pereira (at) gmail (dot) com\n\nThis plugin allows you to plot error-bars over points. Set \"errorbars\" inside\nthe points series to the axis name over which there will be error values in\nyour data array (*even* if you do not intend to plot them later, by setting\n\"show: null\" on xerr/yerr).\n\nThe plugin supports these options:\n\n    series: {\n        points: {\n            errorbars: \"x\" or \"y\" or \"xy\",\n            xerr: {\n                show: null/false or true,\n                asymmetric: null/false or true,\n                upperCap: null or \"-\" or function,\n                lowerCap: null or \"-\" or function,\n                color: null or color,\n                radius: null or number\n            },\n            yerr: { same options as xerr }\n        }\n    }\n\nEach data point array is expected to be of the type:\n\n    \"x\"  [ x, y, xerr ]\n    \"y\"  [ x, y, yerr ]\n    \"xy\" [ x, y, xerr, yerr ]\n\nWhere xerr becomes xerr_lower,xerr_upper for the asymmetric error case, and\nequivalently for yerr. Eg., a datapoint for the \"xy\" case with symmetric\nerror-bars on X and asymmetric on Y would be:\n\n    [ x, y, xerr, yerr_lower, yerr_upper ]\n\nBy default no end caps are drawn. Setting upperCap and/or lowerCap to \"-\" will\ndraw a small cap perpendicular to the error bar. They can also be set to a\nuser-defined drawing function, with (ctx, x, y, radius) as parameters, as eg.\n\n    function drawSemiCircle( ctx, x, y, radius ) {\n        ctx.beginPath();\n        ctx.arc( x, y, radius, 0, Math.PI, false );\n        ctx.moveTo( x - radius, y );\n        ctx.lineTo( x + radius, y );\n        ctx.stroke();\n    }\n\nColor and radius both default to the same ones of the points series if not\nset. The independent radius parameter on xerr/yerr is useful for the case when\nwe may want to add error-bars to a line, without showing the interconnecting\npoints (with radius: 0), and still showing end caps on the error-bars.\nshadowSize and lineWidth are derived as well from the points series.\n\n*/\n\n(function ($) {\n    var options = {\n        series: {\n            points: {\n                errorbars: null, //should be 'x', 'y' or 'xy'\n                xerr: {err: 'x', show: null, asymmetric: null, upperCap: null, lowerCap: null, color: null, radius: null},\n                yerr: {err: 'y', show: null, asymmetric: null, upperCap: null, lowerCap: null, color: null, radius: null}\n            }\n        }\n    };\n\n    function processRawData(plot, series, data, datapoints) {\n        if (!series.points.errorbars) {\n            return;\n        }\n\n        // x,y values\n        var format = [\n            { x: true, number: true, required: true },\n            { y: true, number: true, required: true }\n        ];\n\n        var errors = series.points.errorbars;\n        // error bars - first X then Y\n        if (errors === 'x' || errors === 'xy') {\n            // lower / upper error\n            if (series.points.xerr.asymmetric) {\n                format.push({ x: true, number: true, required: true });\n                format.push({ x: true, number: true, required: true });\n            } else {\n                format.push({ x: true, number: true, required: true });\n            }\n        }\n        if (errors === 'y' || errors === 'xy') {\n            // lower / upper error\n            if (series.points.yerr.asymmetric) {\n                format.push({ y: true, number: true, required: true });\n                format.push({ y: true, number: true, required: true });\n            } else {\n                format.push({ y: true, number: true, required: true });\n            }\n        }\n        datapoints.format = format;\n    }\n\n    function parseErrors(series, i) {\n        var points = series.datapoints.points;\n\n        // read errors from points array\n        var exl = null,\n            exu = null,\n            eyl = null,\n            eyu = null;\n        var xerr = series.points.xerr,\n            yerr = series.points.yerr;\n\n        var eb = series.points.errorbars;\n        // error bars - first X\n        if (eb === 'x' || eb === 'xy') {\n            if (xerr.asymmetric) {\n                exl = points[i + 2];\n                exu = points[i + 3];\n                if (eb === 'xy') {\n                    if (yerr.asymmetric) {\n                        eyl = points[i + 4];\n                        eyu = points[i + 5];\n                    } else {\n                        eyl = points[i + 4];\n                    }\n                }\n            } else {\n                exl = points[i + 2];\n                if (eb === 'xy') {\n                    if (yerr.asymmetric) {\n                        eyl = points[i + 3];\n                        eyu = points[i + 4];\n                    } else {\n                        eyl = points[i + 3];\n                    }\n                }\n            }\n        // only Y\n        } else {\n            if (eb === 'y') {\n                if (yerr.asymmetric) {\n                    eyl = points[i + 2];\n                    eyu = points[i + 3];\n                } else {\n                    eyl = points[i + 2];\n                }\n            }\n        }\n\n        // symmetric errors?\n        if (exu == null) exu = exl;\n        if (eyu == null) eyu = eyl;\n\n        var errRanges = [exl, exu, eyl, eyu];\n        // nullify if not showing\n        if (!xerr.show) {\n            errRanges[0] = null;\n            errRanges[1] = null;\n        }\n        if (!yerr.show) {\n            errRanges[2] = null;\n            errRanges[3] = null;\n        }\n        return errRanges;\n    }\n\n    function drawSeriesErrors(plot, ctx, s) {\n        var points = s.datapoints.points,\n            ps = s.datapoints.pointsize,\n            ax = [s.xaxis, s.yaxis],\n            radius = s.points.radius,\n            err = [s.points.xerr, s.points.yerr],\n            tmp;\n\n        //sanity check, in case some inverted axis hack is applied to flot\n        var invertX = false;\n        if (ax[0].p2c(ax[0].max) < ax[0].p2c(ax[0].min)) {\n            invertX = true;\n            tmp = err[0].lowerCap;\n            err[0].lowerCap = err[0].upperCap;\n            err[0].upperCap = tmp;\n        }\n\n        var invertY = false;\n        if (ax[1].p2c(ax[1].min) < ax[1].p2c(ax[1].max)) {\n            invertY = true;\n            tmp = err[1].lowerCap;\n            err[1].lowerCap = err[1].upperCap;\n            err[1].upperCap = tmp;\n        }\n\n        for (var i = 0; i < s.datapoints.points.length; i += ps) {\n            //parse\n            var errRanges = parseErrors(s, i);\n\n            //cycle xerr & yerr\n            for (var e = 0; e < err.length; e++) {\n                var minmax = [ax[e].min, ax[e].max];\n\n                //draw this error?\n                if (errRanges[e * err.length]) {\n                    //data coordinates\n                    var x = points[i],\n                        y = points[i + 1];\n\n                    //errorbar ranges\n                    var upper = [x, y][e] + errRanges[e * err.length + 1],\n                        lower = [x, y][e] - errRanges[e * err.length];\n\n                    //points outside of the canvas\n                    if (err[e].err === 'x') {\n                        if (y > ax[1].max || y < ax[1].min || upper < ax[0].min || lower > ax[0].max) {\n                            continue;\n                        }\n                    }\n\n                    if (err[e].err === 'y') {\n                        if (x > ax[0].max || x < ax[0].min || upper < ax[1].min || lower > ax[1].max) {\n                            continue;\n                        }\n                    }\n\n                    // prevent errorbars getting out of the canvas\n                    var drawUpper = true,\n                        drawLower = true;\n\n                    if (upper > minmax[1]) {\n                        drawUpper = false;\n                        upper = minmax[1];\n                    }\n                    if (lower < minmax[0]) {\n                        drawLower = false;\n                        lower = minmax[0];\n                    }\n\n                    //sanity check, in case some inverted axis hack is applied to flot\n                    if ((err[e].err === 'x' && invertX) || (err[e].err === 'y' && invertY)) {\n                        //swap coordinates\n                        tmp = lower;\n                        lower = upper;\n                        upper = tmp;\n                        tmp = drawLower;\n                        drawLower = drawUpper;\n                        drawUpper = tmp;\n                        tmp = minmax[0];\n                        minmax[0] = minmax[1];\n                        minmax[1] = tmp;\n                    }\n\n                    // convert to pixels\n                    x = ax[0].p2c(x);\n                    y = ax[1].p2c(y);\n                    upper = ax[e].p2c(upper);\n                    lower = ax[e].p2c(lower);\n                    minmax[0] = ax[e].p2c(minmax[0]);\n                    minmax[1] = ax[e].p2c(minmax[1]);\n\n                    //same style as points by default\n                    var lw = err[e].lineWidth ? err[e].lineWidth : s.points.lineWidth,\n                        sw = s.points.shadowSize != null ? s.points.shadowSize : s.shadowSize;\n\n                    //shadow as for points\n                    if (lw > 0 && sw > 0) {\n                        var w = sw / 2;\n                        ctx.lineWidth = w;\n                        ctx.strokeStyle = \"rgba(0,0,0,0.1)\";\n                        drawError(ctx, err[e], x, y, upper, lower, drawUpper, drawLower, radius, w + w / 2, minmax);\n\n                        ctx.strokeStyle = \"rgba(0,0,0,0.2)\";\n                        drawError(ctx, err[e], x, y, upper, lower, drawUpper, drawLower, radius, w / 2, minmax);\n                    }\n\n                    ctx.strokeStyle = err[e].color\n                        ? err[e].color\n                        : s.color;\n                    ctx.lineWidth = lw;\n                    //draw it\n                    drawError(ctx, err[e], x, y, upper, lower, drawUpper, drawLower, radius, 0, minmax);\n                }\n            }\n        }\n    }\n\n    function drawError(ctx, err, x, y, upper, lower, drawUpper, drawLower, radius, offset, minmax) {\n        //shadow offset\n        y += offset;\n        upper += offset;\n        lower += offset;\n\n        // error bar - avoid plotting over circles\n        if (err.err === 'x') {\n            if (upper > x + radius) drawPath(ctx, [[upper, y], [Math.max(x + radius, minmax[0]), y]]);\n            else drawUpper = false;\n\n            if (lower < x - radius) drawPath(ctx, [[Math.min(x - radius, minmax[1]), y], [lower, y]]);\n            else drawLower = false;\n        } else {\n            if (upper < y - radius) drawPath(ctx, [[x, upper], [x, Math.min(y - radius, minmax[0])]]);\n            else drawUpper = false;\n\n            if (lower > y + radius) drawPath(ctx, [[x, Math.max(y + radius, minmax[1])], [x, lower]]);\n            else drawLower = false;\n        }\n\n        //internal radius value in errorbar, allows to plot radius 0 points and still keep proper sized caps\n        //this is a way to get errorbars on lines without visible connecting dots\n        radius = err.radius != null\n            ? err.radius\n            : radius;\n\n        // upper cap\n        if (drawUpper) {\n            if (err.upperCap === '-') {\n                if (err.err === 'x') drawPath(ctx, [[upper, y - radius], [upper, y + radius]]);\n                else drawPath(ctx, [[x - radius, upper], [x + radius, upper]]);\n            } else if ($.isFunction(err.upperCap)) {\n                if (err.err === 'x') err.upperCap(ctx, upper, y, radius);\n                else err.upperCap(ctx, x, upper, radius);\n            }\n        }\n        // lower cap\n        if (drawLower) {\n            if (err.lowerCap === '-') {\n                if (err.err === 'x') drawPath(ctx, [[lower, y - radius], [lower, y + radius]]);\n                else drawPath(ctx, [[x - radius, lower], [x + radius, lower]]);\n            } else if ($.isFunction(err.lowerCap)) {\n                if (err.err === 'x') err.lowerCap(ctx, lower, y, radius);\n                else err.lowerCap(ctx, x, lower, radius);\n            }\n        }\n    }\n\n    function drawPath(ctx, pts) {\n        ctx.beginPath();\n        ctx.moveTo(pts[0][0], pts[0][1]);\n        for (var p = 1; p < pts.length; p++) {\n            ctx.lineTo(pts[p][0], pts[p][1]);\n        }\n\n        ctx.stroke();\n    }\n\n    function draw(plot, ctx) {\n        var plotOffset = plot.getPlotOffset();\n\n        ctx.save();\n        ctx.translate(plotOffset.left, plotOffset.top);\n        $.each(plot.getData(), function (i, s) {\n            if (s.points.errorbars && (s.points.xerr.show || s.points.yerr.show)) {\n                drawSeriesErrors(plot, ctx, s);\n            }\n        });\n        ctx.restore();\n    }\n\n    function init(plot) {\n        plot.hooks.processRawData.push(processRawData);\n        plot.hooks.draw.push(draw);\n    }\n\n    $.plot.plugins.push({\n        init: init,\n        options: options,\n        name: 'errorbars',\n        version: '1.0'\n    });\n})(jQuery);\n","/* Flot plugin for computing bottoms for filled line and bar charts.\n\nCopyright (c) 2007-2014 IOLA and Ole Laursen.\nLicensed under the MIT license.\n\nThe case: you've got two series that you want to fill the area between. In Flot\nterms, you need to use one as the fill bottom of the other. You can specify the\nbottom of each data point as the third coordinate manually, or you can use this\nplugin to compute it for you.\n\nIn order to name the other series, you need to give it an id, like this:\n\n    var dataset = [\n        { data: [ ... ], id: \"foo\" } ,         // use default bottom\n        { data: [ ... ], fillBetween: \"foo\" }, // use first dataset as bottom\n    ];\n\n    $.plot($(\"#placeholder\"), dataset, { lines: { show: true, fill: true }});\n\nAs a convenience, if the id given is a number that doesn't appear as an id in\nthe series, it is interpreted as the index in the array instead (so fillBetween:\n0 can also mean the first series).\n\nInternally, the plugin modifies the datapoints in each series. For line series,\nextra data points might be inserted through interpolation. Note that at points\nwhere the bottom line is not defined (due to a null point or start/end of line),\nthe current line will show a gap too. The algorithm comes from the\njquery.flot.stack.js plugin, possibly some code could be shared.\n\n*/\n\n(function ($) {\n    var options = {\n        series: {\n            fillBetween: null // or number\n        }\n    };\n\n    function init(plot) {\n        function findBottomSeries(s, allseries) {\n            var i;\n\n            for (i = 0; i < allseries.length; ++i) {\n                if (allseries[ i ].id === s.fillBetween) {\n                    return allseries[ i ];\n                }\n            }\n\n            if (typeof s.fillBetween === \"number\") {\n                if (s.fillBetween < 0 || s.fillBetween >= allseries.length) {\n                    return null;\n                }\n                return allseries[ s.fillBetween ];\n            }\n\n            return null;\n        }\n\n        function computeFormat(plot, s, data, datapoints) {\n            if (s.fillBetween == null) {\n                return;\n            }\n\n            var format = datapoints.format;\n            var plotHasId = function(id) {\n                var plotData = plot.getData();\n                for (var i = 0; i < plotData.length; i++) {\n                    if (plotData[i].id === id) {\n                        return true;\n                    }\n                }\n\n                return false;\n            }\n\n            if (!format) {\n                format = [];\n\n                format.push({\n                    x: true,\n                    number: true,\n                    computeRange: s.xaxis.options.autoScale !== 'none',\n                    required: true\n                });\n                format.push({\n                    y: true,\n                    number: true,\n                    computeRange: s.yaxis.options.autoScale !== 'none',\n                    required: true\n                });\n\n                if (s.fillBetween !== undefined && s.fillBetween !== '' && plotHasId(s.fillBetween) && s.fillBetween !== s.id) {\n                    format.push({\n                        x: false,\n                        y: true,\n                        number: true,\n                        required: false,\n                        computeRange: s.yaxis.options.autoScale !== 'none',\n                        defaultValue: 0\n                    });\n                }\n\n                datapoints.format = format;\n            }\n        }\n\n        function computeFillBottoms(plot, s, datapoints) {\n            if (s.fillBetween == null) {\n                return;\n            }\n\n            var other = findBottomSeries(s, plot.getData());\n\n            if (!other) {\n                return;\n            }\n\n            var ps = datapoints.pointsize,\n                points = datapoints.points,\n                otherps = other.datapoints.pointsize,\n                otherpoints = other.datapoints.points,\n                newpoints = [],\n                px, py, intery, qx, qy, bottom,\n                withlines = s.lines.show,\n                withbottom = ps > 2 && datapoints.format[2].y,\n                withsteps = withlines && s.lines.steps,\n                fromgap = true,\n                i = 0,\n                j = 0,\n                l, m;\n\n            while (true) {\n                if (i >= points.length) {\n                    break;\n                }\n\n                l = newpoints.length;\n\n                if (points[ i ] == null) {\n                    // copy gaps\n                    for (m = 0; m < ps; ++m) {\n                        newpoints.push(points[ i + m ]);\n                    }\n\n                    i += ps;\n                } else if (j >= otherpoints.length) {\n                    // for lines, we can't use the rest of the points\n                    if (!withlines) {\n                        for (m = 0; m < ps; ++m) {\n                            newpoints.push(points[ i + m ]);\n                        }\n                    }\n\n                    i += ps;\n                } else if (otherpoints[ j ] == null) {\n                    // oops, got a gap\n                    for (m = 0; m < ps; ++m) {\n                        newpoints.push(null);\n                    }\n\n                    fromgap = true;\n                    j += otherps;\n                } else {\n                    // cases where we actually got two points\n                    px = points[ i ];\n                    py = points[ i + 1 ];\n                    qx = otherpoints[ j ];\n                    qy = otherpoints[ j + 1 ];\n                    bottom = 0;\n\n                    if (px === qx) {\n                        for (m = 0; m < ps; ++m) {\n                            newpoints.push(points[ i + m ]);\n                        }\n\n                        //newpoints[ l + 1 ] += qy;\n                        bottom = qy;\n\n                        i += ps;\n                        j += otherps;\n                    } else if (px > qx) {\n                        // we got past point below, might need to\n                        // insert interpolated extra point\n\n                        if (withlines && i > 0 && points[ i - ps ] != null) {\n                            intery = py + (points[ i - ps + 1 ] - py) * (qx - px) / (points[ i - ps ] - px);\n                            newpoints.push(qx);\n                            newpoints.push(intery);\n                            for (m = 2; m < ps; ++m) {\n                                newpoints.push(points[ i + m ]);\n                            }\n                            bottom = qy;\n                        }\n\n                        j += otherps;\n                    } else {\n                        // px < qx\n                        // if we come from a gap, we just skip this point\n\n                        if (fromgap && withlines) {\n                            i += ps;\n                            continue;\n                        }\n\n                        for (m = 0; m < ps; ++m) {\n                            newpoints.push(points[ i + m ]);\n                        }\n\n                        // we might be able to interpolate a point below,\n                        // this can give us a better y\n\n                        if (withlines && j > 0 && otherpoints[ j - otherps ] != null) {\n                            bottom = qy + (otherpoints[ j - otherps + 1 ] - qy) * (px - qx) / (otherpoints[ j - otherps ] - qx);\n                        }\n\n                        //newpoints[l + 1] += bottom;\n\n                        i += ps;\n                    }\n\n                    fromgap = false;\n\n                    if (l !== newpoints.length && withbottom) {\n                        newpoints[ l + 2 ] = bottom;\n                    }\n                }\n\n                // maintain the line steps invariant\n\n                if (withsteps && l !== newpoints.length && l > 0 &&\n                    newpoints[ l ] !== null &&\n                    newpoints[ l ] !== newpoints[ l - ps ] &&\n                    newpoints[ l + 1 ] !== newpoints[ l - ps + 1 ]) {\n                    for (m = 0; m < ps; ++m) {\n                        newpoints[ l + ps + m ] = newpoints[ l + m ];\n                    }\n                    newpoints[ l + 1 ] = newpoints[ l - ps + 1 ];\n                }\n            }\n\n            datapoints.points = newpoints;\n        }\n\n        plot.hooks.processRawData.push(computeFormat);\n        plot.hooks.processDatapoints.push(computeFillBottoms);\n    }\n\n    $.plot.plugins.push({\n        init: init,\n        options: options,\n        name: \"fillbetween\",\n        version: \"1.0\"\n    });\n})(jQuery);\n","/* Support for flat 1D data series.\n\nA 1D flat data series is a data series in the form of a regular 1D array. The\nmain reason for using a flat data series is that it performs better, consumes\nless memory and generates less garbage collection than the regular flot format.\n\nExample:\n\n    plot.setData([[[0,0], [1,1], [2,2], [3,3]]]); // regular flot format\n    plot.setData([{flatdata: true, data: [0, 1, 2, 3]}]); // flatdata format\n\nSet series.flatdata to true to enable this plugin.\n\nYou can use series.start to specify the starting index of the series (default is 0)\nYou can use series.step to specify the interval between consecutive indexes of the series (default is 1)\n*/\n\n/* global jQuery*/\n\n(function ($) {\n    'use strict';\n\n    function process1DRawData(plot, series, data, datapoints) {\n        if (series.flatdata === true) {\n            var start = series.start || 0;\n            var step = typeof series.step === 'number' ? series.step : 1;\n            datapoints.pointsize = 2;\n            for (var i = 0, j = 0; i < data.length; i++, j += 2) {\n                datapoints.points[j] = start + (i * step);\n                datapoints.points[j + 1] = data[i];\n            }\n            if (datapoints.points !== undefined) {\n                datapoints.points.length = data.length * 2;\n            } else {\n                datapoints.points = [];\n            }\n        }\n    }\n\n    $.plot.plugins.push({\n        init: function(plot) {\n            plot.hooks.processRawData.push(process1DRawData);\n        },\n        name: 'flatdata',\n        version: '0.0.2'\n    });\n})(jQuery);\n","/* global jQuery */\n\n/**\n## jquery.flot.hover.js\n\nThis plugin is used for mouse hover and tap on a point of plot series.\nIt supports the following options:\n```js\ngrid: {\n    hoverable: false, //to trigger plothover event on mouse hover or tap on a point\n    clickable: false //to trigger plotclick event on mouse hover\n}\n```\n\nIt listens to native mouse move event or click, as well as artificial generated\ntap and touchevent.\n\nWhen the mouse is over a point or a tap on a point is performed, that point or\nthe correscponding bar will be highlighted and a \"plothover\" event will be generated.\n\nCustom \"touchevent\" is triggered when any touch interaction is made. Hover plugin\nhandles this events by unhighlighting all of the previously highlighted points and generates\n\"plothovercleanup\" event to notify any part that is handling plothover (for exemple to cleanup\nthe tooltip from webcharts).\n*/\n\n(function($) {\n    'use strict';\n\n    var options = {\n        grid: {\n            hoverable: false,\n            clickable: false\n        }\n    };\n\n    var browser = $.plot.browser;\n\n    var eventType = {\n        click: 'click',\n        hover: 'hover'\n    }\n\n    function init(plot) {\n        var lastMouseMoveEvent;\n        var highlights = [];\n\n        function bindEvents(plot, eventHolder) {\n            var o = plot.getOptions();\n\n            if (o.grid.hoverable || o.grid.clickable) {\n                eventHolder[0].addEventListener('touchevent', triggerCleanupEvent, false);\n                eventHolder[0].addEventListener('tap', generatePlothoverEvent, false);\n            }\n\n            if (o.grid.clickable) {\n                eventHolder.bind(\"click\", onClick);\n            }\n\n            if (o.grid.hoverable) {\n                eventHolder.bind(\"mousemove\", onMouseMove);\n\n                // Use bind, rather than .mouseleave, because we officially\n                // still support jQuery 1.2.6, which doesn't define a shortcut\n                // for mouseenter or mouseleave.  This was a bug/oversight that\n                // was fixed somewhere around 1.3.x.  We can return to using\n                // .mouseleave when we drop support for 1.2.6.\n\n                eventHolder.bind(\"mouseleave\", onMouseLeave);\n            }\n        }\n\n        function shutdown(plot, eventHolder) {\n            eventHolder[0].removeEventListener('tap', generatePlothoverEvent);\n            eventHolder[0].removeEventListener('touchevent', triggerCleanupEvent);\n            eventHolder.unbind(\"mousemove\", onMouseMove);\n            eventHolder.unbind(\"mouseleave\", onMouseLeave);\n            eventHolder.unbind(\"click\", onClick);\n            highlights = [];\n        }\n\n        function generatePlothoverEvent(e) {\n            var o = plot.getOptions(),\n                newEvent = new CustomEvent('mouseevent');\n\n            //transform from touch event to mouse event format\n            newEvent.pageX = e.detail.changedTouches[0].pageX;\n            newEvent.pageY = e.detail.changedTouches[0].pageY;\n            newEvent.clientX = e.detail.changedTouches[0].clientX;\n            newEvent.clientY = e.detail.changedTouches[0].clientY;\n\n            if (o.grid.hoverable) {\n                doTriggerClickHoverEvent(newEvent, eventType.hover, 30);\n            }\n            return false;\n        }\n\n        function doTriggerClickHoverEvent(event, eventType, searchDistance) {\n            var series = plot.getData();\n            if (event !== undefined &&\n                series.length > 0 &&\n                series[0].xaxis.c2p !== undefined &&\n                series[0].yaxis.c2p !== undefined) {\n                var eventToTrigger = \"plot\" + eventType;\n                var seriesFlag = eventType + \"able\";\n                triggerClickHoverEvent(eventToTrigger, event,\n                    function(i) {\n                        return series[i][seriesFlag] !== false;\n                    }, searchDistance);\n            }\n        }\n\n        function onMouseMove(e) {\n            lastMouseMoveEvent = e;\n            plot.getPlaceholder()[0].lastMouseMoveEvent = e;\n            doTriggerClickHoverEvent(e, eventType.hover);\n        }\n\n        function onMouseLeave(e) {\n            lastMouseMoveEvent = undefined;\n            plot.getPlaceholder()[0].lastMouseMoveEvent = undefined;\n            triggerClickHoverEvent(\"plothover\", e,\n                function(i) {\n                    return false;\n                });\n        }\n\n        function onClick(e) {\n            doTriggerClickHoverEvent(e, eventType.click);\n        }\n\n        function triggerCleanupEvent() {\n            plot.unhighlight();\n            plot.getPlaceholder().trigger('plothovercleanup');\n        }\n\n        // trigger click or hover event (they send the same parameters\n        // so we share their code)\n        function triggerClickHoverEvent(eventname, event, seriesFilter, searchDistance) {\n            var options = plot.getOptions(),\n                offset = plot.offset(),\n                page = browser.getPageXY(event),\n                canvasX = page.X - offset.left,\n                canvasY = page.Y - offset.top,\n                pos = plot.c2p({\n                    left: canvasX,\n                    top: canvasY\n                }),\n                distance = searchDistance !== undefined ? searchDistance : options.grid.mouseActiveRadius;\n\n            pos.pageX = page.X;\n            pos.pageY = page.Y;\n\n            var items = plot.findNearbyItems(canvasX, canvasY, seriesFilter, distance);\n            var item = items[0];\n\n            for (let i = 1; i < items.length; ++i) {\n                if (item.distance === undefined ||\n                    items[i].distance < item.distance) {\n                    item = items[i];\n                }\n            }\n\n            if (item) {\n                // fill in mouse pos for any listeners out there\n                item.pageX = parseInt(item.series.xaxis.p2c(item.datapoint[0]) + offset.left, 10);\n                item.pageY = parseInt(item.series.yaxis.p2c(item.datapoint[1]) + offset.top, 10);\n            } else {\n                item = null;\n            }\n\n            if (options.grid.autoHighlight) {\n                // clear auto-highlights\n                for (let i = 0; i < highlights.length; ++i) {\n                    var h = highlights[i];\n                    if ((h.auto === eventname &&\n                        !(item && h.series === item.series &&\n                            h.point[0] === item.datapoint[0] &&\n                            h.point[1] === item.datapoint[1])) || !item) {\n                        unhighlight(h.series, h.point);\n                    }\n                }\n\n                if (item) {\n                    highlight(item.series, item.datapoint, eventname);\n                }\n            }\n\n            plot.getPlaceholder().trigger(eventname, [pos, item, items]);\n        }\n\n        function highlight(s, point, auto) {\n            if (typeof s === \"number\") {\n                s = plot.getData()[s];\n            }\n\n            if (typeof point === \"number\") {\n                var ps = s.datapoints.pointsize;\n                point = s.datapoints.points.slice(ps * point, ps * (point + 1));\n            }\n\n            var i = indexOfHighlight(s, point);\n            if (i === -1) {\n                highlights.push({\n                    series: s,\n                    point: point,\n                    auto: auto\n                });\n\n                plot.triggerRedrawOverlay();\n            } else if (!auto) {\n                highlights[i].auto = false;\n            }\n        }\n\n        function unhighlight(s, point) {\n            if (s == null && point == null) {\n                highlights = [];\n                plot.triggerRedrawOverlay();\n                return;\n            }\n\n            if (typeof s === \"number\") {\n                s = plot.getData()[s];\n            }\n\n            if (typeof point === \"number\") {\n                var ps = s.datapoints.pointsize;\n                point = s.datapoints.points.slice(ps * point, ps * (point + 1));\n            }\n\n            var i = indexOfHighlight(s, point);\n            if (i !== -1) {\n                highlights.splice(i, 1);\n\n                plot.triggerRedrawOverlay();\n            }\n        }\n\n        function indexOfHighlight(s, p) {\n            for (var i = 0; i < highlights.length; ++i) {\n                var h = highlights[i];\n                if (h.series === s &&\n                    h.point[0] === p[0] &&\n                    h.point[1] === p[1]) {\n                    return i;\n                }\n            }\n\n            return -1;\n        }\n\n        function processDatapoints() {\n            triggerCleanupEvent();\n            doTriggerClickHoverEvent(lastMouseMoveEvent, eventType.hover);\n        }\n\n        function setupGrid() {\n            doTriggerClickHoverEvent(lastMouseMoveEvent, eventType.hover);\n        }\n\n        function drawOverlay(plot, octx, overlay) {\n            var plotOffset = plot.getPlotOffset(),\n                i, hi;\n\n            octx.save();\n            octx.translate(plotOffset.left, plotOffset.top);\n            for (i = 0; i < highlights.length; ++i) {\n                hi = highlights[i];\n\n                if (hi.series.bars.show) drawBarHighlight(hi.series, hi.point, octx);\n                else drawPointHighlight(hi.series, hi.point, octx, plot);\n            }\n            octx.restore();\n        }\n\n        function drawPointHighlight(series, point, octx, plot) {\n            var x = point[0],\n                y = point[1],\n                axisx = series.xaxis,\n                axisy = series.yaxis,\n                highlightColor = (typeof series.highlightColor === \"string\") ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString();\n\n            if (x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max) {\n                return;\n            }\n\n            var pointRadius = series.points.radius + series.points.lineWidth / 2;\n            octx.lineWidth = pointRadius;\n            octx.strokeStyle = highlightColor;\n            var radius = 1.5 * pointRadius;\n            x = axisx.p2c(x);\n            y = axisy.p2c(y);\n\n            octx.beginPath();\n            var symbol = series.points.symbol;\n            if (symbol === 'circle') {\n                octx.arc(x, y, radius, 0, 2 * Math.PI, false);\n            } else if (typeof symbol === 'string' && plot.drawSymbol && plot.drawSymbol[symbol]) {\n                plot.drawSymbol[symbol](octx, x, y, radius, false);\n            }\n\n            octx.closePath();\n            octx.stroke();\n        }\n\n        function drawBarHighlight(series, point, octx) {\n            var highlightColor = (typeof series.highlightColor === \"string\") ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString(),\n                fillStyle = highlightColor,\n                barLeft;\n\n            var barWidth = series.bars.barWidth[0] || series.bars.barWidth;\n            switch (series.bars.align) {\n                case \"left\":\n                    barLeft = 0;\n                    break;\n                case \"right\":\n                    barLeft = -barWidth;\n                    break;\n                default:\n                    barLeft = -barWidth / 2;\n            }\n\n            octx.lineWidth = series.bars.lineWidth;\n            octx.strokeStyle = highlightColor;\n\n            var fillTowards = series.bars.fillTowards || 0,\n                bottom = fillTowards > series.yaxis.min ? Math.min(series.yaxis.max, fillTowards) : series.yaxis.min;\n\n            $.plot.drawSeries.drawBar(point[0], point[1], point[2] || bottom, barLeft, barLeft + barWidth,\n                function() {\n                    return fillStyle;\n                }, series.xaxis, series.yaxis, octx, series.bars.horizontal, series.bars.lineWidth);\n        }\n\n        function initHover(plot, options) {\n            plot.highlight = highlight;\n            plot.unhighlight = unhighlight;\n            if (options.grid.hoverable || options.grid.clickable) {\n                plot.hooks.drawOverlay.push(drawOverlay);\n                plot.hooks.processDatapoints.push(processDatapoints);\n                plot.hooks.setupGrid.push(setupGrid);\n            }\n\n            lastMouseMoveEvent = plot.getPlaceholder()[0].lastMouseMoveEvent;\n        }\n\n        plot.hooks.bindEvents.push(bindEvents);\n        plot.hooks.shutdown.push(shutdown);\n        plot.hooks.processOptions.push(initHover);\n    }\n\n    $.plot.plugins.push({\n        init: init,\n        options: options,\n        name: 'hover',\n        version: '0.1'\n    });\n})(jQuery);\n","/* Flot plugin for plotting images.\n\nCopyright (c) 2007-2014 IOLA and Ole Laursen.\nLicensed under the MIT license.\n\nThe data syntax is [ [ image, x1, y1, x2, y2 ], ... ] where (x1, y1) and\n(x2, y2) are where you intend the two opposite corners of the image to end up\nin the plot. Image must be a fully loaded Javascript image (you can make one\nwith new Image()). If the image is not complete, it's skipped when plotting.\n\nThere are two helpers included for retrieving images. The easiest work the way\nthat you put in URLs instead of images in the data, like this:\n\n    [ \"myimage.png\", 0, 0, 10, 10 ]\n\nThen call $.plot.image.loadData( data, options, callback ) where data and\noptions are the same as you pass in to $.plot. This loads the images, replaces\nthe URLs in the data with the corresponding images and calls \"callback\" when\nall images are loaded (or failed loading). In the callback, you can then call\n$.plot with the data set. See the included example.\n\nA more low-level helper, $.plot.image.load(urls, callback) is also included.\nGiven a list of URLs, it calls callback with an object mapping from URL to\nImage object when all images are loaded or have failed loading.\n\nThe plugin supports these options:\n\n    series: {\n        images: {\n            show: boolean\n            anchor: \"corner\" or \"center\"\n            alpha: [ 0, 1 ]\n        }\n    }\n\nThey can be specified for a specific series:\n\n    $.plot( $(\"#placeholder\"), [{\n        data: [ ... ],\n        images: { ... }\n    ])\n\nNote that because the data format is different from usual data points, you\ncan't use images with anything else in a specific data series.\n\nSetting \"anchor\" to \"center\" causes the pixels in the image to be anchored at\nthe corner pixel centers inside of at the pixel corners, effectively letting\nhalf a pixel stick out to each side in the plot.\n\nA possible future direction could be support for tiling for large images (like\nGoogle Maps).\n\n*/\n\n(function ($) {\n    var options = {\n        series: {\n            images: {\n                show: false,\n                alpha: 1,\n                anchor: \"corner\" // or \"center\"\n            }\n        }\n    };\n\n    $.plot.image = {};\n\n    $.plot.image.loadDataImages = function (series, options, callback) {\n        var urls = [], points = [];\n\n        var defaultShow = options.series.images.show;\n\n        $.each(series, function (i, s) {\n            if (!(defaultShow || s.images.show)) {\n                return;\n            }\n\n            if (s.data) {\n                s = s.data;\n            }\n\n            $.each(s, function (i, p) {\n                if (typeof p[0] === \"string\") {\n                    urls.push(p[0]);\n                    points.push(p);\n                }\n            });\n        });\n\n        $.plot.image.load(urls, function (loadedImages) {\n            $.each(points, function (i, p) {\n                var url = p[0];\n                if (loadedImages[url]) {\n                    p[0] = loadedImages[url];\n                }\n            });\n\n            callback();\n        });\n    }\n\n    $.plot.image.load = function (urls, callback) {\n        var missing = urls.length, loaded = {};\n        if (missing === 0) {\n            callback({});\n        }\n\n        $.each(urls, function (i, url) {\n            var handler = function () {\n                --missing;\n                loaded[url] = this;\n\n                if (missing === 0) {\n                    callback(loaded);\n                }\n            };\n\n            $('<img />').load(handler).error(handler).attr('src', url);\n        });\n    };\n\n    function drawSeries(plot, ctx, series) {\n        var plotOffset = plot.getPlotOffset();\n\n        if (!series.images || !series.images.show) {\n            return;\n        }\n\n        var points = series.datapoints.points,\n            ps = series.datapoints.pointsize;\n\n        for (var i = 0; i < points.length; i += ps) {\n            var img = points[i],\n                x1 = points[i + 1], y1 = points[i + 2],\n                x2 = points[i + 3], y2 = points[i + 4],\n                xaxis = series.xaxis, yaxis = series.yaxis,\n                tmp;\n\n            // actually we should check img.complete, but it\n            // appears to be a somewhat unreliable indicator in\n            // IE6 (false even after load event)\n            if (!img || img.width <= 0 || img.height <= 0) {\n                continue;\n            }\n\n            if (x1 > x2) {\n                tmp = x2;\n                x2 = x1;\n                x1 = tmp;\n            }\n            if (y1 > y2) {\n                tmp = y2;\n                y2 = y1;\n                y1 = tmp;\n            }\n\n            // if the anchor is at the center of the pixel, expand the\n            // image by 1/2 pixel in each direction\n            if (series.images.anchor === \"center\") {\n                tmp = 0.5 * (x2 - x1) / (img.width - 1);\n                x1 -= tmp;\n                x2 += tmp;\n                tmp = 0.5 * (y2 - y1) / (img.height - 1);\n                y1 -= tmp;\n                y2 += tmp;\n            }\n\n            // clip\n            if (x1 === x2 || y1 === y2 ||\n                x1 >= xaxis.max || x2 <= xaxis.min ||\n                y1 >= yaxis.max || y2 <= yaxis.min) {\n                continue;\n            }\n\n            var sx1 = 0, sy1 = 0, sx2 = img.width, sy2 = img.height;\n            if (x1 < xaxis.min) {\n                sx1 += (sx2 - sx1) * (xaxis.min - x1) / (x2 - x1);\n                x1 = xaxis.min;\n            }\n\n            if (x2 > xaxis.max) {\n                sx2 += (sx2 - sx1) * (xaxis.max - x2) / (x2 - x1);\n                x2 = xaxis.max;\n            }\n\n            if (y1 < yaxis.min) {\n                sy2 += (sy1 - sy2) * (yaxis.min - y1) / (y2 - y1);\n                y1 = yaxis.min;\n            }\n\n            if (y2 > yaxis.max) {\n                sy1 += (sy1 - sy2) * (yaxis.max - y2) / (y2 - y1);\n                y2 = yaxis.max;\n            }\n\n            x1 = xaxis.p2c(x1);\n            x2 = xaxis.p2c(x2);\n            y1 = yaxis.p2c(y1);\n            y2 = yaxis.p2c(y2);\n\n            // the transformation may have swapped us\n            if (x1 > x2) {\n                tmp = x2;\n                x2 = x1;\n                x1 = tmp;\n            }\n            if (y1 > y2) {\n                tmp = y2;\n                y2 = y1;\n                y1 = tmp;\n            }\n\n            tmp = ctx.globalAlpha;\n            ctx.globalAlpha *= series.images.alpha;\n            ctx.drawImage(img,\n                          sx1, sy1, sx2 - sx1, sy2 - sy1,\n                          x1 + plotOffset.left, y1 + plotOffset.top,\n                          x2 - x1, y2 - y1);\n            ctx.globalAlpha = tmp;\n        }\n    }\n\n    function processRawData(plot, series, data, datapoints) {\n        if (!series.images.show) {\n            return;\n        }\n\n        // format is Image, x1, y1, x2, y2 (opposite corners)\n        datapoints.format = [\n            { required: true },\n            { x: true, number: true, required: true },\n            { y: true, number: true, required: true },\n            { x: true, number: true, required: true },\n            { y: true, number: true, required: true }\n        ];\n    }\n\n    function init(plot) {\n        plot.hooks.processRawData.push(processRawData);\n        plot.hooks.drawSeries.push(drawSeries);\n    }\n\n    $.plot.plugins.push({\n        init: init,\n        options: options,\n        name: 'image',\n        version: '1.1'\n    });\n})(jQuery);\n","/* Javascript plotting library for jQuery, version 3.0.0.\n\nCopyright (c) 2007-2014 IOLA and Ole Laursen.\nLicensed under the MIT license.\n\n*/\n\n// the actual Flot code\n(function($) {\n    \"use strict\";\n\n    var Canvas = window.Flot.Canvas;\n\n    function defaultTickGenerator(axis) {\n        var ticks = [],\n            start = $.plot.saturated.saturate($.plot.saturated.floorInBase(axis.min, axis.tickSize)),\n            i = 0,\n            v = Number.NaN,\n            prev;\n\n        if (start === -Number.MAX_VALUE) {\n            ticks.push(start);\n            start = $.plot.saturated.floorInBase(axis.min + axis.tickSize, axis.tickSize);\n        }\n\n        do {\n            prev = v;\n            //v = start + i * axis.tickSize;\n            v = $.plot.saturated.multiplyAdd(axis.tickSize, i, start);\n            ticks.push(v);\n            ++i;\n        } while (v < axis.max && v !== prev);\n\n        return ticks;\n    }\n\n    function defaultTickFormatter(value, axis, precision) {\n        var oldTickDecimals = axis.tickDecimals,\n            expPosition = (\"\" + value).indexOf(\"e\");\n\n        if (expPosition !== -1) {\n            return expRepTickFormatter(value, axis, precision);\n        }\n\n        if (precision > 0) {\n            axis.tickDecimals = precision;\n        }\n\n        var factor = axis.tickDecimals ? parseFloat('1e' + axis.tickDecimals) : 1,\n            formatted = \"\" + Math.round(value * factor) / factor;\n\n        // If tickDecimals was specified, ensure that we have exactly that\n        // much precision; otherwise default to the value's own precision.\n        if (axis.tickDecimals != null) {\n            var decimal = formatted.indexOf(\".\"),\n                decimalPrecision = decimal === -1 ? 0 : formatted.length - decimal - 1;\n            if (decimalPrecision < axis.tickDecimals) {\n                var decimals = (\"\" + factor).substr(1, axis.tickDecimals - decimalPrecision);\n                formatted = (decimalPrecision ? formatted : formatted + \".\") + decimals;\n            }\n        }\n\n        axis.tickDecimals = oldTickDecimals;\n        return formatted;\n    };\n\n    function expRepTickFormatter(value, axis, precision) {\n        var expPosition = (\"\" + value).indexOf(\"e\"),\n            exponentValue = parseInt((\"\" + value).substr(expPosition + 1)),\n            tenExponent = expPosition !== -1 ? exponentValue : (value > 0 ? Math.floor(Math.log(value) / Math.LN10) : 0),\n            roundWith = parseFloat('1e' + tenExponent),\n            x = value / roundWith;\n\n        if (precision) {\n            var updatedPrecision = recomputePrecision(value, precision);\n            return (value / roundWith).toFixed(updatedPrecision) + 'e' + tenExponent;\n        }\n\n        if (axis.tickDecimals > 0) {\n            return x.toFixed(recomputePrecision(value, axis.tickDecimals)) + 'e' + tenExponent;\n        }\n        return x.toFixed() + 'e' + tenExponent;\n    }\n\n    function recomputePrecision(num, precision) {\n        //for numbers close to zero, the precision from flot will be a big number\n        //while for big numbers, the precision will be negative\n        var log10Value = Math.log(Math.abs(num)) * Math.LOG10E,\n            newPrecision = Math.abs(log10Value + precision);\n\n        return newPrecision <= 20 ? Math.floor(newPrecision) : 20;\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // The top-level container for the entire plot.\n    function Plot(placeholder, data_, options_, plugins) {\n        // data is on the form:\n        //   [ series1, series2 ... ]\n        // where series is either just the data as [ [x1, y1], [x2, y2], ... ]\n        // or { data: [ [x1, y1], [x2, y2], ... ], label: \"some label\", ... }\n\n        var series = [],\n            options = {\n                // the color theme used for graphs\n                colors: [\"#edc240\", \"#afd8f8\", \"#cb4b4b\", \"#4da74d\", \"#9440ed\"],\n                xaxis: {\n                    show: null, // null = auto-detect, true = always, false = never\n                    position: \"bottom\", // or \"top\"\n                    mode: null, // null or \"time\"\n                    font: null, // null (derived from CSS in placeholder) or object like { size: 11, lineHeight: 13, style: \"italic\", weight: \"bold\", family: \"sans-serif\", variant: \"small-caps\" }\n                    color: null, // base color, labels, ticks\n                    tickColor: null, // possibly different color of ticks, e.g. \"rgba(0,0,0,0.15)\"\n                    transform: null, // null or f: number -> number to transform axis\n                    inverseTransform: null, // if transform is set, this should be the inverse function\n                    min: null, // min. value to show, null means set automatically\n                    max: null, // max. value to show, null means set automatically\n                    autoScaleMargin: null, // margin in % to add if autoScale option is on \"loose\" mode,\n                    autoScale: \"exact\", // Available modes: \"none\", \"loose\", \"exact\", \"sliding-window\"\n                    windowSize: null, // null or number. This is the size of sliding-window.\n                    growOnly: null, // grow only, useful for smoother auto-scale, the scales will grow to accomodate data but won't shrink back.\n                    ticks: null, // either [1, 3] or [[1, \"a\"], 3] or (fn: axis info -> ticks) or app. number of ticks for auto-ticks\n                    tickFormatter: null, // fn: number -> string\n                    showTickLabels: \"major\", // \"none\", \"endpoints\", \"major\", \"all\"\n                    labelWidth: null, // size of tick labels in pixels\n                    labelHeight: null,\n                    reserveSpace: null, // whether to reserve space even if axis isn't shown\n                    tickLength: null, // size in pixels of major tick marks\n                    showMinorTicks: null, // true = show minor tick marks, false = hide minor tick marks\n                    showTicks: null, // true = show tick marks, false = hide all tick marks\n                    gridLines: null, // true = show grid lines, false = hide grid lines\n                    alignTicksWithAxis: null, // axis number or null for no sync\n                    tickDecimals: null, // no. of decimals, null means auto\n                    tickSize: null, // number or [number, \"unit\"]\n                    minTickSize: null, // number or [number, \"unit\"]\n                    offset: { below: 0, above: 0 }, // the plot drawing offset. this is calculated by the flot.navigate for each axis\n                    boxPosition: { centerX: 0, centerY: 0 } //position of the axis on the corresponding axis box\n                },\n                yaxis: {\n                    autoScaleMargin: 0.02, // margin in % to add if autoScale option is on \"loose\" mode\n                    autoScale: \"loose\", // Available modes: \"none\", \"loose\", \"exact\"\n                    growOnly: null, // grow only, useful for smoother auto-scale, the scales will grow to accomodate data but won't shrink back.\n                    position: \"left\", // or \"right\"\n                    showTickLabels: \"major\", // \"none\", \"endpoints\", \"major\", \"all\"\n                    offset: { below: 0, above: 0 }, // the plot drawing offset. this is calculated by the flot.navigate for each axis\n                    boxPosition: { centerX: 0, centerY: 0 } //position of the axis on the corresponding axis box\n                },\n                xaxes: [],\n                yaxes: [],\n                series: {\n                    points: {\n                        show: false,\n                        radius: 3,\n                        lineWidth: 2, // in pixels\n                        fill: true,\n                        fillColor: \"#ffffff\",\n                        symbol: 'circle' // or callback\n                    },\n                    lines: {\n                        // we don't put in show: false so we can see\n                        // whether lines were actively disabled\n                        lineWidth: 1, // in pixels\n                        fill: false,\n                        fillColor: null,\n                        steps: false\n                        // Omit 'zero', so we can later default its value to\n                        // match that of the 'fill' option.\n                    },\n                    bars: {\n                        show: false,\n                        lineWidth: 2, // in pixels\n                        // barWidth: number or [number, absolute]\n                        // when 'absolute' is false, 'number' is relative to the minimum distance between points for the series\n                        // when 'absolute' is true, 'number' is considered to be in units of the x-axis\n                        horizontal: false,\n                        barWidth: 0.8,\n                        fill: true,\n                        fillColor: null,\n                        align: \"left\", // \"left\", \"right\", or \"center\"\n                        zero: true\n                    },\n                    shadowSize: 3,\n                    highlightColor: null\n                },\n                grid: {\n                    show: true,\n                    aboveData: false,\n                    color: \"#545454\", // primary color used for outline and labels\n                    backgroundColor: null, // null for transparent, else color\n                    borderColor: null, // set if different from the grid color\n                    tickColor: null, // color for the ticks, e.g. \"rgba(0,0,0,0.15)\"\n                    margin: 0, // distance from the canvas edge to the grid\n                    labelMargin: 5, // in pixels\n                    axisMargin: 8, // in pixels\n                    borderWidth: 1, // in pixels\n                    minBorderMargin: null, // in pixels, null means taken from points radius\n                    markings: null, // array of ranges or fn: axes -> array of ranges\n                    markingsColor: \"#f4f4f4\",\n                    markingsLineWidth: 2,\n                    // interactive stuff\n                    clickable: false,\n                    hoverable: false,\n                    autoHighlight: true, // highlight in case mouse is near\n                    mouseActiveRadius: 15 // how far the mouse can be away to activate an item\n                },\n                interaction: {\n                    redrawOverlayInterval: 1000 / 60 // time between updates, -1 means in same flow\n                },\n                hooks: {}\n            },\n            surface = null, // the canvas for the plot itself\n            overlay = null, // canvas for interactive stuff on top of plot\n            eventHolder = null, // jQuery object that events should be bound to\n            ctx = null,\n            octx = null,\n            xaxes = [],\n            yaxes = [],\n            plotOffset = {\n                left: 0,\n                right: 0,\n                top: 0,\n                bottom: 0\n            },\n            plotWidth = 0,\n            plotHeight = 0,\n            hooks = {\n                processOptions: [],\n                processRawData: [],\n                processDatapoints: [],\n                processOffset: [],\n                setupGrid: [],\n                adjustSeriesDataRange: [],\n                setRange: [],\n                drawBackground: [],\n                drawSeries: [],\n                drawAxis: [],\n                draw: [],\n                findNearbyItems: [],\n                axisReserveSpace: [],\n                bindEvents: [],\n                drawOverlay: [],\n                resize: [],\n                shutdown: []\n            },\n            plot = this;\n\n        var eventManager = {};\n\n        // interactive features\n\n        var redrawTimeout = null;\n\n        // public functions\n        plot.setData = setData;\n        plot.setupGrid = setupGrid;\n        plot.draw = draw;\n        plot.getPlaceholder = function() {\n            return placeholder;\n        };\n        plot.getCanvas = function() {\n            return surface.element;\n        };\n        plot.getSurface = function() {\n            return surface;\n        };\n        plot.getEventHolder = function() {\n            return eventHolder[0];\n        };\n        plot.getPlotOffset = function() {\n            return plotOffset;\n        };\n        plot.width = function() {\n            return plotWidth;\n        };\n        plot.height = function() {\n            return plotHeight;\n        };\n        plot.offset = function() {\n            var o = eventHolder.offset();\n            o.left += plotOffset.left;\n            o.top += plotOffset.top;\n            return o;\n        };\n        plot.getData = function() {\n            return series;\n        };\n        plot.getAxes = function() {\n            var res = {};\n            $.each(xaxes.concat(yaxes), function(_, axis) {\n                if (axis) {\n                    res[axis.direction + (axis.n !== 1 ? axis.n : \"\") + \"axis\"] = axis;\n                }\n            });\n            return res;\n        };\n        plot.getXAxes = function() {\n            return xaxes;\n        };\n        plot.getYAxes = function() {\n            return yaxes;\n        };\n        plot.c2p = canvasToCartesianAxisCoords;\n        plot.p2c = cartesianAxisToCanvasCoords;\n        plot.getOptions = function() {\n            return options;\n        };\n        plot.triggerRedrawOverlay = triggerRedrawOverlay;\n        plot.pointOffset = function(point) {\n            return {\n                left: parseInt(xaxes[axisNumber(point, \"x\") - 1].p2c(+point.x) + plotOffset.left, 10),\n                top: parseInt(yaxes[axisNumber(point, \"y\") - 1].p2c(+point.y) + plotOffset.top, 10)\n            };\n        };\n        plot.shutdown = shutdown;\n        plot.destroy = function() {\n            shutdown();\n            placeholder.removeData(\"plot\").empty();\n\n            series = [];\n            options = null;\n            surface = null;\n            overlay = null;\n            eventHolder = null;\n            ctx = null;\n            octx = null;\n            xaxes = [];\n            yaxes = [];\n            hooks = null;\n            plot = null;\n        };\n\n        plot.resize = function() {\n            var width = placeholder.width(),\n                height = placeholder.height();\n            surface.resize(width, height);\n            overlay.resize(width, height);\n\n            executeHooks(hooks.resize, [width, height]);\n        };\n\n        plot.clearTextCache = function () {\n            surface.clearCache();\n            overlay.clearCache();\n        };\n\n        plot.autoScaleAxis = autoScaleAxis;\n        plot.computeRangeForDataSeries = computeRangeForDataSeries;\n        plot.adjustSeriesDataRange = adjustSeriesDataRange;\n        plot.findNearbyItem = findNearbyItem;\n        plot.findNearbyItems = findNearbyItems;\n        plot.findNearbyInterpolationPoint = findNearbyInterpolationPoint;\n        plot.computeValuePrecision = computeValuePrecision;\n        plot.computeTickSize = computeTickSize;\n        plot.addEventHandler = addEventHandler;\n\n        // public attributes\n        plot.hooks = hooks;\n\n        // initialize\n        var MINOR_TICKS_COUNT_CONSTANT = $.plot.uiConstants.MINOR_TICKS_COUNT_CONSTANT;\n        var TICK_LENGTH_CONSTANT = $.plot.uiConstants.TICK_LENGTH_CONSTANT;\n        initPlugins(plot);\n        setupCanvases();\n        parseOptions(options_);\n        setData(data_);\n        setupGrid(true);\n        draw();\n        bindEvents();\n\n        function executeHooks(hook, args) {\n            args = [plot].concat(args);\n            for (var i = 0; i < hook.length; ++i) {\n                hook[i].apply(this, args);\n            }\n        }\n\n        function initPlugins() {\n            // References to key classes, allowing plugins to modify them\n\n            var classes = {\n                Canvas: Canvas\n            };\n\n            for (var i = 0; i < plugins.length; ++i) {\n                var p = plugins[i];\n                p.init(plot, classes);\n                if (p.options) {\n                    $.extend(true, options, p.options);\n                }\n            }\n        }\n\n        function parseOptions(opts) {\n            $.extend(true, options, opts);\n\n            // $.extend merges arrays, rather than replacing them.  When less\n            // colors are provided than the size of the default palette, we\n            // end up with those colors plus the remaining defaults, which is\n            // not expected behavior; avoid it by replacing them here.\n\n            if (opts && opts.colors) {\n                options.colors = opts.colors;\n            }\n\n            if (options.xaxis.color == null) {\n                options.xaxis.color = $.color.parse(options.grid.color).scale('a', 0.22).toString();\n            }\n\n            if (options.yaxis.color == null) {\n                options.yaxis.color = $.color.parse(options.grid.color).scale('a', 0.22).toString();\n            }\n\n            if (options.xaxis.tickColor == null) {\n                // grid.tickColor for back-compatibility\n                options.xaxis.tickColor = options.grid.tickColor || options.xaxis.color;\n            }\n\n            if (options.yaxis.tickColor == null) {\n                // grid.tickColor for back-compatibility\n                options.yaxis.tickColor = options.grid.tickColor || options.yaxis.color;\n            }\n\n            if (options.grid.borderColor == null) {\n                options.grid.borderColor = options.grid.color;\n            }\n\n            if (options.grid.tickColor == null) {\n                options.grid.tickColor = $.color.parse(options.grid.color).scale('a', 0.22).toString();\n            }\n\n            // Fill in defaults for axis options, including any unspecified\n            // font-spec fields, if a font-spec was provided.\n\n            // If no x/y axis options were provided, create one of each anyway,\n            // since the rest of the code assumes that they exist.\n\n            var i, axisOptions, axisCount,\n                fontSize = placeholder.css(\"font-size\"),\n                fontSizeDefault = fontSize ? +fontSize.replace(\"px\", \"\") : 13,\n                fontDefaults = {\n                    style: placeholder.css(\"font-style\"),\n                    size: Math.round(0.8 * fontSizeDefault),\n                    variant: placeholder.css(\"font-variant\"),\n                    weight: placeholder.css(\"font-weight\"),\n                    family: placeholder.css(\"font-family\")\n                };\n\n            axisCount = options.xaxes.length || 1;\n            for (i = 0; i < axisCount; ++i) {\n                axisOptions = options.xaxes[i];\n                if (axisOptions && !axisOptions.tickColor) {\n                    axisOptions.tickColor = axisOptions.color;\n                }\n\n                axisOptions = $.extend(true, {}, options.xaxis, axisOptions);\n                options.xaxes[i] = axisOptions;\n\n                if (axisOptions.font) {\n                    axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);\n                    if (!axisOptions.font.color) {\n                        axisOptions.font.color = axisOptions.color;\n                    }\n                    if (!axisOptions.font.lineHeight) {\n                        axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);\n                    }\n                }\n            }\n\n            axisCount = options.yaxes.length || 1;\n            for (i = 0; i < axisCount; ++i) {\n                axisOptions = options.yaxes[i];\n                if (axisOptions && !axisOptions.tickColor) {\n                    axisOptions.tickColor = axisOptions.color;\n                }\n\n                axisOptions = $.extend(true, {}, options.yaxis, axisOptions);\n                options.yaxes[i] = axisOptions;\n\n                if (axisOptions.font) {\n                    axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);\n                    if (!axisOptions.font.color) {\n                        axisOptions.font.color = axisOptions.color;\n                    }\n                    if (!axisOptions.font.lineHeight) {\n                        axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);\n                    }\n                }\n            }\n\n            // save options on axes for future reference\n            for (i = 0; i < options.xaxes.length; ++i) {\n                getOrCreateAxis(xaxes, i + 1).options = options.xaxes[i];\n            }\n\n            for (i = 0; i < options.yaxes.length; ++i) {\n                getOrCreateAxis(yaxes, i + 1).options = options.yaxes[i];\n            }\n\n            //process boxPosition options used for axis.box size\n            $.each(allAxes(), function(_, axis) {\n                axis.boxPosition = axis.options.boxPosition || {centerX: 0, centerY: 0};\n            });\n\n            // add hooks from options\n            for (var n in hooks) {\n                if (options.hooks[n] && options.hooks[n].length) {\n                    hooks[n] = hooks[n].concat(options.hooks[n]);\n                }\n            }\n\n            executeHooks(hooks.processOptions, [options]);\n        }\n\n        function setData(d) {\n            var oldseries = series;\n            series = parseData(d);\n            fillInSeriesOptions();\n            processData(oldseries);\n        }\n\n        function parseData(d) {\n            var res = [];\n            for (var i = 0; i < d.length; ++i) {\n                var s = $.extend(true, {}, options.series);\n\n                if (d[i].data != null) {\n                    s.data = d[i].data; // move the data instead of deep-copy\n                    delete d[i].data;\n\n                    $.extend(true, s, d[i]);\n\n                    d[i].data = s.data;\n                } else {\n                    s.data = d[i];\n                }\n\n                res.push(s);\n            }\n\n            return res;\n        }\n\n        function axisNumber(obj, coord) {\n            var a = obj[coord + \"axis\"];\n            if (typeof a === \"object\") {\n                // if we got a real axis, extract number\n                a = a.n;\n            }\n\n            if (typeof a !== \"number\") {\n                a = 1; // default to first axis\n            }\n\n            return a;\n        }\n\n        function allAxes() {\n            // return flat array without annoying null entries\n            return xaxes.concat(yaxes).filter(function(a) {\n                return a;\n            });\n        }\n\n        // canvas to axis for cartesian axes\n        function canvasToCartesianAxisCoords(pos) {\n            // return an object with x/y corresponding to all used axes\n            var res = {},\n                i, axis;\n            for (i = 0; i < xaxes.length; ++i) {\n                axis = xaxes[i];\n                if (axis && axis.used) {\n                    res[\"x\" + axis.n] = axis.c2p(pos.left);\n                }\n            }\n\n            for (i = 0; i < yaxes.length; ++i) {\n                axis = yaxes[i];\n                if (axis && axis.used) {\n                    res[\"y\" + axis.n] = axis.c2p(pos.top);\n                }\n            }\n\n            if (res.x1 !== undefined) {\n                res.x = res.x1;\n            }\n\n            if (res.y1 !== undefined) {\n                res.y = res.y1;\n            }\n\n            return res;\n        }\n\n        // axis to canvas for cartesian axes\n        function cartesianAxisToCanvasCoords(pos) {\n            // get canvas coords from the first pair of x/y found in pos\n            var res = {},\n                i, axis, key;\n\n            for (i = 0; i < xaxes.length; ++i) {\n                axis = xaxes[i];\n                if (axis && axis.used) {\n                    key = \"x\" + axis.n;\n                    if (pos[key] == null && axis.n === 1) {\n                        key = \"x\";\n                    }\n\n                    if (pos[key] != null) {\n                        res.left = axis.p2c(pos[key]);\n                        break;\n                    }\n                }\n            }\n\n            for (i = 0; i < yaxes.length; ++i) {\n                axis = yaxes[i];\n                if (axis && axis.used) {\n                    key = \"y\" + axis.n;\n                    if (pos[key] == null && axis.n === 1) {\n                        key = \"y\";\n                    }\n\n                    if (pos[key] != null) {\n                        res.top = axis.p2c(pos[key]);\n                        break;\n                    }\n                }\n            }\n\n            return res;\n        }\n\n        function getOrCreateAxis(axes, number) {\n            if (!axes[number - 1]) {\n                axes[number - 1] = {\n                    n: number, // save the number for future reference\n                    direction: axes === xaxes ? \"x\" : \"y\",\n                    options: $.extend(true, {}, axes === xaxes ? options.xaxis : options.yaxis)\n                };\n            }\n\n            return axes[number - 1];\n        }\n\n        function fillInSeriesOptions() {\n            var neededColors = series.length,\n                maxIndex = -1,\n                i;\n\n            // Subtract the number of series that already have fixed colors or\n            // color indexes from the number that we still need to generate.\n\n            for (i = 0; i < series.length; ++i) {\n                var sc = series[i].color;\n                if (sc != null) {\n                    neededColors--;\n                    if (typeof sc === \"number\" && sc > maxIndex) {\n                        maxIndex = sc;\n                    }\n                }\n            }\n\n            // If any of the series have fixed color indexes, then we need to\n            // generate at least as many colors as the highest index.\n\n            if (neededColors <= maxIndex) {\n                neededColors = maxIndex + 1;\n            }\n\n            // Generate all the colors, using first the option colors and then\n            // variations on those colors once they're exhausted.\n\n            var c, colors = [],\n                colorPool = options.colors,\n                colorPoolSize = colorPool.length,\n                variation = 0,\n                definedColors = Math.max(0, series.length - neededColors);\n\n            for (i = 0; i < neededColors; i++) {\n                c = $.color.parse(colorPool[(definedColors + i) % colorPoolSize] || \"#666\");\n\n                // Each time we exhaust the colors in the pool we adjust\n                // a scaling factor used to produce more variations on\n                // those colors. The factor alternates negative/positive\n                // to produce lighter/darker colors.\n\n                // Reset the variation after every few cycles, or else\n                // it will end up producing only white or black colors.\n\n                if (i % colorPoolSize === 0 && i) {\n                    if (variation >= 0) {\n                        if (variation < 0.5) {\n                            variation = -variation - 0.2;\n                        } else variation = 0;\n                    } else variation = -variation;\n                }\n\n                colors[i] = c.scale('rgb', 1 + variation);\n            }\n\n            // Finalize the series options, filling in their colors\n\n            var colori = 0,\n                s;\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n\n                // assign colors\n                if (s.color == null) {\n                    s.color = colors[colori].toString();\n                    ++colori;\n                } else if (typeof s.color === \"number\") {\n                    s.color = colors[s.color].toString();\n                }\n\n                // turn on lines automatically in case nothing is set\n                if (s.lines.show == null) {\n                    var v, show = true;\n                    for (v in s) {\n                        if (s[v] && s[v].show) {\n                            show = false;\n                            break;\n                        }\n                    }\n\n                    if (show) {\n                        s.lines.show = true;\n                    }\n                }\n\n                // If nothing was provided for lines.zero, default it to match\n                // lines.fill, since areas by default should extend to zero.\n\n                if (s.lines.zero == null) {\n                    s.lines.zero = !!s.lines.fill;\n                }\n\n                // setup axes\n                s.xaxis = getOrCreateAxis(xaxes, axisNumber(s, \"x\"));\n                s.yaxis = getOrCreateAxis(yaxes, axisNumber(s, \"y\"));\n            }\n        }\n\n        function processData(prevSeries) {\n            var topSentry = Number.POSITIVE_INFINITY,\n                bottomSentry = Number.NEGATIVE_INFINITY,\n                i, j, k, m,\n                s, points, ps, val, f, p,\n                data, format;\n\n            function updateAxis(axis, min, max) {\n                if (min < axis.datamin && min !== -Infinity) {\n                    axis.datamin = min;\n                }\n\n                if (max > axis.datamax && max !== Infinity) {\n                    axis.datamax = max;\n                }\n            }\n\n            function reusePoints(prevSeries, i) {\n                if (prevSeries && prevSeries[i] && prevSeries[i].datapoints && prevSeries[i].datapoints.points) {\n                    return prevSeries[i].datapoints.points;\n                }\n\n                return [];\n            }\n\n            $.each(allAxes(), function(_, axis) {\n                // init axis\n                if (axis.options.growOnly !== true) {\n                    axis.datamin = topSentry;\n                    axis.datamax = bottomSentry;\n                } else {\n                    if (axis.datamin === undefined) {\n                        axis.datamin = topSentry;\n                    }\n                    if (axis.datamax === undefined) {\n                        axis.datamax = bottomSentry;\n                    }\n                }\n                axis.used = false;\n            });\n\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n                s.datapoints = {\n                    points: []\n                };\n\n                if (s.datapoints.points.length === 0) {\n                    s.datapoints.points = reusePoints(prevSeries, i);\n                }\n\n                executeHooks(hooks.processRawData, [s, s.data, s.datapoints]);\n            }\n\n            // first pass: clean and copy data\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n\n                data = s.data;\n                format = s.datapoints.format;\n\n                if (!format) {\n                    format = [];\n                    // find out how to copy\n                    format.push({\n                        x: true,\n                        y: false,\n                        number: true,\n                        required: true,\n                        computeRange: s.xaxis.options.autoScale !== 'none',\n                        defaultValue: null\n                    });\n\n                    format.push({\n                        x: false,\n                        y: true,\n                        number: true,\n                        required: true,\n                        computeRange: s.yaxis.options.autoScale !== 'none',\n                        defaultValue: null\n                    });\n\n                    if (s.stack || s.bars.show || (s.lines.show && s.lines.fill)) {\n                        var expectedPs = s.datapoints.pointsize != null ? s.datapoints.pointsize : (s.data && s.data[0] && s.data[0].length ? s.data[0].length : 3);\n                        if (expectedPs > 2) {\n                            format.push({\n                                x: false,\n                                y: true,\n                                number: true,\n                                required: false,\n                                computeRange: s.yaxis.options.autoScale !== 'none',\n                                defaultValue: 0\n                            });\n                        }\n                    }\n\n                    s.datapoints.format = format;\n                }\n\n                s.xaxis.used = s.yaxis.used = true;\n\n                if (s.datapoints.pointsize != null) continue; // already filled in\n\n                s.datapoints.pointsize = format.length;\n                ps = s.datapoints.pointsize;\n                points = s.datapoints.points;\n\n                for (j = k = 0; j < data.length; ++j, k += ps) {\n                    p = data[j];\n\n                    var nullify = p == null;\n                    if (!nullify) {\n                        for (m = 0; m < ps; ++m) {\n                            val = p[m];\n                            f = format[m];\n\n                            if (f) {\n                                if (f.number && val != null) {\n                                    val = +val; // convert to number\n                                    if (isNaN(val)) {\n                                        val = null;\n                                    }\n                                }\n\n                                if (val == null) {\n                                    if (f.required) nullify = true;\n\n                                    if (f.defaultValue != null) val = f.defaultValue;\n                                }\n                            }\n\n                            points[k + m] = val;\n                        }\n                    }\n\n                    if (nullify) {\n                        for (m = 0; m < ps; ++m) {\n                            val = points[k + m];\n                            if (val != null) {\n                                f = format[m];\n                                // extract min/max info\n                                if (f.computeRange) {\n                                    if (f.x) {\n                                        updateAxis(s.xaxis, val, val);\n                                    }\n                                    if (f.y) {\n                                        updateAxis(s.yaxis, val, val);\n                                    }\n                                }\n                            }\n                            points[k + m] = null;\n                        }\n                    }\n                }\n\n                points.length = k; //trims the internal buffer to the correct length\n            }\n\n            // give the hooks a chance to run\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n\n                executeHooks(hooks.processDatapoints, [s, s.datapoints]);\n            }\n\n            // second pass: find datamax/datamin for auto-scaling\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n                format = s.datapoints.format;\n\n                if (format.every(function (f) { return !f.computeRange; })) {\n                    continue;\n                }\n\n                var range = plot.adjustSeriesDataRange(s,\n                    plot.computeRangeForDataSeries(s));\n\n                executeHooks(hooks.adjustSeriesDataRange, [s, range]);\n\n                updateAxis(s.xaxis, range.xmin, range.xmax);\n                updateAxis(s.yaxis, range.ymin, range.ymax);\n            }\n\n            $.each(allAxes(), function(_, axis) {\n                if (axis.datamin === topSentry) {\n                    axis.datamin = null;\n                }\n\n                if (axis.datamax === bottomSentry) {\n                    axis.datamax = null;\n                }\n            });\n        }\n\n        function setupCanvases() {\n            // Make sure the placeholder is clear of everything except canvases\n            // from a previous plot in this container that we'll try to re-use.\n\n            placeholder.css(\"padding\", 0) // padding messes up the positioning\n                .children().filter(function() {\n                    return !$(this).hasClass(\"flot-overlay\") && !$(this).hasClass('flot-base');\n                }).remove();\n\n            if (placeholder.css(\"position\") === 'static') {\n                placeholder.css(\"position\", \"relative\"); // for positioning labels and overlay\n            }\n\n            surface = new Canvas(\"flot-base\", placeholder[0]);\n            overlay = new Canvas(\"flot-overlay\", placeholder[0]); // overlay canvas for interactive features\n\n            ctx = surface.context;\n            octx = overlay.context;\n\n            // define which element we're listening for events on\n            eventHolder = $(overlay.element).unbind();\n\n            // If we're re-using a plot object, shut down the old one\n\n            var existing = placeholder.data(\"plot\");\n\n            if (existing) {\n                existing.shutdown();\n                overlay.clear();\n            }\n\n            // save in case we get replotted\n            placeholder.data(\"plot\", plot);\n        }\n\n        function bindEvents() {\n            executeHooks(hooks.bindEvents, [eventHolder]);\n        }\n\n        function addEventHandler(event, handler, eventHolder, priority) {\n            var key = eventHolder + event;\n            var eventList = eventManager[key] || [];\n\n            eventList.push({\"event\": event, \"handler\": handler, \"eventHolder\": eventHolder, \"priority\": priority});\n            eventList.sort((a, b) => b.priority - a.priority);\n            eventList.forEach(eventData => {\n                eventData.eventHolder.unbind(eventData.event, eventData.handler);\n                eventData.eventHolder.bind(eventData.event, eventData.handler);\n            });\n\n            eventManager[key] = eventList;\n        }\n\n        function shutdown() {\n            if (redrawTimeout) {\n                clearTimeout(redrawTimeout);\n            }\n\n            executeHooks(hooks.shutdown, [eventHolder]);\n        }\n\n        function setTransformationHelpers(axis) {\n            // set helper functions on the axis, assumes plot area\n            // has been computed already\n\n            function identity(x) {\n                return x;\n            }\n\n            var s, m, t = axis.options.transform || identity,\n                it = axis.options.inverseTransform;\n\n            // precompute how much the axis is scaling a point\n            // in canvas space\n            if (axis.direction === \"x\") {\n                if (isFinite(t(axis.max) - t(axis.min))) {\n                    s = axis.scale = plotWidth / Math.abs(t(axis.max) - t(axis.min));\n                } else {\n                    s = axis.scale = 1 / Math.abs($.plot.saturated.delta(t(axis.min), t(axis.max), plotWidth));\n                }\n                m = Math.min(t(axis.max), t(axis.min));\n            } else {\n                if (isFinite(t(axis.max) - t(axis.min))) {\n                    s = axis.scale = plotHeight / Math.abs(t(axis.max) - t(axis.min));\n                } else {\n                    s = axis.scale = 1 / Math.abs($.plot.saturated.delta(t(axis.min), t(axis.max), plotHeight));\n                }\n                s = -s;\n                m = Math.max(t(axis.max), t(axis.min));\n            }\n\n            // data point to canvas coordinate\n            if (t === identity) {\n                // slight optimization\n                axis.p2c = function(p) {\n                    if (isFinite(p - m)) {\n                        return (p - m) * s;\n                    } else {\n                        return (p / 4 - m / 4) * s * 4;\n                    }\n                };\n            } else {\n                axis.p2c = function(p) {\n                    var tp = t(p);\n\n                    if (isFinite(tp - m)) {\n                        return (tp - m) * s;\n                    } else {\n                        return (tp / 4 - m / 4) * s * 4;\n                    }\n                };\n            }\n\n            // canvas coordinate to data point\n            if (!it) {\n                axis.c2p = function(c) {\n                    return m + c / s;\n                };\n            } else {\n                axis.c2p = function(c) {\n                    return it(m + c / s);\n                };\n            }\n        }\n\n        function measureTickLabels(axis) {\n            var opts = axis.options,\n                ticks = opts.showTickLabels !== 'none' && axis.ticks ? axis.ticks : [],\n                showMajorTickLabels = opts.showTickLabels === 'major' || opts.showTickLabels === 'all',\n                showEndpointsTickLabels = opts.showTickLabels === 'endpoints' || opts.showTickLabels === 'all',\n                labelWidth = opts.labelWidth || 0,\n                labelHeight = opts.labelHeight || 0,\n                legacyStyles = axis.direction + \"Axis \" + axis.direction + axis.n + \"Axis\",\n                layer = \"flot-\" + axis.direction + \"-axis flot-\" + axis.direction + axis.n + \"-axis \" + legacyStyles,\n                font = opts.font || \"flot-tick-label tickLabel\";\n\n            for (var i = 0; i < ticks.length; ++i) {\n                var t = ticks[i];\n                var label = t.label;\n\n                if (!t.label ||\n                    (showMajorTickLabels === false && i > 0 && i < ticks.length - 1) ||\n                    (showEndpointsTickLabels === false && (i === 0 || i === ticks.length - 1))) {\n                    continue;\n                }\n\n                if (typeof t.label === 'object') {\n                    label = t.label.name;\n                }\n\n                var info = surface.getTextInfo(layer, label, font);\n\n                labelWidth = Math.max(labelWidth, info.width);\n                labelHeight = Math.max(labelHeight, info.height);\n            }\n\n            axis.labelWidth = opts.labelWidth || labelWidth;\n            axis.labelHeight = opts.labelHeight || labelHeight;\n        }\n\n        function allocateAxisBoxFirstPhase(axis) {\n            // find the bounding box of the axis by looking at label\n            // widths/heights and ticks, make room by diminishing the\n            // plotOffset; this first phase only looks at one\n            // dimension per axis, the other dimension depends on the\n            // other axes so will have to wait\n\n            // here reserve additional space\n            executeHooks(hooks.axisReserveSpace, [axis]);\n\n            var lw = axis.labelWidth,\n                lh = axis.labelHeight,\n                pos = axis.options.position,\n                isXAxis = axis.direction === \"x\",\n                tickLength = axis.options.tickLength,\n                showTicks = axis.options.showTicks,\n                showMinorTicks = axis.options.showMinorTicks,\n                gridLines = axis.options.gridLines,\n                axisMargin = options.grid.axisMargin,\n                padding = options.grid.labelMargin,\n                innermost = true,\n                outermost = true,\n                found = false;\n\n            // Determine the axis's position in its direction and on its side\n\n            $.each(isXAxis ? xaxes : yaxes, function(i, a) {\n                if (a && (a.show || a.reserveSpace)) {\n                    if (a === axis) {\n                        found = true;\n                    } else if (a.options.position === pos) {\n                        if (found) {\n                            outermost = false;\n                        } else {\n                            innermost = false;\n                        }\n                    }\n                }\n            });\n\n            // The outermost axis on each side has no margin\n            if (outermost) {\n                axisMargin = 0;\n            }\n\n            // Set the default tickLength if necessary\n            if (tickLength == null) {\n                tickLength = TICK_LENGTH_CONSTANT;\n            }\n\n            // By default, major tick marks are visible\n            if (showTicks == null) {\n                showTicks = true;\n            }\n\n            // By default, minor tick marks are visible\n            if (showMinorTicks == null) {\n                showMinorTicks = true;\n            }\n\n            // By default, grid lines are visible\n            if (gridLines == null) {\n                if (innermost) {\n                    gridLines = true;\n                } else {\n                    gridLines = false;\n                }\n            }\n\n            if (!isNaN(+tickLength)) {\n                padding += showTicks ? +tickLength : 0;\n            }\n\n            if (isXAxis) {\n                lh += padding;\n\n                if (pos === \"bottom\") {\n                    plotOffset.bottom += lh + axisMargin;\n                    axis.box = {\n                        top: surface.height - plotOffset.bottom,\n                        height: lh\n                    };\n                } else {\n                    axis.box = {\n                        top: plotOffset.top + axisMargin,\n                        height: lh\n                    };\n                    plotOffset.top += lh + axisMargin;\n                }\n            } else {\n                lw += padding;\n\n                if (pos === \"left\") {\n                    axis.box = {\n                        left: plotOffset.left + axisMargin,\n                        width: lw\n                    };\n                    plotOffset.left += lw + axisMargin;\n                } else {\n                    plotOffset.right += lw + axisMargin;\n                    axis.box = {\n                        left: surface.width - plotOffset.right,\n                        width: lw\n                    };\n                }\n            }\n\n            // save for future reference\n            axis.position = pos;\n            axis.tickLength = tickLength;\n            axis.showMinorTicks = showMinorTicks;\n            axis.showTicks = showTicks;\n            axis.gridLines = gridLines;\n            axis.box.padding = padding;\n            axis.innermost = innermost;\n        }\n\n        function allocateAxisBoxSecondPhase(axis) {\n            // now that all axis boxes have been placed in one\n            // dimension, we can set the remaining dimension coordinates\n            if (axis.direction === \"x\") {\n                axis.box.left = plotOffset.left - axis.labelWidth / 2;\n                axis.box.width = surface.width - plotOffset.left - plotOffset.right + axis.labelWidth;\n            } else {\n                axis.box.top = plotOffset.top - axis.labelHeight / 2;\n                axis.box.height = surface.height - plotOffset.bottom - plotOffset.top + axis.labelHeight;\n            }\n        }\n\n        function adjustLayoutForThingsStickingOut() {\n            // possibly adjust plot offset to ensure everything stays\n            // inside the canvas and isn't clipped off\n\n            var minMargin = options.grid.minBorderMargin,\n                i;\n\n            // check stuff from the plot (FIXME: this should just read\n            // a value from the series, otherwise it's impossible to\n            // customize)\n            if (minMargin == null) {\n                minMargin = 0;\n                for (i = 0; i < series.length; ++i) {\n                    minMargin = Math.max(minMargin, 2 * (series[i].points.radius + series[i].points.lineWidth / 2));\n                }\n            }\n\n            var a, offset = {},\n                margins = {\n                    left: minMargin,\n                    right: minMargin,\n                    top: minMargin,\n                    bottom: minMargin\n                };\n\n            // check axis labels, note we don't check the actual\n            // labels but instead use the overall width/height to not\n            // jump as much around with replots\n            $.each(allAxes(), function(_, axis) {\n                if (axis.reserveSpace && axis.ticks && axis.ticks.length) {\n                    if (axis.direction === \"x\") {\n                        margins.left = Math.max(margins.left, axis.labelWidth / 2);\n                        margins.right = Math.max(margins.right, axis.labelWidth / 2);\n                    } else {\n                        margins.bottom = Math.max(margins.bottom, axis.labelHeight / 2);\n                        margins.top = Math.max(margins.top, axis.labelHeight / 2);\n                    }\n                }\n            });\n\n            for (a in margins) {\n                offset[a] = margins[a] - plotOffset[a];\n            }\n            $.each(xaxes.concat(yaxes), function(_, axis) {\n                alignAxisWithGrid(axis, offset, function (offset) {\n                    return offset > 0;\n                });\n            });\n\n            plotOffset.left = Math.ceil(Math.max(margins.left, plotOffset.left));\n            plotOffset.right = Math.ceil(Math.max(margins.right, plotOffset.right));\n            plotOffset.top = Math.ceil(Math.max(margins.top, plotOffset.top));\n            plotOffset.bottom = Math.ceil(Math.max(margins.bottom, plotOffset.bottom));\n        }\n\n        function alignAxisWithGrid(axis, offset, isValid) {\n            if (axis.direction === \"x\") {\n                if (axis.position === \"bottom\" && isValid(offset.bottom)) {\n                    axis.box.top -= Math.ceil(offset.bottom);\n                }\n                if (axis.position === \"top\" && isValid(offset.top)) {\n                    axis.box.top += Math.ceil(offset.top);\n                }\n            } else {\n                if (axis.position === \"left\" && isValid(offset.left)) {\n                    axis.box.left += Math.ceil(offset.left);\n                }\n                if (axis.position === \"right\" && isValid(offset.right)) {\n                    axis.box.left -= Math.ceil(offset.right);\n                }\n            }\n        }\n\n        function setupGrid(autoScale) {\n            var i, a, axes = allAxes(),\n                showGrid = options.grid.show;\n\n            // Initialize the plot's offset from the edge of the canvas\n\n            for (a in plotOffset) {\n                plotOffset[a] = 0;\n            }\n\n            executeHooks(hooks.processOffset, [plotOffset]);\n\n            // If the grid is visible, add its border width to the offset\n            for (a in plotOffset) {\n                if (typeof (options.grid.borderWidth) === \"object\") {\n                    plotOffset[a] += showGrid ? options.grid.borderWidth[a] : 0;\n                } else {\n                    plotOffset[a] += showGrid ? options.grid.borderWidth : 0;\n                }\n            }\n\n            $.each(axes, function(_, axis) {\n                var axisOpts = axis.options;\n                axis.show = axisOpts.show == null ? axis.used : axisOpts.show;\n                axis.reserveSpace = axisOpts.reserveSpace == null ? axis.show : axisOpts.reserveSpace;\n                setupTickFormatter(axis);\n                executeHooks(hooks.setRange, [axis, autoScale]);\n                setRange(axis, autoScale);\n            });\n\n            if (showGrid) {\n                plotWidth = surface.width - plotOffset.left - plotOffset.right;\n                plotHeight = surface.height - plotOffset.bottom - plotOffset.top;\n\n                var allocatedAxes = $.grep(axes, function(axis) {\n                    return axis.show || axis.reserveSpace;\n                });\n\n                $.each(allocatedAxes, function(_, axis) {\n                    // make the ticks\n                    setupTickGeneration(axis);\n                    setMajorTicks(axis);\n                    snapRangeToTicks(axis, axis.ticks, series);\n\n                    //for computing the endpoints precision, transformationHelpers are needed\n                    setTransformationHelpers(axis);\n                    setEndpointTicks(axis, series);\n\n                    // find labelWidth/Height for axis\n                    measureTickLabels(axis);\n                });\n\n                // with all dimensions calculated, we can compute the\n                // axis bounding boxes, start from the outside\n                // (reverse order)\n                for (i = allocatedAxes.length - 1; i >= 0; --i) {\n                    allocateAxisBoxFirstPhase(allocatedAxes[i]);\n                }\n\n                // make sure we've got enough space for things that\n                // might stick out\n                adjustLayoutForThingsStickingOut();\n\n                $.each(allocatedAxes, function(_, axis) {\n                    allocateAxisBoxSecondPhase(axis);\n                });\n            }\n\n            //adjust axis and plotOffset according to grid.margins\n            if (options.grid.margin) {\n                for (a in plotOffset) {\n                    var margin = options.grid.margin || 0;\n                    plotOffset[a] += typeof margin === \"number\" ? margin : (margin[a] || 0);\n                }\n                $.each(xaxes.concat(yaxes), function(_, axis) {\n                    alignAxisWithGrid(axis, options.grid.margin, function(offset) {\n                        return offset !== undefined && offset !== null;\n                    });\n                });\n            }\n\n            //after adjusting the axis, plot width and height will be modified\n            plotWidth = surface.width - plotOffset.left - plotOffset.right;\n            plotHeight = surface.height - plotOffset.bottom - plotOffset.top;\n\n            // now we got the proper plot dimensions, we can compute the scaling\n            $.each(axes, function(_, axis) {\n                setTransformationHelpers(axis);\n            });\n\n            if (showGrid) {\n                drawAxisLabels();\n            }\n\n            executeHooks(hooks.setupGrid, []);\n        }\n\n        function widenMinMax(minimum, maximum) {\n            var min = (minimum === undefined ? null : minimum);\n            var max = (maximum === undefined ? null : maximum);\n            var delta = max - min;\n            if (delta === 0.0) {\n                // degenerate case\n                var widen = max === 0 ? 1 : 0.01;\n                var wmin = null;\n                if (min == null) {\n                    wmin -= widen;\n                }\n\n                // always widen max if we couldn't widen min to ensure we\n                // don't fall into min == max which doesn't work\n                if (max == null || min != null) {\n                    max += widen;\n                }\n\n                if (wmin != null) {\n                    min = wmin;\n                }\n            }\n\n            return {\n                min: min,\n                max: max\n            };\n        }\n\n        function autoScaleAxis(axis) {\n            var opts = axis.options,\n                min = opts.min,\n                max = opts.max,\n                datamin = axis.datamin,\n                datamax = axis.datamax,\n                delta;\n\n            switch (opts.autoScale) {\n                case \"none\":\n                    min = +(opts.min != null ? opts.min : datamin);\n                    max = +(opts.max != null ? opts.max : datamax);\n                    break;\n                case \"loose\":\n                    if (datamin != null && datamax != null) {\n                        min = datamin;\n                        max = datamax;\n                        delta = $.plot.saturated.saturate(max - min);\n                        var margin = ((typeof opts.autoScaleMargin === 'number') ? opts.autoScaleMargin : 0.02);\n                        min = $.plot.saturated.saturate(min - delta * margin);\n                        max = $.plot.saturated.saturate(max + delta * margin);\n\n                        // make sure we don't go below zero if all values are positive\n                        if (min < 0 && datamin >= 0) {\n                            min = 0;\n                        }\n                    } else {\n                        min = opts.min;\n                        max = opts.max;\n                    }\n                    break;\n                case \"exact\":\n                    min = (datamin != null ? datamin : opts.min);\n                    max = (datamax != null ? datamax : opts.max);\n                    break;\n                case \"sliding-window\":\n                    if (datamax > max) {\n                        // move the window to fit the new data,\n                        // keeping the axis range constant\n                        max = datamax;\n                        min = Math.max(datamax - (opts.windowSize || 100), min);\n                    }\n                    break;\n            }\n\n            var widenedMinMax = widenMinMax(min, max);\n            min = widenedMinMax.min;\n            max = widenedMinMax.max;\n\n            // grow loose or grow exact supported\n            if (opts.growOnly === true && opts.autoScale !== \"none\" && opts.autoScale !== \"sliding-window\") {\n                min = (min < datamin) ? min : (datamin !== null ? datamin : min);\n                max = (max > datamax) ? max : (datamax !== null ? datamax : max);\n            }\n\n            axis.autoScaledMin = min;\n            axis.autoScaledMax = max;\n        }\n\n        function setRange(axis, autoScale) {\n            var min = typeof axis.options.min === 'number' ? axis.options.min : axis.min,\n                max = typeof axis.options.max === 'number' ? axis.options.max : axis.max,\n                plotOffset = axis.options.offset;\n\n            if (autoScale) {\n                autoScaleAxis(axis);\n                min = axis.autoScaledMin;\n                max = axis.autoScaledMax;\n            }\n\n            min = (min != null ? min : -1) + (plotOffset.below || 0);\n            max = (max != null ? max : 1) + (plotOffset.above || 0);\n\n            if (min > max) {\n                var tmp = min;\n                min = max;\n                max = tmp;\n                axis.options.offset = { above: 0, below: 0 };\n            }\n\n            axis.min = $.plot.saturated.saturate(min);\n            axis.max = $.plot.saturated.saturate(max);\n        }\n\n        function computeValuePrecision (min, max, direction, ticks, tickDecimals) {\n            var noTicks = fixupNumberOfTicks(direction, surface, ticks);\n\n            var delta = $.plot.saturated.delta(min, max, noTicks),\n                dec = -Math.floor(Math.log(delta) / Math.LN10);\n\n            //if it is called with tickDecimals, then the precision should not be greather then that\n            if (tickDecimals && dec > tickDecimals) {\n                dec = tickDecimals;\n            }\n\n            var magn = parseFloat('1e' + (-dec)),\n                norm = delta / magn;\n\n            if (norm > 2.25 && norm < 3 && (dec + 1) <= tickDecimals) {\n                //we need an extra decimals when tickSize is 2.5\n                ++dec;\n            }\n\n            return isFinite(dec) ? dec : 0;\n        };\n\n        function computeTickSize (min, max, noTicks, tickDecimals) {\n            var delta = $.plot.saturated.delta(min, max, noTicks),\n                dec = -Math.floor(Math.log(delta) / Math.LN10);\n\n            //if it is called with tickDecimals, then the precision should not be greather then that\n            if (tickDecimals && dec > tickDecimals) {\n                dec = tickDecimals;\n            }\n\n            var magn = parseFloat('1e' + (-dec)),\n                norm = delta / magn, // norm is between 1.0 and 10.0\n                size;\n\n            if (norm < 1.5) {\n                size = 1;\n            } else if (norm < 3) {\n                size = 2;\n                if (norm > 2.25 && (tickDecimals == null || (dec + 1) <= tickDecimals)) {\n                    size = 2.5;\n                }\n            } else if (norm < 7.5) {\n                size = 5;\n            } else {\n                size = 10;\n            }\n\n            size *= magn;\n            return size;\n        }\n\n        function getAxisTickSize(min, max, direction, options, tickDecimals) {\n            var noTicks;\n\n            if (typeof options.ticks === \"number\" && options.ticks > 0) {\n                noTicks = options.ticks;\n            } else {\n            // heuristic based on the model a*sqrt(x) fitted to\n            // some data points that seemed reasonable\n                noTicks = 0.3 * Math.sqrt(direction === \"x\" ? surface.width : surface.height);\n            }\n\n            var size = computeTickSize(min, max, noTicks, tickDecimals);\n\n            if (options.minTickSize != null && size < options.minTickSize) {\n                size = options.minTickSize;\n            }\n\n            return options.tickSize || size;\n        };\n\n        function fixupNumberOfTicks(direction, surface, ticksOption) {\n            var noTicks;\n\n            if (typeof ticksOption === \"number\" && ticksOption > 0) {\n                noTicks = ticksOption;\n            } else {\n                noTicks = 0.3 * Math.sqrt(direction === \"x\" ? surface.width : surface.height);\n            }\n\n            return noTicks;\n        }\n\n        function setupTickFormatter(axis) {\n            var opts = axis.options;\n            if (!axis.tickFormatter) {\n                if (typeof opts.tickFormatter === 'function') {\n                    axis.tickFormatter = function() {\n                        var args = Array.prototype.slice.call(arguments);\n                        return \"\" + opts.tickFormatter.apply(null, args);\n                    };\n                } else {\n                    axis.tickFormatter = defaultTickFormatter;\n                }\n            }\n        }\n\n        function setupTickGeneration(axis) {\n            var opts = axis.options;\n            var noTicks;\n\n            noTicks = fixupNumberOfTicks(axis.direction, surface, opts.ticks);\n\n            axis.delta = $.plot.saturated.delta(axis.min, axis.max, noTicks);\n            var precision = plot.computeValuePrecision(axis.min, axis.max, axis.direction, noTicks, opts.tickDecimals);\n\n            axis.tickDecimals = Math.max(0, opts.tickDecimals != null ? opts.tickDecimals : precision);\n            axis.tickSize = getAxisTickSize(axis.min, axis.max, axis.direction, opts, opts.tickDecimals);\n\n            // Flot supports base-10 axes; any other mode else is handled by a plug-in,\n            // like flot.time.js.\n\n            if (!axis.tickGenerator) {\n                if (typeof opts.tickGenerator === 'function') {\n                    axis.tickGenerator = opts.tickGenerator;\n                } else {\n                    axis.tickGenerator = defaultTickGenerator;\n                }\n            }\n\n            if (opts.alignTicksWithAxis != null) {\n                var otherAxis = (axis.direction === \"x\" ? xaxes : yaxes)[opts.alignTicksWithAxis - 1];\n                if (otherAxis && otherAxis.used && otherAxis !== axis) {\n                    // consider snapping min/max to outermost nice ticks\n                    var niceTicks = axis.tickGenerator(axis, plot);\n                    if (niceTicks.length > 0) {\n                        if (opts.min == null) {\n                            axis.min = Math.min(axis.min, niceTicks[0]);\n                        }\n\n                        if (opts.max == null && niceTicks.length > 1) {\n                            axis.max = Math.max(axis.max, niceTicks[niceTicks.length - 1]);\n                        }\n                    }\n\n                    axis.tickGenerator = function(axis) {\n                        // copy ticks, scaled to this axis\n                        var ticks = [],\n                            v, i;\n                        for (i = 0; i < otherAxis.ticks.length; ++i) {\n                            v = (otherAxis.ticks[i].v - otherAxis.min) / (otherAxis.max - otherAxis.min);\n                            v = axis.min + v * (axis.max - axis.min);\n                            ticks.push(v);\n                        }\n                        return ticks;\n                    };\n\n                    // we might need an extra decimal since forced\n                    // ticks don't necessarily fit naturally\n                    if (!axis.mode && opts.tickDecimals == null) {\n                        var extraDec = Math.max(0, -Math.floor(Math.log(axis.delta) / Math.LN10) + 1),\n                            ts = axis.tickGenerator(axis, plot);\n\n                        // only proceed if the tick interval rounded\n                        // with an extra decimal doesn't give us a\n                        // zero at end\n                        if (!(ts.length > 1 && /\\..*0$/.test((ts[1] - ts[0]).toFixed(extraDec)))) {\n                            axis.tickDecimals = extraDec;\n                        }\n                    }\n                }\n            }\n        }\n\n        function setMajorTicks(axis) {\n            var oticks = axis.options.ticks,\n                ticks = [];\n            if (oticks == null || (typeof oticks === \"number\" && oticks > 0)) {\n                ticks = axis.tickGenerator(axis, plot);\n            } else if (oticks) {\n                if ($.isFunction(oticks)) {\n                // generate the ticks\n                    ticks = oticks(axis);\n                } else {\n                    ticks = oticks;\n                }\n            }\n\n            // clean up/labelify the supplied ticks, copy them over\n            var i, v;\n            axis.ticks = [];\n            for (i = 0; i < ticks.length; ++i) {\n                var label = null;\n                var t = ticks[i];\n                if (typeof t === \"object\") {\n                    v = +t[0];\n                    if (t.length > 1) {\n                        label = t[1];\n                    }\n                } else {\n                    v = +t;\n                }\n\n                if (!isNaN(v)) {\n                    axis.ticks.push(\n                        newTick(v, label, axis, 'major'));\n                }\n            }\n        }\n\n        function newTick(v, label, axis, type) {\n            if (label === null) {\n                switch (type) {\n                    case 'min':\n                    case 'max':\n                        //improving the precision of endpoints\n                        var precision = getEndpointPrecision(v, axis);\n                        label = isFinite(precision) ? axis.tickFormatter(v, axis, precision, plot) : axis.tickFormatter(v, axis, precision, plot);\n                        break;\n                    case 'major':\n                        label = axis.tickFormatter(v, axis, undefined, plot);\n                }\n            }\n            return {\n                v: v,\n                label: label\n            };\n        }\n\n        function snapRangeToTicks(axis, ticks, series) {\n            var anyDataInSeries = function(series) {\n                return series.some(e => e.datapoints.points.length > 0);\n            }\n\n            if (axis.options.autoScale === \"loose\" && ticks.length > 0 && anyDataInSeries(series)) {\n                // snap to ticks\n                axis.min = Math.min(axis.min, ticks[0].v);\n                axis.max = Math.max(axis.max, ticks[ticks.length - 1].v);\n            }\n        }\n\n        function getEndpointPrecision(value, axis) {\n            var canvas1 = Math.floor(axis.p2c(value)),\n                canvas2 = axis.direction === \"x\" ? canvas1 + 1 : canvas1 - 1,\n                point1 = axis.c2p(canvas1),\n                point2 = axis.c2p(canvas2),\n                precision = computeValuePrecision(point1, point2, axis.direction, 1);\n\n            return precision;\n        }\n\n        function setEndpointTicks(axis, series) {\n            if (isValidEndpointTick(axis, series)) {\n                axis.ticks.unshift(newTick(axis.min, null, axis, 'min'));\n                axis.ticks.push(newTick(axis.max, null, axis, 'max'));\n            }\n        }\n\n        function isValidEndpointTick(axis, series) {\n            if (axis.options.showTickLabels === 'endpoints') {\n                return true;\n            }\n            if (axis.options.showTickLabels === 'all') {\n                var associatedSeries = series.filter(function(s) {\n                        return s.bars.horizontal ? s.yaxis === axis : s.xaxis === axis;\n                    }),\n                    notAllBarSeries = associatedSeries.some(function(s) {\n                        return !s.bars.show;\n                    });\n                return associatedSeries.length === 0 || notAllBarSeries;\n            }\n            if (axis.options.showTickLabels === 'major' || axis.options.showTickLabels === 'none') {\n                return false;\n            }\n        }\n\n        function draw() {\n            surface.clear();\n            executeHooks(hooks.drawBackground, [ctx]);\n\n            var grid = options.grid;\n\n            // draw background, if any\n            if (grid.show && grid.backgroundColor) {\n                drawBackground();\n            }\n\n            if (grid.show && !grid.aboveData) {\n                drawGrid();\n            }\n\n            for (var i = 0; i < series.length; ++i) {\n                executeHooks(hooks.drawSeries, [ctx, series[i], i, getColorOrGradient]);\n                drawSeries(series[i]);\n            }\n\n            executeHooks(hooks.draw, [ctx]);\n\n            if (grid.show && grid.aboveData) {\n                drawGrid();\n            }\n\n            surface.render();\n\n            // A draw implies that either the axes or data have changed, so we\n            // should probably update the overlay highlights as well.\n            triggerRedrawOverlay();\n        }\n\n        function extractRange(ranges, coord) {\n            var axis, from, to, key, axes = allAxes();\n\n            for (var i = 0; i < axes.length; ++i) {\n                axis = axes[i];\n                if (axis.direction === coord) {\n                    key = coord + axis.n + \"axis\";\n                    if (!ranges[key] && axis.n === 1) {\n                        // support x1axis as xaxis\n                        key = coord + \"axis\";\n                    }\n\n                    if (ranges[key]) {\n                        from = ranges[key].from;\n                        to = ranges[key].to;\n                        break;\n                    }\n                }\n            }\n\n            // backwards-compat stuff - to be removed in future\n            if (!ranges[key]) {\n                axis = coord === \"x\" ? xaxes[0] : yaxes[0];\n                from = ranges[coord + \"1\"];\n                to = ranges[coord + \"2\"];\n            }\n\n            // auto-reverse as an added bonus\n            if (from != null && to != null && from > to) {\n                var tmp = from;\n                from = to;\n                to = tmp;\n            }\n\n            return {\n                from: from,\n                to: to,\n                axis: axis\n            };\n        }\n\n        function drawBackground() {\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            ctx.fillStyle = getColorOrGradient(options.grid.backgroundColor, plotHeight, 0, \"rgba(255, 255, 255, 0)\");\n            ctx.fillRect(0, 0, plotWidth, plotHeight);\n            ctx.restore();\n        }\n\n        function drawMarkings() {\n            // draw markings\n            var markings = options.grid.markings,\n                axes;\n\n            if (markings) {\n                if ($.isFunction(markings)) {\n                    axes = plot.getAxes();\n                    // xmin etc. is backwards compatibility, to be\n                    // removed in the future\n                    axes.xmin = axes.xaxis.min;\n                    axes.xmax = axes.xaxis.max;\n                    axes.ymin = axes.yaxis.min;\n                    axes.ymax = axes.yaxis.max;\n\n                    markings = markings(axes);\n                }\n\n                var i;\n                for (i = 0; i < markings.length; ++i) {\n                    var m = markings[i],\n                        xrange = extractRange(m, \"x\"),\n                        yrange = extractRange(m, \"y\");\n\n                    // fill in missing\n                    if (xrange.from == null) {\n                        xrange.from = xrange.axis.min;\n                    }\n\n                    if (xrange.to == null) {\n                        xrange.to = xrange.axis.max;\n                    }\n\n                    if (yrange.from == null) {\n                        yrange.from = yrange.axis.min;\n                    }\n\n                    if (yrange.to == null) {\n                        yrange.to = yrange.axis.max;\n                    }\n\n                    // clip\n                    if (xrange.to < xrange.axis.min || xrange.from > xrange.axis.max ||\n                        yrange.to < yrange.axis.min || yrange.from > yrange.axis.max) {\n                        continue;\n                    }\n\n                    xrange.from = Math.max(xrange.from, xrange.axis.min);\n                    xrange.to = Math.min(xrange.to, xrange.axis.max);\n                    yrange.from = Math.max(yrange.from, yrange.axis.min);\n                    yrange.to = Math.min(yrange.to, yrange.axis.max);\n\n                    var xequal = xrange.from === xrange.to,\n                        yequal = yrange.from === yrange.to;\n\n                    if (xequal && yequal) {\n                        continue;\n                    }\n\n                    // then draw\n                    xrange.from = Math.floor(xrange.axis.p2c(xrange.from));\n                    xrange.to = Math.floor(xrange.axis.p2c(xrange.to));\n                    yrange.from = Math.floor(yrange.axis.p2c(yrange.from));\n                    yrange.to = Math.floor(yrange.axis.p2c(yrange.to));\n\n                    if (xequal || yequal) {\n                        var lineWidth = m.lineWidth || options.grid.markingsLineWidth,\n                            subPixel = lineWidth % 2 ? 0.5 : 0;\n                        ctx.beginPath();\n                        ctx.strokeStyle = m.color || options.grid.markingsColor;\n                        ctx.lineWidth = lineWidth;\n                        if (xequal) {\n                            ctx.moveTo(xrange.to + subPixel, yrange.from);\n                            ctx.lineTo(xrange.to + subPixel, yrange.to);\n                        } else {\n                            ctx.moveTo(xrange.from, yrange.to + subPixel);\n                            ctx.lineTo(xrange.to, yrange.to + subPixel);\n                        }\n                        ctx.stroke();\n                    } else {\n                        ctx.fillStyle = m.color || options.grid.markingsColor;\n                        ctx.fillRect(xrange.from, yrange.to,\n                            xrange.to - xrange.from,\n                            yrange.from - yrange.to);\n                    }\n                }\n            }\n        }\n\n        function findEdges(axis) {\n            var box = axis.box,\n                x = 0,\n                y = 0;\n\n            // find the edges\n            if (axis.direction === \"x\") {\n                x = 0;\n                y = box.top - plotOffset.top + (axis.position === \"top\" ? box.height : 0);\n            } else {\n                y = 0;\n                x = box.left - plotOffset.left + (axis.position === \"left\" ? box.width : 0) + axis.boxPosition.centerX;\n            }\n\n            return {\n                x: x,\n                y: y\n            };\n        };\n\n        function alignPosition(lineWidth, pos) {\n            return ((lineWidth % 2) !== 0) ? Math.floor(pos) + 0.5 : pos;\n        };\n\n        function drawTickBar(axis) {\n            ctx.lineWidth = 1;\n            var edges = findEdges(axis),\n                x = edges.x,\n                y = edges.y;\n\n            // draw tick bar\n            if (axis.show) {\n                var xoff = 0,\n                    yoff = 0;\n\n                ctx.strokeStyle = axis.options.color;\n                ctx.beginPath();\n                if (axis.direction === \"x\") {\n                    xoff = plotWidth + 1;\n                } else {\n                    yoff = plotHeight + 1;\n                }\n\n                if (axis.direction === \"x\") {\n                    y = alignPosition(ctx.lineWidth, y);\n                } else {\n                    x = alignPosition(ctx.lineWidth, x);\n                }\n\n                ctx.moveTo(x, y);\n                ctx.lineTo(x + xoff, y + yoff);\n                ctx.stroke();\n            }\n        };\n\n        function drawTickMarks(axis) {\n            var t = axis.tickLength,\n                minorTicks = axis.showMinorTicks,\n                minorTicksNr = MINOR_TICKS_COUNT_CONSTANT,\n                edges = findEdges(axis),\n                x = edges.x,\n                y = edges.y,\n                i = 0;\n\n            // draw major tick marks\n            ctx.strokeStyle = axis.options.color;\n            ctx.beginPath();\n\n            for (i = 0; i < axis.ticks.length; ++i) {\n                var v = axis.ticks[i].v,\n                    xoff = 0,\n                    yoff = 0,\n                    xminor = 0,\n                    yminor = 0,\n                    j;\n\n                if (!isNaN(v) && v >= axis.min && v <= axis.max) {\n                    if (axis.direction === \"x\") {\n                        x = axis.p2c(v);\n                        yoff = t;\n\n                        if (axis.position === \"top\") {\n                            yoff = -yoff;\n                        }\n                    } else {\n                        y = axis.p2c(v);\n                        xoff = t;\n\n                        if (axis.position === \"left\") {\n                            xoff = -xoff;\n                        }\n                    }\n\n                    if (axis.direction === \"x\") {\n                        x = alignPosition(ctx.lineWidth, x);\n                    } else {\n                        y = alignPosition(ctx.lineWidth, y);\n                    }\n\n                    ctx.moveTo(x, y);\n                    ctx.lineTo(x + xoff, y + yoff);\n                }\n\n                //draw minor tick marks\n                if (minorTicks === true && i < axis.ticks.length - 1) {\n                    var v1 = axis.ticks[i].v,\n                        v2 = axis.ticks[i + 1].v,\n                        step = (v2 - v1) / (minorTicksNr + 1);\n\n                    for (j = 1; j <= minorTicksNr; j++) {\n                        // compute minor tick position\n                        if (axis.direction === \"x\") {\n                            yminor = t / 2; // minor ticks are half length\n                            x = alignPosition(ctx.lineWidth, axis.p2c(v1 + j * step))\n\n                            if (axis.position === \"top\") {\n                                yminor = -yminor;\n                            }\n\n                            // don't go over the plot borders\n                            if ((x < 0) || (x > plotWidth)) {\n                                continue;\n                            }\n                        } else {\n                            xminor = t / 2; // minor ticks are half length\n                            y = alignPosition(ctx.lineWidth, axis.p2c(v1 + j * step));\n\n                            if (axis.position === \"left\") {\n                                xminor = -xminor;\n                            }\n\n                            // don't go over the plot borders\n                            if ((y < 0) || (y > plotHeight)) {\n                                continue;\n                            }\n                        }\n\n                        ctx.moveTo(x, y);\n                        ctx.lineTo(x + xminor, y + yminor);\n                    }\n                }\n            }\n\n            ctx.stroke();\n        };\n\n        function drawGridLines(axis) {\n            // check if the line will be overlapped with a border\n            var overlappedWithBorder = function (value) {\n                var bw = options.grid.borderWidth;\n                return (((typeof bw === \"object\" && bw[axis.position] > 0) || bw > 0) && (value === axis.min || value === axis.max));\n            };\n\n            ctx.strokeStyle = options.grid.tickColor;\n            ctx.beginPath();\n            var i;\n            for (i = 0; i < axis.ticks.length; ++i) {\n                var v = axis.ticks[i].v,\n                    xoff = 0,\n                    yoff = 0,\n                    x = 0,\n                    y = 0;\n\n                if (isNaN(v) || v < axis.min || v > axis.max) continue;\n\n                // skip those lying on the axes if we got a border\n                if (overlappedWithBorder(v)) continue;\n\n                if (axis.direction === \"x\") {\n                    x = axis.p2c(v);\n                    y = plotHeight;\n                    yoff = -plotHeight;\n                } else {\n                    x = 0;\n                    y = axis.p2c(v);\n                    xoff = plotWidth;\n                }\n\n                if (axis.direction === \"x\") {\n                    x = alignPosition(ctx.lineWidth, x);\n                } else {\n                    y = alignPosition(ctx.lineWidth, y);\n                }\n\n                ctx.moveTo(x, y);\n                ctx.lineTo(x + xoff, y + yoff);\n            }\n\n            ctx.stroke();\n        };\n\n        function drawBorder() {\n            // If either borderWidth or borderColor is an object, then draw the border\n            // line by line instead of as one rectangle\n            var bw = options.grid.borderWidth,\n                bc = options.grid.borderColor;\n\n            if (typeof bw === \"object\" || typeof bc === \"object\") {\n                if (typeof bw !== \"object\") {\n                    bw = {\n                        top: bw,\n                        right: bw,\n                        bottom: bw,\n                        left: bw\n                    };\n                }\n                if (typeof bc !== \"object\") {\n                    bc = {\n                        top: bc,\n                        right: bc,\n                        bottom: bc,\n                        left: bc\n                    };\n                }\n\n                if (bw.top > 0) {\n                    ctx.strokeStyle = bc.top;\n                    ctx.lineWidth = bw.top;\n                    ctx.beginPath();\n                    ctx.moveTo(0 - bw.left, 0 - bw.top / 2);\n                    ctx.lineTo(plotWidth, 0 - bw.top / 2);\n                    ctx.stroke();\n                }\n\n                if (bw.right > 0) {\n                    ctx.strokeStyle = bc.right;\n                    ctx.lineWidth = bw.right;\n                    ctx.beginPath();\n                    ctx.moveTo(plotWidth + bw.right / 2, 0 - bw.top);\n                    ctx.lineTo(plotWidth + bw.right / 2, plotHeight);\n                    ctx.stroke();\n                }\n\n                if (bw.bottom > 0) {\n                    ctx.strokeStyle = bc.bottom;\n                    ctx.lineWidth = bw.bottom;\n                    ctx.beginPath();\n                    ctx.moveTo(plotWidth + bw.right, plotHeight + bw.bottom / 2);\n                    ctx.lineTo(0, plotHeight + bw.bottom / 2);\n                    ctx.stroke();\n                }\n\n                if (bw.left > 0) {\n                    ctx.strokeStyle = bc.left;\n                    ctx.lineWidth = bw.left;\n                    ctx.beginPath();\n                    ctx.moveTo(0 - bw.left / 2, plotHeight + bw.bottom);\n                    ctx.lineTo(0 - bw.left / 2, 0);\n                    ctx.stroke();\n                }\n            } else {\n                ctx.lineWidth = bw;\n                ctx.strokeStyle = options.grid.borderColor;\n                ctx.strokeRect(-bw / 2, -bw / 2, plotWidth + bw, plotHeight + bw);\n            }\n        };\n\n        function drawGrid() {\n            var axes, bw;\n\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            drawMarkings();\n\n            axes = allAxes();\n            bw = options.grid.borderWidth;\n\n            for (var j = 0; j < axes.length; ++j) {\n                var axis = axes[j];\n\n                if (!axis.show) {\n                    continue;\n                }\n\n                drawTickBar(axis);\n                if (axis.showTicks === true) {\n                    drawTickMarks(axis);\n                }\n\n                if (axis.gridLines === true) {\n                    drawGridLines(axis, bw);\n                }\n            }\n\n            // draw border\n            if (bw) {\n                drawBorder();\n            }\n\n            ctx.restore();\n        }\n\n        function drawAxisLabels() {\n            $.each(allAxes(), function(_, axis) {\n                var box = axis.box,\n                    legacyStyles = axis.direction + \"Axis \" + axis.direction + axis.n + \"Axis\",\n                    layer = \"flot-\" + axis.direction + \"-axis flot-\" + axis.direction + axis.n + \"-axis \" + legacyStyles,\n                    font = axis.options.font || \"flot-tick-label tickLabel\",\n                    i, x, y, halign, valign, info,\n                    margin = 3,\n                    nullBox = {x: NaN, y: NaN, width: NaN, height: NaN}, newLabelBox, labelBoxes = [],\n                    overlapping = function(x11, y11, x12, y12, x21, y21, x22, y22) {\n                        return ((x11 <= x21 && x21 <= x12) || (x21 <= x11 && x11 <= x22)) &&\n                               ((y11 <= y21 && y21 <= y12) || (y21 <= y11 && y11 <= y22));\n                    },\n                    overlapsOtherLabels = function(newLabelBox, previousLabelBoxes) {\n                        return previousLabelBoxes.some(function(labelBox) {\n                            return overlapping(\n                                newLabelBox.x, newLabelBox.y, newLabelBox.x + newLabelBox.width, newLabelBox.y + newLabelBox.height,\n                                labelBox.x, labelBox.y, labelBox.x + labelBox.width, labelBox.y + labelBox.height);\n                        });\n                    },\n                    drawAxisLabel = function (tick, labelBoxes) {\n                        if (!tick || !tick.label || tick.v < axis.min || tick.v > axis.max) {\n                            return nullBox;\n                        }\n\n                        info = surface.getTextInfo(layer, tick.label, font);\n\n                        if (axis.direction === \"x\") {\n                            halign = \"center\";\n                            x = plotOffset.left + axis.p2c(tick.v);\n                            if (axis.position === \"bottom\") {\n                                y = box.top + box.padding - axis.boxPosition.centerY;\n                            } else {\n                                y = box.top + box.height - box.padding + axis.boxPosition.centerY;\n                                valign = \"bottom\";\n                            }\n                            newLabelBox = {x: x - info.width / 2 - margin, y: y - margin, width: info.width + 2 * margin, height: info.height + 2 * margin};\n                        } else {\n                            valign = \"middle\";\n                            y = plotOffset.top + axis.p2c(tick.v);\n                            if (axis.position === \"left\") {\n                                x = box.left + box.width - box.padding - axis.boxPosition.centerX;\n                                halign = \"right\";\n                            } else {\n                                x = box.left + box.padding + axis.boxPosition.centerX;\n                            }\n                            newLabelBox = {x: x - info.width / 2 - margin, y: y - margin, width: info.width + 2 * margin, height: info.height + 2 * margin};\n                        }\n\n                        if (overlapsOtherLabels(newLabelBox, labelBoxes)) {\n                            return nullBox;\n                        }\n\n                        surface.addText(layer, x, y, tick.label, font, null, null, halign, valign);\n\n                        return newLabelBox;\n                    };\n\n                // Remove text before checking for axis.show and ticks.length;\n                // otherwise plugins, like flot-tickrotor, that draw their own\n                // tick labels will end up with both theirs and the defaults.\n\n                surface.removeText(layer);\n\n                executeHooks(hooks.drawAxis, [axis, surface]);\n\n                if (!axis.show) {\n                    return;\n                }\n\n                switch (axis.options.showTickLabels) {\n                    case 'none':\n                        break;\n                    case 'endpoints':\n                        labelBoxes.push(drawAxisLabel(axis.ticks[0], labelBoxes));\n                        labelBoxes.push(drawAxisLabel(axis.ticks[axis.ticks.length - 1], labelBoxes));\n                        break;\n                    case 'major':\n                        labelBoxes.push(drawAxisLabel(axis.ticks[0], labelBoxes));\n                        labelBoxes.push(drawAxisLabel(axis.ticks[axis.ticks.length - 1], labelBoxes));\n                        for (i = 1; i < axis.ticks.length - 1; ++i) {\n                            labelBoxes.push(drawAxisLabel(axis.ticks[i], labelBoxes));\n                        }\n                        break;\n                    case 'all':\n                        labelBoxes.push(drawAxisLabel(axis.ticks[0], []));\n                        labelBoxes.push(drawAxisLabel(axis.ticks[axis.ticks.length - 1], labelBoxes));\n                        for (i = 1; i < axis.ticks.length - 1; ++i) {\n                            labelBoxes.push(drawAxisLabel(axis.ticks[i], labelBoxes));\n                        }\n                        break;\n                }\n            });\n        }\n\n        function drawSeries(series) {\n            if (series.lines.show) {\n                $.plot.drawSeries.drawSeriesLines(series, ctx, plotOffset, plotWidth, plotHeight, plot.drawSymbol, getColorOrGradient);\n            }\n\n            if (series.bars.show) {\n                $.plot.drawSeries.drawSeriesBars(series, ctx, plotOffset, plotWidth, plotHeight, plot.drawSymbol, getColorOrGradient);\n            }\n\n            if (series.points.show) {\n                $.plot.drawSeries.drawSeriesPoints(series, ctx, plotOffset, plotWidth, plotHeight, plot.drawSymbol, getColorOrGradient);\n            }\n        }\n\n        function computeRangeForDataSeries(series, force, isValid) {\n            var points = series.datapoints.points,\n                ps = series.datapoints.pointsize,\n                format = series.datapoints.format,\n                topSentry = Number.POSITIVE_INFINITY,\n                bottomSentry = Number.NEGATIVE_INFINITY,\n                range = {\n                    xmin: topSentry,\n                    ymin: topSentry,\n                    xmax: bottomSentry,\n                    ymax: bottomSentry\n                };\n\n            for (var j = 0; j < points.length; j += ps) {\n                if (points[j] === null) {\n                    continue;\n                }\n\n                if (typeof (isValid) === 'function' && !isValid(points[j])) {\n                    continue;\n                }\n\n                for (var m = 0; m < ps; ++m) {\n                    var val = points[j + m],\n                        f = format[m];\n                    if (f === null || f === undefined) {\n                        continue;\n                    }\n\n                    if (typeof (isValid) === 'function' && !isValid(val)) {\n                        continue;\n                    }\n\n                    if ((!force && !f.computeRange) || val === Infinity || val === -Infinity) {\n                        continue;\n                    }\n\n                    if (f.x === true) {\n                        if (val < range.xmin) {\n                            range.xmin = val;\n                        }\n\n                        if (val > range.xmax) {\n                            range.xmax = val;\n                        }\n                    }\n\n                    if (f.y === true) {\n                        if (val < range.ymin) {\n                            range.ymin = val;\n                        }\n\n                        if (val > range.ymax) {\n                            range.ymax = val;\n                        }\n                    }\n                }\n            }\n\n            return range;\n        };\n\n        function adjustSeriesDataRange(series, range) {\n            if (series.bars.show) {\n                // make sure we got room for the bar on the dancing floor\n                var delta;\n\n                // update bar width if needed\n                var useAbsoluteBarWidth = series.bars.barWidth[1];\n                if (series.datapoints && series.datapoints.points && !useAbsoluteBarWidth) {\n                    computeBarWidth(series);\n                }\n\n                var barWidth = series.bars.barWidth[0] || series.bars.barWidth;\n                switch (series.bars.align) {\n                    case \"left\":\n                        delta = 0;\n                        break;\n                    case \"right\":\n                        delta = -barWidth;\n                        break;\n                    default:\n                        delta = -barWidth / 2;\n                }\n\n                if (series.bars.horizontal) {\n                    range.ymin += delta;\n                    range.ymax += delta + barWidth;\n                } else {\n                    range.xmin += delta;\n                    range.xmax += delta + barWidth;\n                }\n            }\n\n            if ((series.bars.show && series.bars.zero) || (series.lines.show && series.lines.zero)) {\n                var ps = series.datapoints.pointsize;\n\n                // make sure the 0 point is included in the computed y range when requested\n                if (ps <= 2) {\n                    /*if ps > 0 the points were already taken into account for autoScale */\n                    range.ymin = Math.min(0, range.ymin);\n                    range.ymax = Math.max(0, range.ymax);\n                }\n            }\n\n            return range;\n        };\n\n        function computeBarWidth(series) {\n            var xValues = [];\n            var pointsize = series.datapoints.pointsize, minDistance = Number.MAX_VALUE;\n\n            if (series.datapoints.points.length <= pointsize) {\n                minDistance = 1;\n            }\n\n            var start = series.bars.horizontal ? 1 : 0;\n            for (let j = start; j < series.datapoints.points.length; j += pointsize) {\n                if (isFinite(series.datapoints.points[j]) && series.datapoints.points[j] !== null) {\n                    xValues.push(series.datapoints.points[j]);\n                }\n            }\n\n            function onlyUnique(value, index, self) {\n                return self.indexOf(value) === index;\n            }\n\n            xValues = xValues.filter(onlyUnique);\n            xValues.sort(function(a, b) { return a - b });\n\n            for (let j = 1; j < xValues.length; j++) {\n                var distance = Math.abs(xValues[j] - xValues[j - 1]);\n                if (distance < minDistance && isFinite(distance)) {\n                    minDistance = distance;\n                }\n            }\n\n            if (typeof series.bars.barWidth === \"number\") {\n                series.bars.barWidth = series.bars.barWidth * minDistance;\n            } else {\n                series.bars.barWidth[0] = series.bars.barWidth[0] * minDistance;\n            }\n        }\n\n        function findNearbyItems(mouseX, mouseY, seriesFilter, radius, computeDistance) {\n            var items = findItems(mouseX, mouseY, seriesFilter, radius, computeDistance);\n            for (var i = 0; i < series.length; ++i) {\n                if (seriesFilter(i)) {\n                    executeHooks(hooks.findNearbyItems, [mouseX, mouseY, series, i, radius, computeDistance, items]);\n                }\n            }\n\n            return items.sort((a, b) => {\n                if (b.distance === undefined) {\n                    return -1;\n                } else if (a.distance === undefined && b.distance !== undefined) {\n                    return 1;\n                }\n\n                return a.distance - b.distance;\n            });\n        }\n\n        function findNearbyItem(mouseX, mouseY, seriesFilter, radius, computeDistance) {\n            var items = findNearbyItems(mouseX, mouseY, seriesFilter, radius, computeDistance);\n            return items[0] !== undefined ? items[0] : null;\n        }\n\n        // returns the data item the mouse is over/ the cursor is closest to, or null if none is found\n        function findItems(mouseX, mouseY, seriesFilter, radius, computeDistance) {\n            var i, foundItems = [],\n                items = [],\n                smallestDistance = radius * radius + 1;\n\n            for (i = series.length - 1; i >= 0; --i) {\n                if (!seriesFilter(i)) continue;\n\n                var s = series[i];\n                if (!s.datapoints) return;\n\n                var foundPoint = false;\n                if (s.lines.show || s.points.show) {\n                    var found = findNearbyPoint(s, mouseX, mouseY, radius, computeDistance);\n                    if (found) {\n                        items.push({ seriesIndex: i, dataIndex: found.dataIndex, distance: found.distance });\n                        foundPoint = true;\n                    }\n                }\n\n                if (s.bars.show && !foundPoint) { // no other point can be nearby\n                    var foundIndex = findNearbyBar(s, mouseX, mouseY);\n                    if (foundIndex >= 0) {\n                        items.push({ seriesIndex: i, dataIndex: foundIndex, distance: smallestDistance });\n                    }\n                }\n            }\n\n            for (i = 0; i < items.length; i++) {\n                var seriesIndex = items[i].seriesIndex;\n                var dataIndex = items[i].dataIndex;\n                var itemDistance = items[i].distance;\n                var ps = series[seriesIndex].datapoints.pointsize;\n\n                foundItems.push({\n                    datapoint: series[seriesIndex].datapoints.points.slice(dataIndex * ps, (dataIndex + 1) * ps),\n                    dataIndex: dataIndex,\n                    series: series[seriesIndex],\n                    seriesIndex: seriesIndex,\n                    distance: Math.sqrt(itemDistance)\n                });\n            }\n\n            return foundItems;\n        }\n\n        function findNearbyPoint (series, mouseX, mouseY, maxDistance, computeDistance) {\n            var mx = series.xaxis.c2p(mouseX),\n                my = series.yaxis.c2p(mouseY),\n                maxx = maxDistance / series.xaxis.scale,\n                maxy = maxDistance / series.yaxis.scale,\n                points = series.datapoints.points,\n                ps = series.datapoints.pointsize,\n                smallestDistance = Number.POSITIVE_INFINITY;\n\n            // with inverse transforms, we can't use the maxx/maxy\n            // optimization, sadly\n            if (series.xaxis.options.inverseTransform) {\n                maxx = Number.MAX_VALUE;\n            }\n\n            if (series.yaxis.options.inverseTransform) {\n                maxy = Number.MAX_VALUE;\n            }\n\n            var found = null;\n            for (var j = 0; j < points.length; j += ps) {\n                var x = points[j];\n                var y = points[j + 1];\n                if (x == null) {\n                    continue;\n                }\n\n                if (x - mx > maxx || x - mx < -maxx ||\n                    y - my > maxy || y - my < -maxy) {\n                    continue;\n                }\n\n                // We have to calculate distances in pixels, not in\n                // data units, because the scales of the axes may be different\n                var dx = Math.abs(series.xaxis.p2c(x) - mouseX);\n                var dy = Math.abs(series.yaxis.p2c(y) - mouseY);\n                var dist = computeDistance ? computeDistance(dx, dy) : dx * dx + dy * dy;\n\n                // use <= to ensure last point takes precedence\n                // (last generally means on top of)\n                if (dist < smallestDistance) {\n                    smallestDistance = dist;\n                    found = { dataIndex: j / ps, distance: dist };\n                }\n            }\n\n            return found;\n        }\n\n        function findNearbyBar (series, mouseX, mouseY) {\n            var barLeft, barRight,\n                barWidth = series.bars.barWidth[0] || series.bars.barWidth,\n                mx = series.xaxis.c2p(mouseX),\n                my = series.yaxis.c2p(mouseY),\n                points = series.datapoints.points,\n                ps = series.datapoints.pointsize;\n\n            switch (series.bars.align) {\n                case \"left\":\n                    barLeft = 0;\n                    break;\n                case \"right\":\n                    barLeft = -barWidth;\n                    break;\n                default:\n                    barLeft = -barWidth / 2;\n            }\n\n            barRight = barLeft + barWidth;\n\n            var fillTowards = series.bars.fillTowards || 0;\n            var defaultBottom = fillTowards > series.yaxis.min ? Math.min(series.yaxis.max, fillTowards) : series.yaxis.min;\n\n            var foundIndex = -1;\n            for (var j = 0; j < points.length; j += ps) {\n                var x = points[j], y = points[j + 1];\n                if (x == null) {\n                    continue;\n                }\n\n                var bottom = ps === 3 ? points[j + 2] : defaultBottom;\n                // for a bar graph, the cursor must be inside the bar\n                if (series.bars.horizontal\n                    ? (mx <= Math.max(bottom, x) && mx >= Math.min(bottom, x) &&\n                        my >= y + barLeft && my <= y + barRight)\n                    : (mx >= x + barLeft && mx <= x + barRight &&\n                        my >= Math.min(bottom, y) && my <= Math.max(bottom, y))) {\n                    foundIndex = j / ps;\n                }\n            }\n\n            return foundIndex;\n        }\n\n        function findNearbyInterpolationPoint(posX, posY, seriesFilter) {\n            var i, j, dist, dx, dy, ps,\n                item,\n                smallestDistance = Number.MAX_VALUE;\n\n            for (i = 0; i < series.length; ++i) {\n                if (!seriesFilter(i)) {\n                    continue;\n                }\n                var points = series[i].datapoints.points;\n                ps = series[i].datapoints.pointsize;\n\n                // if the data is coming from positive -> negative, reverse the comparison\n                const comparer = points[points.length - ps] < points[0]\n                    ? function (x1, x2) { return x1 > x2 }\n                    : function (x1, x2) { return x2 > x1 };\n\n                // do not interpolate outside the bounds of the data.\n                if (comparer(posX, points[0])) {\n                    continue;\n                }\n\n                // Find the nearest points, x-wise\n                for (j = ps; j < points.length; j += ps) {\n                    if (comparer(posX, points[j])) {\n                        break;\n                    }\n                }\n\n                // Now Interpolate\n                var y,\n                    p1x = points[j - ps],\n                    p1y = points[j - ps + 1],\n                    p2x = points[j],\n                    p2y = points[j + 1];\n\n                if ((p1x === undefined) || (p2x === undefined) ||\n                    (p1y === undefined) || (p2y === undefined)) {\n                    continue;\n                }\n\n                if (p1x === p2x) {\n                    y = p2y\n                } else {\n                    y = p1y + (p2y - p1y) * (posX - p1x) / (p2x - p1x);\n                }\n\n                posY = y;\n\n                dx = Math.abs(series[i].xaxis.p2c(p2x) - posX);\n                dy = Math.abs(series[i].yaxis.p2c(p2y) - posY);\n                dist = dx * dx + dy * dy;\n\n                if (dist < smallestDistance) {\n                    smallestDistance = dist;\n                    item = [posX, posY, i, j];\n                }\n            }\n\n            if (item) {\n                i = item[2];\n                j = item[3];\n                ps = series[i].datapoints.pointsize;\n                points = series[i].datapoints.points;\n                p1x = points[j - ps];\n                p1y = points[j - ps + 1];\n                p2x = points[j];\n                p2y = points[j + 1];\n\n                return {\n                    datapoint: [item[0], item[1]],\n                    leftPoint: [p1x, p1y],\n                    rightPoint: [p2x, p2y],\n                    seriesIndex: i\n                };\n            }\n\n            return null;\n        }\n\n        function triggerRedrawOverlay() {\n            var t = options.interaction.redrawOverlayInterval;\n            if (t === -1) { // skip event queue\n                drawOverlay();\n                return;\n            }\n\n            if (!redrawTimeout) {\n                redrawTimeout = setTimeout(function() {\n                    drawOverlay(plot);\n                }, t);\n            }\n        }\n\n        function drawOverlay(plot) {\n            redrawTimeout = null;\n\n            if (!octx) {\n                return;\n            }\n            overlay.clear();\n            executeHooks(hooks.drawOverlay, [octx, overlay]);\n            var event = new CustomEvent('onDrawingDone');\n            plot.getEventHolder().dispatchEvent(event);\n            plot.getPlaceholder().trigger('drawingdone');\n        }\n\n        function getColorOrGradient(spec, bottom, top, defaultColor) {\n            if (typeof spec === \"string\") {\n                return spec;\n            } else {\n                // assume this is a gradient spec; IE currently only\n                // supports a simple vertical gradient properly, so that's\n                // what we support too\n                var gradient = ctx.createLinearGradient(0, top, 0, bottom);\n\n                for (var i = 0, l = spec.colors.length; i < l; ++i) {\n                    var c = spec.colors[i];\n                    if (typeof c !== \"string\") {\n                        var co = $.color.parse(defaultColor);\n                        if (c.brightness != null) {\n                            co = co.scale('rgb', c.brightness);\n                        }\n\n                        if (c.opacity != null) {\n                            co.a *= c.opacity;\n                        }\n\n                        c = co.toString();\n                    }\n                    gradient.addColorStop(i / (l - 1), c);\n                }\n\n                return gradient;\n            }\n        }\n    }\n\n    // Add the plot function to the top level of the jQuery object\n\n    $.plot = function(placeholder, data, options) {\n        var plot = new Plot($(placeholder), data, options, $.plot.plugins);\n        return plot;\n    };\n\n    $.plot.version = \"3.0.0\";\n\n    $.plot.plugins = [];\n\n    // Also add the plot function as a chainable property\n    $.fn.plot = function(data, options) {\n        return this.each(function() {\n            $.plot(this, data, options);\n        });\n    };\n\n    $.plot.linearTickGenerator = defaultTickGenerator;\n    $.plot.defaultTickFormatter = defaultTickFormatter;\n    $.plot.expRepTickFormatter = expRepTickFormatter;\n})(jQuery);\n","/* Flot plugin for drawing legends.\n\n*/\n\n(function($) {\n    var defaultOptions = {\n        legend: {\n            show: false,\n            noColumns: 1,\n            labelFormatter: null, // fn: string -> string\n            container: null, // container (as jQuery object) to put legend in, null means default on top of graph\n            position: 'ne', // position of default legend container within plot\n            margin: 5, // distance from grid edge to default legend container within plot\n            sorted: null // default to no legend sorting\n        }\n    };\n\n    function insertLegend(plot, options, placeholder, legendEntries) {\n        // clear before redraw\n        if (options.legend.container != null) {\n            $(options.legend.container).html('');\n        } else {\n            placeholder.find('.legend').remove();\n        }\n\n        if (!options.legend.show) {\n            return;\n        }\n\n        // Save the legend entries in legend options\n        var entries = options.legend.legendEntries = legendEntries,\n            plotOffset = options.legend.plotOffset = plot.getPlotOffset(),\n            html = [],\n            entry, labelHtml, iconHtml,\n            j = 0,\n            i,\n            pos = \"\",\n            p = options.legend.position,\n            m = options.legend.margin,\n            shape = {\n                name: '',\n                label: '',\n                xPos: '',\n                yPos: ''\n            };\n\n        html[j++] = '<svg class=\"legendLayer\" style=\"width:inherit;height:inherit;\">';\n        html[j++] = '<rect class=\"background\" width=\"100%\" height=\"100%\"/>';\n        html[j++] = svgShapeDefs;\n\n        var left = 0;\n        var columnWidths = [];\n        var style = window.getComputedStyle(document.querySelector('body'));\n        for (i = 0; i < entries.length; ++i) {\n            let columnIndex = i % options.legend.noColumns;\n            entry = entries[i];\n            shape.label = entry.label;\n            var info = plot.getSurface().getTextInfo('', shape.label, {\n                style: style.fontStyle,\n                variant: style.fontVariant,\n                weight: style.fontWeight,\n                size: parseInt(style.fontSize),\n                lineHeight: parseInt(style.lineHeight),\n                family: style.fontFamily\n            });\n\n            var labelWidth = info.width;\n            // 36px = 1.5em + 6px margin\n            var iconWidth = 48;\n            if (columnWidths[columnIndex]) {\n                if (labelWidth > columnWidths[columnIndex]) {\n                    columnWidths[columnIndex] = labelWidth + iconWidth;\n                }\n            } else {\n                columnWidths[columnIndex] = labelWidth + iconWidth;\n            }\n        }\n\n        // Generate html for icons and labels from a list of entries\n        for (i = 0; i < entries.length; ++i) {\n            let columnIndex = i % options.legend.noColumns;\n            entry = entries[i];\n            iconHtml = '';\n            shape.label = entry.label;\n            shape.xPos = (left + 3) + 'px';\n            left += columnWidths[columnIndex];\n            if ((i + 1) % options.legend.noColumns === 0) {\n                left = 0;\n            }\n            shape.yPos = Math.floor(i / options.legend.noColumns) * 1.5 + 'em';\n            // area\n            if (entry.options.lines.show && entry.options.lines.fill) {\n                shape.name = 'area';\n                shape.fillColor = entry.color;\n                iconHtml += getEntryIconHtml(shape);\n            }\n            // bars\n            if (entry.options.bars.show) {\n                shape.name = 'bar';\n                shape.fillColor = entry.color;\n                iconHtml += getEntryIconHtml(shape);\n            }\n            // lines\n            if (entry.options.lines.show && !entry.options.lines.fill) {\n                shape.name = 'line';\n                shape.strokeColor = entry.color;\n                shape.strokeWidth = entry.options.lines.lineWidth;\n                iconHtml += getEntryIconHtml(shape);\n            }\n            // points\n            if (entry.options.points.show) {\n                shape.name = entry.options.points.symbol;\n                shape.strokeColor = entry.color;\n                shape.fillColor = entry.options.points.fillColor;\n                shape.strokeWidth = entry.options.points.lineWidth;\n                iconHtml += getEntryIconHtml(shape);\n            }\n\n            labelHtml = '<text x=\"' + shape.xPos + '\" y=\"' + shape.yPos + '\" text-anchor=\"start\"><tspan dx=\"2em\" dy=\"1.2em\">' + shape.label + '</tspan></text>'\n            html[j++] = '<g>' + iconHtml + labelHtml + '</g>';\n        }\n\n        html[j++] = '</svg>';\n        if (m[0] == null) {\n            m = [m, m];\n        }\n\n        if (p.charAt(0) === 'n') {\n            pos += 'top:' + (m[1] + plotOffset.top) + 'px;';\n        } else if (p.charAt(0) === 's') {\n            pos += 'bottom:' + (m[1] + plotOffset.bottom) + 'px;';\n        }\n\n        if (p.charAt(1) === 'e') {\n            pos += 'right:' + (m[0] + plotOffset.right) + 'px;';\n        } else if (p.charAt(1) === 'w') {\n            pos += 'left:' + (m[0] + plotOffset.left) + 'px;';\n        }\n\n        var width = 6;\n        for (i = 0; i < columnWidths.length; ++i) {\n            width += columnWidths[i];\n        }\n\n        var legendEl,\n            height = Math.ceil(entries.length / options.legend.noColumns) * 1.6;\n        if (!options.legend.container) {\n            legendEl = $('<div class=\"legend\" style=\"position:absolute;' + pos + '\">' + html.join('') + '</div>').appendTo(placeholder);\n            legendEl.css('width', width + 'px');\n            legendEl.css('height', height + 'em');\n            legendEl.css('pointerEvents', 'none');\n        } else {\n            legendEl = $(html.join('')).appendTo(options.legend.container)[0];\n            options.legend.container.style.width = width + 'px';\n            options.legend.container.style.height = height + 'em';\n        }\n    }\n\n    // Generate html for a shape\n    function getEntryIconHtml(shape) {\n        var html = '',\n            name = shape.name,\n            x = shape.xPos,\n            y = shape.yPos,\n            fill = shape.fillColor,\n            stroke = shape.strokeColor,\n            width = shape.strokeWidth;\n        switch (name) {\n            case 'circle':\n                html = '<use xlink:href=\"#circle\" class=\"legendIcon\" ' +\n                    'x=\"' + x + '\" ' +\n                    'y=\"' + y + '\" ' +\n                    'fill=\"' + fill + '\" ' +\n                    'stroke=\"' + stroke + '\" ' +\n                    'stroke-width=\"' + width + '\" ' +\n                    'width=\"1.5em\" height=\"1.5em\"' +\n                    '/>';\n                break;\n            case 'diamond':\n                html = '<use xlink:href=\"#diamond\" class=\"legendIcon\" ' +\n                    'x=\"' + x + '\" ' +\n                    'y=\"' + y + '\" ' +\n                    'fill=\"' + fill + '\" ' +\n                    'stroke=\"' + stroke + '\" ' +\n                    'stroke-width=\"' + width + '\" ' +\n                    'width=\"1.5em\" height=\"1.5em\"' +\n                    '/>';\n                break;\n            case 'cross':\n                html = '<use xlink:href=\"#cross\" class=\"legendIcon\" ' +\n                    'x=\"' + x + '\" ' +\n                    'y=\"' + y + '\" ' +\n                    // 'fill=\"' + fill + '\" ' +\n                    'stroke=\"' + stroke + '\" ' +\n                    'stroke-width=\"' + width + '\" ' +\n                    'width=\"1.5em\" height=\"1.5em\"' +\n                    '/>';\n                break;\n            case 'rectangle':\n                html = '<use xlink:href=\"#rectangle\" class=\"legendIcon\" ' +\n                    'x=\"' + x + '\" ' +\n                    'y=\"' + y + '\" ' +\n                    'fill=\"' + fill + '\" ' +\n                    'stroke=\"' + stroke + '\" ' +\n                    'stroke-width=\"' + width + '\" ' +\n                    'width=\"1.5em\" height=\"1.5em\"' +\n                    '/>';\n                break;\n            case 'plus':\n                html = '<use xlink:href=\"#plus\" class=\"legendIcon\" ' +\n                    'x=\"' + x + '\" ' +\n                    'y=\"' + y + '\" ' +\n                    // 'fill=\"' + fill + '\" ' +\n                    'stroke=\"' + stroke + '\" ' +\n                    'stroke-width=\"' + width + '\" ' +\n                    'width=\"1.5em\" height=\"1.5em\"' +\n                    '/>';\n                break;\n            case 'bar':\n                html = '<use xlink:href=\"#bars\" class=\"legendIcon\" ' +\n                    'x=\"' + x + '\" ' +\n                    'y=\"' + y + '\" ' +\n                    'fill=\"' + fill + '\" ' +\n                    // 'stroke=\"' + stroke + '\" ' +\n                    // 'stroke-width=\"' + width + '\" ' +\n                    'width=\"1.5em\" height=\"1.5em\"' +\n                    '/>';\n                break;\n            case 'area':\n                html = '<use xlink:href=\"#area\" class=\"legendIcon\" ' +\n                    'x=\"' + x + '\" ' +\n                    'y=\"' + y + '\" ' +\n                    'fill=\"' + fill + '\" ' +\n                    // 'stroke=\"' + stroke + '\" ' +\n                    // 'stroke-width=\"' + width + '\" ' +\n                    'width=\"1.5em\" height=\"1.5em\"' +\n                    '/>';\n                break;\n            case 'line':\n                html = '<use xlink:href=\"#line\" class=\"legendIcon\" ' +\n                    'x=\"' + x + '\" ' +\n                    'y=\"' + y + '\" ' +\n                    // 'fill=\"' + fill + '\" ' +\n                    'stroke=\"' + stroke + '\" ' +\n                    'stroke-width=\"' + width + '\" ' +\n                    'width=\"1.5em\" height=\"1.5em\"' +\n                    '/>';\n                break;\n            default:\n                // default is circle\n                html = '<use xlink:href=\"#circle\" class=\"legendIcon\" ' +\n                    'x=\"' + x + '\" ' +\n                    'y=\"' + y + '\" ' +\n                    'fill=\"' + fill + '\" ' +\n                    'stroke=\"' + stroke + '\" ' +\n                    'stroke-width=\"' + width + '\" ' +\n                    'width=\"1.5em\" height=\"1.5em\"' +\n                    '/>';\n        }\n\n        return html;\n    }\n\n    // Define svg symbols for shapes\n    var svgShapeDefs = '' +\n        '<defs>' +\n            '<symbol id=\"line\" fill=\"none\" viewBox=\"-5 -5 25 25\">' +\n                '<polyline points=\"0,15 5,5 10,10 15,0\"/>' +\n            '</symbol>' +\n\n            '<symbol id=\"area\" stroke-width=\"1\" viewBox=\"-5 -5 25 25\">' +\n                '<polyline points=\"0,15 5,5 10,10 15,0, 15,15, 0,15\"/>' +\n            '</symbol>' +\n\n            '<symbol id=\"bars\" stroke-width=\"1\" viewBox=\"-5 -5 25 25\">' +\n                '<polyline points=\"1.5,15.5 1.5,12.5, 4.5,12.5 4.5,15.5 6.5,15.5 6.5,3.5, 9.5,3.5 9.5,15.5 11.5,15.5 11.5,7.5 14.5,7.5 14.5,15.5 1.5,15.5\"/>' +\n            '</symbol>' +\n\n            '<symbol id=\"circle\" viewBox=\"-5 -5 25 25\">' +\n                '<circle cx=\"0\" cy=\"15\" r=\"2.5\"/>' +\n                '<circle cx=\"5\" cy=\"5\" r=\"2.5\"/>' +\n                '<circle cx=\"10\" cy=\"10\" r=\"2.5\"/>' +\n                '<circle cx=\"15\" cy=\"0\" r=\"2.5\"/>' +\n            '</symbol>' +\n\n            '<symbol id=\"rectangle\" viewBox=\"-5 -5 25 25\">' +\n                '<rect x=\"-2.1\" y=\"12.9\" width=\"4.2\" height=\"4.2\"/>' +\n                '<rect x=\"2.9\" y=\"2.9\" width=\"4.2\" height=\"4.2\"/>' +\n                '<rect x=\"7.9\" y=\"7.9\" width=\"4.2\" height=\"4.2\"/>' +\n                '<rect x=\"12.9\" y=\"-2.1\" width=\"4.2\" height=\"4.2\"/>' +\n            '</symbol>' +\n\n            '<symbol id=\"diamond\" viewBox=\"-5 -5 25 25\">' +\n                '<path d=\"M-3,15 L0,12 L3,15, L0,18 Z\"/>' +\n                '<path d=\"M2,5 L5,2 L8,5, L5,8 Z\"/>' +\n                '<path d=\"M7,10 L10,7 L13,10, L10,13 Z\"/>' +\n                '<path d=\"M12,0 L15,-3 L18,0, L15,3 Z\"/>' +\n            '</symbol>' +\n\n            '<symbol id=\"cross\" fill=\"none\" viewBox=\"-5 -5 25 25\">' +\n                '<path d=\"M-2.1,12.9 L2.1,17.1, M2.1,12.9 L-2.1,17.1 Z\"/>' +\n                '<path d=\"M2.9,2.9 L7.1,7.1 M7.1,2.9 L2.9,7.1 Z\"/>' +\n                '<path d=\"M7.9,7.9 L12.1,12.1 M12.1,7.9 L7.9,12.1 Z\"/>' +\n                '<path d=\"M12.9,-2.1 L17.1,2.1 M17.1,-2.1 L12.9,2.1 Z\"/>' +\n            '</symbol>' +\n\n            '<symbol id=\"plus\" fill=\"none\" viewBox=\"-5 -5 25 25\">' +\n                '<path d=\"M0,12 L0,18, M-3,15 L3,15 Z\"/>' +\n                '<path d=\"M5,2 L5,8 M2,5 L8,5 Z\"/>' +\n                '<path d=\"M10,7 L10,13 M7,10 L13,10 Z\"/>' +\n                '<path d=\"M15,-3 L15,3 M12,0 L18,0 Z\"/>' +\n            '</symbol>' +\n        '</defs>';\n\n    // Generate a list of legend entries in their final order\n    function getLegendEntries(series, labelFormatter, sorted) {\n        var lf = labelFormatter,\n            legendEntries = series.reduce(function(validEntries, s, i) {\n                var labelEval = (lf ? lf(s.label, s) : s.label)\n                if (s.hasOwnProperty(\"label\") ? labelEval : true) {\n                    var entry = {\n                        label: labelEval || 'Plot ' + (i + 1),\n                        color: s.color,\n                        options: {\n                            lines: s.lines,\n                            points: s.points,\n                            bars: s.bars\n                        }\n                    }\n                    validEntries.push(entry)\n                }\n                return validEntries;\n            }, []);\n\n        // Sort the legend using either the default or a custom comparator\n        if (sorted) {\n            if ($.isFunction(sorted)) {\n                legendEntries.sort(sorted);\n            } else if (sorted === 'reverse') {\n                legendEntries.reverse();\n            } else {\n                var ascending = (sorted !== 'descending');\n                legendEntries.sort(function(a, b) {\n                    return a.label === b.label\n                        ? 0\n                        : ((a.label < b.label) !== ascending ? 1 : -1 // Logical XOR\n                        );\n                });\n            }\n        }\n\n        return legendEntries;\n    }\n\n    // return false if opts1 same as opts2\n    function checkOptions(opts1, opts2) {\n        for (var prop in opts1) {\n            if (opts1.hasOwnProperty(prop)) {\n                if (opts1[prop] !== opts2[prop]) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    // Compare two lists of legend entries\n    function shouldRedraw(oldEntries, newEntries) {\n        if (!oldEntries || !newEntries) {\n            return true;\n        }\n\n        if (oldEntries.length !== newEntries.length) {\n            return true;\n        }\n        var i, newEntry, oldEntry, newOpts, oldOpts;\n        for (i = 0; i < newEntries.length; i++) {\n            newEntry = newEntries[i];\n            oldEntry = oldEntries[i];\n\n            if (newEntry.label !== oldEntry.label) {\n                return true;\n            }\n\n            if (newEntry.color !== oldEntry.color) {\n                return true;\n            }\n\n            // check for changes in lines options\n            newOpts = newEntry.options.lines;\n            oldOpts = oldEntry.options.lines;\n            if (checkOptions(newOpts, oldOpts)) {\n                return true;\n            }\n\n            // check for changes in points options\n            newOpts = newEntry.options.points;\n            oldOpts = oldEntry.options.points;\n            if (checkOptions(newOpts, oldOpts)) {\n                return true;\n            }\n\n            // check for changes in bars options\n            newOpts = newEntry.options.bars;\n            oldOpts = oldEntry.options.bars;\n            if (checkOptions(newOpts, oldOpts)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    function init(plot) {\n        plot.hooks.setupGrid.push(function (plot) {\n            var options = plot.getOptions();\n            var series = plot.getData(),\n                labelFormatter = options.legend.labelFormatter,\n                oldEntries = options.legend.legendEntries,\n                oldPlotOffset = options.legend.plotOffset,\n                newEntries = getLegendEntries(series, labelFormatter, options.legend.sorted),\n                newPlotOffset = plot.getPlotOffset();\n\n            if (shouldRedraw(oldEntries, newEntries) ||\n                checkOptions(oldPlotOffset, newPlotOffset)) {\n                insertLegend(plot, options, plot.getPlaceholder(), newEntries);\n            }\n        });\n    }\n\n    $.plot.plugins.push({\n        init: init,\n        options: defaultOptions,\n        name: 'legend',\n        version: '1.0'\n    });\n})(jQuery);\n","/* Pretty handling of log axes.\n\nCopyright (c) 2007-2014 IOLA and Ole Laursen.\nCopyright (c) 2015 Ciprian Ceteras cipix2000@gmail.com.\nCopyright (c) 2017 Raluca Portase\nLicensed under the MIT license.\n\nSet axis.mode to \"log\" to enable.\n*/\n\n/* global jQuery*/\n\n/**\n## jquery.flot.logaxis\nThis plugin is used to create logarithmic axis. This includes tick generation,\nformatters and transformers to and from logarithmic representation.\n\n### Methods and hooks\n*/\n\n(function ($) {\n    'use strict';\n\n    var options = {\n        xaxis: {}\n    };\n\n    /*tick generators and formatters*/\n    var PREFERRED_LOG_TICK_VALUES = computePreferedLogTickValues(Number.MAX_VALUE, 10),\n        EXTENDED_LOG_TICK_VALUES = computePreferedLogTickValues(Number.MAX_VALUE, 4);\n\n    function computePreferedLogTickValues(endLimit, rangeStep) {\n        var log10End = Math.floor(Math.log(endLimit) * Math.LOG10E) - 1,\n            log10Start = -log10End,\n            val, range, vals = [];\n\n        for (var power = log10Start; power <= log10End; power++) {\n            range = parseFloat('1e' + power);\n            for (var mult = 1; mult < 9; mult += rangeStep) {\n                val = range * mult;\n                vals.push(val);\n            }\n        }\n        return vals;\n    }\n\n    /**\n    - logTickGenerator(plot, axis, noTicks)\n\n    Generates logarithmic ticks, depending on axis range.\n    In case the number of ticks that can be generated is less than the expected noTicks/4,\n    a linear tick generation is used.\n    */\n    var logTickGenerator = function (plot, axis, noTicks) {\n        var ticks = [],\n            minIdx = -1,\n            maxIdx = -1,\n            surface = plot.getCanvas(),\n            logTickValues = PREFERRED_LOG_TICK_VALUES,\n            min = clampAxis(axis, plot),\n            max = axis.max;\n\n        if (!noTicks) {\n            noTicks = 0.3 * Math.sqrt(axis.direction === \"x\" ? surface.width : surface.height);\n        }\n\n        PREFERRED_LOG_TICK_VALUES.some(function (val, i) {\n            if (val >= min) {\n                minIdx = i;\n                return true;\n            } else {\n                return false;\n            }\n        });\n\n        PREFERRED_LOG_TICK_VALUES.some(function (val, i) {\n            if (val >= max) {\n                maxIdx = i;\n                return true;\n            } else {\n                return false;\n            }\n        });\n\n        if (maxIdx === -1) {\n            maxIdx = PREFERRED_LOG_TICK_VALUES.length - 1;\n        }\n\n        if (maxIdx - minIdx <= noTicks / 4 && logTickValues.length !== EXTENDED_LOG_TICK_VALUES.length) {\n            //try with multiple of 5 for tick values\n            logTickValues = EXTENDED_LOG_TICK_VALUES;\n            minIdx *= 2;\n            maxIdx *= 2;\n        }\n\n        var lastDisplayed = null,\n            inverseNoTicks = 1 / noTicks,\n            tickValue, pixelCoord, tick;\n\n        // Count the number of tick values would appear, if we can get at least\n        // nTicks / 4 accept them.\n        if (maxIdx - minIdx >= noTicks / 4) {\n            for (var idx = maxIdx; idx >= minIdx; idx--) {\n                tickValue = logTickValues[idx];\n                pixelCoord = (Math.log(tickValue) - Math.log(min)) / (Math.log(max) - Math.log(min));\n                tick = tickValue;\n\n                if (lastDisplayed === null) {\n                    lastDisplayed = {\n                        pixelCoord: pixelCoord,\n                        idealPixelCoord: pixelCoord\n                    };\n                } else {\n                    if (Math.abs(pixelCoord - lastDisplayed.pixelCoord) >= inverseNoTicks) {\n                        lastDisplayed = {\n                            pixelCoord: pixelCoord,\n                            idealPixelCoord: lastDisplayed.idealPixelCoord - inverseNoTicks\n                        };\n                    } else {\n                        tick = null;\n                    }\n                }\n\n                if (tick) {\n                    ticks.push(tick);\n                }\n            }\n            // Since we went in backwards order.\n            ticks.reverse();\n        } else {\n            var tickSize = plot.computeTickSize(min, max, noTicks),\n                customAxis = {min: min, max: max, tickSize: tickSize};\n            ticks = $.plot.linearTickGenerator(customAxis);\n        }\n\n        return ticks;\n    };\n\n    var clampAxis = function (axis, plot) {\n        var min = axis.min,\n            max = axis.max;\n\n        if (min <= 0) {\n            //for empty graph if axis.min is not strictly positive make it 0.1\n            if (axis.datamin === null) {\n                min = axis.min = 0.1;\n            } else {\n                min = processAxisOffset(plot, axis);\n            }\n\n            if (max < min) {\n                axis.max = axis.datamax !== null ? axis.datamax : axis.options.max;\n                axis.options.offset.below = 0;\n                axis.options.offset.above = 0;\n            }\n        }\n\n        return min;\n    }\n\n    /**\n    - logTickFormatter(value, axis, precision)\n\n    This is the corresponding tickFormatter of the logaxis.\n    For a number greater that 10^6 or smaller than 10^(-3), this will be drawn\n    with e representation\n    */\n    var logTickFormatter = function (value, axis, precision) {\n        var tenExponent = value > 0 ? Math.floor(Math.log(value) / Math.LN10) : 0;\n\n        if (precision) {\n            if ((tenExponent >= -4) && (tenExponent <= 7)) {\n                return $.plot.defaultTickFormatter(value, axis, precision);\n            } else {\n                return $.plot.expRepTickFormatter(value, axis, precision);\n            }\n        }\n        if ((tenExponent >= -4) && (tenExponent <= 7)) {\n            //if we have float numbers, return a limited length string(ex: 0.0009 is represented as 0.000900001)\n            var formattedValue = tenExponent < 0 ? value.toFixed(-tenExponent) : value.toFixed(tenExponent + 2);\n            if (formattedValue.indexOf('.') !== -1) {\n                var lastZero = formattedValue.lastIndexOf('0');\n\n                while (lastZero === formattedValue.length - 1) {\n                    formattedValue = formattedValue.slice(0, -1);\n                    lastZero = formattedValue.lastIndexOf('0');\n                }\n\n                //delete the dot if is last\n                if (formattedValue.indexOf('.') === formattedValue.length - 1) {\n                    formattedValue = formattedValue.slice(0, -1);\n                }\n            }\n            return formattedValue;\n        } else {\n            return $.plot.expRepTickFormatter(value, axis);\n        }\n    };\n\n    /*logaxis caracteristic functions*/\n    var logTransform = function (v) {\n        if (v < PREFERRED_LOG_TICK_VALUES[0]) {\n            v = PREFERRED_LOG_TICK_VALUES[0];\n        }\n\n        return Math.log(v);\n    };\n\n    var logInverseTransform = function (v) {\n        return Math.exp(v);\n    };\n\n    var invertedTransform = function (v) {\n        return -v;\n    }\n\n    var invertedLogTransform = function (v) {\n        return -logTransform(v);\n    }\n\n    var invertedLogInverseTransform = function (v) {\n        return logInverseTransform(-v);\n    }\n\n    /**\n    - setDataminRange(plot, axis)\n\n    It is used for clamping the starting point of a logarithmic axis.\n    This will set the axis datamin range to 0.1 or to the first datapoint greater then 0.\n    The function is usefull since the logarithmic representation can not show\n    values less than or equal to 0.\n    */\n    function setDataminRange(plot, axis) {\n        if (axis.options.mode === 'log' && axis.datamin <= 0) {\n            if (axis.datamin === null) {\n                axis.datamin = 0.1;\n            } else {\n                axis.datamin = processAxisOffset(plot, axis);\n            }\n        }\n    }\n\n    function processAxisOffset(plot, axis) {\n        var series = plot.getData(),\n            range = series\n                .filter(function(series) {\n                    return series.xaxis === axis || series.yaxis === axis;\n                })\n                .map(function(series) {\n                    return plot.computeRangeForDataSeries(series, null, isValid);\n                }),\n            min = axis.direction === 'x'\n                ? Math.min(0.1, range && range[0] ? range[0].xmin : 0.1)\n                : Math.min(0.1, range && range[0] ? range[0].ymin : 0.1);\n\n        axis.min = min;\n\n        return min;\n    }\n\n    function isValid(a) {\n        return a > 0;\n    }\n\n    function init(plot) {\n        plot.hooks.processOptions.push(function (plot) {\n            $.each(plot.getAxes(), function (axisName, axis) {\n                var opts = axis.options;\n                if (opts.mode === 'log') {\n                    axis.tickGenerator = function (axis) {\n                        var noTicks = 11;\n                        return logTickGenerator(plot, axis, noTicks);\n                    };\n                    if (typeof axis.options.tickFormatter !== 'function') {\n                        axis.options.tickFormatter = logTickFormatter;\n                    }\n                    axis.options.transform = opts.inverted ? invertedLogTransform : logTransform;\n                    axis.options.inverseTransform = opts.inverted ? invertedLogInverseTransform : logInverseTransform;\n                    axis.options.autoScaleMargin = 0;\n                    plot.hooks.setRange.push(setDataminRange);\n                } else if (opts.inverted) {\n                    axis.options.transform = invertedTransform;\n                    axis.options.inverseTransform = invertedTransform;\n                }\n            });\n        });\n    }\n\n    $.plot.plugins.push({\n        init: init,\n        options: options,\n        name: 'log',\n        version: '0.1'\n    });\n\n    $.plot.logTicksGenerator = logTickGenerator;\n    $.plot.logTickFormatter = logTickFormatter;\n})(jQuery);\n","/* Flot plugin for adding the ability to pan and zoom the plot.\n\nCopyright (c) 2007-2014 IOLA and Ole Laursen.\nCopyright (c) 2016 Ciprian Ceteras.\nCopyright (c) 2017 Raluca Portase.\nLicensed under the MIT license.\n\n*/\n\n/**\n## jquery.flot.navigate.js\n\nThis flot plugin is used for adding the ability to pan and zoom the plot.\nA higher level overview is available at [interactions](interactions.md) documentation.\n\nThe default behaviour is scrollwheel up/down to zoom in, drag\nto pan. The plugin defines plot.zoom({ center }), plot.zoomOut() and\nplot.pan( offset ) so you easily can add custom controls. It also fires\n\"plotpan\" and \"plotzoom\" events, useful for synchronizing plots.\n\nThe plugin supports these options:\n```js\n    zoom: {\n        interactive: false,\n        active: false,\n        amount: 1.5         // 2 = 200% (zoom in), 0.5 = 50% (zoom out)\n    }\n\n    pan: {\n        interactive: false,\n        active: false,\n        cursor: \"move\",     // CSS mouse cursor value used when dragging, e.g. \"pointer\"\n        frameRate: 60,\n        mode: \"smart\"       // enable smart pan mode\n    }\n\n    xaxis: {\n        axisZoom: true, //zoom axis when mouse over it is allowed\n        plotZoom: true, //zoom axis is allowed for plot zoom\n        axisPan: true, //pan axis when mouse over it is allowed\n        plotPan: true, //pan axis is allowed for plot pan\n        panRange: [undefined, undefined], // no limit on pan range, or [min, max] in axis units\n        zoomRange: [undefined, undefined], // no limit on zoom range, or [closest zoom, furthest zoom] in axis units\n    }\n\n    yaxis: {\n        axisZoom: true, //zoom axis when mouse over it is allowed\n        plotZoom: true, //zoom axis is allowed for plot zoom\n        axisPan: true, //pan axis when mouse over it is allowed\n        plotPan: true //pan axis is allowed for plot pan\n        panRange: [undefined, undefined], // no limit on pan range, or [min, max] in axis units\n        zoomRange: [undefined, undefined], // no limit on zoom range, or [closest zoom, furthest zoom] in axis units\n    }\n```\n**interactive** enables the built-in drag/click behaviour. If you enable\ninteractive for pan, then you'll have a basic plot that supports moving\naround; the same for zoom.\n\n**active** is true after a touch tap on plot. This enables plot navigation.\nOnce activated, zoom and pan cannot be deactivated. When the plot becomes active,\n\"plotactivated\" event is triggered.\n\n**amount** specifies the default amount to zoom in (so 1.5 = 150%) relative to\nthe current viewport.\n\n**cursor** is a standard CSS mouse cursor string used for visual feedback to the\nuser when dragging.\n\n**frameRate** specifies the maximum number of times per second the plot will\nupdate itself while the user is panning around on it (set to null to disable\nintermediate pans, the plot will then not update until the mouse button is\nreleased).\n\n**mode** a string specifies the pan mode for mouse interaction. Accepted values:\n'manual': no pan hint or direction snapping;\n'smart': The graph shows pan hint bar and the pan movement will snap\nto one direction when the drag direction is close to it;\n'smartLock'. The graph shows pan hint bar and the pan movement will always\nsnap to a direction that the drag diorection started with.\n\nExample API usage:\n```js\n    plot = $.plot(...);\n\n    // zoom default amount in on the pixel ( 10, 20 )\n    plot.zoom({ center: { left: 10, top: 20 } });\n\n    // zoom out again\n    plot.zoomOut({ center: { left: 10, top: 20 } });\n\n    // zoom 200% in on the pixel (10, 20)\n    plot.zoom({ amount: 2, center: { left: 10, top: 20 } });\n\n    // pan 100 pixels to the left (changing x-range in a positive way) and 20 down\n    plot.pan({ left: -100, top: 20 })\n```\n\nHere, \"center\" specifies where the center of the zooming should happen. Note\nthat this is defined in pixel space, not the space of the data points (you can\nuse the p2c helpers on the axes in Flot to help you convert between these).\n\n**amount** is the amount to zoom the viewport relative to the current range, so\n1 is 100% (i.e. no change), 1.5 is 150% (zoom in), 0.7 is 70% (zoom out). You\ncan set the default in the options.\n*/\n\n/* eslint-enable */\n(function($) {\n    'use strict';\n\n    var options = {\n        zoom: {\n            interactive: false,\n            active: false,\n            amount: 1.5 // how much to zoom relative to current position, 2 = 200% (zoom in), 0.5 = 50% (zoom out)\n        },\n        pan: {\n            interactive: false,\n            active: false,\n            cursor: \"move\",\n            frameRate: 60,\n            mode: 'smart'\n        },\n        recenter: {\n            interactive: true\n        },\n        xaxis: {\n            axisZoom: true, //zoom axis when mouse over it is allowed\n            plotZoom: true, //zoom axis is allowed for plot zoom\n            axisPan: true, //pan axis when mouse over it is allowed\n            plotPan: true, //pan axis is allowed for plot pan\n            panRange: [undefined, undefined], // no limit on pan range, or [min, max] in axis units\n            zoomRange: [undefined, undefined] // no limit on zoom range, or [closest zoom, furthest zoom] in axis units\n        },\n        yaxis: {\n            axisZoom: true,\n            plotZoom: true,\n            axisPan: true,\n            plotPan: true,\n            panRange: [undefined, undefined], // no limit on pan range, or [min, max] in axis units\n            zoomRange: [undefined, undefined] // no limit on zoom range, or [closest zoom, furthest zoom] in axis units\n        }\n    };\n\n    var saturated = $.plot.saturated;\n    var browser = $.plot.browser;\n    var SNAPPING_CONSTANT = $.plot.uiConstants.SNAPPING_CONSTANT;\n    var PANHINT_LENGTH_CONSTANT = $.plot.uiConstants.PANHINT_LENGTH_CONSTANT;\n\n    function init(plot) {\n        plot.hooks.processOptions.push(initNevigation);\n    }\n\n    function initNevigation(plot, options) {\n        var panAxes = null;\n        var canDrag = false;\n        var useManualPan = options.pan.mode === 'manual',\n            smartPanLock = options.pan.mode === 'smartLock',\n            useSmartPan = smartPanLock || options.pan.mode === 'smart';\n\n        function onZoomClick(e, zoomOut, amount) {\n            var page = browser.getPageXY(e);\n\n            var c = plot.offset();\n            c.left = page.X - c.left;\n            c.top = page.Y - c.top;\n\n            var ec = plot.getPlaceholder().offset();\n            ec.left = page.X - ec.left;\n            ec.top = page.Y - ec.top;\n\n            var axes = plot.getXAxes().concat(plot.getYAxes()).filter(function (axis) {\n                var box = axis.box;\n                if (box !== undefined) {\n                    return (ec.left > box.left) && (ec.left < box.left + box.width) &&\n                        (ec.top > box.top) && (ec.top < box.top + box.height);\n                }\n            });\n\n            if (axes.length === 0) {\n                axes = undefined;\n            }\n\n            if (zoomOut) {\n                plot.zoomOut({\n                    center: c,\n                    axes: axes,\n                    amount: amount\n                });\n            } else {\n                plot.zoom({\n                    center: c,\n                    axes: axes,\n                    amount: amount\n                });\n            }\n        }\n\n        var prevCursor = 'default',\n            panHint = null,\n            panTimeout = null,\n            plotState,\n            prevDragPosition = { x: 0, y: 0 },\n            isPanAction = false;\n\n        function onMouseWheel(e, delta) {\n            var maxAbsoluteDeltaOnMac = 1,\n                isMacScroll = Math.abs(e.originalEvent.deltaY) <= maxAbsoluteDeltaOnMac,\n                defaultNonMacScrollAmount = null,\n                macMagicRatio = 50,\n                amount = isMacScroll ? 1 + Math.abs(e.originalEvent.deltaY) / macMagicRatio : defaultNonMacScrollAmount;\n\n            if (isPanAction) {\n                onDragEnd(e);\n            }\n\n            if (plot.getOptions().zoom.active) {\n                e.preventDefault();\n                onZoomClick(e, delta < 0, amount);\n                return false;\n            }\n        }\n\n        plot.navigationState = function(startPageX, startPageY) {\n            var axes = this.getAxes();\n            var result = {};\n            Object.keys(axes).forEach(function(axisName) {\n                var axis = axes[axisName];\n                result[axisName] = {\n                    navigationOffset: { below: axis.options.offset.below || 0,\n                        above: axis.options.offset.above || 0},\n                    axisMin: axis.min,\n                    axisMax: axis.max,\n                    diagMode: false\n                }\n            });\n\n            result.startPageX = startPageX || 0;\n            result.startPageY = startPageY || 0;\n            return result;\n        }\n\n        function onMouseDown(e) {\n            canDrag = true;\n        }\n\n        function onMouseUp(e) {\n            canDrag = false;\n        }\n\n        function isLeftMouseButtonPressed(e) {\n            return e.button === 0;\n        }\n\n        function onDragStart(e) {\n            if (!canDrag || !isLeftMouseButtonPressed(e)) {\n                return false;\n            }\n\n            isPanAction = true;\n            var page = browser.getPageXY(e);\n\n            var ec = plot.getPlaceholder().offset();\n            ec.left = page.X - ec.left;\n            ec.top = page.Y - ec.top;\n\n            panAxes = plot.getXAxes().concat(plot.getYAxes()).filter(function (axis) {\n                var box = axis.box;\n                if (box !== undefined) {\n                    return (ec.left > box.left) && (ec.left < box.left + box.width) &&\n                        (ec.top > box.top) && (ec.top < box.top + box.height);\n                }\n            });\n\n            if (panAxes.length === 0) {\n                panAxes = undefined;\n            }\n\n            var c = plot.getPlaceholder().css('cursor');\n            if (c) {\n                prevCursor = c;\n            }\n\n            plot.getPlaceholder().css('cursor', plot.getOptions().pan.cursor);\n\n            if (useSmartPan) {\n                plotState = plot.navigationState(page.X, page.Y);\n            } else if (useManualPan) {\n                prevDragPosition.x = page.X;\n                prevDragPosition.y = page.Y;\n            }\n        }\n\n        function onDrag(e) {\n            if (!isPanAction) {\n                return;\n            }\n\n            var page = browser.getPageXY(e);\n            var frameRate = plot.getOptions().pan.frameRate;\n\n            if (frameRate === -1) {\n                if (useSmartPan) {\n                    plot.smartPan({\n                        x: plotState.startPageX - page.X,\n                        y: plotState.startPageY - page.Y\n                    }, plotState, panAxes, false, smartPanLock);\n                } else if (useManualPan) {\n                    plot.pan({\n                        left: prevDragPosition.x - page.X,\n                        top: prevDragPosition.y - page.Y,\n                        axes: panAxes\n                    });\n                    prevDragPosition.x = page.X;\n                    prevDragPosition.y = page.Y;\n                }\n                return;\n            }\n\n            if (panTimeout || !frameRate) return;\n\n            panTimeout = setTimeout(function() {\n                if (useSmartPan) {\n                    plot.smartPan({\n                        x: plotState.startPageX - page.X,\n                        y: plotState.startPageY - page.Y\n                    }, plotState, panAxes, false, smartPanLock);\n                } else if (useManualPan) {\n                    plot.pan({\n                        left: prevDragPosition.x - page.X,\n                        top: prevDragPosition.y - page.Y,\n                        axes: panAxes\n                    });\n                    prevDragPosition.x = page.X;\n                    prevDragPosition.y = page.Y;\n                }\n\n                panTimeout = null;\n            }, 1 / frameRate * 1000);\n        }\n\n        function onDragEnd(e) {\n            if (!isPanAction) {\n                return;\n            }\n\n            if (panTimeout) {\n                clearTimeout(panTimeout);\n                panTimeout = null;\n            }\n\n            isPanAction = false;\n            var page = browser.getPageXY(e);\n\n            plot.getPlaceholder().css('cursor', prevCursor);\n\n            if (useSmartPan) {\n                plot.smartPan({\n                    x: plotState.startPageX - page.X,\n                    y: plotState.startPageY - page.Y\n                }, plotState, panAxes, false, smartPanLock);\n                plot.smartPan.end();\n            } else if (useManualPan) {\n                plot.pan({\n                    left: prevDragPosition.x - page.X,\n                    top: prevDragPosition.y - page.Y,\n                    axes: panAxes\n                });\n                prevDragPosition.x = 0;\n                prevDragPosition.y = 0;\n            }\n        }\n\n        function onDblClick(e) {\n            plot.activate();\n            var o = plot.getOptions()\n\n            if (!o.recenter.interactive) { return; }\n\n            var axes = plot.getTouchedAxis(e.clientX, e.clientY),\n                event;\n\n            plot.recenter({ axes: axes[0] ? axes : null });\n\n            if (axes[0]) {\n                event = new $.Event('re-center', { detail: {\n                    axisTouched: axes[0]\n                }});\n            } else {\n                event = new $.Event('re-center', { detail: e });\n            }\n            plot.getPlaceholder().trigger(event);\n        }\n\n        function onClick(e) {\n            plot.activate();\n\n            if (isPanAction) {\n                onDragEnd(e);\n            }\n\n            return false;\n        }\n\n        plot.activate = function() {\n            var o = plot.getOptions();\n            if (!o.pan.active || !o.zoom.active) {\n                o.pan.active = true;\n                o.zoom.active = true;\n                plot.getPlaceholder().trigger(\"plotactivated\", [plot]);\n            }\n        }\n\n        function bindEvents(plot, eventHolder) {\n            var o = plot.getOptions();\n            if (o.zoom.interactive) {\n                eventHolder.mousewheel(onMouseWheel);\n            }\n\n            if (o.pan.interactive) {\n                plot.addEventHandler(\"dragstart\", onDragStart, eventHolder, 0);\n                plot.addEventHandler(\"drag\", onDrag, eventHolder, 0);\n                plot.addEventHandler(\"dragend\", onDragEnd, eventHolder, 0);\n                eventHolder.bind(\"mousedown\", onMouseDown);\n                eventHolder.bind(\"mouseup\", onMouseUp);\n            }\n\n            eventHolder.dblclick(onDblClick);\n            eventHolder.click(onClick);\n        }\n\n        plot.zoomOut = function(args) {\n            if (!args) {\n                args = {};\n            }\n\n            if (!args.amount) {\n                args.amount = plot.getOptions().zoom.amount;\n            }\n\n            args.amount = 1 / args.amount;\n            plot.zoom(args);\n        };\n\n        plot.zoom = function(args) {\n            if (!args) {\n                args = {};\n            }\n\n            var c = args.center,\n                amount = args.amount || plot.getOptions().zoom.amount,\n                w = plot.width(),\n                h = plot.height(),\n                axes = args.axes || plot.getAxes();\n\n            if (!c) {\n                c = {\n                    left: w / 2,\n                    top: h / 2\n                };\n            }\n\n            var xf = c.left / w,\n                yf = c.top / h,\n                minmax = {\n                    x: {\n                        min: c.left - xf * w / amount,\n                        max: c.left + (1 - xf) * w / amount\n                    },\n                    y: {\n                        min: c.top - yf * h / amount,\n                        max: c.top + (1 - yf) * h / amount\n                    }\n                };\n\n            for (var key in axes) {\n                if (!axes.hasOwnProperty(key)) {\n                    continue;\n                }\n\n                var axis = axes[key],\n                    opts = axis.options,\n                    min = minmax[axis.direction].min,\n                    max = minmax[axis.direction].max,\n                    navigationOffset = axis.options.offset;\n\n                //skip axis without axisZoom when zooming only on certain axis or axis without plotZoom for zoom on entire plot\n                if ((!opts.axisZoom && args.axes) || (!args.axes && !opts.plotZoom)) {\n                    continue;\n                }\n\n                min = $.plot.saturated.saturate(axis.c2p(min));\n                max = $.plot.saturated.saturate(axis.c2p(max));\n                if (min > max) {\n                    // make sure min < max\n                    var tmp = min;\n                    min = max;\n                    max = tmp;\n                }\n\n                // test for zoom limits zoomRange: [min,max]\n                if (opts.zoomRange) {\n                    // zoomed in too far\n                    if (max - min < opts.zoomRange[0]) {\n                        continue;\n                    }\n                    // zoomed out to far\n                    if (max - min > opts.zoomRange[1]) {\n                        continue;\n                    }\n                }\n\n                var offsetBelow = $.plot.saturated.saturate(navigationOffset.below - (axis.min - min));\n                var offsetAbove = $.plot.saturated.saturate(navigationOffset.above - (axis.max - max));\n                opts.offset = { below: offsetBelow, above: offsetAbove };\n            };\n\n            plot.setupGrid(true);\n            plot.draw();\n\n            if (!args.preventEvent) {\n                plot.getPlaceholder().trigger(\"plotzoom\", [plot, args]);\n            }\n        };\n\n        plot.pan = function(args) {\n            var delta = {\n                x: +args.left,\n                y: +args.top\n            };\n\n            if (isNaN(delta.x)) delta.x = 0;\n            if (isNaN(delta.y)) delta.y = 0;\n\n            $.each(args.axes || plot.getAxes(), function(_, axis) {\n                var opts = axis.options,\n                    d = delta[axis.direction];\n\n                //skip axis without axisPan when panning only on certain axis or axis without plotPan for pan the entire plot\n                if ((!opts.axisPan && args.axes) || (!opts.plotPan && !args.axes)) {\n                    return;\n                }\n\n                // calc min delta (revealing left edge of plot)\n                var minD = axis.p2c(opts.panRange[0]) - axis.p2c(axis.min);\n                // calc max delta (revealing right edge of plot)\n                var maxD = axis.p2c(opts.panRange[1]) - axis.p2c(axis.max);\n                // limit delta to min or max if enabled\n                if (opts.panRange[0] !== undefined && d >= maxD) d = maxD;\n                if (opts.panRange[1] !== undefined && d <= minD) d = minD;\n\n                if (d !== 0) {\n                    var navigationOffsetBelow = saturated.saturate(axis.c2p(axis.p2c(axis.min) + d) - axis.c2p(axis.p2c(axis.min))),\n                        navigationOffsetAbove = saturated.saturate(axis.c2p(axis.p2c(axis.max) + d) - axis.c2p(axis.p2c(axis.max)));\n\n                    if (!isFinite(navigationOffsetBelow)) {\n                        navigationOffsetBelow = 0;\n                    }\n\n                    if (!isFinite(navigationOffsetAbove)) {\n                        navigationOffsetAbove = 0;\n                    }\n\n                    opts.offset = {\n                        below: saturated.saturate(navigationOffsetBelow + (opts.offset.below || 0)),\n                        above: saturated.saturate(navigationOffsetAbove + (opts.offset.above || 0))\n                    };\n                }\n            });\n\n            plot.setupGrid(true);\n            plot.draw();\n            if (!args.preventEvent) {\n                plot.getPlaceholder().trigger(\"plotpan\", [plot, args]);\n            }\n        };\n\n        plot.recenter = function(args) {\n            $.each(args.axes || plot.getAxes(), function(_, axis) {\n                if (args.axes) {\n                    if (this.direction === 'x') {\n                        axis.options.offset = { below: 0 };\n                    } else if (this.direction === 'y') {\n                        axis.options.offset = { above: 0 };\n                    }\n                } else {\n                    axis.options.offset = { below: 0, above: 0 };\n                }\n            });\n            plot.setupGrid(true);\n            plot.draw();\n        };\n\n        var shouldSnap = function(delta) {\n            return (Math.abs(delta.y) < SNAPPING_CONSTANT && Math.abs(delta.x) >= SNAPPING_CONSTANT) ||\n                (Math.abs(delta.x) < SNAPPING_CONSTANT && Math.abs(delta.y) >= SNAPPING_CONSTANT);\n        }\n\n        // adjust delta so the pan action is constrained on the vertical or horizontal direction\n        // it the movements in the other direction are small\n        var adjustDeltaToSnap = function(delta) {\n            if (Math.abs(delta.x) < SNAPPING_CONSTANT && Math.abs(delta.y) >= SNAPPING_CONSTANT) {\n                return {x: 0, y: delta.y};\n            }\n\n            if (Math.abs(delta.y) < SNAPPING_CONSTANT && Math.abs(delta.x) >= SNAPPING_CONSTANT) {\n                return {x: delta.x, y: 0};\n            }\n\n            return delta;\n        }\n\n        var lockedDirection = null;\n        var lockDeltaDirection = function(delta) {\n            if (!lockedDirection && Math.max(Math.abs(delta.x), Math.abs(delta.y)) >= SNAPPING_CONSTANT) {\n                lockedDirection = Math.abs(delta.x) < Math.abs(delta.y) ? 'y' : 'x';\n            }\n\n            switch (lockedDirection) {\n                case 'x':\n                    return { x: delta.x, y: 0 };\n                case 'y':\n                    return { x: 0, y: delta.y };\n                default:\n                    return { x: 0, y: 0 };\n            }\n        }\n\n        var isDiagonalMode = function(delta) {\n            if (Math.abs(delta.x) > 0 && Math.abs(delta.y) > 0) {\n                return true;\n            }\n            return false;\n        }\n\n        var restoreAxisOffset = function(axes, initialState, delta) {\n            var axis;\n            Object.keys(axes).forEach(function(axisName) {\n                axis = axes[axisName];\n                if (delta[axis.direction] === 0) {\n                    axis.options.offset.below = initialState[axisName].navigationOffset.below;\n                    axis.options.offset.above = initialState[axisName].navigationOffset.above;\n                }\n            });\n        }\n\n        var prevDelta = { x: 0, y: 0 };\n        plot.smartPan = function(delta, initialState, panAxes, preventEvent, smartLock) {\n            var snap = smartLock ? true : shouldSnap(delta),\n                axes = plot.getAxes(),\n                opts;\n            delta = smartLock ? lockDeltaDirection(delta) : adjustDeltaToSnap(delta);\n\n            if (isDiagonalMode(delta)) {\n                initialState.diagMode = true;\n            }\n\n            if (snap && initialState.diagMode === true) {\n                initialState.diagMode = false;\n                restoreAxisOffset(axes, initialState, delta);\n            }\n\n            if (snap) {\n                panHint = {\n                    start: {\n                        x: initialState.startPageX - plot.offset().left + plot.getPlotOffset().left,\n                        y: initialState.startPageY - plot.offset().top + plot.getPlotOffset().top\n                    },\n                    end: {\n                        x: initialState.startPageX - delta.x - plot.offset().left + plot.getPlotOffset().left,\n                        y: initialState.startPageY - delta.y - plot.offset().top + plot.getPlotOffset().top\n                    }\n                }\n            } else {\n                panHint = {\n                    start: {\n                        x: initialState.startPageX - plot.offset().left + plot.getPlotOffset().left,\n                        y: initialState.startPageY - plot.offset().top + plot.getPlotOffset().top\n                    },\n                    end: false\n                }\n            }\n\n            if (isNaN(delta.x)) delta.x = 0;\n            if (isNaN(delta.y)) delta.y = 0;\n\n            if (panAxes) {\n                axes = panAxes;\n            }\n\n            var axis, axisMin, axisMax, p, d;\n            Object.keys(axes).forEach(function(axisName) {\n                axis = axes[axisName];\n                axisMin = axis.min;\n                axisMax = axis.max;\n                opts = axis.options;\n\n                d = delta[axis.direction];\n                p = prevDelta[axis.direction];\n\n                //skip axis without axisPan when panning only on certain axis or axis without plotPan for pan the entire plot\n                if ((!opts.axisPan && panAxes) || (!panAxes && !opts.plotPan)) {\n                    return;\n                }\n\n                // calc min delta (revealing left edge of plot)\n                var minD = p + axis.p2c(opts.panRange[0]) - axis.p2c(axisMin);\n                // calc max delta (revealing right edge of plot)\n                var maxD = p + axis.p2c(opts.panRange[1]) - axis.p2c(axisMax);\n                // limit delta to min or max if enabled\n                if (opts.panRange[0] !== undefined && d >= maxD) d = maxD;\n                if (opts.panRange[1] !== undefined && d <= minD) d = minD;\n\n                if (d !== 0) {\n                    var navigationOffsetBelow = saturated.saturate(axis.c2p(axis.p2c(axisMin) - (p - d)) - axis.c2p(axis.p2c(axisMin))),\n                        navigationOffsetAbove = saturated.saturate(axis.c2p(axis.p2c(axisMax) - (p - d)) - axis.c2p(axis.p2c(axisMax)));\n\n                    if (!isFinite(navigationOffsetBelow)) {\n                        navigationOffsetBelow = 0;\n                    }\n\n                    if (!isFinite(navigationOffsetAbove)) {\n                        navigationOffsetAbove = 0;\n                    }\n\n                    axis.options.offset.below = saturated.saturate(navigationOffsetBelow + (axis.options.offset.below || 0));\n                    axis.options.offset.above = saturated.saturate(navigationOffsetAbove + (axis.options.offset.above || 0));\n                }\n            });\n\n            prevDelta = delta;\n            plot.setupGrid(true);\n            plot.draw();\n\n            if (!preventEvent) {\n                plot.getPlaceholder().trigger(\"plotpan\", [plot, delta, panAxes, initialState]);\n            }\n        };\n\n        plot.smartPan.end = function() {\n            panHint = null;\n            lockedDirection = null;\n            prevDelta = { x: 0, y: 0 };\n            plot.triggerRedrawOverlay();\n        }\n\n        function shutdown(plot, eventHolder) {\n            eventHolder.unbind(\"mousewheel\", onMouseWheel);\n            eventHolder.unbind(\"mousedown\", onMouseDown);\n            eventHolder.unbind(\"mouseup\", onMouseUp);\n            eventHolder.unbind(\"dragstart\", onDragStart);\n            eventHolder.unbind(\"drag\", onDrag);\n            eventHolder.unbind(\"dragend\", onDragEnd);\n            eventHolder.unbind(\"dblclick\", onDblClick);\n            eventHolder.unbind(\"click\", onClick);\n\n            if (panTimeout) clearTimeout(panTimeout);\n        }\n\n        function drawOverlay(plot, ctx) {\n            if (panHint) {\n                ctx.strokeStyle = 'rgba(96, 160, 208, 0.7)';\n                ctx.lineWidth = 2;\n                ctx.lineJoin = \"round\";\n                var startx = Math.round(panHint.start.x),\n                    starty = Math.round(panHint.start.y),\n                    endx, endy;\n\n                if (panAxes) {\n                    if (panAxes[0].direction === 'x') {\n                        endy = Math.round(panHint.start.y);\n                        endx = Math.round(panHint.end.x);\n                    } else if (panAxes[0].direction === 'y') {\n                        endx = Math.round(panHint.start.x);\n                        endy = Math.round(panHint.end.y);\n                    }\n                } else {\n                    endx = Math.round(panHint.end.x);\n                    endy = Math.round(panHint.end.y);\n                }\n\n                ctx.beginPath();\n\n                if (panHint.end === false) {\n                    ctx.moveTo(startx, starty - PANHINT_LENGTH_CONSTANT);\n                    ctx.lineTo(startx, starty + PANHINT_LENGTH_CONSTANT);\n\n                    ctx.moveTo(startx + PANHINT_LENGTH_CONSTANT, starty);\n                    ctx.lineTo(startx - PANHINT_LENGTH_CONSTANT, starty);\n                } else {\n                    var dirX = starty === endy;\n\n                    ctx.moveTo(startx - (dirX ? 0 : PANHINT_LENGTH_CONSTANT), starty - (dirX ? PANHINT_LENGTH_CONSTANT : 0));\n                    ctx.lineTo(startx + (dirX ? 0 : PANHINT_LENGTH_CONSTANT), starty + (dirX ? PANHINT_LENGTH_CONSTANT : 0));\n\n                    ctx.moveTo(startx, starty);\n                    ctx.lineTo(endx, endy);\n\n                    ctx.moveTo(endx - (dirX ? 0 : PANHINT_LENGTH_CONSTANT), endy - (dirX ? PANHINT_LENGTH_CONSTANT : 0));\n                    ctx.lineTo(endx + (dirX ? 0 : PANHINT_LENGTH_CONSTANT), endy + (dirX ? PANHINT_LENGTH_CONSTANT : 0));\n                }\n\n                ctx.stroke();\n            }\n        }\n\n        plot.getTouchedAxis = function(touchPointX, touchPointY) {\n            var ec = plot.getPlaceholder().offset();\n            ec.left = touchPointX - ec.left;\n            ec.top = touchPointY - ec.top;\n\n            var axis = plot.getXAxes().concat(plot.getYAxes()).filter(function (axis) {\n                var box = axis.box;\n                if (box !== undefined) {\n                    return (ec.left > box.left) && (ec.left < box.left + box.width) &&\n                            (ec.top > box.top) && (ec.top < box.top + box.height);\n                }\n            });\n\n            return axis;\n        }\n\n        plot.hooks.drawOverlay.push(drawOverlay);\n        plot.hooks.bindEvents.push(bindEvents);\n        plot.hooks.shutdown.push(shutdown);\n    }\n\n    $.plot.plugins.push({\n        init: init,\n        options: options,\n        name: 'navigate',\n        version: '1.3'\n    });\n})(jQuery);\n","/* Flot plugin for rendering pie charts.\n\nCopyright (c) 2007-2014 IOLA and Ole Laursen.\nLicensed under the MIT license.\n\nThe plugin assumes that each series has a single data value, and that each\nvalue is a positive integer or zero.  Negative numbers don't make sense for a\npie chart, and have unpredictable results.  The values do NOT need to be\npassed in as percentages; the plugin will calculate the total and per-slice\npercentages internally.\n\n* Created by Brian Medendorp\n\n* Updated with contributions from btburnett3, Anthony Aragues and Xavi Ivars\n\nThe plugin supports these options:\n\n    series: {\n        pie: {\n            show: true/false\n            radius: 0-1 for percentage of fullsize, or a specified pixel length, or 'auto'\n            innerRadius: 0-1 for percentage of fullsize or a specified pixel length, for creating a donut effect\n            startAngle: 0-2 factor of PI used for starting angle (in radians) i.e 3/2 starts at the top, 0 and 2 have the same result\n            tilt: 0-1 for percentage to tilt the pie, where 1 is no tilt, and 0 is completely flat (nothing will show)\n            offset: {\n                top: integer value to move the pie up or down\n                left: integer value to move the pie left or right, or 'auto'\n            },\n            stroke: {\n                color: any hexidecimal color value (other formats may or may not work, so best to stick with something like '#FFF')\n                width: integer pixel width of the stroke\n            },\n            label: {\n                show: true/false, or 'auto'\n                formatter:  a user-defined function that modifies the text/style of the label text\n                radius: 0-1 for percentage of fullsize, or a specified pixel length\n                background: {\n                    color: any hexidecimal color value (other formats may or may not work, so best to stick with something like '#000')\n                    opacity: 0-1\n                },\n                threshold: 0-1 for the percentage value at which to hide labels (if they're too small)\n            },\n            combine: {\n                threshold: 0-1 for the percentage value at which to combine slices (if they're too small)\n                color: any hexidecimal color value (other formats may or may not work, so best to stick with something like '#CCC'), if null, the plugin will automatically use the color of the first slice to be combined\n                label: any text value of what the combined slice should be labeled\n            }\n            highlight: {\n                opacity: 0-1\n            }\n        }\n    }\n\nMore detail and specific examples can be found in the included HTML file.\n\n*/\n\n(function($) {\n    // Maximum redraw attempts when fitting labels within the plot\n\n    var REDRAW_ATTEMPTS = 10;\n\n    // Factor by which to shrink the pie when fitting labels within the plot\n\n    var REDRAW_SHRINK = 0.95;\n\n    function init(plot) {\n        var canvas = null,\n            target = null,\n            options = null,\n            maxRadius = null,\n            centerLeft = null,\n            centerTop = null,\n            processed = false,\n            ctx = null;\n\n        // interactive variables\n\n        var highlights = [];\n\n        // add hook to determine if pie plugin in enabled, and then perform necessary operations\n\n        plot.hooks.processOptions.push(function(plot, options) {\n            if (options.series.pie.show) {\n                options.grid.show = false;\n\n                // set labels.show\n\n                if (options.series.pie.label.show === \"auto\") {\n                    if (options.legend.show) {\n                        options.series.pie.label.show = false;\n                    } else {\n                        options.series.pie.label.show = true;\n                    }\n                }\n\n                // set radius\n\n                if (options.series.pie.radius === \"auto\") {\n                    if (options.series.pie.label.show) {\n                        options.series.pie.radius = 3 / 4;\n                    } else {\n                        options.series.pie.radius = 1;\n                    }\n                }\n\n                // ensure sane tilt\n\n                if (options.series.pie.tilt > 1) {\n                    options.series.pie.tilt = 1;\n                } else if (options.series.pie.tilt < 0) {\n                    options.series.pie.tilt = 0;\n                }\n            }\n        });\n\n        plot.hooks.bindEvents.push(function(plot, eventHolder) {\n            var options = plot.getOptions();\n            if (options.series.pie.show) {\n                if (options.grid.hoverable) {\n                    eventHolder.unbind(\"mousemove\").mousemove(onMouseMove);\n                    eventHolder.bind(\"mouseleave\", onMouseMove);\n                }\n                if (options.grid.clickable) {\n                    eventHolder.unbind(\"click\").click(onClick);\n                }\n            }\n        });\n\n        plot.hooks.shutdown.push(function (plot, eventHolder) {\n            eventHolder.unbind(\"mousemove\", onMouseMove);\n            eventHolder.unbind(\"mouseleave\", onMouseMove);\n            eventHolder.unbind(\"click\", onClick);\n            highlights = [];\n        });\n\n        plot.hooks.processDatapoints.push(function(plot, series, data, datapoints) {\n            var options = plot.getOptions();\n            if (options.series.pie.show) {\n                processDatapoints(plot, series, data, datapoints);\n            }\n        });\n\n        plot.hooks.drawOverlay.push(function(plot, octx) {\n            var options = plot.getOptions();\n            if (options.series.pie.show) {\n                drawOverlay(plot, octx);\n            }\n        });\n\n        plot.hooks.draw.push(function(plot, newCtx) {\n            var options = plot.getOptions();\n            if (options.series.pie.show) {\n                draw(plot, newCtx);\n            }\n        });\n\n        function processDatapoints(plot, series, datapoints) {\n            if (!processed) {\n                processed = true;\n                canvas = plot.getCanvas();\n                target = $(canvas).parent();\n                options = plot.getOptions();\n                plot.setData(combine(plot.getData()));\n            }\n        }\n\n        function combine(data) {\n            var total = 0,\n                combined = 0,\n                numCombined = 0,\n                color = options.series.pie.combine.color,\n                newdata = [],\n                i,\n                value;\n\n            // Fix up the raw data from Flot, ensuring the data is numeric\n\n            for (i = 0; i < data.length; ++i) {\n                value = data[i].data;\n\n                // If the data is an array, we'll assume that it's a standard\n                // Flot x-y pair, and are concerned only with the second value.\n\n                // Note how we use the original array, rather than creating a\n                // new one; this is more efficient and preserves any extra data\n                // that the user may have stored in higher indexes.\n\n                if ($.isArray(value) && value.length === 1) {\n                    value = value[0];\n                }\n\n                if ($.isArray(value)) {\n                    // Equivalent to $.isNumeric() but compatible with jQuery < 1.7\n                    if (!isNaN(parseFloat(value[1])) && isFinite(value[1])) {\n                        value[1] = +value[1];\n                    } else {\n                        value[1] = 0;\n                    }\n                } else if (!isNaN(parseFloat(value)) && isFinite(value)) {\n                    value = [1, +value];\n                } else {\n                    value = [1, 0];\n                }\n\n                data[i].data = [value];\n            }\n\n            // Sum up all the slices, so we can calculate percentages for each\n\n            for (i = 0; i < data.length; ++i) {\n                total += data[i].data[0][1];\n            }\n\n            // Count the number of slices with percentages below the combine\n            // threshold; if it turns out to be just one, we won't combine.\n\n            for (i = 0; i < data.length; ++i) {\n                value = data[i].data[0][1];\n                if (value / total <= options.series.pie.combine.threshold) {\n                    combined += value;\n                    numCombined++;\n                    if (!color) {\n                        color = data[i].color;\n                    }\n                }\n            }\n\n            for (i = 0; i < data.length; ++i) {\n                value = data[i].data[0][1];\n                if (numCombined < 2 || value / total > options.series.pie.combine.threshold) {\n                    newdata.push(\n                        $.extend(data[i], {     /* extend to allow keeping all other original data values\n                                                   and using them e.g. in labelFormatter. */\n                            data: [[1, value]],\n                            color: data[i].color,\n                            label: data[i].label,\n                            angle: value * Math.PI * 2 / total,\n                            percent: value / (total / 100)\n                        })\n                    );\n                }\n            }\n\n            if (numCombined > 1) {\n                newdata.push({\n                    data: [[1, combined]],\n                    color: color,\n                    label: options.series.pie.combine.label,\n                    angle: combined * Math.PI * 2 / total,\n                    percent: combined / (total / 100)\n                });\n            }\n\n            return newdata;\n        }\n\n        function draw(plot, newCtx) {\n            if (!target) {\n                return; // if no series were passed\n            }\n\n            var canvasWidth = plot.getPlaceholder().width(),\n                canvasHeight = plot.getPlaceholder().height(),\n                legendWidth = target.children().filter(\".legend\").children().width() || 0;\n\n            ctx = newCtx;\n\n            // WARNING: HACK! REWRITE THIS CODE AS SOON AS POSSIBLE!\n\n            // When combining smaller slices into an 'other' slice, we need to\n            // add a new series.  Since Flot gives plugins no way to modify the\n            // list of series, the pie plugin uses a hack where the first call\n            // to processDatapoints results in a call to setData with the new\n            // list of series, then subsequent processDatapoints do nothing.\n\n            // The plugin-global 'processed' flag is used to control this hack;\n            // it starts out false, and is set to true after the first call to\n            // processDatapoints.\n\n            // Unfortunately this turns future setData calls into no-ops; they\n            // call processDatapoints, the flag is true, and nothing happens.\n\n            // To fix this we'll set the flag back to false here in draw, when\n            // all series have been processed, so the next sequence of calls to\n            // processDatapoints once again starts out with a slice-combine.\n            // This is really a hack; in 0.9 we need to give plugins a proper\n            // way to modify series before any processing begins.\n\n            processed = false;\n\n            // calculate maximum radius and center point\n            maxRadius = Math.min(canvasWidth, canvasHeight / options.series.pie.tilt) / 2;\n            centerTop = canvasHeight / 2 + options.series.pie.offset.top;\n            centerLeft = canvasWidth / 2;\n\n            if (options.series.pie.offset.left === \"auto\") {\n                if (options.legend.position.match(\"w\")) {\n                    centerLeft += legendWidth / 2;\n                } else {\n                    centerLeft -= legendWidth / 2;\n                }\n                if (centerLeft < maxRadius) {\n                    centerLeft = maxRadius;\n                } else if (centerLeft > canvasWidth - maxRadius) {\n                    centerLeft = canvasWidth - maxRadius;\n                }\n            } else {\n                centerLeft += options.series.pie.offset.left;\n            }\n\n            var slices = plot.getData(),\n                attempts = 0;\n\n            // Keep shrinking the pie's radius until drawPie returns true,\n            // indicating that all the labels fit, or we try too many times.\n            do {\n                if (attempts > 0) {\n                    maxRadius *= REDRAW_SHRINK;\n                }\n                attempts += 1;\n                clear();\n                if (options.series.pie.tilt <= 0.8) {\n                    drawShadow();\n                }\n            } while (!drawPie() && attempts < REDRAW_ATTEMPTS)\n\n            if (attempts >= REDRAW_ATTEMPTS) {\n                clear();\n                target.prepend(\"<div class='error'>Could not draw pie with labels contained inside canvas</div>\");\n            }\n\n            if (plot.setSeries && plot.insertLegend) {\n                plot.setSeries(slices);\n                plot.insertLegend();\n            }\n\n            // we're actually done at this point, just defining internal functions at this point\n            function clear() {\n                ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n                target.children().filter(\".pieLabel, .pieLabelBackground\").remove();\n            }\n\n            function drawShadow() {\n                var shadowLeft = options.series.pie.shadow.left;\n                var shadowTop = options.series.pie.shadow.top;\n                var edge = 10;\n                var alpha = options.series.pie.shadow.alpha;\n                var radius = options.series.pie.radius > 1 ? options.series.pie.radius : maxRadius * options.series.pie.radius;\n\n                if (radius >= canvasWidth / 2 - shadowLeft || radius * options.series.pie.tilt >= canvasHeight / 2 - shadowTop || radius <= edge) {\n                    return;    // shadow would be outside canvas, so don't draw it\n                }\n\n                ctx.save();\n                ctx.translate(shadowLeft, shadowTop);\n                ctx.globalAlpha = alpha;\n                ctx.fillStyle = \"#000\";\n\n                // center and rotate to starting position\n                ctx.translate(centerLeft, centerTop);\n                ctx.scale(1, options.series.pie.tilt);\n\n                //radius -= edge;\n                for (var i = 1; i <= edge; i++) {\n                    ctx.beginPath();\n                    ctx.arc(0, 0, radius, 0, Math.PI * 2, false);\n                    ctx.fill();\n                    radius -= i;\n                }\n\n                ctx.restore();\n            }\n\n            function drawPie() {\n                var startAngle = Math.PI * options.series.pie.startAngle;\n                var radius = options.series.pie.radius > 1 ? options.series.pie.radius : maxRadius * options.series.pie.radius;\n                var i;\n                // center and rotate to starting position\n\n                ctx.save();\n                ctx.translate(centerLeft, centerTop);\n                ctx.scale(1, options.series.pie.tilt);\n                //ctx.rotate(startAngle); // start at top; -- This doesn't work properly in Opera\n\n                // draw slices\n                ctx.save();\n\n                var currentAngle = startAngle;\n                for (i = 0; i < slices.length; ++i) {\n                    slices[i].startAngle = currentAngle;\n                    drawSlice(slices[i].angle, slices[i].color, true);\n                }\n\n                ctx.restore();\n\n                // draw slice outlines\n                if (options.series.pie.stroke.width > 0) {\n                    ctx.save();\n                    ctx.lineWidth = options.series.pie.stroke.width;\n                    currentAngle = startAngle;\n                    for (i = 0; i < slices.length; ++i) {\n                        drawSlice(slices[i].angle, options.series.pie.stroke.color, false);\n                    }\n\n                    ctx.restore();\n                }\n\n                // draw donut hole\n                drawDonutHole(ctx);\n\n                ctx.restore();\n\n                // Draw the labels, returning true if they fit within the plot\n                if (options.series.pie.label.show) {\n                    return drawLabels();\n                } else return true;\n\n                function drawSlice(angle, color, fill) {\n                    if (angle <= 0 || isNaN(angle)) {\n                        return;\n                    }\n\n                    if (fill) {\n                        ctx.fillStyle = color;\n                    } else {\n                        ctx.strokeStyle = color;\n                        ctx.lineJoin = \"round\";\n                    }\n\n                    ctx.beginPath();\n                    if (Math.abs(angle - Math.PI * 2) > 0.000000001) {\n                        ctx.moveTo(0, 0); // Center of the pie\n                    }\n\n                    //ctx.arc(0, 0, radius, 0, angle, false); // This doesn't work properly in Opera\n                    ctx.arc(0, 0, radius, currentAngle, currentAngle + angle / 2, false);\n                    ctx.arc(0, 0, radius, currentAngle + angle / 2, currentAngle + angle, false);\n                    ctx.closePath();\n                    //ctx.rotate(angle); // This doesn't work properly in Opera\n                    currentAngle += angle;\n\n                    if (fill) {\n                        ctx.fill();\n                    } else {\n                        ctx.stroke();\n                    }\n                }\n\n                function drawLabels() {\n                    var currentAngle = startAngle;\n                    var radius = options.series.pie.label.radius > 1 ? options.series.pie.label.radius : maxRadius * options.series.pie.label.radius;\n\n                    for (var i = 0; i < slices.length; ++i) {\n                        if (slices[i].percent >= options.series.pie.label.threshold * 100) {\n                            if (!drawLabel(slices[i], currentAngle, i)) {\n                                return false;\n                            }\n                        }\n                        currentAngle += slices[i].angle;\n                    }\n\n                    return true;\n\n                    function drawLabel(slice, startAngle, index) {\n                        if (slice.data[0][1] === 0) {\n                            return true;\n                        }\n\n                        // format label text\n                        var lf = options.legend.labelFormatter, text, plf = options.series.pie.label.formatter;\n\n                        if (lf) {\n                            text = lf(slice.label, slice);\n                        } else {\n                            text = slice.label;\n                        }\n\n                        if (plf) {\n                            text = plf(text, slice);\n                        }\n\n                        var halfAngle = ((startAngle + slice.angle) + startAngle) / 2;\n                        var x = centerLeft + Math.round(Math.cos(halfAngle) * radius);\n                        var y = centerTop + Math.round(Math.sin(halfAngle) * radius) * options.series.pie.tilt;\n\n                        var html = \"<span class='pieLabel' id='pieLabel\" + index + \"' style='position:absolute;top:\" + y + \"px;left:\" + x + \"px;'>\" + text + \"</span>\";\n                        target.append(html);\n\n                        var label = target.children(\"#pieLabel\" + index);\n                        var labelTop = (y - label.height() / 2);\n                        var labelLeft = (x - label.width() / 2);\n\n                        label.css(\"top\", labelTop);\n                        label.css(\"left\", labelLeft);\n\n                        // check to make sure that the label is not outside the canvas\n                        if (0 - labelTop > 0 || 0 - labelLeft > 0 || canvasHeight - (labelTop + label.height()) < 0 || canvasWidth - (labelLeft + label.width()) < 0) {\n                            return false;\n                        }\n\n                        if (options.series.pie.label.background.opacity !== 0) {\n                            // put in the transparent background separately to avoid blended labels and label boxes\n                            var c = options.series.pie.label.background.color;\n                            if (c == null) {\n                                c = slice.color;\n                            }\n\n                            var pos = \"top:\" + labelTop + \"px;left:\" + labelLeft + \"px;\";\n                            $(\"<div class='pieLabelBackground' style='position:absolute;width:\" + label.width() + \"px;height:\" + label.height() + \"px;\" + pos + \"background-color:\" + c + \";'></div>\")\n                                .css(\"opacity\", options.series.pie.label.background.opacity)\n                                .insertBefore(label);\n                        }\n\n                        return true;\n                    } // end individual label function\n                } // end drawLabels function\n            } // end drawPie function\n        } // end draw function\n\n        // Placed here because it needs to be accessed from multiple locations\n\n        function drawDonutHole(layer) {\n            if (options.series.pie.innerRadius > 0) {\n                // subtract the center\n                layer.save();\n                var innerRadius = options.series.pie.innerRadius > 1 ? options.series.pie.innerRadius : maxRadius * options.series.pie.innerRadius;\n                layer.globalCompositeOperation = \"destination-out\"; // this does not work with excanvas, but it will fall back to using the stroke color\n                layer.beginPath();\n                layer.fillStyle = options.series.pie.stroke.color;\n                layer.arc(0, 0, innerRadius, 0, Math.PI * 2, false);\n                layer.fill();\n                layer.closePath();\n                layer.restore();\n\n                // add inner stroke\n                layer.save();\n                layer.beginPath();\n                layer.strokeStyle = options.series.pie.stroke.color;\n                layer.arc(0, 0, innerRadius, 0, Math.PI * 2, false);\n                layer.stroke();\n                layer.closePath();\n                layer.restore();\n\n                // TODO: add extra shadow inside hole (with a mask) if the pie is tilted.\n            }\n        }\n\n        //-- Additional Interactive related functions --\n\n        function isPointInPoly(poly, pt) {\n            for (var c = false, i = -1, l = poly.length, j = l - 1; ++i < l; j = i) {\n                ((poly[i][1] <= pt[1] && pt[1] < poly[j][1]) ||\n                (poly[j][1] <= pt[1] && pt[1] < poly[i][1])) &&\n                (pt[0] < (poly[j][0] - poly[i][0]) * (pt[1] - poly[i][1]) / (poly[j][1] - poly[i][1]) + poly[i][0]) &&\n                (c = !c);\n            }\n            return c;\n        }\n\n        function findNearbySlice(mouseX, mouseY) {\n            var slices = plot.getData(),\n                options = plot.getOptions(),\n                radius = options.series.pie.radius > 1 ? options.series.pie.radius : maxRadius * options.series.pie.radius,\n                x, y;\n\n            for (var i = 0; i < slices.length; ++i) {\n                var s = slices[i];\n                if (s.pie.show) {\n                    ctx.save();\n                    ctx.beginPath();\n                    ctx.moveTo(0, 0); // Center of the pie\n                    //ctx.scale(1, options.series.pie.tilt);    // this actually seems to break everything when here.\n                    ctx.arc(0, 0, radius, s.startAngle, s.startAngle + s.angle / 2, false);\n                    ctx.arc(0, 0, radius, s.startAngle + s.angle / 2, s.startAngle + s.angle, false);\n                    ctx.closePath();\n                    x = mouseX - centerLeft;\n                    y = mouseY - centerTop;\n\n                    if (ctx.isPointInPath) {\n                        if (ctx.isPointInPath(mouseX - centerLeft, mouseY - centerTop)) {\n                            ctx.restore();\n                            return {\n                                datapoint: [s.percent, s.data],\n                                dataIndex: 0,\n                                series: s,\n                                seriesIndex: i\n                            };\n                        }\n                    } else {\n                        // excanvas for IE doesn;t support isPointInPath, this is a workaround.\n                        var p1X = radius * Math.cos(s.startAngle),\n                            p1Y = radius * Math.sin(s.startAngle),\n                            p2X = radius * Math.cos(s.startAngle + s.angle / 4),\n                            p2Y = radius * Math.sin(s.startAngle + s.angle / 4),\n                            p3X = radius * Math.cos(s.startAngle + s.angle / 2),\n                            p3Y = radius * Math.sin(s.startAngle + s.angle / 2),\n                            p4X = radius * Math.cos(s.startAngle + s.angle / 1.5),\n                            p4Y = radius * Math.sin(s.startAngle + s.angle / 1.5),\n                            p5X = radius * Math.cos(s.startAngle + s.angle),\n                            p5Y = radius * Math.sin(s.startAngle + s.angle),\n                            arrPoly = [[0, 0], [p1X, p1Y], [p2X, p2Y], [p3X, p3Y], [p4X, p4Y], [p5X, p5Y]],\n                            arrPoint = [x, y];\n\n                        // TODO: perhaps do some mathmatical trickery here with the Y-coordinate to compensate for pie tilt?\n\n                        if (isPointInPoly(arrPoly, arrPoint)) {\n                            ctx.restore();\n                            return {\n                                datapoint: [s.percent, s.data],\n                                dataIndex: 0,\n                                series: s,\n                                seriesIndex: i\n                            };\n                        }\n                    }\n\n                    ctx.restore();\n                }\n            }\n\n            return null;\n        }\n\n        function onMouseMove(e) {\n            triggerClickHoverEvent(\"plothover\", e);\n        }\n\n        function onClick(e) {\n            triggerClickHoverEvent(\"plotclick\", e);\n        }\n\n        // trigger click or hover event (they send the same parameters so we share their code)\n\n        function triggerClickHoverEvent(eventname, e) {\n            var offset = plot.offset();\n            var canvasX = parseInt(e.pageX - offset.left);\n            var canvasY = parseInt(e.pageY - offset.top);\n            var item = findNearbySlice(canvasX, canvasY);\n\n            if (options.grid.autoHighlight) {\n                // clear auto-highlights\n                for (var i = 0; i < highlights.length; ++i) {\n                    var h = highlights[i];\n                    if (h.auto === eventname && !(item && h.series === item.series)) {\n                        unhighlight(h.series);\n                    }\n                }\n            }\n\n            // highlight the slice\n\n            if (item) {\n                highlight(item.series, eventname);\n            }\n\n            // trigger any hover bind events\n\n            var pos = { pageX: e.pageX, pageY: e.pageY };\n            target.trigger(eventname, [pos, item]);\n        }\n\n        function highlight(s, auto) {\n            //if (typeof s == \"number\") {\n            //    s = series[s];\n            //}\n\n            var i = indexOfHighlight(s);\n\n            if (i === -1) {\n                highlights.push({ series: s, auto: auto });\n                plot.triggerRedrawOverlay();\n            } else if (!auto) {\n                highlights[i].auto = false;\n            }\n        }\n\n        function unhighlight(s) {\n            if (s == null) {\n                highlights = [];\n                plot.triggerRedrawOverlay();\n            }\n\n            //if (typeof s == \"number\") {\n            //    s = series[s];\n            //}\n\n            var i = indexOfHighlight(s);\n\n            if (i !== -1) {\n                highlights.splice(i, 1);\n                plot.triggerRedrawOverlay();\n            }\n        }\n\n        function indexOfHighlight(s) {\n            for (var i = 0; i < highlights.length; ++i) {\n                var h = highlights[i];\n                if (h.series === s) {\n                    return i;\n                }\n            }\n            return -1;\n        }\n\n        function drawOverlay(plot, octx) {\n            var options = plot.getOptions();\n            var radius = options.series.pie.radius > 1 ? options.series.pie.radius : maxRadius * options.series.pie.radius;\n\n            octx.save();\n            octx.translate(centerLeft, centerTop);\n            octx.scale(1, options.series.pie.tilt);\n\n            for (var i = 0; i < highlights.length; ++i) {\n                drawHighlight(highlights[i].series);\n            }\n\n            drawDonutHole(octx);\n\n            octx.restore();\n\n            function drawHighlight(series) {\n                if (series.angle <= 0 || isNaN(series.angle)) {\n                    return;\n                }\n\n                //octx.fillStyle = parseColor(options.series.pie.highlight.color).scale(null, null, null, options.series.pie.highlight.opacity).toString();\n                octx.fillStyle = \"rgba(255, 255, 255, \" + options.series.pie.highlight.opacity + \")\"; // this is temporary until we have access to parseColor\n                octx.beginPath();\n                if (Math.abs(series.angle - Math.PI * 2) > 0.000000001) {\n                    octx.moveTo(0, 0); // Center of the pie\n                }\n                octx.arc(0, 0, radius, series.startAngle, series.startAngle + series.angle / 2, false);\n                octx.arc(0, 0, radius, series.startAngle + series.angle / 2, series.startAngle + series.angle, false);\n                octx.closePath();\n                octx.fill();\n            }\n        }\n    } // end init (plugin body)\n\n    // define pie specific options and their default values\n    var options = {\n        series: {\n            pie: {\n                show: false,\n                radius: \"auto\",    // actual radius of the visible pie (based on full calculated radius if <=1, or hard pixel value)\n                innerRadius: 0, /* for donut */\n                startAngle: 3 / 2,\n                tilt: 1,\n                shadow: {\n                    left: 5,    // shadow left offset\n                    top: 15,    // shadow top offset\n                    alpha: 0.02    // shadow alpha\n                },\n                offset: {\n                    top: 0,\n                    left: \"auto\"\n                },\n                stroke: {\n                    color: \"#fff\",\n                    width: 1\n                },\n                label: {\n                    show: \"auto\",\n                    formatter: function(label, slice) {\n                        return \"<div style='font-size:x-small;text-align:center;padding:2px;color:\" + slice.color + \";'>\" + label + \"<br/>\" + Math.round(slice.percent) + \"%</div>\";\n                    },    // formatter function\n                    radius: 1,    // radius at which to place the labels (based on full calculated radius if <=1, or hard pixel value)\n                    background: {\n                        color: null,\n                        opacity: 0\n                    },\n                    threshold: 0    // percentage at which to hide the label (i.e. the slice is too narrow)\n                },\n                combine: {\n                    threshold: -1,    // percentage at which to combine little slices into one larger slice\n                    color: null,    // color to give the new slice (auto-generated if null)\n                    label: \"Other\"    // label to give the new slice\n                },\n                highlight: {\n                    //color: \"#fff\",        // will add this functionality once parseColor is available\n                    opacity: 0.5\n                }\n            }\n        }\n    };\n\n    $.plot.plugins.push({\n        init: init,\n        options: options,\n        name: \"pie\",\n        version: \"1.1\"\n    });\n})(jQuery);\n","/* eslint-disable */\n/* Flot plugin for automatically redrawing plots as the placeholder resizes.\n\nCopyright (c) 2007-2014 IOLA and Ole Laursen.\nLicensed under the MIT license.\n\nIt works by listening for changes on the placeholder div (through the jQuery\nresize event plugin) - if the size changes, it will redraw the plot.\n\nThere are no options. If you need to disable the plugin for some plots, you\ncan just fix the size of their placeholders.\n\n*/\n\n/* Inline dependency:\n * jQuery resize event - v1.1 - 3/14/2010\n * http://benalman.com/projects/jquery-resize-plugin/\n *\n * Copyright (c) 2010 \"Cowboy\" Ben Alman\n * Dual licensed under the MIT and GPL licenses.\n * http://benalman.com/about/license/\n */\n(function($,e,t){\"$:nomunge\";var i=[],n=$.resize=$.extend($.resize,{}),a,r=false,s=\"setTimeout\",u=\"resize\",m=u+\"-special-event\",o=\"pendingDelay\",l=\"activeDelay\",f=\"throttleWindow\";n[o]=200;n[l]=20;n[f]=true;$.event.special[u]={setup:function(){if(!n[f]&&this[s]){return false}var e=$(this);i.push(this);e.data(m,{w:e.width(),h:e.height()});if(i.length===1){a=t;h()}},teardown:function(){if(!n[f]&&this[s]){return false}var e=$(this);for(var t=i.length-1;t>=0;t--){if(i[t]==this){i.splice(t,1);break}}e.removeData(m);if(!i.length){if(r){cancelAnimationFrame(a)}else{clearTimeout(a)}a=null}},add:function(e){if(!n[f]&&this[s]){return false}var i;function a(e,n,a){var r=$(this),s=r.data(m)||{};s.w=n!==t?n:r.width();s.h=a!==t?a:r.height();i.apply(this,arguments)}if($.isFunction(e)){i=e;return a}else{i=e.handler;e.handler=a}}};function h(t){if(r===true){r=t||1}for(var s=i.length-1;s>=0;s--){var l=$(i[s]);if(l[0]==e||l.is(\":visible\")){var f=l.width(),c=l.height(),d=l.data(m);if(d&&(f!==d.w||c!==d.h)){l.trigger(u,[d.w=f,d.h=c]);r=t||true}}else{d=l.data(m);d.w=0;d.h=0}}if(a!==null){if(r&&(t==null||t-r<1e3)){a=e.requestAnimationFrame(h)}else{a=setTimeout(h,n[o]);r=false}}}if(!e.requestAnimationFrame){e.requestAnimationFrame=function(){return e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(t,i){return e.setTimeout(function(){t((new Date).getTime())},n[l])}}()}if(!e.cancelAnimationFrame){e.cancelAnimationFrame=function(){return e.webkitCancelRequestAnimationFrame||e.mozCancelRequestAnimationFrame||e.oCancelRequestAnimationFrame||e.msCancelRequestAnimationFrame||clearTimeout}()}})(jQuery,window);\n\n/* eslint-enable */\n(function ($) {\n    var options = { }; // no options\n\n    function init(plot) {\n        function onResize() {\n            var placeholder = plot.getPlaceholder();\n\n            // somebody might have hidden us and we can't plot\n            // when we don't have the dimensions\n            if (placeholder.width() === 0 || placeholder.height() === 0) return;\n\n            plot.resize();\n            plot.setupGrid();\n            plot.draw();\n        }\n\n        function bindEvents(plot, eventHolder) {\n            plot.getPlaceholder().resize(onResize);\n        }\n\n        function shutdown(plot, eventHolder) {\n            plot.getPlaceholder().unbind(\"resize\", onResize);\n        }\n\n        plot.hooks.bindEvents.push(bindEvents);\n        plot.hooks.shutdown.push(shutdown);\n    }\n\n    $.plot.plugins.push({\n        init: init,\n        options: options,\n        name: 'resize',\n        version: '1.0'\n    });\n})(jQuery);\n","(function ($) {\n    'use strict';\n    var saturated = {\n        saturate: function (a) {\n            if (a === Infinity) {\n                return Number.MAX_VALUE;\n            }\n\n            if (a === -Infinity) {\n                return -Number.MAX_VALUE;\n            }\n\n            return a;\n        },\n        delta: function(min, max, noTicks) {\n            return ((max - min) / noTicks) === Infinity ? (max / noTicks - min / noTicks) : (max - min) / noTicks\n        },\n        multiply: function (a, b) {\n            return saturated.saturate(a * b);\n        },\n        // returns c * bInt * a. Beahves properly in the case where c is negative\n        // and bInt * a is bigger that Number.MAX_VALUE (Infinity)\n        multiplyAdd: function (a, bInt, c) {\n            if (isFinite(a * bInt)) {\n                return saturated.saturate(a * bInt + c);\n            } else {\n                var result = c;\n\n                for (var i = 0; i < bInt; i++) {\n                    result += a;\n                }\n\n                return saturated.saturate(result);\n            }\n        },\n        // round to nearby lower multiple of base\n        floorInBase: function(n, base) {\n            return base * Math.floor(n / base);\n        }\n    };\n\n    $.plot.saturated = saturated;\n})(jQuery);\n","/* Flot plugin for selecting regions of a plot.\n\nCopyright (c) 2007-2014 IOLA and Ole Laursen.\nLicensed under the MIT license.\n\nThe plugin supports these options:\n\nselection: {\n    mode: null or \"x\" or \"y\" or \"xy\" or \"smart\",\n    color: color,\n    shape: \"round\" or \"miter\" or \"bevel\",\n    visualization: \"fill\" or \"focus\",\n    displaySelectionDecorations: true or false,\n    minSize: number of pixels\n}\n\nSelection support is enabled by setting the mode to one of \"x\", \"y\" or \"xy\".\nIn \"x\" mode, the user will only be able to specify the x range, similarly for\n\"y\" mode. For \"xy\", the selection becomes a rectangle where both ranges can be\nspecified. \"color\" is color of the selection (if you need to change the color\nlater on, you can get to it with plot.getOptions().selection.color). \"shape\"\nis the shape of the corners of the selection.\n\nThe way how the selection is visualized, can be changed by using the option\n\"visualization\". Flot currently supports two modes: \"focus\" and \"fill\". The\noption \"focus\" draws a colored bezel around the selected area while keeping\nthe selected area clear. The option \"fill\" highlights (i.e., fills) the\nselected area with a colored highlight.\n\nThere are optional selection decorations (handles) that are rendered with the\n\"focus\" visualization option. The selection decoration is rendered by default\nbut can be turned off by setting displaySelectionDecorations to false.\n\n\"minSize\" is the minimum size a selection can be in pixels. This value can\nbe customized to determine the smallest size a selection can be and still\nhave the selection rectangle be displayed. When customizing this value, the\nfact that it refers to pixels, not axis units must be taken into account.\nThus, for example, if there is a bar graph in time mode with BarWidth set to 1\nminute, setting \"minSize\" to 1 will not make the minimum selection size 1\nminute, but rather 1 pixel. Note also that setting \"minSize\" to 0 will prevent\n\"plotunselected\" events from being fired when the user clicks the mouse without\ndragging.\n\nWhen selection support is enabled, a \"plotselected\" event will be emitted on\nthe DOM element you passed into the plot function. The event handler gets a\nparameter with the ranges selected on the axes, like this:\n\n    placeholder.bind( \"plotselected\", function( event, ranges ) {\n        alert(\"You selected \" + ranges.xaxis.from + \" to \" + ranges.xaxis.to)\n        // similar for yaxis - with multiple axes, the extra ones are in\n        // x2axis, x3axis, ...\n    });\n\nThe \"plotselected\" event is only fired when the user has finished making the\nselection. A \"plotselecting\" event is fired during the process with the same\nparameters as the \"plotselected\" event, in case you want to know what's\nhappening while it's happening,\n\nA \"plotunselected\" event with no arguments is emitted when the user clicks the\nmouse to remove the selection. As stated above, setting \"minSize\" to 0 will\ndestroy this behavior.\n\nThe plugin allso adds the following methods to the plot object:\n\n- setSelection( ranges, preventEvent )\n\n  Set the selection rectangle. The passed in ranges is on the same form as\n  returned in the \"plotselected\" event. If the selection mode is \"x\", you\n  should put in either an xaxis range, if the mode is \"y\" you need to put in\n  an yaxis range and both xaxis and yaxis if the selection mode is \"xy\", like\n  this:\n\n    setSelection({ xaxis: { from: 0, to: 10 }, yaxis: { from: 40, to: 60 } });\n\n  setSelection will trigger the \"plotselected\" event when called. If you don't\n  want that to happen, e.g. if you're inside a \"plotselected\" handler, pass\n  true as the second parameter. If you are using multiple axes, you can\n  specify the ranges on any of those, e.g. as x2axis/x3axis/... instead of\n  xaxis, the plugin picks the first one it sees.\n\n- clearSelection( preventEvent )\n\n  Clear the selection rectangle. Pass in true to avoid getting a\n  \"plotunselected\" event.\n\n- getSelection()\n\n  Returns the current selection in the same format as the \"plotselected\"\n  event. If there's currently no selection, the function returns null.\n\n*/\n\n(function ($) {\n    function init(plot) {\n        var selection = {\n            first: {x: -1, y: -1},\n            second: {x: -1, y: -1},\n            show: false,\n            currentMode: 'xy',\n            active: false\n        };\n\n        var SNAPPING_CONSTANT = $.plot.uiConstants.SNAPPING_CONSTANT;\n\n        // FIXME: The drag handling implemented here should be\n        // abstracted out, there's some similar code from a library in\n        // the navigation plugin, this should be massaged a bit to fit\n        // the Flot cases here better and reused. Doing this would\n        // make this plugin much slimmer.\n        var savedhandlers = {};\n\n        function onDrag(e) {\n            if (selection.active) {\n                updateSelection(e);\n\n                plot.getPlaceholder().trigger(\"plotselecting\", [ getSelection() ]);\n            }\n        }\n\n        function onDragStart(e) {\n            var o = plot.getOptions();\n            // only accept left-click\n            if (e.which !== 1 || o.selection.mode === null) return;\n\n            // reinitialize currentMode\n            selection.currentMode = 'xy';\n\n            // cancel out any text selections\n            document.body.focus();\n\n            // prevent text selection and drag in old-school browsers\n            if (document.onselectstart !== undefined && savedhandlers.onselectstart == null) {\n                savedhandlers.onselectstart = document.onselectstart;\n                document.onselectstart = function () { return false; };\n            }\n            if (document.ondrag !== undefined && savedhandlers.ondrag == null) {\n                savedhandlers.ondrag = document.ondrag;\n                document.ondrag = function () { return false; };\n            }\n\n            setSelectionPos(selection.first, e);\n\n            selection.active = true;\n        }\n\n        function onDragEnd(e) {\n            // revert drag stuff for old-school browsers\n            if (document.onselectstart !== undefined) {\n                document.onselectstart = savedhandlers.onselectstart;\n            }\n\n            if (document.ondrag !== undefined) {\n                document.ondrag = savedhandlers.ondrag;\n            }\n\n            // no more dragging\n            selection.active = false;\n            updateSelection(e);\n\n            if (selectionIsSane()) {\n                triggerSelectedEvent();\n            } else {\n                // this counts as a clear\n                plot.getPlaceholder().trigger(\"plotunselected\", [ ]);\n                plot.getPlaceholder().trigger(\"plotselecting\", [ null ]);\n            }\n\n            return false;\n        }\n\n        function getSelection() {\n            if (!selectionIsSane()) return null;\n\n            if (!selection.show) return null;\n\n            var r = {},\n                c1 = {x: selection.first.x, y: selection.first.y},\n                c2 = {x: selection.second.x, y: selection.second.y};\n\n            if (selectionDirection(plot) === 'x') {\n                c1.y = 0;\n                c2.y = plot.height();\n            }\n\n            if (selectionDirection(plot) === 'y') {\n                c1.x = 0;\n                c2.x = plot.width();\n            }\n\n            $.each(plot.getAxes(), function (name, axis) {\n                if (axis.used) {\n                    var p1 = axis.c2p(c1[axis.direction]), p2 = axis.c2p(c2[axis.direction]);\n                    r[name] = { from: Math.min(p1, p2), to: Math.max(p1, p2) };\n                }\n            });\n            return r;\n        }\n\n        function triggerSelectedEvent() {\n            var r = getSelection();\n\n            plot.getPlaceholder().trigger(\"plotselected\", [ r ]);\n\n            // backwards-compat stuff, to be removed in future\n            if (r.xaxis && r.yaxis) {\n                plot.getPlaceholder().trigger(\"selected\", [ { x1: r.xaxis.from, y1: r.yaxis.from, x2: r.xaxis.to, y2: r.yaxis.to } ]);\n            }\n        }\n\n        function clamp(min, value, max) {\n            return value < min ? min : (value > max ? max : value);\n        }\n\n        function selectionDirection(plot) {\n            var o = plot.getOptions();\n\n            if (o.selection.mode === 'smart') {\n                return selection.currentMode;\n            } else {\n                return o.selection.mode;\n            }\n        }\n\n        function updateMode(pos) {\n            if (selection.first) {\n                var delta = {\n                    x: pos.x - selection.first.x,\n                    y: pos.y - selection.first.y\n                };\n\n                if (Math.abs(delta.x) < SNAPPING_CONSTANT) {\n                    selection.currentMode = 'y';\n                } else if (Math.abs(delta.y) < SNAPPING_CONSTANT) {\n                    selection.currentMode = 'x';\n                } else {\n                    selection.currentMode = 'xy';\n                }\n            }\n        }\n\n        function setSelectionPos(pos, e) {\n            var offset = plot.getPlaceholder().offset();\n            var plotOffset = plot.getPlotOffset();\n            pos.x = clamp(0, e.pageX - offset.left - plotOffset.left, plot.width());\n            pos.y = clamp(0, e.pageY - offset.top - plotOffset.top, plot.height());\n\n            if (pos !== selection.first) updateMode(pos);\n\n            if (selectionDirection(plot) === \"y\") {\n                pos.x = pos === selection.first ? 0 : plot.width();\n            }\n\n            if (selectionDirection(plot) === \"x\") {\n                pos.y = pos === selection.first ? 0 : plot.height();\n            }\n        }\n\n        function updateSelection(pos) {\n            if (pos.pageX == null) return;\n\n            setSelectionPos(selection.second, pos);\n            if (selectionIsSane()) {\n                selection.show = true;\n                plot.triggerRedrawOverlay();\n            } else clearSelection(true);\n        }\n\n        function clearSelection(preventEvent) {\n            if (selection.show) {\n                selection.show = false;\n                selection.currentMode = '';\n                plot.triggerRedrawOverlay();\n                if (!preventEvent) {\n                    plot.getPlaceholder().trigger(\"plotunselected\", [ ]);\n                }\n            }\n        }\n\n        // function taken from markings support in Flot\n        function extractRange(ranges, coord) {\n            var axis, from, to, key, axes = plot.getAxes();\n\n            for (var k in axes) {\n                axis = axes[k];\n                if (axis.direction === coord) {\n                    key = coord + axis.n + \"axis\";\n                    if (!ranges[key] && axis.n === 1) {\n                        // support x1axis as xaxis\n                        key = coord + \"axis\";\n                    }\n\n                    if (ranges[key]) {\n                        from = ranges[key].from;\n                        to = ranges[key].to;\n                        break;\n                    }\n                }\n            }\n\n            // backwards-compat stuff - to be removed in future\n            if (!ranges[key]) {\n                axis = coord === \"x\" ? plot.getXAxes()[0] : plot.getYAxes()[0];\n                from = ranges[coord + \"1\"];\n                to = ranges[coord + \"2\"];\n            }\n\n            // auto-reverse as an added bonus\n            if (from != null && to != null && from > to) {\n                var tmp = from;\n                from = to;\n                to = tmp;\n            }\n\n            return { from: from, to: to, axis: axis };\n        }\n\n        function setSelection(ranges, preventEvent) {\n            var range;\n\n            if (selectionDirection(plot) === \"y\") {\n                selection.first.x = 0;\n                selection.second.x = plot.width();\n            } else {\n                range = extractRange(ranges, \"x\");\n                selection.first.x = range.axis.p2c(range.from);\n                selection.second.x = range.axis.p2c(range.to);\n            }\n\n            if (selectionDirection(plot) === \"x\") {\n                selection.first.y = 0;\n                selection.second.y = plot.height();\n            } else {\n                range = extractRange(ranges, \"y\");\n                selection.first.y = range.axis.p2c(range.from);\n                selection.second.y = range.axis.p2c(range.to);\n            }\n\n            selection.show = true;\n            plot.triggerRedrawOverlay();\n            if (!preventEvent && selectionIsSane()) {\n                triggerSelectedEvent();\n            }\n        }\n\n        function selectionIsSane() {\n            var minSize = plot.getOptions().selection.minSize;\n            return Math.abs(selection.second.x - selection.first.x) >= minSize &&\n                Math.abs(selection.second.y - selection.first.y) >= minSize;\n        }\n\n        plot.clearSelection = clearSelection;\n        plot.setSelection = setSelection;\n        plot.getSelection = getSelection;\n\n        plot.hooks.bindEvents.push(function(plot, eventHolder) {\n            var o = plot.getOptions();\n            if (o.selection.mode != null) {\n                plot.addEventHandler(\"dragstart\", onDragStart, eventHolder, 0);\n                plot.addEventHandler(\"drag\", onDrag, eventHolder, 0);\n                plot.addEventHandler(\"dragend\", onDragEnd, eventHolder, 0);\n            }\n        });\n\n        function drawSelectionDecorations(ctx, x, y, w, h, oX, oY, mode) {\n            var spacing = 3;\n            var fullEarWidth = 15;\n            var earWidth = Math.max(0, Math.min(fullEarWidth, w / 2 - 2, h / 2 - 2));\n            ctx.fillStyle = '#ffffff';\n\n            if (mode === 'xy') {\n                ctx.beginPath();\n                ctx.moveTo(x, y + earWidth);\n                ctx.lineTo(x - 3, y + earWidth);\n                ctx.lineTo(x - 3, y - 3);\n                ctx.lineTo(x + earWidth, y - 3);\n                ctx.lineTo(x + earWidth, y);\n                ctx.lineTo(x, y);\n                ctx.closePath();\n\n                ctx.moveTo(x, y + h - earWidth);\n                ctx.lineTo(x - 3, y + h - earWidth);\n                ctx.lineTo(x - 3, y + h + 3);\n                ctx.lineTo(x + earWidth, y + h + 3);\n                ctx.lineTo(x + earWidth, y + h);\n                ctx.lineTo(x, y + h);\n                ctx.closePath();\n\n                ctx.moveTo(x + w, y + earWidth);\n                ctx.lineTo(x + w + 3, y + earWidth);\n                ctx.lineTo(x + w + 3, y - 3);\n                ctx.lineTo(x + w - earWidth, y - 3);\n                ctx.lineTo(x + w - earWidth, y);\n                ctx.lineTo(x + w, y);\n                ctx.closePath();\n\n                ctx.moveTo(x + w, y + h - earWidth);\n                ctx.lineTo(x + w + 3, y + h - earWidth);\n                ctx.lineTo(x + w + 3, y + h + 3);\n                ctx.lineTo(x + w - earWidth, y + h + 3);\n                ctx.lineTo(x + w - earWidth, y + h);\n                ctx.lineTo(x + w, y + h);\n                ctx.closePath();\n\n                ctx.stroke();\n                ctx.fill();\n            }\n\n            x = oX;\n            y = oY;\n\n            if (mode === 'x') {\n                ctx.beginPath();\n                ctx.moveTo(x, y + fullEarWidth);\n                ctx.lineTo(x, y - fullEarWidth);\n                ctx.lineTo(x - spacing, y - fullEarWidth);\n                ctx.lineTo(x - spacing, y + fullEarWidth);\n                ctx.closePath();\n\n                ctx.moveTo(x + w, y + fullEarWidth);\n                ctx.lineTo(x + w, y - fullEarWidth);\n                ctx.lineTo(x + w + spacing, y - fullEarWidth);\n                ctx.lineTo(x + w + spacing, y + fullEarWidth);\n                ctx.closePath();\n                ctx.stroke();\n                ctx.fill();\n            }\n\n            if (mode === 'y') {\n                ctx.beginPath();\n\n                ctx.moveTo(x - fullEarWidth, y);\n                ctx.lineTo(x + fullEarWidth, y);\n                ctx.lineTo(x + fullEarWidth, y - spacing);\n                ctx.lineTo(x - fullEarWidth, y - spacing);\n                ctx.closePath();\n\n                ctx.moveTo(x - fullEarWidth, y + h);\n                ctx.lineTo(x + fullEarWidth, y + h);\n                ctx.lineTo(x + fullEarWidth, y + h + spacing);\n                ctx.lineTo(x - fullEarWidth, y + h + spacing);\n                ctx.closePath();\n                ctx.stroke();\n                ctx.fill();\n            }\n        }\n\n        plot.hooks.drawOverlay.push(function (plot, ctx) {\n            // draw selection\n            if (selection.show && selectionIsSane()) {\n                var plotOffset = plot.getPlotOffset();\n                var o = plot.getOptions();\n\n                ctx.save();\n                ctx.translate(plotOffset.left, plotOffset.top);\n\n                var c = $.color.parse(o.selection.color);\n                var visualization = o.selection.visualization;\n                var displaySelectionDecorations = o.selection.displaySelectionDecorations;\n\n                var scalingFactor = 1;\n\n                // use a dimmer scaling factor if visualization is \"fill\"\n                if (visualization === \"fill\") {\n                    scalingFactor = 0.8;\n                }\n\n                ctx.strokeStyle = c.scale('a', scalingFactor).toString();\n                ctx.lineWidth = 1;\n                ctx.lineJoin = o.selection.shape;\n                ctx.fillStyle = c.scale('a', 0.4).toString();\n\n                var x = Math.min(selection.first.x, selection.second.x) + 0.5,\n                    oX = x,\n                    y = Math.min(selection.first.y, selection.second.y) + 0.5,\n                    oY = y,\n                    w = Math.abs(selection.second.x - selection.first.x) - 1,\n                    h = Math.abs(selection.second.y - selection.first.y) - 1;\n\n                if (selectionDirection(plot) === 'x') {\n                    h += y;\n                    y = 0;\n                }\n\n                if (selectionDirection(plot) === 'y') {\n                    w += x;\n                    x = 0;\n                }\n\n                if (visualization === \"fill\") {\n                    ctx.fillRect(x, y, w, h);\n                    ctx.strokeRect(x, y, w, h);\n                } else {\n                    ctx.fillRect(0, 0, plot.width(), plot.height());\n                    ctx.clearRect(x, y, w, h);\n\n                    if (displaySelectionDecorations) {\n                        drawSelectionDecorations(ctx, x, y, w, h, oX, oY, selectionDirection(plot));\n                    }\n                }\n\n                ctx.restore();\n            }\n        });\n\n        plot.hooks.shutdown.push(function (plot, eventHolder) {\n            eventHolder.unbind(\"dragstart\", onDragStart);\n            eventHolder.unbind(\"drag\", onDrag);\n            eventHolder.unbind(\"dragend\", onDragEnd);\n        });\n    }\n\n    $.plot.plugins.push({\n        init: init,\n        options: {\n            selection: {\n                mode: null, // one of null, \"x\", \"y\" or \"xy\"\n                visualization: \"focus\", // \"focus\" or \"fill\"\n                displaySelectionDecorations: true, // true or false (currently only relevant for the focus visualization)\n                color: \"#888888\",\n                shape: \"round\", // one of \"round\", \"miter\", or \"bevel\"\n                minSize: 5 // minimum number of pixels\n            }\n        },\n        name: 'selection',\n        version: '1.1'\n    });\n})(jQuery);\n","/* Flot plugin for stacking data sets rather than overlaying them.\n\nCopyright (c) 2007-2014 IOLA and Ole Laursen.\nLicensed under the MIT license.\n\nThe plugin assumes the data is sorted on x (or y if stacking horizontally).\nFor line charts, it is assumed that if a line has an undefined gap (from a\nnull point), then the line above it should have the same gap - insert zeros\ninstead of \"null\" if you want another behaviour. This also holds for the start\nand end of the chart. Note that stacking a mix of positive and negative values\nin most instances doesn't make sense (so it looks weird).\n\nTwo or more series are stacked when their \"stack\" attribute is set to the same\nkey (which can be any number or string or just \"true\"). To specify the default\nstack, you can set the stack option like this:\n\n    series: {\n        stack: null/false, true, or a key (number/string)\n    }\n\nYou can also specify it for a single series, like this:\n\n    $.plot( $(\"#placeholder\"), [{\n        data: [ ... ],\n        stack: true\n    }])\n\nThe stacking order is determined by the order of the data series in the array\n(later series end up on top of the previous).\n\nInternally, the plugin modifies the datapoints in each series, adding an\noffset to the y value. For line series, extra data points are inserted through\ninterpolation. If there's a second y value, it's also adjusted (e.g for bar\ncharts or filled areas).\n\n*/\n\n(function ($) {\n    var options = {\n        series: { stack: null } // or number/string\n    };\n\n    function init(plot) {\n        function findMatchingSeries(s, allseries) {\n            var res = null;\n            for (var i = 0; i < allseries.length; ++i) {\n                if (s === allseries[i]) break;\n\n                if (allseries[i].stack === s.stack) {\n                    res = allseries[i];\n                }\n            }\n\n            return res;\n        }\n\n        function addBottomPoints (s, datapoints) {\n            var formattedPoints = [];\n            for (var i = 0; i < datapoints.points.length; i += 2) {\n                formattedPoints.push(datapoints.points[i]);\n                formattedPoints.push(datapoints.points[i + 1]);\n                formattedPoints.push(0);\n            }\n\n            datapoints.format.push({\n                x: false,\n                y: true,\n                number: true,\n                required: false,\n                computeRange: s.yaxis.options.autoScale !== 'none',\n                defaultValue: 0\n            });\n            datapoints.points = formattedPoints;\n            datapoints.pointsize = 3;\n        }\n\n        function stackData(plot, s, datapoints) {\n            if (s.stack == null || s.stack === false) return;\n\n            var needsBottom = s.bars.show || (s.lines.show && s.lines.fill);\n            var hasBottom = datapoints.pointsize > 2 && (s.bars.horizontal ? datapoints.format[2].x : datapoints.format[2].y);\n            // Series data is missing bottom points - need to format\n            if (needsBottom && !hasBottom) {\n                addBottomPoints(s, datapoints);\n            }\n\n            var other = findMatchingSeries(s, plot.getData());\n            if (!other) return;\n\n            var ps = datapoints.pointsize,\n                points = datapoints.points,\n                otherps = other.datapoints.pointsize,\n                otherpoints = other.datapoints.points,\n                newpoints = [],\n                px, py, intery, qx, qy, bottom,\n                withlines = s.lines.show,\n                horizontal = s.bars.horizontal,\n                withsteps = withlines && s.lines.steps,\n                fromgap = true,\n                keyOffset = horizontal ? 1 : 0,\n                accumulateOffset = horizontal ? 0 : 1,\n                i = 0, j = 0, l, m;\n\n            while (true) {\n                if (i >= points.length) break;\n\n                l = newpoints.length;\n\n                if (points[i] == null) {\n                    // copy gaps\n                    for (m = 0; m < ps; ++m) {\n                        newpoints.push(points[i + m]);\n                    }\n\n                    i += ps;\n                } else if (j >= otherpoints.length) {\n                    // for lines, we can't use the rest of the points\n                    if (!withlines) {\n                        for (m = 0; m < ps; ++m) {\n                            newpoints.push(points[i + m]);\n                        }\n                    }\n\n                    i += ps;\n                } else if (otherpoints[j] == null) {\n                    // oops, got a gap\n                    for (m = 0; m < ps; ++m) {\n                        newpoints.push(null);\n                    }\n\n                    fromgap = true;\n                    j += otherps;\n                } else {\n                    // cases where we actually got two points\n                    px = points[i + keyOffset];\n                    py = points[i + accumulateOffset];\n                    qx = otherpoints[j + keyOffset];\n                    qy = otherpoints[j + accumulateOffset];\n                    bottom = 0;\n\n                    if (px === qx) {\n                        for (m = 0; m < ps; ++m) {\n                            newpoints.push(points[i + m]);\n                        }\n\n                        newpoints[l + accumulateOffset] += qy;\n                        bottom = qy;\n\n                        i += ps;\n                        j += otherps;\n                    } else if (px > qx) {\n                        // we got past point below, might need to\n                        // insert interpolated extra point\n                        if (withlines && i > 0 && points[i - ps] != null) {\n                            intery = py + (points[i - ps + accumulateOffset] - py) * (qx - px) / (points[i - ps + keyOffset] - px);\n                            newpoints.push(qx);\n                            newpoints.push(intery + qy);\n                            for (m = 2; m < ps; ++m) {\n                                newpoints.push(points[i + m]);\n                            }\n\n                            bottom = qy;\n                        }\n\n                        j += otherps;\n                    } else { // px < qx\n                        if (fromgap && withlines) {\n                            // if we come from a gap, we just skip this point\n                            i += ps;\n                            continue;\n                        }\n\n                        for (m = 0; m < ps; ++m) {\n                            newpoints.push(points[i + m]);\n                        }\n\n                        // we might be able to interpolate a point below,\n                        // this can give us a better y\n                        if (withlines && j > 0 && otherpoints[j - otherps] != null) {\n                            bottom = qy + (otherpoints[j - otherps + accumulateOffset] - qy) * (px - qx) / (otherpoints[j - otherps + keyOffset] - qx);\n                        }\n\n                        newpoints[l + accumulateOffset] += bottom;\n\n                        i += ps;\n                    }\n\n                    fromgap = false;\n\n                    if (l !== newpoints.length && needsBottom) {\n                        newpoints[l + 2] += bottom;\n                    }\n                }\n\n                // maintain the line steps invariant\n                if (withsteps && l !== newpoints.length && l > 0 &&\n                    newpoints[l] !== null &&\n                    newpoints[l] !== newpoints[l - ps] &&\n                    newpoints[l + 1] !== newpoints[l - ps + 1]) {\n                    for (m = 0; m < ps; ++m) {\n                        newpoints[l + ps + m] = newpoints[l + m];\n                    }\n\n                    newpoints[l + 1] = newpoints[l - ps + 1];\n                }\n            }\n\n            datapoints.points = newpoints;\n        }\n\n        plot.hooks.processDatapoints.push(stackData);\n    }\n\n    $.plot.plugins.push({\n        init: init,\n        options: options,\n        name: 'stack',\n        version: '1.2'\n    });\n})(jQuery);\n","/* Flot plugin that adds some extra symbols for plotting points.\n\nCopyright (c) 2007-2014 IOLA and Ole Laursen.\nLicensed under the MIT license.\n\nThe symbols are accessed as strings through the standard symbol options:\n\n    series: {\n        points: {\n            symbol: \"square\" // or \"diamond\", \"triangle\", \"cross\", \"plus\", \"ellipse\", \"rectangle\"\n        }\n    }\n\n*/\n\n(function ($) {\n    // we normalize the area of each symbol so it is approximately the\n    // same as a circle of the given radius\n\n    var square = function (ctx, x, y, radius, shadow) {\n            // pi * r^2 = (2s)^2  =>  s = r * sqrt(pi)/2\n            var size = radius * Math.sqrt(Math.PI) / 2;\n            ctx.rect(x - size, y - size, size + size, size + size);\n        },\n        rectangle = function (ctx, x, y, radius, shadow) {\n            // pi * r^2 = (2s)^2  =>  s = r * sqrt(pi)/2\n            var size = radius * Math.sqrt(Math.PI) / 2;\n            ctx.rect(x - size, y - size, size + size, size + size);\n        },\n        diamond = function (ctx, x, y, radius, shadow) {\n            // pi * r^2 = 2s^2  =>  s = r * sqrt(pi/2)\n            var size = radius * Math.sqrt(Math.PI / 2);\n            ctx.moveTo(x - size, y);\n            ctx.lineTo(x, y - size);\n            ctx.lineTo(x + size, y);\n            ctx.lineTo(x, y + size);\n            ctx.lineTo(x - size, y);\n            ctx.lineTo(x, y - size);\n        },\n        triangle = function (ctx, x, y, radius, shadow) {\n            // pi * r^2 = 1/2 * s^2 * sin (pi / 3)  =>  s = r * sqrt(2 * pi / sin(pi / 3))\n            var size = radius * Math.sqrt(2 * Math.PI / Math.sin(Math.PI / 3));\n            var height = size * Math.sin(Math.PI / 3);\n            ctx.moveTo(x - size / 2, y + height / 2);\n            ctx.lineTo(x + size / 2, y + height / 2);\n            if (!shadow) {\n                ctx.lineTo(x, y - height / 2);\n                ctx.lineTo(x - size / 2, y + height / 2);\n                ctx.lineTo(x + size / 2, y + height / 2);\n            }\n        },\n        cross = function (ctx, x, y, radius, shadow) {\n            // pi * r^2 = (2s)^2  =>  s = r * sqrt(pi)/2\n            var size = radius * Math.sqrt(Math.PI) / 2;\n            ctx.moveTo(x - size, y - size);\n            ctx.lineTo(x + size, y + size);\n            ctx.moveTo(x - size, y + size);\n            ctx.lineTo(x + size, y - size);\n        },\n        ellipse = function(ctx, x, y, radius, shadow, fill) {\n            if (!shadow) {\n                ctx.moveTo(x + radius, y);\n                ctx.arc(x, y, radius, 0, Math.PI * 2, false);\n            }\n        },\n        plus = function (ctx, x, y, radius, shadow) {\n            var size = radius * Math.sqrt(Math.PI / 2);\n            ctx.moveTo(x - size, y);\n            ctx.lineTo(x + size, y);\n            ctx.moveTo(x, y + size);\n            ctx.lineTo(x, y - size);\n        },\n        handlers = {\n            square: square,\n            rectangle: rectangle,\n            diamond: diamond,\n            triangle: triangle,\n            cross: cross,\n            ellipse: ellipse,\n            plus: plus\n        };\n\n    square.fill = true;\n    rectangle.fill = true;\n    diamond.fill = true;\n    triangle.fill = true;\n    ellipse.fill = true;\n\n    function init(plot) {\n        plot.drawSymbol = handlers;\n    }\n\n    $.plot.plugins.push({\n        init: init,\n        name: 'symbols',\n        version: '1.0'\n    });\n})(jQuery);\n","/* Flot plugin for thresholding data.\n\nCopyright (c) 2007-2014 IOLA and Ole Laursen.\nLicensed under the MIT license.\n\nThe plugin supports these options:\n\n    series: {\n        threshold: {\n            below: number\n            color: colorspec\n        }\n    }\n\nIt can also be applied to a single series, like this:\n\n    $.plot( $(\"#placeholder\"), [{\n        data: [ ... ],\n        threshold: { ... }\n    }])\n\nAn array can be passed for multiple thresholding, like this:\n\n    threshold: [{\n        below: number1\n        color: color1\n    },{\n        below: number2\n        color: color2\n    }]\n\nThese multiple threshold objects can be passed in any order since they are\nsorted by the processing function.\n\nThe data points below \"below\" are drawn with the specified color. This makes\nit easy to mark points below 0, e.g. for budget data.\n\nInternally, the plugin works by splitting the data into two series, above and\nbelow the threshold. The extra series below the threshold will have its label\ncleared and the special \"originSeries\" attribute set to the original series.\nYou may need to check for this in hover events.\n\n*/\n\n(function ($) {\n    var options = {\n        series: { threshold: null } // or { below: number, color: color spec}\n    };\n\n    function init(plot) {\n        function thresholdData(plot, s, datapoints, below, color) {\n            var ps = datapoints.pointsize, i, x, y, p, prevp,\n                thresholded = $.extend({}, s); // note: shallow copy\n\n            thresholded.datapoints = { points: [], pointsize: ps, format: datapoints.format };\n            thresholded.label = null;\n            thresholded.color = color;\n            thresholded.threshold = null;\n            thresholded.originSeries = s;\n            thresholded.data = [];\n\n            var origpoints = datapoints.points,\n                addCrossingPoints = s.lines.show;\n\n            var threspoints = [];\n            var newpoints = [];\n            var m;\n\n            for (i = 0; i < origpoints.length; i += ps) {\n                x = origpoints[i];\n                y = origpoints[i + 1];\n\n                prevp = p;\n                if (y < below) p = threspoints;\n                else p = newpoints;\n\n                if (addCrossingPoints && prevp !== p &&\n                    x !== null && i > 0 &&\n                    origpoints[i - ps] != null) {\n                    var interx = x + (below - y) * (x - origpoints[i - ps]) / (y - origpoints[i - ps + 1]);\n                    prevp.push(interx);\n                    prevp.push(below);\n                    for (m = 2; m < ps; ++m) {\n                        prevp.push(origpoints[i + m]);\n                    }\n\n                    p.push(null); // start new segment\n                    p.push(null);\n                    for (m = 2; m < ps; ++m) {\n                        p.push(origpoints[i + m]);\n                    }\n\n                    p.push(interx);\n                    p.push(below);\n                    for (m = 2; m < ps; ++m) {\n                        p.push(origpoints[i + m]);\n                    }\n                }\n\n                p.push(x);\n                p.push(y);\n                for (m = 2; m < ps; ++m) {\n                    p.push(origpoints[i + m]);\n                }\n            }\n\n            datapoints.points = newpoints;\n            thresholded.datapoints.points = threspoints;\n\n            if (thresholded.datapoints.points.length > 0) {\n                var origIndex = $.inArray(s, plot.getData());\n                // Insert newly-generated series right after original one (to prevent it from becoming top-most)\n                plot.getData().splice(origIndex + 1, 0, thresholded);\n            }\n\n            // FIXME: there are probably some edge cases left in bars\n        }\n\n        function processThresholds(plot, s, datapoints) {\n            if (!s.threshold) return;\n            if (s.threshold instanceof Array) {\n                s.threshold.sort(function(a, b) {\n                    return a.below - b.below;\n                });\n\n                $(s.threshold).each(function(i, th) {\n                    thresholdData(plot, s, datapoints, th.below, th.color);\n                });\n            } else {\n                thresholdData(plot, s, datapoints, s.threshold.below, s.threshold.color);\n            }\n        }\n\n        plot.hooks.processDatapoints.push(processThresholds);\n    }\n\n    $.plot.plugins.push({\n        init: init,\n        options: options,\n        name: 'threshold',\n        version: '1.2'\n    });\n})(jQuery);\n","/* Pretty handling of time axes.\n\nCopyright (c) 2007-2014 IOLA and Ole Laursen.\nLicensed under the MIT license.\n\nSet axis.mode to \"time\" to enable. See the section \"Time series data\" in\nAPI.txt for details.\n*/\n\n(function($) {\n    'use strict';\n\n    var options = {\n        xaxis: {\n            timezone: null, // \"browser\" for local to the client or timezone for timezone-js\n            timeformat: null, // format string to use\n            twelveHourClock: false, // 12 or 24 time in time mode\n            monthNames: null, // list of names of months\n            timeBase: 'seconds' // are the values in given in mircoseconds, milliseconds or seconds\n        },\n        yaxis: {\n            timeBase: 'seconds'\n        }\n    };\n\n    var floorInBase = $.plot.saturated.floorInBase;\n\n    // Method to provide microsecond support to Date like classes.\n    var CreateMicroSecondDate = function(DateType, microEpoch) {\n        var newDate = new DateType(microEpoch);\n\n        var oldSetTime = newDate.setTime.bind(newDate);\n        newDate.update = function(microEpoch) {\n            oldSetTime(microEpoch);\n\n            // Round epoch to 3 decimal accuracy\n            microEpoch = Math.round(microEpoch * 1000) / 1000;\n\n            // Microseconds are stored as integers\n            this.microseconds = 1000 * (microEpoch - Math.floor(microEpoch));\n        };\n\n        var oldGetTime = newDate.getTime.bind(newDate);\n        newDate.getTime = function () {\n            var microEpoch = oldGetTime() + this.microseconds / 1000;\n            return microEpoch;\n        };\n\n        newDate.setTime = function (microEpoch) {\n            this.update(microEpoch);\n        };\n\n        newDate.getMicroseconds = function() {\n            return this.microseconds;\n        };\n\n        newDate.setMicroseconds = function(microseconds) {\n            var epochWithoutMicroseconds = oldGetTime();\n            var newEpoch = epochWithoutMicroseconds + microseconds / 1000;\n            this.update(newEpoch);\n        };\n\n        newDate.setUTCMicroseconds = function(microseconds) { this.setMicroseconds(microseconds); }\n\n        newDate.getUTCMicroseconds = function() { return this.getMicroseconds(); }\n\n        newDate.microseconds = null;\n        newDate.microEpoch = null;\n        newDate.update(microEpoch);\n        return newDate;\n    }\n\n    // Returns a string with the date d formatted according to fmt.\n    // A subset of the Open Group's strftime format is supported.\n\n    function formatDate(d, fmt, monthNames, dayNames) {\n        if (typeof d.strftime === \"function\") {\n            return d.strftime(fmt);\n        }\n\n        var leftPad = function(n, pad) {\n            n = \"\" + n;\n            pad = \"\" + (pad == null ? \"0\" : pad);\n            return n.length === 1 ? pad + n : n;\n        };\n\n        var formatSubSeconds = function(milliseconds, microseconds, numberDecimalPlaces) {\n            var totalMicroseconds = milliseconds * 1000 + microseconds;\n            var formattedString;\n            if (numberDecimalPlaces < 6 && numberDecimalPlaces > 0) {\n                var magnitude = parseFloat('1e' + (numberDecimalPlaces - 6));\n                totalMicroseconds = Math.round(Math.round(totalMicroseconds * magnitude) / magnitude);\n                formattedString = ('00000' + totalMicroseconds).slice(-6, -(6 - numberDecimalPlaces));\n            } else {\n                totalMicroseconds = Math.round(totalMicroseconds)\n                formattedString = ('00000' + totalMicroseconds).slice(-6);\n            }\n            return formattedString;\n        };\n\n        var r = [];\n        var escape = false;\n        var hours = d.getHours();\n        var isAM = hours < 12;\n\n        if (!monthNames) {\n            monthNames = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n        }\n\n        if (!dayNames) {\n            dayNames = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"];\n        }\n\n        var hours12;\n        if (hours > 12) {\n            hours12 = hours - 12;\n        } else if (hours === 0) {\n            hours12 = 12;\n        } else {\n            hours12 = hours;\n        }\n\n        var decimals = -1;\n        for (var i = 0; i < fmt.length; ++i) {\n            var c = fmt.charAt(i);\n\n            if (!isNaN(Number(c)) && Number(c) > 0) {\n                decimals = Number(c);\n            } else if (escape) {\n                switch (c) {\n                    case 'a': c = \"\" + dayNames[d.getDay()]; break;\n                    case 'b': c = \"\" + monthNames[d.getMonth()]; break;\n                    case 'd': c = leftPad(d.getDate()); break;\n                    case 'e': c = leftPad(d.getDate(), \" \"); break;\n                    case 'h': // For back-compat with 0.7; remove in 1.0\n                    case 'H': c = leftPad(hours); break;\n                    case 'I': c = leftPad(hours12); break;\n                    case 'l': c = leftPad(hours12, \" \"); break;\n                    case 'm': c = leftPad(d.getMonth() + 1); break;\n                    case 'M': c = leftPad(d.getMinutes()); break;\n                    // quarters not in Open Group's strftime specification\n                    case 'q':\n                        c = \"\" + (Math.floor(d.getMonth() / 3) + 1); break;\n                    case 'S': c = leftPad(d.getSeconds()); break;\n                    case 's': c = \"\" + formatSubSeconds(d.getMilliseconds(), d.getMicroseconds(), decimals); break;\n                    case 'y': c = leftPad(d.getFullYear() % 100); break;\n                    case 'Y': c = \"\" + d.getFullYear(); break;\n                    case 'p': c = (isAM) ? (\"\" + \"am\") : (\"\" + \"pm\"); break;\n                    case 'P': c = (isAM) ? (\"\" + \"AM\") : (\"\" + \"PM\"); break;\n                    case 'w': c = \"\" + d.getDay(); break;\n                }\n                r.push(c);\n                escape = false;\n            } else {\n                if (c === \"%\") {\n                    escape = true;\n                } else {\n                    r.push(c);\n                }\n            }\n        }\n\n        return r.join(\"\");\n    }\n\n    // To have a consistent view of time-based data independent of which time\n    // zone the client happens to be in we need a date-like object independent\n    // of time zones.  This is done through a wrapper that only calls the UTC\n    // versions of the accessor methods.\n\n    function makeUtcWrapper(d) {\n        function addProxyMethod(sourceObj, sourceMethod, targetObj, targetMethod) {\n            sourceObj[sourceMethod] = function() {\n                return targetObj[targetMethod].apply(targetObj, arguments);\n            };\n        }\n\n        var utc = {\n            date: d\n        };\n\n        // support strftime, if found\n        if (d.strftime !== undefined) {\n            addProxyMethod(utc, \"strftime\", d, \"strftime\");\n        }\n\n        addProxyMethod(utc, \"getTime\", d, \"getTime\");\n        addProxyMethod(utc, \"setTime\", d, \"setTime\");\n\n        var props = [\"Date\", \"Day\", \"FullYear\", \"Hours\", \"Minutes\", \"Month\", \"Seconds\", \"Milliseconds\", \"Microseconds\"];\n\n        for (var p = 0; p < props.length; p++) {\n            addProxyMethod(utc, \"get\" + props[p], d, \"getUTC\" + props[p]);\n            addProxyMethod(utc, \"set\" + props[p], d, \"setUTC\" + props[p]);\n        }\n\n        return utc;\n    }\n\n    // select time zone strategy.  This returns a date-like object tied to the\n    // desired timezone\n    function dateGenerator(ts, opts) {\n        var maxDateValue = 8640000000000000;\n\n        if (opts && opts.timeBase === 'seconds') {\n            ts *= 1000;\n        } else if (opts.timeBase === 'microseconds') {\n            ts /= 1000;\n        }\n\n        if (ts > maxDateValue) {\n            ts = maxDateValue;\n        } else if (ts < -maxDateValue) {\n            ts = -maxDateValue;\n        }\n\n        if (opts.timezone === \"browser\") {\n            return CreateMicroSecondDate(Date, ts);\n        } else if (!opts.timezone || opts.timezone === \"utc\") {\n            return makeUtcWrapper(CreateMicroSecondDate(Date, ts));\n        } else if (typeof timezoneJS !== \"undefined\" && typeof timezoneJS.Date !== \"undefined\") {\n            var d = CreateMicroSecondDate(timezoneJS.Date, ts);\n            // timezone-js is fickle, so be sure to set the time zone before\n            // setting the time.\n            d.setTimezone(opts.timezone);\n            d.setTime(ts);\n            return d;\n        } else {\n            return makeUtcWrapper(CreateMicroSecondDate(Date, ts));\n        }\n    }\n\n    // map of app. size of time units in seconds\n    var timeUnitSizeSeconds = {\n        \"microsecond\": 0.000001,\n        \"millisecond\": 0.001,\n        \"second\": 1,\n        \"minute\": 60,\n        \"hour\": 60 * 60,\n        \"day\": 24 * 60 * 60,\n        \"month\": 30 * 24 * 60 * 60,\n        \"quarter\": 3 * 30 * 24 * 60 * 60,\n        \"year\": 365.2425 * 24 * 60 * 60\n    };\n\n    // map of app. size of time units in milliseconds\n    var timeUnitSizeMilliseconds = {\n        \"microsecond\": 0.001,\n        \"millisecond\": 1,\n        \"second\": 1000,\n        \"minute\": 60 * 1000,\n        \"hour\": 60 * 60 * 1000,\n        \"day\": 24 * 60 * 60 * 1000,\n        \"month\": 30 * 24 * 60 * 60 * 1000,\n        \"quarter\": 3 * 30 * 24 * 60 * 60 * 1000,\n        \"year\": 365.2425 * 24 * 60 * 60 * 1000\n    };\n\n    // map of app. size of time units in microseconds\n    var timeUnitSizeMicroseconds = {\n        \"microsecond\": 1,\n        \"millisecond\": 1000,\n        \"second\": 1000000,\n        \"minute\": 60 * 1000000,\n        \"hour\": 60 * 60 * 1000000,\n        \"day\": 24 * 60 * 60 * 1000000,\n        \"month\": 30 * 24 * 60 * 60 * 1000000,\n        \"quarter\": 3 * 30 * 24 * 60 * 60 * 1000000,\n        \"year\": 365.2425 * 24 * 60 * 60 * 1000000\n    };\n\n    // the allowed tick sizes, after 1 year we use\n    // an integer algorithm\n\n    var baseSpec = [\n        [1, \"microsecond\"], [2, \"microsecond\"], [5, \"microsecond\"], [10, \"microsecond\"],\n        [25, \"microsecond\"], [50, \"microsecond\"], [100, \"microsecond\"], [250, \"microsecond\"], [500, \"microsecond\"],\n        [1, \"millisecond\"], [2, \"millisecond\"], [5, \"millisecond\"], [10, \"millisecond\"],\n        [25, \"millisecond\"], [50, \"millisecond\"], [100, \"millisecond\"], [250, \"millisecond\"], [500, \"millisecond\"],\n        [1, \"second\"], [2, \"second\"], [5, \"second\"], [10, \"second\"],\n        [30, \"second\"],\n        [1, \"minute\"], [2, \"minute\"], [5, \"minute\"], [10, \"minute\"],\n        [30, \"minute\"],\n        [1, \"hour\"], [2, \"hour\"], [4, \"hour\"],\n        [8, \"hour\"], [12, \"hour\"],\n        [1, \"day\"], [2, \"day\"], [3, \"day\"],\n        [0.25, \"month\"], [0.5, \"month\"], [1, \"month\"],\n        [2, \"month\"]\n    ];\n\n    // we don't know which variant(s) we'll need yet, but generating both is\n    // cheap\n\n    var specMonths = baseSpec.concat([[3, \"month\"], [6, \"month\"],\n        [1, \"year\"]]);\n    var specQuarters = baseSpec.concat([[1, \"quarter\"], [2, \"quarter\"],\n        [1, \"year\"]]);\n\n    function dateTickGenerator(axis) {\n        var opts = axis.options,\n            ticks = [],\n            d = dateGenerator(axis.min, opts),\n            minSize = 0;\n\n        // make quarter use a possibility if quarters are\n        // mentioned in either of these options\n        var spec = (opts.tickSize && opts.tickSize[1] ===\n            \"quarter\") ||\n            (opts.minTickSize && opts.minTickSize[1] ===\n            \"quarter\") ? specQuarters : specMonths;\n\n        var timeUnitSize;\n        if (opts.timeBase === 'seconds') {\n            timeUnitSize = timeUnitSizeSeconds;\n        } else if (opts.timeBase === 'microseconds') {\n            timeUnitSize = timeUnitSizeMicroseconds;\n        } else {\n            timeUnitSize = timeUnitSizeMilliseconds;\n        }\n\n        if (opts.minTickSize !== null && opts.minTickSize !== undefined) {\n            if (typeof opts.tickSize === \"number\") {\n                minSize = opts.tickSize;\n            } else {\n                minSize = opts.minTickSize[0] * timeUnitSize[opts.minTickSize[1]];\n            }\n        }\n\n        for (var i = 0; i < spec.length - 1; ++i) {\n            if (axis.delta < (spec[i][0] * timeUnitSize[spec[i][1]] +\n                spec[i + 1][0] * timeUnitSize[spec[i + 1][1]]) / 2 &&\n                spec[i][0] * timeUnitSize[spec[i][1]] >= minSize) {\n                break;\n            }\n        }\n\n        var size = spec[i][0];\n        var unit = spec[i][1];\n        // special-case the possibility of several years\n        if (unit === \"year\") {\n            // if given a minTickSize in years, just use it,\n            // ensuring that it's an integer\n\n            if (opts.minTickSize !== null && opts.minTickSize !== undefined && opts.minTickSize[1] === \"year\") {\n                size = Math.floor(opts.minTickSize[0]);\n            } else {\n                var magn = parseFloat('1e' + Math.floor(Math.log(axis.delta / timeUnitSize.year) / Math.LN10));\n                var norm = (axis.delta / timeUnitSize.year) / magn;\n\n                if (norm < 1.5) {\n                    size = 1;\n                } else if (norm < 3) {\n                    size = 2;\n                } else if (norm < 7.5) {\n                    size = 5;\n                } else {\n                    size = 10;\n                }\n\n                size *= magn;\n            }\n\n            // minimum size for years is 1\n\n            if (size < 1) {\n                size = 1;\n            }\n        }\n\n        axis.tickSize = opts.tickSize || [size, unit];\n        var tickSize = axis.tickSize[0];\n        unit = axis.tickSize[1];\n\n        var step = tickSize * timeUnitSize[unit];\n\n        if (unit === \"microsecond\") {\n            d.setMicroseconds(floorInBase(d.getMicroseconds(), tickSize));\n        } else if (unit === \"millisecond\") {\n            d.setMilliseconds(floorInBase(d.getMilliseconds(), tickSize));\n        } else if (unit === \"second\") {\n            d.setSeconds(floorInBase(d.getSeconds(), tickSize));\n        } else if (unit === \"minute\") {\n            d.setMinutes(floorInBase(d.getMinutes(), tickSize));\n        } else if (unit === \"hour\") {\n            d.setHours(floorInBase(d.getHours(), tickSize));\n        } else if (unit === \"month\") {\n            d.setMonth(floorInBase(d.getMonth(), tickSize));\n        } else if (unit === \"quarter\") {\n            d.setMonth(3 * floorInBase(d.getMonth() / 3,\n                tickSize));\n        } else if (unit === \"year\") {\n            d.setFullYear(floorInBase(d.getFullYear(), tickSize));\n        }\n\n        // reset smaller components\n\n        if (step >= timeUnitSize.millisecond) {\n            if (step >= timeUnitSize.second) {\n                d.setMicroseconds(0);\n            } else {\n                d.setMicroseconds(d.getMilliseconds() * 1000);\n            }\n        }\n        if (step >= timeUnitSize.minute) {\n            d.setSeconds(0);\n        }\n        if (step >= timeUnitSize.hour) {\n            d.setMinutes(0);\n        }\n        if (step >= timeUnitSize.day) {\n            d.setHours(0);\n        }\n        if (step >= timeUnitSize.day * 4) {\n            d.setDate(1);\n        }\n        if (step >= timeUnitSize.month * 2) {\n            d.setMonth(floorInBase(d.getMonth(), 3));\n        }\n        if (step >= timeUnitSize.quarter * 2) {\n            d.setMonth(floorInBase(d.getMonth(), 6));\n        }\n        if (step >= timeUnitSize.year) {\n            d.setMonth(0);\n        }\n\n        var carry = 0;\n        var v = Number.NaN;\n        var v1000;\n        var prev;\n        do {\n            prev = v;\n            v1000 = d.getTime();\n            if (opts && opts.timeBase === 'seconds') {\n                v = v1000 / 1000;\n            } else if (opts && opts.timeBase === 'microseconds') {\n                v = v1000 * 1000;\n            } else {\n                v = v1000;\n            }\n\n            ticks.push(v);\n\n            if (unit === \"month\" || unit === \"quarter\") {\n                if (tickSize < 1) {\n                    // a bit complicated - we'll divide the\n                    // month/quarter up but we need to take\n                    // care of fractions so we don't end up in\n                    // the middle of a day\n                    d.setDate(1);\n                    var start = d.getTime();\n                    d.setMonth(d.getMonth() +\n                        (unit === \"quarter\" ? 3 : 1));\n                    var end = d.getTime();\n                    d.setTime((v + carry * timeUnitSize.hour + (end - start) * tickSize));\n                    carry = d.getHours();\n                    d.setHours(0);\n                } else {\n                    d.setMonth(d.getMonth() +\n                        tickSize * (unit === \"quarter\" ? 3 : 1));\n                }\n            } else if (unit === \"year\") {\n                d.setFullYear(d.getFullYear() + tickSize);\n            } else {\n                if (opts.timeBase === 'seconds') {\n                    d.setTime((v + step) * 1000);\n                } else if (opts.timeBase === 'microseconds') {\n                    d.setTime((v + step) / 1000);\n                } else {\n                    d.setTime(v + step);\n                }\n            }\n        } while (v < axis.max && v !== prev);\n\n        return ticks;\n    };\n\n    function init(plot) {\n        plot.hooks.processOptions.push(function (plot) {\n            $.each(plot.getAxes(), function(axisName, axis) {\n                var opts = axis.options;\n                if (opts.mode === \"time\") {\n                    axis.tickGenerator = dateTickGenerator;\n\n                    // if a tick formatter is already provided do not overwrite it\n                    if ('tickFormatter' in opts && typeof opts.tickFormatter === 'function') return;\n\n                    axis.tickFormatter = function (v, axis) {\n                        var d = dateGenerator(v, axis.options);\n\n                        // first check global format\n                        if (opts.timeformat != null) {\n                            return formatDate(d, opts.timeformat, opts.monthNames, opts.dayNames);\n                        }\n\n                        // possibly use quarters if quarters are mentioned in\n                        // any of these places\n                        var useQuarters = (axis.options.tickSize &&\n                                axis.options.tickSize[1] === \"quarter\") ||\n                            (axis.options.minTickSize &&\n                                axis.options.minTickSize[1] === \"quarter\");\n\n                        var timeUnitSize;\n                        if (opts.timeBase === 'seconds') {\n                            timeUnitSize = timeUnitSizeSeconds;\n                        } else if (opts.timeBase === 'microseconds') {\n                            timeUnitSize = timeUnitSizeMicroseconds;\n                        } else {\n                            timeUnitSize = timeUnitSizeMilliseconds;\n                        }\n\n                        var t = axis.tickSize[0] * timeUnitSize[axis.tickSize[1]];\n                        var span = axis.max - axis.min;\n                        var suffix = (opts.twelveHourClock) ? \" %p\" : \"\";\n                        var hourCode = (opts.twelveHourClock) ? \"%I\" : \"%H\";\n                        var factor;\n                        var fmt;\n\n                        if (opts.timeBase === 'seconds') {\n                            factor = 1;\n                        } else if (opts.timeBase === 'microseconds') {\n                            factor = 1000000\n                        } else {\n                            factor = 1000;\n                        }\n\n                        if (t < timeUnitSize.second) {\n                            var decimals = -Math.floor(Math.log10(t / factor))\n\n                            // the two-and-halves require an additional decimal\n                            if (String(t).indexOf('25') > -1) {\n                                decimals++;\n                            }\n\n                            fmt = \"%S.%\" + decimals + \"s\";\n                        } else\n                        if (t < timeUnitSize.minute) {\n                            fmt = hourCode + \":%M:%S\" + suffix;\n                        } else if (t < timeUnitSize.day) {\n                            if (span < 2 * timeUnitSize.day) {\n                                fmt = hourCode + \":%M\" + suffix;\n                            } else {\n                                fmt = \"%b %d \" + hourCode + \":%M\" + suffix;\n                            }\n                        } else if (t < timeUnitSize.month) {\n                            fmt = \"%b %d\";\n                        } else if ((useQuarters && t < timeUnitSize.quarter) ||\n                            (!useQuarters && t < timeUnitSize.year)) {\n                            if (span < timeUnitSize.year) {\n                                fmt = \"%b\";\n                            } else {\n                                fmt = \"%b %Y\";\n                            }\n                        } else if (useQuarters && t < timeUnitSize.year) {\n                            if (span < timeUnitSize.year) {\n                                fmt = \"Q%q\";\n                            } else {\n                                fmt = \"Q%q %Y\";\n                            }\n                        } else {\n                            fmt = \"%Y\";\n                        }\n\n                        var rt = formatDate(d, fmt, opts.monthNames, opts.dayNames);\n\n                        return rt;\n                    };\n                }\n            });\n        });\n    }\n\n    $.plot.plugins.push({\n        init: init,\n        options: options,\n        name: 'time',\n        version: '1.0'\n    });\n\n    // Time-axis support used to be in Flot core, which exposed the\n    // formatDate function on the plot object.  Various plugins depend\n    // on the function, so we need to re-expose it here.\n\n    $.plot.formatDate = formatDate;\n    $.plot.dateGenerator = dateGenerator;\n    $.plot.dateTickGenerator = dateTickGenerator;\n    $.plot.makeUtcWrapper = makeUtcWrapper;\n})(jQuery);\n","\n/* global jQuery */\n\n(function($) {\n    'use strict';\n\n    var options = {\n        propagateSupportedGesture: false\n    };\n\n    function init(plot) {\n        plot.hooks.processOptions.push(initTouchNavigation);\n    }\n\n    function initTouchNavigation(plot, options) {\n        var gestureState = {\n                twoTouches: false,\n                currentTapStart: { x: 0, y: 0 },\n                currentTapEnd: { x: 0, y: 0 },\n                prevTap: { x: 0, y: 0 },\n                currentTap: { x: 0, y: 0 },\n                interceptedLongTap: false,\n                isUnsupportedGesture: false,\n                prevTapTime: null,\n                tapStartTime: null,\n                longTapTriggerId: null\n            },\n            maxDistanceBetweenTaps = 20,\n            maxIntervalBetweenTaps = 500,\n            maxLongTapDistance = 20,\n            minLongTapDuration = 1500,\n            pressedTapDuration = 125,\n            mainEventHolder;\n\n        function interpretGestures(e) {\n            var o = plot.getOptions();\n\n            if (!o.pan.active && !o.zoom.active) {\n                return;\n            }\n\n            updateOnMultipleTouches(e);\n            mainEventHolder.dispatchEvent(new CustomEvent('touchevent', { detail: e }));\n\n            if (isPinchEvent(e)) {\n                executeAction(e, 'pinch');\n            } else {\n                executeAction(e, 'pan');\n                if (!wasPinchEvent(e)) {\n                    if (isDoubleTap(e)) {\n                        executeAction(e, 'doubleTap');\n                    }\n                    executeAction(e, 'tap');\n                    executeAction(e, 'longTap');\n                }\n            }\n        }\n\n        function executeAction(e, gesture) {\n            switch (gesture) {\n                case 'pan':\n                    pan[e.type](e);\n                    break;\n                case 'pinch':\n                    pinch[e.type](e);\n                    break;\n                case 'doubleTap':\n                    doubleTap.onDoubleTap(e);\n                    break;\n                case 'longTap':\n                    longTap[e.type](e);\n                    break;\n                case 'tap':\n                    tap[e.type](e);\n                    break;\n            }\n        }\n\n        function bindEvents(plot, eventHolder) {\n            mainEventHolder = eventHolder[0];\n            eventHolder[0].addEventListener('touchstart', interpretGestures, false);\n            eventHolder[0].addEventListener('touchmove', interpretGestures, false);\n            eventHolder[0].addEventListener('touchend', interpretGestures, false);\n        }\n\n        function shutdown(plot, eventHolder) {\n            eventHolder[0].removeEventListener('touchstart', interpretGestures);\n            eventHolder[0].removeEventListener('touchmove', interpretGestures);\n            eventHolder[0].removeEventListener('touchend', interpretGestures);\n            if (gestureState.longTapTriggerId) {\n                clearTimeout(gestureState.longTapTriggerId);\n                gestureState.longTapTriggerId = null;\n            }\n        }\n\n        var pan = {\n            touchstart: function(e) {\n                updatePrevForDoubleTap();\n                updateCurrentForDoubleTap(e);\n                updateStateForLongTapStart(e);\n\n                mainEventHolder.dispatchEvent(new CustomEvent('panstart', { detail: e }));\n            },\n\n            touchmove: function(e) {\n                preventEventBehaviors(e);\n\n                updateCurrentForDoubleTap(e);\n                updateStateForLongTapEnd(e);\n\n                if (!gestureState.isUnsupportedGesture) {\n                    mainEventHolder.dispatchEvent(new CustomEvent('pandrag', { detail: e }));\n                }\n            },\n\n            touchend: function(e) {\n                preventEventBehaviors(e);\n\n                if (wasPinchEvent(e)) {\n                    mainEventHolder.dispatchEvent(new CustomEvent('pinchend', { detail: e }));\n                    mainEventHolder.dispatchEvent(new CustomEvent('panstart', { detail: e }));\n                } else if (noTouchActive(e)) {\n                    mainEventHolder.dispatchEvent(new CustomEvent('panend', { detail: e }));\n                }\n            }\n        };\n\n        var pinch = {\n            touchstart: function(e) {\n                mainEventHolder.dispatchEvent(new CustomEvent('pinchstart', { detail: e }));\n            },\n\n            touchmove: function(e) {\n                preventEventBehaviors(e);\n                gestureState.twoTouches = isPinchEvent(e);\n                if (!gestureState.isUnsupportedGesture) {\n                    mainEventHolder.dispatchEvent(new CustomEvent('pinchdrag', { detail: e }));\n                }\n            },\n\n            touchend: function(e) {\n                preventEventBehaviors(e);\n            }\n        };\n\n        var doubleTap = {\n            onDoubleTap: function(e) {\n                preventEventBehaviors(e);\n                mainEventHolder.dispatchEvent(new CustomEvent('doubletap', { detail: e }));\n            }\n        };\n\n        var longTap = {\n            touchstart: function(e) {\n                longTap.waitForLongTap(e);\n            },\n\n            touchmove: function(e) {\n            },\n\n            touchend: function(e) {\n                if (gestureState.longTapTriggerId) {\n                    clearTimeout(gestureState.longTapTriggerId);\n                    gestureState.longTapTriggerId = null;\n                }\n            },\n\n            isLongTap: function(e) {\n                var currentTime = new Date().getTime(),\n                    tapDuration = currentTime - gestureState.tapStartTime;\n                if (tapDuration >= minLongTapDuration && !gestureState.interceptedLongTap) {\n                    if (distance(gestureState.currentTapStart.x, gestureState.currentTapStart.y, gestureState.currentTapEnd.x, gestureState.currentTapEnd.y) < maxLongTapDistance) {\n                        gestureState.interceptedLongTap = true;\n                        return true;\n                    }\n                }\n                return false;\n            },\n\n            waitForLongTap: function(e) {\n                var longTapTrigger = function() {\n                    if (longTap.isLongTap(e)) {\n                        mainEventHolder.dispatchEvent(new CustomEvent('longtap', { detail: e }));\n                    }\n                    gestureState.longTapTriggerId = null;\n                };\n                if (!gestureState.longTapTriggerId) {\n                    gestureState.longTapTriggerId = setTimeout(longTapTrigger, minLongTapDuration);\n                }\n            }\n        };\n\n        var tap = {\n            touchstart: function(e) {\n                gestureState.tapStartTime = new Date().getTime();\n            },\n\n            touchmove: function(e) {\n            },\n\n            touchend: function(e) {\n                if (tap.isTap(e)) {\n                    mainEventHolder.dispatchEvent(new CustomEvent('tap', { detail: e }));\n                    preventEventBehaviors(e);\n                }\n            },\n\n            isTap: function(e) {\n                var currentTime = new Date().getTime(),\n                    tapDuration = currentTime - gestureState.tapStartTime;\n                if (tapDuration <= pressedTapDuration) {\n                    if (distance(gestureState.currentTapStart.x, gestureState.currentTapStart.y, gestureState.currentTapEnd.x, gestureState.currentTapEnd.y) < maxLongTapDistance) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n        };\n\n        if (options.pan.enableTouch === true || options.zoom.enableTouch) {\n            plot.hooks.bindEvents.push(bindEvents);\n            plot.hooks.shutdown.push(shutdown);\n        };\n\n        function updatePrevForDoubleTap() {\n            gestureState.prevTap = {\n                x: gestureState.currentTap.x,\n                y: gestureState.currentTap.y\n            };\n        };\n\n        function updateCurrentForDoubleTap(e) {\n            gestureState.currentTap = {\n                x: e.touches[0].pageX,\n                y: e.touches[0].pageY\n            };\n        }\n\n        function updateStateForLongTapStart(e) {\n            gestureState.tapStartTime = new Date().getTime();\n            gestureState.interceptedLongTap = false;\n            gestureState.currentTapStart = {\n                x: e.touches[0].pageX,\n                y: e.touches[0].pageY\n            };\n            gestureState.currentTapEnd = {\n                x: e.touches[0].pageX,\n                y: e.touches[0].pageY\n            };\n        };\n\n        function updateStateForLongTapEnd(e) {\n            gestureState.currentTapEnd = {\n                x: e.touches[0].pageX,\n                y: e.touches[0].pageY\n            };\n        };\n\n        function isDoubleTap(e) {\n            var currentTime = new Date().getTime(),\n                intervalBetweenTaps = currentTime - gestureState.prevTapTime;\n\n            if (intervalBetweenTaps >= 0 && intervalBetweenTaps < maxIntervalBetweenTaps) {\n                if (distance(gestureState.prevTap.x, gestureState.prevTap.y, gestureState.currentTap.x, gestureState.currentTap.y) < maxDistanceBetweenTaps) {\n                    e.firstTouch = gestureState.prevTap;\n                    e.secondTouch = gestureState.currentTap;\n                    return true;\n                }\n            }\n            gestureState.prevTapTime = currentTime;\n            return false;\n        }\n\n        function preventEventBehaviors(e) {\n            if (!gestureState.isUnsupportedGesture) {\n                e.preventDefault();\n                if (!plot.getOptions().propagateSupportedGesture) {\n                    e.stopPropagation();\n                }\n            }\n        }\n\n        function distance(x1, y1, x2, y2) {\n            return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n        }\n\n        function noTouchActive(e) {\n            return (e.touches && e.touches.length === 0);\n        }\n\n        function wasPinchEvent(e) {\n            return (gestureState.twoTouches && e.touches.length === 1);\n        }\n\n        function updateOnMultipleTouches(e) {\n            if (e.touches.length >= 3) {\n                gestureState.isUnsupportedGesture = true;\n            } else {\n                gestureState.isUnsupportedGesture = false;\n            }\n        }\n\n        function isPinchEvent(e) {\n            if (e.touches && e.touches.length >= 2) {\n                if (e.touches[0].target === plot.getEventHolder() &&\n                    e.touches[1].target === plot.getEventHolder()) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n\n    $.plot.plugins.push({\n        init: init,\n        options: options,\n        name: 'navigateTouch',\n        version: '0.3'\n    });\n})(jQuery);\n","/* global jQuery */\n\n(function($) {\n    'use strict';\n\n    var options = {\n        zoom: {\n            enableTouch: false\n        },\n        pan: {\n            enableTouch: false,\n            touchMode: 'manual'\n        },\n        recenter: {\n            enableTouch: true\n        }\n    };\n\n    var ZOOM_DISTANCE_MARGIN = $.plot.uiConstants.ZOOM_DISTANCE_MARGIN;\n\n    function init(plot) {\n        plot.hooks.processOptions.push(initTouchNavigation);\n    }\n\n    function initTouchNavigation(plot, options) {\n        var gestureState = {\n                zoomEnable: false,\n                prevDistance: null,\n                prevTapTime: 0,\n                prevPanPosition: { x: 0, y: 0 },\n                prevTapPosition: { x: 0, y: 0 }\n            },\n            navigationState = {\n                prevTouchedAxis: 'none',\n                currentTouchedAxis: 'none',\n                touchedAxis: null,\n                navigationConstraint: 'unconstrained',\n                initialState: null\n            },\n            useManualPan = options.pan.interactive && options.pan.touchMode === 'manual',\n            smartPanLock = options.pan.touchMode === 'smartLock',\n            useSmartPan = options.pan.interactive && (smartPanLock || options.pan.touchMode === 'smart'),\n            pan, pinch, doubleTap;\n\n        function bindEvents(plot, eventHolder) {\n            var o = plot.getOptions();\n\n            if (o.zoom.interactive && o.zoom.enableTouch) {\n                eventHolder[0].addEventListener('pinchstart', pinch.start, false);\n                eventHolder[0].addEventListener('pinchdrag', pinch.drag, false);\n                eventHolder[0].addEventListener('pinchend', pinch.end, false);\n            }\n\n            if (o.pan.interactive && o.pan.enableTouch) {\n                eventHolder[0].addEventListener('panstart', pan.start, false);\n                eventHolder[0].addEventListener('pandrag', pan.drag, false);\n                eventHolder[0].addEventListener('panend', pan.end, false);\n            }\n\n            if ((o.recenter.interactive && o.recenter.enableTouch)) {\n                eventHolder[0].addEventListener('doubletap', doubleTap.recenterPlot, false);\n            }\n        }\n\n        function shutdown(plot, eventHolder) {\n            eventHolder[0].removeEventListener('panstart', pan.start);\n            eventHolder[0].removeEventListener('pandrag', pan.drag);\n            eventHolder[0].removeEventListener('panend', pan.end);\n            eventHolder[0].removeEventListener('pinchstart', pinch.start);\n            eventHolder[0].removeEventListener('pinchdrag', pinch.drag);\n            eventHolder[0].removeEventListener('pinchend', pinch.end);\n            eventHolder[0].removeEventListener('doubletap', doubleTap.recenterPlot);\n        }\n\n        pan = {\n            start: function(e) {\n                presetNavigationState(e, 'pan', gestureState);\n                updateData(e, 'pan', gestureState, navigationState);\n\n                if (useSmartPan) {\n                    var point = getPoint(e, 'pan');\n                    navigationState.initialState = plot.navigationState(point.x, point.y);\n                }\n            },\n\n            drag: function(e) {\n                presetNavigationState(e, 'pan', gestureState);\n\n                if (useSmartPan) {\n                    var point = getPoint(e, 'pan');\n                    plot.smartPan({\n                        x: navigationState.initialState.startPageX - point.x,\n                        y: navigationState.initialState.startPageY - point.y\n                    }, navigationState.initialState, navigationState.touchedAxis, false, smartPanLock);\n                } else if (useManualPan) {\n                    plot.pan({\n                        left: -delta(e, 'pan', gestureState).x,\n                        top: -delta(e, 'pan', gestureState).y,\n                        axes: navigationState.touchedAxis\n                    });\n                    updatePrevPanPosition(e, 'pan', gestureState, navigationState);\n                }\n            },\n\n            end: function(e) {\n                presetNavigationState(e, 'pan', gestureState);\n\n                if (useSmartPan) {\n                    plot.smartPan.end();\n                }\n\n                if (wasPinchEvent(e, gestureState)) {\n                    updateprevPanPosition(e, 'pan', gestureState, navigationState);\n                }\n            }\n        };\n\n        var pinchDragTimeout;\n        pinch = {\n            start: function(e) {\n                if (pinchDragTimeout) {\n                    clearTimeout(pinchDragTimeout);\n                    pinchDragTimeout = null;\n                }\n                presetNavigationState(e, 'pinch', gestureState);\n                setPrevDistance(e, gestureState);\n                updateData(e, 'pinch', gestureState, navigationState);\n            },\n\n            drag: function(e) {\n                if (pinchDragTimeout) {\n                    return;\n                }\n                pinchDragTimeout = setTimeout(function() {\n                    presetNavigationState(e, 'pinch', gestureState);\n                    plot.pan({\n                        left: -delta(e, 'pinch', gestureState).x,\n                        top: -delta(e, 'pinch', gestureState).y,\n                        axes: navigationState.touchedAxis\n                    });\n                    updatePrevPanPosition(e, 'pinch', gestureState, navigationState);\n\n                    var dist = pinchDistance(e);\n\n                    if (gestureState.zoomEnable || Math.abs(dist - gestureState.prevDistance) > ZOOM_DISTANCE_MARGIN) {\n                        zoomPlot(plot, e, gestureState, navigationState);\n\n                        //activate zoom mode\n                        gestureState.zoomEnable = true;\n                    }\n                    pinchDragTimeout = null;\n                }, 1000 / 60);\n            },\n\n            end: function(e) {\n                if (pinchDragTimeout) {\n                    clearTimeout(pinchDragTimeout);\n                    pinchDragTimeout = null;\n                }\n                presetNavigationState(e, 'pinch', gestureState);\n                gestureState.prevDistance = null;\n            }\n        };\n\n        doubleTap = {\n            recenterPlot: function(e) {\n                if (e && e.detail && e.detail.type === 'touchstart') {\n                    // only do not recenter for touch start;\n                    recenterPlotOnDoubleTap(plot, e, gestureState, navigationState);\n                }\n            }\n        };\n\n        if (options.pan.enableTouch === true || options.zoom.enableTouch === true) {\n            plot.hooks.bindEvents.push(bindEvents);\n            plot.hooks.shutdown.push(shutdown);\n        }\n\n        function presetNavigationState(e, gesture, gestureState) {\n            navigationState.touchedAxis = getAxis(plot, e, gesture, navigationState);\n            if (noAxisTouched(navigationState)) {\n                navigationState.navigationConstraint = 'unconstrained';\n            } else {\n                navigationState.navigationConstraint = 'axisConstrained';\n            }\n        }\n    }\n\n    $.plot.plugins.push({\n        init: init,\n        options: options,\n        name: 'navigateTouch',\n        version: '0.3'\n    });\n\n    function recenterPlotOnDoubleTap(plot, e, gestureState, navigationState) {\n        checkAxesForDoubleTap(plot, e, navigationState);\n        if ((navigationState.currentTouchedAxis === 'x' && navigationState.prevTouchedAxis === 'x') ||\n            (navigationState.currentTouchedAxis === 'y' && navigationState.prevTouchedAxis === 'y') ||\n            (navigationState.currentTouchedAxis === 'none' && navigationState.prevTouchedAxis === 'none')) {\n            var event;\n\n            plot.recenter({ axes: navigationState.touchedAxis });\n\n            if (navigationState.touchedAxis) {\n                event = new $.Event('re-center', { detail: { axisTouched: navigationState.touchedAxis } });\n            } else {\n                event = new $.Event('re-center', { detail: e });\n            }\n            plot.getPlaceholder().trigger(event);\n        }\n    }\n\n    function checkAxesForDoubleTap(plot, e, navigationState) {\n        var axis = plot.getTouchedAxis(e.detail.firstTouch.x, e.detail.firstTouch.y);\n        if (axis[0] !== undefined) {\n            navigationState.prevTouchedAxis = axis[0].direction;\n        }\n\n        axis = plot.getTouchedAxis(e.detail.secondTouch.x, e.detail.secondTouch.y);\n        if (axis[0] !== undefined) {\n            navigationState.touchedAxis = axis;\n            navigationState.currentTouchedAxis = axis[0].direction;\n        }\n\n        if (noAxisTouched(navigationState)) {\n            navigationState.touchedAxis = null;\n            navigationState.prevTouchedAxis = 'none';\n            navigationState.currentTouchedAxis = 'none';\n        }\n    }\n\n    function zoomPlot(plot, e, gestureState, navigationState) {\n        var offset = plot.offset(),\n            center = {\n                left: 0,\n                top: 0\n            },\n            zoomAmount = pinchDistance(e) / gestureState.prevDistance,\n            dist = pinchDistance(e);\n\n        center.left = getPoint(e, 'pinch').x - offset.left;\n        center.top = getPoint(e, 'pinch').y - offset.top;\n\n        // send the computed touched axis to the zoom function so that it only zooms on that one\n        plot.zoom({\n            center: center,\n            amount: zoomAmount,\n            axes: navigationState.touchedAxis\n        });\n        gestureState.prevDistance = dist;\n    }\n\n    function wasPinchEvent(e, gestureState) {\n        return (gestureState.zoomEnable && e.detail.touches.length === 1);\n    }\n\n    function getAxis(plot, e, gesture, navigationState) {\n        if (e.type === 'pinchstart') {\n            var axisTouch1 = plot.getTouchedAxis(e.detail.touches[0].pageX, e.detail.touches[0].pageY);\n            var axisTouch2 = plot.getTouchedAxis(e.detail.touches[1].pageX, e.detail.touches[1].pageY);\n\n            if (axisTouch1.length === axisTouch2.length && axisTouch1.toString() === axisTouch2.toString()) {\n                return axisTouch1;\n            }\n        } else if (e.type === 'panstart') {\n            return plot.getTouchedAxis(e.detail.touches[0].pageX, e.detail.touches[0].pageY);\n        } else if (e.type === 'pinchend') {\n            //update axis since instead on pinch, a pan event is made\n            return plot.getTouchedAxis(e.detail.touches[0].pageX, e.detail.touches[0].pageY);\n        } else {\n            return navigationState.touchedAxis;\n        }\n    }\n\n    function noAxisTouched(navigationState) {\n        return (!navigationState.touchedAxis || navigationState.touchedAxis.length === 0);\n    }\n\n    function setPrevDistance(e, gestureState) {\n        gestureState.prevDistance = pinchDistance(e);\n    }\n\n    function updateData(e, gesture, gestureState, navigationState) {\n        var axisDir,\n            point = getPoint(e, gesture);\n\n        switch (navigationState.navigationConstraint) {\n            case 'unconstrained':\n                navigationState.touchedAxis = null;\n                gestureState.prevTapPosition = {\n                    x: gestureState.prevPanPosition.x,\n                    y: gestureState.prevPanPosition.y\n                };\n                gestureState.prevPanPosition = {\n                    x: point.x,\n                    y: point.y\n                };\n                break;\n            case 'axisConstrained':\n                axisDir = navigationState.touchedAxis[0].direction;\n                navigationState.currentTouchedAxis = axisDir;\n                gestureState.prevTapPosition[axisDir] = gestureState.prevPanPosition[axisDir];\n                gestureState.prevPanPosition[axisDir] = point[axisDir];\n                break;\n            default:\n                break;\n        }\n    }\n\n    function distance(x1, y1, x2, y2) {\n        return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n    }\n\n    function pinchDistance(e) {\n        var t1 = e.detail.touches[0],\n            t2 = e.detail.touches[1];\n        return distance(t1.pageX, t1.pageY, t2.pageX, t2.pageY);\n    }\n\n    function updatePrevPanPosition(e, gesture, gestureState, navigationState) {\n        var point = getPoint(e, gesture);\n\n        switch (navigationState.navigationConstraint) {\n            case 'unconstrained':\n                gestureState.prevPanPosition.x = point.x;\n                gestureState.prevPanPosition.y = point.y;\n                break;\n            case 'axisConstrained':\n                gestureState.prevPanPosition[navigationState.currentTouchedAxis] =\n                point[navigationState.currentTouchedAxis];\n                break;\n            default:\n                break;\n        }\n    }\n\n    function delta(e, gesture, gestureState) {\n        var point = getPoint(e, gesture);\n\n        return {\n            x: point.x - gestureState.prevPanPosition.x,\n            y: point.y - gestureState.prevPanPosition.y\n        }\n    }\n\n    function getPoint(e, gesture) {\n        if (gesture === 'pinch') {\n            return {\n                x: (e.detail.touches[0].pageX + e.detail.touches[1].pageX) / 2,\n                y: (e.detail.touches[0].pageY + e.detail.touches[1].pageY) / 2\n            }\n        } else {\n            return {\n                x: e.detail.touches[0].pageX,\n                y: e.detail.touches[0].pageY\n            }\n        }\n    }\n})(jQuery);\n","(function ($) {\n    'use strict';\n    $.plot.uiConstants = {\n        SNAPPING_CONSTANT: 20,\n        PANHINT_LENGTH_CONSTANT: 10,\n        MINOR_TICKS_COUNT_CONSTANT: 4,\n        TICK_LENGTH_CONSTANT: 10,\n        ZOOM_DISTANCE_MARGIN: 25\n    };\n})(jQuery);\n"],"sourceRoot":""}