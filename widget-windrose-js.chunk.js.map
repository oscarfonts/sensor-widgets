{"version":3,"sources":["webpack:///./src/js/sos-data-access.js","webpack:///./src/js/widget/windrose.js"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AACwB;;AAExB;AACA;AACA;;AAEe;AACf,EAAE,4CAAG;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,4CAAG;AACP;;AAEA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;ACjHF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACoC;AACa;AACL;AACN;;AAEtC,iEAAO,CAAC,iDAAU;;AAElB,qBAAqB;;AAEN;AACf,UAAU,sDAAM;AAChB,uCAAuC,sDAAM;AAC7C,oBAAoB,iBAAiB;;AAErC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,IAAI,sDAAM;;AAEV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE,8DAA8D;AAC9D;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,mBAAmB,UAAU,IAAI,kBAAkB;AACnD;AACA,SAAS;AACT,OAAO;;AAEP;AACA;AACA,UAAU,iDAAU;AACpB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC,aAAa;AACb,WAAW;AACX,SAAS;AACT;AACA;AACA,yCAAyC,kBAAkB,kBAAkB,iBAAiB,OAAO,iDAAU,yBAAyB;AACxI,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA,OAAO;AACP;;AAEA;AACA,iBAAiB,gEAAU;AAC3B;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH,CAAC,EAAC","file":"widget-windrose-js.chunk.js","sourcesContent":["/* eslint-disable no-nested-ternary, camelcase */\nimport SOS from './SOS';\n\nconst propertyNames = {};\nconst waitingDescribeResponse = {};\nconst propertyCallbackQueue = {};\n\nexport default (config, redraw, errorHandler) => {\n  SOS.setUrl(config.service);\n\n  function isArray(obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n  }\n\n  function getPropertyName(procedure, id, callback, context) {\n    if (!propertyNames[procedure]) {\n      // Queue callback call\n      if (!propertyCallbackQueue[procedure]) {\n        propertyCallbackQueue[procedure] = [];\n      }\n\n      propertyCallbackQueue[procedure].push({\n        callback,\n        id,\n        context,\n      });\n\n      if (!waitingDescribeResponse[procedure]) {\n        waitingDescribeResponse[procedure] = true;\n        // Trigger a DescribeSensor, cache all property names for this procedure\n        SOS.describeSensor(procedure, (description) => {\n          let properties = Object.prototype.hasOwnProperty.call(description, 'ProcessModel')\n            ? description.ProcessModel.outputs.OutputList.output\n            : description.System.outputs.OutputList.output;\n          properties = properties instanceof Array ? properties : [properties];\n          const types = ['Quantity', 'Count', 'Boolean', 'Category', 'Text', 'ObservableProperty'];\n\n          const names = [];\n          Object.values(properties).forEach((property) => {\n            Object.values(types).forEach((type) => {\n              if (Object.prototype.hasOwnProperty.call(property, type)) {\n                // eslint-disable-next-line no-param-reassign\n                property.id = property[type].definition;\n              }\n            });\n            names[property.id] = property.name;\n          });\n          propertyNames[procedure] = names;\n\n          // Clear propertyCallbackQueue\n          while (propertyCallbackQueue[procedure].length) {\n            const elem = propertyCallbackQueue[procedure].shift();\n            elem.callback.call(undefined, propertyNames[procedure][elem.id], elem.context);\n          }\n        }, errorHandler);\n      }\n    } else {\n      callback(propertyNames[procedure][id], context);\n    }\n  }\n\n  function parse(observations) {\n    if (!observations.length) {\n      redraw([]);\n    }\n\n    // Get tabular data from observations\n    const data = [];\n\n    function addObservation(property, observation) {\n      const foi = observation.featureOfInterest;\n      data.push({\n        time: new Date(observation.resultTime),\n        value: Object.prototype.hasOwnProperty.call(observation.result, 'value') ? observation.result.value : observation.result,\n        feature: foi.name ? foi.name.value : (foi.identifier ? foi.identifier.value : foi),\n        property,\n        uom: Object.prototype.hasOwnProperty.call(observation.result, 'uom') ? observation.result.uom : '(N/A)',\n      });\n      if (data.length === observations.length) {\n        redraw(data);\n      }\n    }\n    Object.values(observations).forEach((observation) => {\n      getPropertyName(observation.procedure, observation.observableProperty,\n        addObservation, observation);\n    });\n  }\n\n  function read() {\n    const {\n      offering, feature, property, features, properties, time_start, time_end,\n    } = config;\n    const getFeatures = feature\n      ? [feature]\n      : isArray(features)\n        ? features\n        : features\n          ? JSON.parse(features)\n          : undefined;\n    const getProperties = property\n      ? [property]\n      : isArray(properties)\n        ? properties\n        : properties\n          ? JSON.parse(properties)\n          : undefined;\n    const time = (time_start && time_end) ? [time_start, time_end] : 'latest';\n    SOS.getObservation(offering, getFeatures, getProperties, time, parse, errorHandler);\n  }\n\n  return {\n    read,\n  };\n};\n","/* eslint-disable no-param-reassign */\nimport Highcharts from 'highcharts';\nimport addMore from 'highcharts/highcharts-more';\nimport dataAccess from '../sos-data-access';\nimport common from '../widget-common';\n\naddMore(Highcharts);\n\nconst labels = ['&gt; 10 m/s', '8-10 m/s', '6-8 m/s', '4-6 m/s', '2-4 m/s', '0-2 m/s'];\n\nexport default {\n  inputs: common.inputs.concat(['feature', 'properties', 'time_start', 'time_end', 'refresh_interval', 'title']),\n  optional_inputs: ['subtitle'].concat(common.optional_inputs),\n  preferredSizes: [{ w: 620, h: 450 }],\n\n  init(config, el, errorHandler) {\n    // Main div\n    const mainDiv = document.createElement('div');\n    mainDiv.className = 'windrose widget';\n\n    // Chart div\n    const chart = document.createElement('div');\n    mainDiv.appendChild(chart);\n\n    // Add footnote element\n    const footnoteDiv = document.createElement('div');\n    const footnoteSpan = document.createElement('span');\n    footnoteSpan.className = 'footnote';\n    footnoteDiv.appendChild(footnoteSpan);\n    mainDiv.appendChild(footnoteDiv);\n\n    el.appendChild(mainDiv);\n\n    // load widget common features\n    common.init(config, el, errorHandler);\n\n    function redraw(data) {\n      const arr = [];\n      Object.keys(data).forEach((i) => {\n        const measure = data[i];\n\n        // Build a sparse array where index is timestamp, and member is a 2-element array\n        // First element is wind speed, second element is wind direction\n        const timestamp = measure.time.getTime();\n        const magnitude = measure.uom === 'ยบ' ? 1 : 0;\n\n        if (!arr[timestamp]) {\n          arr[timestamp] = [];\n        }\n        arr[timestamp][magnitude] = measure.value;\n      });\n\n      // Build a matrix where first index is speed range, and second is direction\n      const slots = [];\n      while (slots.length < 6) {\n        const dirs = [];\n        while (dirs.push(null) < 16) {\n          // do nothing\n        }\n        slots.push(dirs);\n      }\n\n      // Sum the number of observations for each speed+direction slot\n      let n = 0;\n      Object.keys(arr).forEach((i) => {\n        const values = arr[i];\n        if (values.length === 2) {\n          const speed = 5 - Math.min(Math.floor(values[0] / 2), 5); // Speed slot - from 0 to 5\n          const direction = Math.round(values[1] / 22.5) % 16; // Direction slot - from 0 to 15\n          if (!slots[speed][direction]) {\n            slots[speed][direction] = 1;\n          } else {\n            slots[speed][direction] += 1;\n          }\n          n += 1;\n        }\n      });\n\n      // Convert from sample count to percentage\n      // Generate legend\n      const series = [];\n      Object.keys(slots).forEach((i) => {\n        let total = 0;\n        Object.keys(slots[i]).forEach((j) => {\n          slots[i][j] = (slots[i][j] * 100) / n;\n          total += slots[i][j];\n        });\n        series.push({\n          name: `${labels[i]} (${Math.round(total)}%)`,\n          data: slots[i],\n        });\n      });\n\n      // Finally, generate the chart\n      // eslint-disable-next-line no-new\n      new Highcharts.Chart({\n        chart: {\n          type: 'column',\n          polar: true,\n          renderTo: chart,\n        },\n        title: {\n          text: config.title,\n        },\n        subtitle: {\n          text: config.subtitle,\n        },\n        pane: {\n          size: '85%',\n        },\n        legend: {\n          align: 'right',\n          verticalAlign: 'top',\n          y: 100,\n          layout: 'vertical',\n        },\n        xAxis: {\n          tickmarkPlacement: 'on',\n          categories: ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'],\n        },\n        yAxis: {\n          min: 0,\n          endOnTick: false,\n          showLastLabel: true,\n          labels: {\n            formatter() {\n              return `${this.value} %`;\n            },\n          },\n        },\n        tooltip: {\n          formatter() {\n            return `<span style=\"color:${this.series.color}\">\\u25CF</span> ${this.series.name}: <b>${Highcharts.numberFormat(this.y, 1)} %</b><br/>`;\n          },\n        },\n        plotOptions: {\n          series: {\n            stacking: 'normal',\n            shadow: false,\n            groupPadding: 0,\n            pointPlacement: 'on',\n          },\n        },\n        colors: ['#BD0BC9', '#C9170B', '#C9760B', '#BDC90B', '#0BC917', '#0BBDC9'],\n        series,\n      });\n    }\n\n    // Setup SOS data access\n    const data = dataAccess(config, redraw);\n    const refreshIntervalId = setInterval(data.read, config.refresh_interval * 1000);\n    data.read();\n\n    return {\n      destroy() {\n        clearInterval(refreshIntervalId);\n      },\n    };\n  },\n};\n"],"sourceRoot":""}