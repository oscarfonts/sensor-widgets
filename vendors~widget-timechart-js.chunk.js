(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors~widget-timechart-js"],{

/***/ "./node_modules/flot-plugins/dist/source/misc/jquery.flot.tooltip.js":
/*!***************************************************************************!*\
  !*** ./node_modules/flot-plugins/dist/source/misc/jquery.flot.tooltip.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
 * jquery.flot.tooltip
 * 
 * description: easy-to-use tooltips for Flot charts
 * version: 0.9.0
 * authors: Krzysztof Urbas @krzysu [myviews.pl],Evan Steinkerchner @Roundaround
 * website: https://github.com/krzysu/flot.tooltip
 * 
 * build on 2016-07-26
 * released under MIT License, 2012
*/ 
(function ($) {
    // plugin options, default values
    var defaultOptions = {
        tooltip: {
            show: false,
            cssClass: "flotTip",
            content: "%s | X: %x | Y: %y",
            // allowed templates are:
            // %s -> series label,
            // %c -> series color,
            // %lx -> x axis label (requires flot-axislabels plugin https://github.com/markrcote/flot-axislabels),
            // %ly -> y axis label (requires flot-axislabels plugin https://github.com/markrcote/flot-axislabels),
            // %x -> X value,
            // %y -> Y value,
            // %x.2 -> precision of X value,
            // %p -> percent
            // %n -> value (not percent) of pie chart
            xDateFormat: null,
            yDateFormat: null,
            monthNames: null,
            dayNames: null,
            shifts: {
                x: 10,
                y: 20
            },
            defaultTheme: true,
            snap: true,
            lines: false,
            clickTips: false,

            // callbacks
            onHover: function (flotItem, $tooltipEl) {},

            $compat: false
        }
    };

    // dummy default options object for legacy code (<0.8.5) - is deleted later
    defaultOptions.tooltipOpts = defaultOptions.tooltip;

    // object
    var FlotTooltip = function (plot) {
        // variables
        this.tipPosition = {x: 0, y: 0};

        this.init(plot);
    };

    // main plugin function
    FlotTooltip.prototype.init = function (plot) {
        var that = this;

        // detect other flot plugins
        var plotPluginsLength = $.plot.plugins.length;
        this.plotPlugins = [];

        if (plotPluginsLength) {
            for (var p = 0; p < plotPluginsLength; p++) {
                this.plotPlugins.push($.plot.plugins[p].name);
            }
        }

        plot.hooks.bindEvents.push(function (plot, eventHolder) {

            // get plot options
            that.plotOptions = plot.getOptions();

            // for legacy (<0.8.5) implementations
            if (typeof(that.plotOptions.tooltip) === 'boolean') {
                that.plotOptions.tooltipOpts.show = that.plotOptions.tooltip;
                that.plotOptions.tooltip = that.plotOptions.tooltipOpts;
                delete that.plotOptions.tooltipOpts;
            }

            // if not enabled return
            if (that.plotOptions.tooltip.show === false || typeof that.plotOptions.tooltip.show === 'undefined') return;

            // shortcut to access tooltip options
            that.tooltipOptions = that.plotOptions.tooltip;

            if (that.tooltipOptions.$compat) {
                that.wfunc = 'width';
                that.hfunc = 'height';
            } else {
                that.wfunc = 'innerWidth';
                that.hfunc = 'innerHeight';
            }

            // create tooltip DOM element
            var $tip = that.getDomElement();

            // bind event
            $( plot.getPlaceholder() ).bind("plothover", plothover);
            if (that.tooltipOptions.clickTips) {
                $( plot.getPlaceholder() ).bind("plotclick", plotclick);
            }
            that.clickmode = false;

            $(eventHolder).bind('mousemove', mouseMove);
        });

        plot.hooks.shutdown.push(function (plot, eventHolder){
            $(plot.getPlaceholder()).unbind("plothover", plothover);
            $(plot.getPlaceholder()).unbind("plotclick", plotclick);
            plot.removeTooltip();
            $(eventHolder).unbind("mousemove", mouseMove);
        });

        function mouseMove(e){
            var pos = {};
            pos.x = e.pageX;
            pos.y = e.pageY;
            plot.setTooltipPosition(pos);
        }

        /**
         *  open the tooltip (if not already open) and freeze it on the current position till the next click
         */
        function plotclick(event, pos, item) {
            if (! that.clickmode) {
                // it is the click activating the clicktip
                plothover(event, pos, item);
                if (that.getDomElement().is(":visible")) {
                    $(plot.getPlaceholder()).unbind("plothover", plothover);
                    that.clickmode = true;
                }
            } else {
                // it is the click deactivating the clicktip
                $( plot.getPlaceholder() ).bind("plothover", plothover);
                plot.hideTooltip();
                that.clickmode = false;
            }
        }

        function plothover(event, pos, item) {
            // Simple distance formula.
            var lineDistance = function (p1x, p1y, p2x, p2y) {
                return Math.sqrt((p2x - p1x) * (p2x - p1x) + (p2y - p1y) * (p2y - p1y));
            };

            // Here is some voodoo magic for determining the distance to a line form a given point {x, y}.
            var dotLineLength = function (x, y, x0, y0, x1, y1, o) {
                if (o && !(o =
                    function (x, y, x0, y0, x1, y1) {
                        if (typeof x0 !== 'undefined') return { x: x0, y: y };
                        else if (typeof y0 !== 'undefined') return { x: x, y: y0 };

                        var left,
                            tg = -1 / ((y1 - y0) / (x1 - x0));

                        return {
                            x: left = (x1 * (x * tg - y + y0) + x0 * (x * -tg + y - y1)) / (tg * (x1 - x0) + y0 - y1),
                            y: tg * left - tg * x + y
                        };
                    } (x, y, x0, y0, x1, y1),
                    o.x >= Math.min(x0, x1) && o.x <= Math.max(x0, x1) && o.y >= Math.min(y0, y1) && o.y <= Math.max(y0, y1))
                ) {
                    var l1 = lineDistance(x, y, x0, y0), l2 = lineDistance(x, y, x1, y1);
                    return l1 > l2 ? l2 : l1;
                } else {
                    var a = y0 - y1, b = x1 - x0, c = x0 * y1 - y0 * x1;
                    return Math.abs(a * x + b * y + c) / Math.sqrt(a * a + b * b);
                }
            };

            if (item && !isNaN(item.dataIndex)) {
                plot.showTooltip(item, that.tooltipOptions.snap ? item : pos);
            } else if (that.plotOptions.series.lines.show && that.tooltipOptions.lines === true) {
                var maxDistance = that.plotOptions.grid.mouseActiveRadius;

                var closestTrace = {
                    distance: maxDistance + 1
                };

                var ttPos = pos;

                $.each(plot.getData(), function (i, series) {
                    var xBeforeIndex = 0,
                        xAfterIndex = -1;

                    // Our search here assumes our data is sorted via the x-axis.
                    // TODO: Improve efficiency somehow - search smaller sets of data.
                    for (var j = 1; j < series.data.length; j++) {
                        if (series.data[j - 1][0] <= pos.x && series.data[j][0] >= pos.x) {
                            xBeforeIndex = j - 1;
                            xAfterIndex = j;
                        }
                    }

                    if (xAfterIndex === -1) {
                        plot.hideTooltip();
                        return;
                    }

                    var pointPrev = { x: series.data[xBeforeIndex][0], y: series.data[xBeforeIndex][1] },
                        pointNext = { x: series.data[xAfterIndex][0], y: series.data[xAfterIndex][1] };

                    var distToLine = dotLineLength(series.xaxis.p2c(pos.x), series.yaxis.p2c(pos.y), series.xaxis.p2c(pointPrev.x),
                        series.yaxis.p2c(pointPrev.y), series.xaxis.p2c(pointNext.x), series.yaxis.p2c(pointNext.y), false);

                    if (distToLine < closestTrace.distance) {

                        var closestIndex = lineDistance(pointPrev.x, pointPrev.y, pos.x, pos.y) <
                            lineDistance(pos.x, pos.y, pointNext.x, pointNext.y) ? xBeforeIndex : xAfterIndex;

                        var pointSize = series.datapoints.pointsize;

                        // Calculate the point on the line vertically closest to our cursor.
                        var pointOnLine = [
                            pos.x,
                            pointPrev.y + ((pointNext.y - pointPrev.y) * ((pos.x - pointPrev.x) / (pointNext.x - pointPrev.x)))
                        ];

                        var item = {
                            datapoint: pointOnLine,
                            dataIndex: closestIndex,
                            series: series,
                            seriesIndex: i
                        };

                        closestTrace = {
                            distance: distToLine,
                            item: item
                        };

                        if (that.tooltipOptions.snap) {
                            ttPos = {
                                pageX: series.xaxis.p2c(pointOnLine[0]),
                                pageY: series.yaxis.p2c(pointOnLine[1])
                            };
                        }
                    }
                });

                if (closestTrace.distance < maxDistance + 1)
                    plot.showTooltip(closestTrace.item, ttPos);
                else
                    plot.hideTooltip();
            } else {
                plot.hideTooltip();
            }
        }

        // Quick little function for setting the tooltip position.
        plot.setTooltipPosition = function (pos) {
            var $tip = that.getDomElement();

            var totalTipWidth = $tip.outerWidth() + that.tooltipOptions.shifts.x;
            var totalTipHeight = $tip.outerHeight() + that.tooltipOptions.shifts.y;
            if ((pos.x - $(window).scrollLeft()) > ($(window)[that.wfunc]() - totalTipWidth)) {
                pos.x -= totalTipWidth;
                pos.x = Math.max(pos.x, 0);
            }
            if ((pos.y - $(window).scrollTop()) > ($(window)[that.hfunc]() - totalTipHeight)) {
                pos.y -= totalTipHeight;
            }

	    /*
	       The section applies the new positioning ONLY if pos.x and pos.y
	       are numbers. If they are undefined or not a number, use the last
	       known numerical position. This hack fixes a bug that kept pie
	       charts from keeping their tooltip positioning.
	     */

            if (isNaN(pos.x)) {
		that.tipPosition.x = that.tipPosition.xPrev;
	    }
	    else {
		that.tipPosition.x = pos.x;
		that.tipPosition.xPrev = pos.x;
	    }
	    if (isNaN(pos.y)) {
		that.tipPosition.y = that.tipPosition.yPrev;
	    }
	    else {
		that.tipPosition.y = pos.y;
		that.tipPosition.yPrev = pos.y;
	    }

        };

        // Quick little function for showing the tooltip.
        plot.showTooltip = function (target, position, targetPosition) {
            var $tip = that.getDomElement();

            // convert tooltip content template to real tipText
            var tipText = that.stringFormat(that.tooltipOptions.content, target);
            if (tipText === '')
                return;

            $tip.html(tipText);
            plot.setTooltipPosition({ x: that.tipPosition.x, y: that.tipPosition.y });
            $tip.css({
                left: that.tipPosition.x + that.tooltipOptions.shifts.x,
                top: that.tipPosition.y + that.tooltipOptions.shifts.y
            }).show();

            // run callback
            if (typeof that.tooltipOptions.onHover === 'function') {
                that.tooltipOptions.onHover(target, $tip);
            }
        };

        // Quick little function for hiding the tooltip.
        plot.hideTooltip = function () {
            that.getDomElement().hide().html('');
        };

        plot.removeTooltip = function() {
            that.getDomElement().remove();
        };
    };

    /**
     * get or create tooltip DOM element
     * @return jQuery object
     */
    FlotTooltip.prototype.getDomElement = function () {
        var $tip = $('<div>');
        if (this.tooltipOptions && this.tooltipOptions.cssClass) {
            $tip = $('.' + this.tooltipOptions.cssClass);

            if( $tip.length === 0 ){
                $tip = $('<div />').addClass(this.tooltipOptions.cssClass);
                $tip.appendTo('body').hide().css({position: 'absolute'});

                if(this.tooltipOptions.defaultTheme) {
                    $tip.css({
                        'background': '#fff',
                        'z-index': '1040',
                        'padding': '0.4em 0.6em',
                        'border-radius': '0.5em',
                        'font-size': '0.8em',
                        'border': '1px solid #111',
                        'display': 'none',
                        'white-space': 'nowrap'
                    });
                }
            }
        }

        return $tip;
    };

    /**
     * core function, create tooltip content
     * @param  {string} content - template with tooltip content
     * @param  {object} item - Flot item
     * @return {string} real tooltip content for current item
     */
    FlotTooltip.prototype.stringFormat = function (content, item) {
        var percentPattern = /%p\.{0,1}(\d{0,})/;
        var seriesPattern = /%s/;
        var colorPattern = /%c/;
        var xLabelPattern = /%lx/; // requires flot-axislabels plugin https://github.com/markrcote/flot-axislabels, will be ignored if plugin isn't loaded
        var yLabelPattern = /%ly/; // requires flot-axislabels plugin https://github.com/markrcote/flot-axislabels, will be ignored if plugin isn't loaded
        var xPattern = /%x\.{0,1}(\d{0,})/;
        var yPattern = /%y\.{0,1}(\d{0,})/;
        var xPatternWithoutPrecision = "%x";
        var yPatternWithoutPrecision = "%y";
        var customTextPattern = "%ct";
	var nPiePattern = "%n";

        var x, y, customText, p, n;

        // for threshold plugin we need to read data from different place
        if (typeof item.series.threshold !== "undefined") {
            x = item.datapoint[0];
            y = item.datapoint[1];
            customText = item.datapoint[2];
	}

	// for CurvedLines plugin we need to read data from different place
	    else if (typeof item.series.curvedLines !== "undefined") {
		x = item.datapoint[0];
		y = item.datapoint[1];
	    }

        else if (typeof item.series.lines !== "undefined" && item.series.lines.steps) {
            x = item.series.datapoints.points[item.dataIndex * 2];
            y = item.series.datapoints.points[item.dataIndex * 2 + 1];
            // TODO: where to find custom text in this variant?
            customText = "";
        } else {
            x = item.series.data[item.dataIndex][0];
            y = item.series.data[item.dataIndex][1];
            customText = item.series.data[item.dataIndex][2];
        }

        // I think this is only in case of threshold plugin
        if (item.series.label === null && item.series.originSeries) {
            item.series.label = item.series.originSeries.label;
        }

        // if it is a function callback get the content string
        if (typeof(content) === 'function') {
            content = content(item.series.label, x, y, item);
        }

        // the case where the passed content is equal to false
        if (typeof(content) === 'boolean' && !content) {
            return '';
        }

        /* replacement of %ct and other multi-character templates must
           precede the replacement of single-character templates
           to avoid conflict between '%c' and '%ct'  and similar substrings
        */
        if (customText) {
            content = content.replace(customTextPattern, customText);
        }

        // percent match for pie charts and stacked percent
        if (typeof (item.series.percent) !== 'undefined') {
            p = item.series.percent;
        } else if (typeof (item.series.percents) !== 'undefined') {
            p = item.series.percents[item.dataIndex];
        }
        if (typeof p === 'number') {
            content = this.adjustValPrecision(percentPattern, content, p);
        }

        // replace %n with number of items represented by slice in pie charts
        if (item.series.hasOwnProperty('pie')) {
            if (typeof item.series.data[0][1] !== 'undefined') {
                n = item.series.data[0][1];
            }
        }
        if (typeof n === 'number') {
            content = content.replace(nPiePattern, n);
        }

        // series match
        if (typeof(item.series.label) !== 'undefined') {
            content = content.replace(seriesPattern, item.series.label);
        } else {
            //remove %s if label is undefined
            content = content.replace(seriesPattern, "");
        }

        // color match
        if (typeof(item.series.color) !== 'undefined') {
            content = content.replace(colorPattern, item.series.color);
        } else {
            //remove %s if color is undefined
            content = content.replace(colorPattern, "");
        }

        // x axis label match
        if (this.hasAxisLabel('xaxis', item)) {
            content = content.replace(xLabelPattern, item.series.xaxis.options.axisLabel);
        } else {
            //remove %lx if axis label is undefined or axislabels plugin not present
            content = content.replace(xLabelPattern, "");
        }

        // y axis label match
        if (this.hasAxisLabel('yaxis', item)) {
            content = content.replace(yLabelPattern, item.series.yaxis.options.axisLabel);
        } else {
            //remove %ly if axis label is undefined or axislabels plugin not present
            content = content.replace(yLabelPattern, "");
        }

        // time mode axes with custom dateFormat
        if (this.isTimeMode('xaxis', item) && this.isXDateFormat(item)) {
            content = content.replace(xPattern, this.timestampToDate(x, this.tooltipOptions.xDateFormat, item.series.xaxis.options));
        }
        if (this.isTimeMode('yaxis', item) && this.isYDateFormat(item)) {
            content = content.replace(yPattern, this.timestampToDate(y, this.tooltipOptions.yDateFormat, item.series.yaxis.options));
        }

        // set precision if defined
        if (typeof x === 'number') {
            content = this.adjustValPrecision(xPattern, content, x);
        }
        if (typeof y === 'number') {
            content = this.adjustValPrecision(yPattern, content, y);
        }

        // change x from number to given label, if given
        if (typeof item.series.xaxis.ticks !== 'undefined') {

            var ticks;
            if (this.hasRotatedXAxisTicks(item)) {
                // xaxis.ticks will be an empty array if tickRotor is being used, but the values are available in rotatedTicks
                ticks = 'rotatedTicks';
            } else {
                ticks = 'ticks';
            }

            // see https://github.com/krzysu/flot.tooltip/issues/65
            var tickIndex = item.dataIndex + item.seriesIndex;

            for (var xIndex in item.series.xaxis[ticks]) {
                if (item.series.xaxis[ticks].hasOwnProperty(tickIndex) && !this.isTimeMode('xaxis', item)) {
                    var valueX = (this.isCategoriesMode('xaxis', item)) ? item.series.xaxis[ticks][tickIndex].label : item.series.xaxis[ticks][tickIndex].v;
                    if (valueX === x) {
                        content = content.replace(xPattern, item.series.xaxis[ticks][tickIndex].label.replace(/\$/g, '$$$$'));
                    }
                }
            }
        }

        // change y from number to given label, if given
        if (typeof item.series.yaxis.ticks !== 'undefined') {
            for (var yIndex in item.series.yaxis.ticks) {
                if (item.series.yaxis.ticks.hasOwnProperty(yIndex)) {
                    var valueY = (this.isCategoriesMode('yaxis', item)) ? item.series.yaxis.ticks[yIndex].label : item.series.yaxis.ticks[yIndex].v;
                    if (valueY === y) {
                        content = content.replace(yPattern, item.series.yaxis.ticks[yIndex].label.replace(/\$/g, '$$$$'));
                    }
                }
            }
        }

        // if no value customization, use tickFormatter by default
        if (typeof item.series.xaxis.tickFormatter !== 'undefined') {
            //escape dollar
            content = content.replace(xPatternWithoutPrecision, item.series.xaxis.tickFormatter(x, item.series.xaxis).replace(/\$/g, '$$'));
        }
        if (typeof item.series.yaxis.tickFormatter !== 'undefined') {
            //escape dollar
            content = content.replace(yPatternWithoutPrecision, item.series.yaxis.tickFormatter(y, item.series.yaxis).replace(/\$/g, '$$'));
        }

        return content;
    };

    // helpers just for readability
    FlotTooltip.prototype.isTimeMode = function (axisName, item) {
        return (typeof item.series[axisName].options.mode !== 'undefined' && item.series[axisName].options.mode === 'time');
    };

    FlotTooltip.prototype.isXDateFormat = function (item) {
        return (typeof this.tooltipOptions.xDateFormat !== 'undefined' && this.tooltipOptions.xDateFormat !== null);
    };

    FlotTooltip.prototype.isYDateFormat = function (item) {
        return (typeof this.tooltipOptions.yDateFormat !== 'undefined' && this.tooltipOptions.yDateFormat !== null);
    };

    FlotTooltip.prototype.isCategoriesMode = function (axisName, item) {
        return (typeof item.series[axisName].options.mode !== 'undefined' && item.series[axisName].options.mode === 'categories');
    };

    //
    FlotTooltip.prototype.timestampToDate = function (tmst, dateFormat, options) {
        var theDate = $.plot.dateGenerator(tmst, options);
        return $.plot.formatDate(theDate, dateFormat, this.tooltipOptions.monthNames, this.tooltipOptions.dayNames);
    };

    //
    FlotTooltip.prototype.adjustValPrecision = function (pattern, content, value) {

        var precision;
        var matchResult = content.match(pattern);
        if( matchResult !== null ) {
            if(RegExp.$1 !== '') {
                precision = RegExp.$1;
                value = value.toFixed(precision);

                // only replace content if precision exists, in other case use thickformater
                content = content.replace(pattern, value);
            }
        }
        return content;
    };

    // other plugins detection below

    // check if flot-axislabels plugin (https://github.com/markrcote/flot-axislabels) is used and that an axis label is given
    FlotTooltip.prototype.hasAxisLabel = function (axisName, item) {
        return ($.inArray('axisLabels', this.plotPlugins) !== -1 && typeof item.series[axisName].options.axisLabel !== 'undefined' && item.series[axisName].options.axisLabel.length > 0);
    };

    // check whether flot-tickRotor, a plugin which allows rotation of X-axis ticks, is being used
    FlotTooltip.prototype.hasRotatedXAxisTicks = function (item) {
        return ($.inArray('tickRotor',this.plotPlugins) !== -1 && typeof item.series.xaxis.rotatedTicks !== 'undefined');
    };

    //
    var init = function (plot) {
      new FlotTooltip(plot);
    };

    // define Flot plugin
    $.plot.plugins.push({
        init: init,
        options: defaultOptions,
        name: 'tooltip',
        version: '0.8.5'
    });

})(jQuery);


/***/ }),

/***/ "./node_modules/flot/lib/jquery.mousewheel.js":
/*!****************************************************!*\
  !*** ./node_modules/flot/lib/jquery.mousewheel.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Source: https://github.com/jquery/jquery-mousewheel/blob/a06ef4e1a127795606642c55e22d4f2945edc061/jquery.mousewheel.js

/*! Copyright (c) 2011 Brandon Aaron (http://brandonaaron.net)
 * Licensed under the MIT License (LICENSE.txt).
 *
 * Thanks to: http://adomas.org/javascript-mouse-wheel/ for some pointers.
 * Thanks to: Mathias Bank(http://www.mathias-bank.de) for a scope bug fix.
 * Thanks to: Seamus Leahy for adding deltaX and deltaY
 *
 * Version: 3.0.6
 *
 * Requires: 1.2.2+
 */

(function($) {

var types = ['DOMMouseScroll', 'mousewheel'];

if ($.event.fixHooks) {
    for ( var i=types.length; i; ) {
        $.event.fixHooks[ types[--i] ] = $.event.mouseHooks;
    }
}

$.event.special.mousewheel = {
    setup: function() {
        if ( this.addEventListener ) {
            for ( var i=types.length; i; ) {
                this.addEventListener( types[--i], handler, false );
            }
        } else {
            this.onmousewheel = handler;
        }
    },

    teardown: function() {
        if ( this.removeEventListener ) {
            for ( var i=types.length; i; ) {
                this.removeEventListener( types[--i], handler, false );
            }
        } else {
            this.onmousewheel = null;
        }
    }
};

$.fn.extend({
    mousewheel: function(fn) {
        return fn ? this.bind("mousewheel", fn) : this.trigger("mousewheel");
    },

    unmousewheel: function(fn) {
        return this.unbind("mousewheel", fn);
    }
});


function handler(event) {
    var orgEvent = event || window.event, args = [].slice.call( arguments, 1 ), delta = 0, returnValue = true, deltaX = 0, deltaY = 0;
    event = $.event.fix(orgEvent);
    event.type = "mousewheel";

    // Old school scrollwheel delta
    if ( orgEvent.wheelDelta ) { delta = orgEvent.wheelDelta/120; }
    if ( orgEvent.detail     ) { delta = -orgEvent.detail/3; }

    // New school multidimensional scroll (touchpads) deltas
    deltaY = delta;

    // Gecko
    if ( orgEvent.axis !== undefined && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {
        deltaY = 0;
        deltaX = -1*delta;
    }

    // Webkit
    if ( orgEvent.wheelDeltaY !== undefined ) { deltaY = orgEvent.wheelDeltaY/120; }
    if ( orgEvent.wheelDeltaX !== undefined ) { deltaX = -1*orgEvent.wheelDeltaX/120; }

    // Add event and delta to the front of the arguments
    args.unshift(event, delta, deltaX, deltaY);

    return ($.event.dispatch || $.event.handle).apply(this, args);
}

})(jQuery);


/***/ }),

/***/ "./node_modules/flot/source/jquery.canvaswrapper.js":
/*!**********************************************************!*\
  !*** ./node_modules/flot/source/jquery.canvaswrapper.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** ## jquery.flot.canvaswrapper

This plugin contains the function for creating and manipulating both the canvas
layers and svg layers.

The Canvas object is a wrapper around an HTML5 canvas tag.
The constructor Canvas(cls, container) takes as parameters cls,
the list of classes to apply to the canvas adnd the containter,
element onto which to append the canvas. The canvas operations
don't work unless the canvas is attached to the DOM.

### jquery.canvaswrapper.js API functions
*/

(function($) {
    var Canvas = function(cls, container) {
        var element = container.getElementsByClassName(cls)[0];

        if (!element) {
            element = document.createElement('canvas');
            element.className = cls;
            element.style.direction = 'ltr';
            element.style.position = 'absolute';
            element.style.left = '0px';
            element.style.top = '0px';

            container.appendChild(element);

            // If HTML5 Canvas isn't available, throw

            if (!element.getContext) {
                throw new Error('Canvas is not available.');
            }
        }

        this.element = element;

        var context = this.context = element.getContext('2d');
        this.pixelRatio = $.plot.browser.getPixelRatio(context);

        // Size the canvas to match the internal dimensions of its container
        var width = $(container).width();
        var height = $(container).height();
        this.resize(width, height);

        // Collection of HTML div layers for text overlaid onto the canvas

        this.SVGContainer = null;
        this.SVG = {};

        // Cache of text fragments and metrics, so we can avoid expensively
        // re-calculating them when the plot is re-rendered in a loop.

        this._textCache = {};
    }

    /**
    - resize(width, height)

     Resizes the canvas to the given dimensions.
     The width represents the new width of the canvas, meanwhile the height
     is the new height of the canvas, both of them in pixels.
    */

    Canvas.prototype.resize = function(width, height) {
        var minSize = 10;
        width = width < minSize ? minSize : width;
        height = height < minSize ? minSize : height;

        var element = this.element,
            context = this.context,
            pixelRatio = this.pixelRatio;

        // Resize the canvas, increasing its density based on the display's
        // pixel ratio; basically giving it more pixels without increasing the
        // size of its element, to take advantage of the fact that retina
        // displays have that many more pixels in the same advertised space.

        // Resizing should reset the state (excanvas seems to be buggy though)

        if (this.width !== width) {
            element.width = width * pixelRatio;
            element.style.width = width + 'px';
            this.width = width;
        }

        if (this.height !== height) {
            element.height = height * pixelRatio;
            element.style.height = height + 'px';
            this.height = height;
        }

        // Save the context, so we can reset in case we get replotted.  The
        // restore ensure that we're really back at the initial state, and
        // should be safe even if we haven't saved the initial state yet.

        context.restore();
        context.save();

        // Scale the coordinate space to match the display density; so even though we
        // may have twice as many pixels, we still want lines and other drawing to
        // appear at the same size; the extra pixels will just make them crisper.

        context.scale(pixelRatio, pixelRatio);
    };

    /**
    - clear()

     Clears the entire canvas area, not including any overlaid HTML text
    */
    Canvas.prototype.clear = function() {
        this.context.clearRect(0, 0, this.width, this.height);
    };

    /**
    - render()

     Finishes rendering the canvas, including managing the text overlay.
    */
    Canvas.prototype.render = function() {
        var cache = this._textCache;

        // For each text layer, add elements marked as active that haven't
        // already been rendered, and remove those that are no longer active.

        for (var layerKey in cache) {
            if (hasOwnProperty.call(cache, layerKey)) {
                var layer = this.getSVGLayer(layerKey),
                    layerCache = cache[layerKey];

                var display = layer.style.display;
                layer.style.display = 'none';

                for (var styleKey in layerCache) {
                    if (hasOwnProperty.call(layerCache, styleKey)) {
                        var styleCache = layerCache[styleKey];
                        for (var key in styleCache) {
                            if (hasOwnProperty.call(styleCache, key)) {
                                var val = styleCache[key],
                                    positions = val.positions;

                                for (var i = 0, position; positions[i]; i++) {
                                    position = positions[i];
                                    if (position.active) {
                                        if (!position.rendered) {
                                            layer.appendChild(position.element);
                                            position.rendered = true;
                                        }
                                    } else {
                                        positions.splice(i--, 1);
                                        if (position.rendered) {
                                            while (position.element.firstChild) {
                                                position.element.removeChild(position.element.firstChild);
                                            }
                                            position.element.parentNode.removeChild(position.element);
                                        }
                                    }
                                }

                                if (positions.length === 0) {
                                    if (val.measured) {
                                        val.measured = false;
                                    } else {
                                        delete styleCache[key];
                                    }
                                }
                            }
                        }
                    }
                }

                layer.style.display = display;
            }
        }
    };

    /**
    - getSVGLayer(classes)

     Creates (if necessary) and returns the SVG overlay container.
     The classes string represents the string of space-separated CSS classes
     used to uniquely identify the text layer. It return the svg-layer div.
    */
    Canvas.prototype.getSVGLayer = function(classes) {
        var layer = this.SVG[classes];

        // Create the SVG layer if it doesn't exist

        if (!layer) {
            // Create the svg layer container, if it doesn't exist

            var svgElement;

            if (!this.SVGContainer) {
                this.SVGContainer = document.createElement('div');
                this.SVGContainer.className = 'flot-svg';
                this.SVGContainer.style.position = 'absolute';
                this.SVGContainer.style.top = '0px';
                this.SVGContainer.style.left = '0px';
                this.SVGContainer.style.height = '100%';
                this.SVGContainer.style.width = '100%';
                this.SVGContainer.style.pointerEvents = 'none';
                this.element.parentNode.appendChild(this.SVGContainer);

                svgElement = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svgElement.style.width = '100%';
                svgElement.style.height = '100%';

                this.SVGContainer.appendChild(svgElement);
            } else {
                svgElement = this.SVGContainer.firstChild;
            }

            layer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            layer.setAttribute('class', classes);
            layer.style.position = 'absolute';
            layer.style.top = '0px';
            layer.style.left = '0px';
            layer.style.bottom = '0px';
            layer.style.right = '0px';
            svgElement.appendChild(layer);
            this.SVG[classes] = layer;
        }

        return layer;
    };

    /**
    - getTextInfo(layer, text, font, angle, width)

     Creates (if necessary) and returns a text info object.
     The object looks like this:
     ```js
     {
         width //Width of the text's wrapper div.
         height //Height of the text's wrapper div.
         element //The HTML div containing the text.
         positions //Array of positions at which this text is drawn.
      }
      ```
      The positions array contains objects that look like this:
      ```js
      {
         active //Flag indicating whether the text should be visible.
         rendered //Flag indicating whether the text is currently visible.
         element //The HTML div containing the text.
         text //The actual text and is identical with element[0].textContent.
         x //X coordinate at which to draw the text.
         y //Y coordinate at which to draw the text.
      }
      ```
      Each position after the first receives a clone of the original element.
      The idea is that that the width, height, and general 'identity' of the
      text is constant no matter where it is placed; the placements are a
      secondary property.

      Canvas maintains a cache of recently-used text info objects; getTextInfo
      either returns the cached element or creates a new entry.

     The layer parameter is string of space-separated CSS classes uniquely
     identifying the layer containing this text.
     Text is the text string to retrieve info for.
     Font is either a string of space-separated CSS classes or a font-spec object,
     defining the text's font and style.
     Angle is the angle at which to rotate the text, in degrees. Angle is currently unused,
     it will be implemented in the future.
     The last parameter is the Maximum width of the text before it wraps.
     The method returns a text info object.
    */
    Canvas.prototype.getTextInfo = function(layer, text, font, angle, width) {
        var textStyle, layerCache, styleCache, info;

        // Cast the value to a string, in case we were given a number or such

        text = '' + text;

        // If the font is a font-spec object, generate a CSS font definition

        if (typeof font === 'object') {
            textStyle = font.style + ' ' + font.variant + ' ' + font.weight + ' ' + font.size + 'px/' + font.lineHeight + 'px ' + font.family;
        } else {
            textStyle = font;
        }

        // Retrieve (or create) the cache for the text's layer and styles

        layerCache = this._textCache[layer];

        if (layerCache == null) {
            layerCache = this._textCache[layer] = {};
        }

        styleCache = layerCache[textStyle];

        if (styleCache == null) {
            styleCache = layerCache[textStyle] = {};
        }

        var key = generateKey(text);
        info = styleCache[key];

        // If we can't find a matching element in our cache, create a new one

        if (!info) {
            var element = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            if (text.indexOf('<br>') !== -1) {
                addTspanElements(text, element, -9999);
            } else {
                var textNode = document.createTextNode(text);
                element.appendChild(textNode);
            }

            element.style.position = 'absolute';
            element.style.maxWidth = width;
            element.setAttributeNS(null, 'x', -9999);
            element.setAttributeNS(null, 'y', -9999);

            if (typeof font === 'object') {
                element.style.font = textStyle;
                element.style.fill = font.fill;
            } else if (typeof font === 'string') {
                element.setAttribute('class', font);
            }

            this.getSVGLayer(layer).appendChild(element);
            var elementRect = element.getBBox();

            info = styleCache[key] = {
                width: elementRect.width,
                height: elementRect.height,
                measured: true,
                element: element,
                positions: []
            };

            //remove elements from dom
            while (element.firstChild) {
                element.removeChild(element.firstChild);
            }
            element.parentNode.removeChild(element);
        }

        info.measured = true;
        return info;
    };

    function updateTransforms (element, transforms) {
        element.transform.baseVal.clear();
        if (transforms) {
            transforms.forEach(function(t) {
                element.transform.baseVal.appendItem(t);
            });
        }
    }

    /**
    - addText (layer, x, y, text, font, angle, width, halign, valign, transforms)

     Adds a text string to the canvas text overlay.
     The text isn't drawn immediately; it is marked as rendering, which will
     result in its addition to the canvas on the next render pass.

     The layer is string of space-separated CSS classes uniquely
     identifying the layer containing this text.
     X and Y represents the X and Y coordinate at which to draw the text.
     and text is the string to draw
    */
    Canvas.prototype.addText = function(layer, x, y, text, font, angle, width, halign, valign, transforms) {
        var info = this.getTextInfo(layer, text, font, angle, width),
            positions = info.positions;

        // Tweak the div's position to match the text's alignment

        if (halign === 'center') {
            x -= info.width / 2;
        } else if (halign === 'right') {
            x -= info.width;
        }

        if (valign === 'middle') {
            y -= info.height / 2;
        } else if (valign === 'bottom') {
            y -= info.height;
        }

        y += 0.75 * info.height;

        // Determine whether this text already exists at this position.
        // If so, mark it for inclusion in the next render pass.

        for (var i = 0, position; positions[i]; i++) {
            position = positions[i];
            if (position.x === x && position.y === y && position.text === text) {
                position.active = true;
                // update the transforms
                updateTransforms(position.element, transforms);

                return;
            } else if (position.active === false) {
                position.active = true;
                position.text = text;
                if (text.indexOf('<br>') !== -1) {
                    y -= 0.25 * info.height;
                    addTspanElements(text, position.element, x);
                } else {
                    position.element.textContent = text;
                }
                position.element.setAttributeNS(null, 'x', x);
                position.element.setAttributeNS(null, 'y', y);
                position.x = x;
                position.y = y;
                // update the transforms
                updateTransforms(position.element, transforms);

                return;
            }
        }

        // If the text doesn't exist at this position, create a new entry

        // For the very first position we'll re-use the original element,
        // while for subsequent ones we'll clone it.

        position = {
            active: true,
            rendered: false,
            element: positions.length ? info.element.cloneNode() : info.element,
            text: text,
            x: x,
            y: y
        };

        positions.push(position);

        if (text.indexOf('<br>') !== -1) {
            y -= 0.25 * info.height;
            addTspanElements(text, position.element, x);
        } else {
            position.element.textContent = text;
        }

        // Move the element to its final position within the container
        position.element.setAttributeNS(null, 'x', x);
        position.element.setAttributeNS(null, 'y', y);
        position.element.style.textAlign = halign;
        // update the transforms
        updateTransforms(position.element, transforms);
    };

    var addTspanElements = function(text, element, x) {
        var lines = text.split('<br>'),
            tspan, i, offset;

        for (i = 0; i < lines.length; i++) {
            if (!element.childNodes[i]) {
                tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
                element.appendChild(tspan);
            } else {
                tspan = element.childNodes[i];
            }
            tspan.textContent = lines[i];
            offset = (i === 0 ? 0 : 1) + 'em';
            tspan.setAttributeNS(null, 'dy', offset);
            tspan.setAttributeNS(null, 'x', x);
        }
    }

    /**
    - removeText (layer, x, y, text, font, angle)

      The function removes one or more text strings from the canvas text overlay.
      If no parameters are given, all text within the layer is removed.

      Note that the text is not immediately removed; it is simply marked as
      inactive, which will result in its removal on the next render pass.
      This avoids the performance penalty for 'clear and redraw' behavior,
      where we potentially get rid of all text on a layer, but will likely
      add back most or all of it later, as when redrawing axes, for example.

      The layer is a string of space-separated CSS classes uniquely
      identifying the layer containing this text. The following parameter are
      X and Y coordinate of the text.
      Text is the string to remove, while the font is either a string of space-separated CSS
      classes or a font-spec object, defining the text's font and style.
     */
    Canvas.prototype.removeText = function(layer, x, y, text, font, angle) {
        var info, htmlYCoord;
        if (text == null) {
            var layerCache = this._textCache[layer];
            if (layerCache != null) {
                for (var styleKey in layerCache) {
                    if (hasOwnProperty.call(layerCache, styleKey)) {
                        var styleCache = layerCache[styleKey];
                        for (var key in styleCache) {
                            if (hasOwnProperty.call(styleCache, key)) {
                                var positions = styleCache[key].positions;
                                positions.forEach(function(position) {
                                    position.active = false;
                                });
                            }
                        }
                    }
                }
            }
        } else {
            info = this.getTextInfo(layer, text, font, angle);
            positions = info.positions;
            positions.forEach(function(position) {
                htmlYCoord = y + 0.75 * info.height;
                if (position.x === x && position.y === htmlYCoord && position.text === text) {
                    position.active = false;
                }
            });
        }
    };

    /**
    - clearCache()

     Clears the cache used to speed up the text size measurements.
     As an (unfortunate) side effect all text within the text Layer is removed.
     Use this function before plot.setupGrid() and plot.draw() if the plot just
     became visible or the styles changed.
    */
    Canvas.prototype.clearCache = function() {
        var cache = this._textCache;
        for (var layerKey in cache) {
            if (hasOwnProperty.call(cache, layerKey)) {
                var layer = this.getSVGLayer(layerKey);
                while (layer.firstChild) {
                    layer.removeChild(layer.firstChild);
                }
            }
        };

        this._textCache = {};
    };

    function generateKey(text) {
        return text.replace(/0|1|2|3|4|5|6|7|8|9/g, '0');
    }

    if (!window.Flot) {
        window.Flot = {};
    }

    window.Flot.Canvas = Canvas;
})(jQuery);


/***/ }),

/***/ "./node_modules/flot/source/jquery.colorhelpers.js":
/*!*********************************************************!*\
  !*** ./node_modules/flot/source/jquery.colorhelpers.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* Plugin for jQuery for working with colors.
 *
 * Version 1.1.
 *
 * Inspiration from jQuery color animation plugin by John Resig.
 *
 * Released under the MIT license by Ole Laursen, October 2009.
 *
 * Examples:
 *
 *   $.color.parse("#fff").scale('rgb', 0.25).add('a', -0.5).toString()
 *   var c = $.color.extract($("#mydiv"), 'background-color');
 *   console.log(c.r, c.g, c.b, c.a);
 *   $.color.make(100, 50, 25, 0.4).toString() // returns "rgba(100,50,25,0.4)"
 *
 * Note that .scale() and .add() return the same modified object
 * instead of making a new one.
 *
 * V. 1.1: Fix error handling so e.g. parsing an empty string does
 * produce a color rather than just crashing.
 */

(function($) {
    $.color = {};

    // construct color object with some convenient chainable helpers
    $.color.make = function (r, g, b, a) {
        var o = {};
        o.r = r || 0;
        o.g = g || 0;
        o.b = b || 0;
        o.a = a != null ? a : 1;

        o.add = function (c, d) {
            for (var i = 0; i < c.length; ++i) {
                o[c.charAt(i)] += d;
            }

            return o.normalize();
        };

        o.scale = function (c, f) {
            for (var i = 0; i < c.length; ++i) {
                o[c.charAt(i)] *= f;
            }

            return o.normalize();
        };

        o.toString = function () {
            if (o.a >= 1.0) {
                return "rgb(" + [o.r, o.g, o.b].join(",") + ")";
            } else {
                return "rgba(" + [o.r, o.g, o.b, o.a].join(",") + ")";
            }
        };

        o.normalize = function () {
            function clamp(min, value, max) {
                return value < min ? min : (value > max ? max : value);
            }

            o.r = clamp(0, parseInt(o.r), 255);
            o.g = clamp(0, parseInt(o.g), 255);
            o.b = clamp(0, parseInt(o.b), 255);
            o.a = clamp(0, o.a, 1);
            return o;
        };

        o.clone = function () {
            return $.color.make(o.r, o.b, o.g, o.a);
        };

        return o.normalize();
    }

    // extract CSS color property from element, going up in the DOM
    // if it's "transparent"
    $.color.extract = function (elem, css) {
        var c;

        do {
            c = elem.css(css).toLowerCase();
            // keep going until we find an element that has color, or
            // we hit the body or root (have no parent)
            if (c !== '' && c !== 'transparent') {
                break;
            }

            elem = elem.parent();
        } while (elem.length && !$.nodeName(elem.get(0), "body"));

        // catch Safari's way of signalling transparent
        if (c === "rgba(0, 0, 0, 0)") {
            c = "transparent";
        }

        return $.color.parse(c);
    }

    // parse CSS color string (like "rgb(10, 32, 43)" or "#fff"),
    // returns color object, if parsing failed, you get black (0, 0,
    // 0) out
    $.color.parse = function (str) {
        var res, m = $.color.make;

        // Look for rgb(num,num,num)
        res = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/.exec(str);
        if (res) {
            return m(parseInt(res[1], 10), parseInt(res[2], 10), parseInt(res[3], 10));
        }

        // Look for rgba(num,num,num,num)
        res = /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]+(?:\.[0-9]+)?)\s*\)/.exec(str)
        if (res) {
            return m(parseInt(res[1], 10), parseInt(res[2], 10), parseInt(res[3], 10), parseFloat(res[4]));
        }

        // Look for rgb(num%,num%,num%)
        res = /rgb\(\s*([0-9]+(?:\.[0-9]+)?)%\s*,\s*([0-9]+(?:\.[0-9]+)?)%\s*,\s*([0-9]+(?:\.[0-9]+)?)%\s*\)/.exec(str);
        if (res) {
            return m(parseFloat(res[1]) * 2.55, parseFloat(res[2]) * 2.55, parseFloat(res[3]) * 2.55);
        }

        // Look for rgba(num%,num%,num%,num)
        res = /rgba\(\s*([0-9]+(?:\.[0-9]+)?)%\s*,\s*([0-9]+(?:\.[0-9]+)?)%\s*,\s*([0-9]+(?:\.[0-9]+)?)%\s*,\s*([0-9]+(?:\.[0-9]+)?)\s*\)/.exec(str);
        if (res) {
            return m(parseFloat(res[1]) * 2.55, parseFloat(res[2]) * 2.55, parseFloat(res[3]) * 2.55, parseFloat(res[4]));
        }

        // Look for #a0b1c2
        res = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(str);
        if (res) {
            return m(parseInt(res[1], 16), parseInt(res[2], 16), parseInt(res[3], 16));
        }

        // Look for #fff
        res = /#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(str);
        if (res) {
            return m(parseInt(res[1] + res[1], 16), parseInt(res[2] + res[2], 16), parseInt(res[3] + res[3], 16));
        }

        // Otherwise, we're most likely dealing with a named color
        var name = $.trim(str).toLowerCase();
        if (name === "transparent") {
            return m(255, 255, 255, 0);
        } else {
            // default to black
            res = lookupColors[name] || [0, 0, 0];
            return m(res[0], res[1], res[2]);
        }
    }

    var lookupColors = {
        aqua: [0, 255, 255],
        azure: [240, 255, 255],
        beige: [245, 245, 220],
        black: [0, 0, 0],
        blue: [0, 0, 255],
        brown: [165, 42, 42],
        cyan: [0, 255, 255],
        darkblue: [0, 0, 139],
        darkcyan: [0, 139, 139],
        darkgrey: [169, 169, 169],
        darkgreen: [0, 100, 0],
        darkkhaki: [189, 183, 107],
        darkmagenta: [139, 0, 139],
        darkolivegreen: [85, 107, 47],
        darkorange: [255, 140, 0],
        darkorchid: [153, 50, 204],
        darkred: [139, 0, 0],
        darksalmon: [233, 150, 122],
        darkviolet: [148, 0, 211],
        fuchsia: [255, 0, 255],
        gold: [255, 215, 0],
        green: [0, 128, 0],
        indigo: [75, 0, 130],
        khaki: [240, 230, 140],
        lightblue: [173, 216, 230],
        lightcyan: [224, 255, 255],
        lightgreen: [144, 238, 144],
        lightgrey: [211, 211, 211],
        lightpink: [255, 182, 193],
        lightyellow: [255, 255, 224],
        lime: [0, 255, 0],
        magenta: [255, 0, 255],
        maroon: [128, 0, 0],
        navy: [0, 0, 128],
        olive: [128, 128, 0],
        orange: [255, 165, 0],
        pink: [255, 192, 203],
        purple: [128, 0, 128],
        violet: [128, 0, 128],
        red: [255, 0, 0],
        silver: [192, 192, 192],
        white: [255, 255, 255],
        yellow: [255, 255, 0]
    };
})(jQuery);


/***/ }),

/***/ "./node_modules/flot/source/jquery.flot.axislabels.js":
/*!************************************************************!*\
  !*** ./node_modules/flot/source/jquery.flot.axislabels.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
Axis label plugin for flot

Derived from:
Axis Labels Plugin for flot.
http://github.com/markrcote/flot-axislabels

Original code is Copyright (c) 2010 Xuan Luo.
Original code was released under the GPLv3 license by Xuan Luo, September 2010.
Original code was rereleased under the MIT license by Xuan Luo, April 2012.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

(function($) {
    "use strict";

    var options = {
        axisLabels: {
            show: true
        }
    };

    function AxisLabel(axisName, position, padding, placeholder, axisLabel, surface) {
        this.axisName = axisName;
        this.position = position;
        this.padding = padding;
        this.placeholder = placeholder;
        this.axisLabel = axisLabel;
        this.surface = surface;
        this.width = 0;
        this.height = 0;
        this.elem = null;
    }

    AxisLabel.prototype.calculateSize = function() {
        var axisId = this.axisName + 'Label',
            layerId = axisId + 'Layer',
            className = axisId + ' axisLabels';

        var info = this.surface.getTextInfo(layerId, this.axisLabel, className);
        this.labelWidth = info.width;
        this.labelHeight = info.height;

        if (this.position === 'left' || this.position === 'right') {
            this.width = this.labelHeight + this.padding;
            this.height = 0;
        } else {
            this.width = 0;
            this.height = this.labelHeight + this.padding;
        }
    };

    AxisLabel.prototype.transforms = function(degrees, x, y, svgLayer) {
        var transforms = [], translate, rotate;
        if (x !== 0 || y !== 0) {
            translate = svgLayer.createSVGTransform();
            translate.setTranslate(x, y);
            transforms.push(translate);
        }
        if (degrees !== 0) {
            rotate = svgLayer.createSVGTransform();
            var centerX = Math.round(this.labelWidth / 2),
                centerY = 0;
            rotate.setRotate(degrees, centerX, centerY);
            transforms.push(rotate);
        }

        return transforms;
    };

    AxisLabel.prototype.calculateOffsets = function(box) {
        var offsets = {
            x: 0,
            y: 0,
            degrees: 0
        };
        if (this.position === 'bottom') {
            offsets.x = box.left + box.width / 2 - this.labelWidth / 2;
            offsets.y = box.top + box.height - this.labelHeight;
        } else if (this.position === 'top') {
            offsets.x = box.left + box.width / 2 - this.labelWidth / 2;
            offsets.y = box.top;
        } else if (this.position === 'left') {
            offsets.degrees = -90;
            offsets.x = box.left - this.labelWidth / 2;
            offsets.y = box.height / 2 + box.top;
        } else if (this.position === 'right') {
            offsets.degrees = 90;
            offsets.x = box.left + box.width - this.labelWidth / 2;
            offsets.y = box.height / 2 + box.top;
        }
        offsets.x = Math.round(offsets.x);
        offsets.y = Math.round(offsets.y);

        return offsets;
    };

    AxisLabel.prototype.cleanup = function() {
        var axisId = this.axisName + 'Label',
            layerId = axisId + 'Layer',
            className = axisId + ' axisLabels';
        this.surface.removeText(layerId, 0, 0, this.axisLabel, className);
    };

    AxisLabel.prototype.draw = function(box) {
        var axisId = this.axisName + 'Label',
            layerId = axisId + 'Layer',
            className = axisId + ' axisLabels',
            offsets = this.calculateOffsets(box),
            style = {
                position: 'absolute',
                bottom: '',
                right: '',
                display: 'inline-block',
                'white-space': 'nowrap'
            };

        var layer = this.surface.getSVGLayer(layerId);
        var transforms = this.transforms(offsets.degrees, offsets.x, offsets.y, layer.parentNode);

        this.surface.addText(layerId, 0, 0, this.axisLabel, className, undefined, undefined, undefined, undefined, transforms);
        this.surface.render();
        Object.keys(style).forEach(function(key) {
            layer.style[key] = style[key];
        });
    };

    function init(plot) {
        plot.hooks.processOptions.push(function(plot, options) {
            if (!options.axisLabels.show) {
                return;
            }

            var axisLabels = {};
            var defaultPadding = 2; // padding between axis and tick labels

            plot.hooks.axisReserveSpace.push(function(plot, axis) {
                var opts = axis.options;
                var axisName = axis.direction + axis.n;

                axis.labelHeight += axis.boxPosition.centerY;
                axis.labelWidth += axis.boxPosition.centerX;

                if (!opts || !opts.axisLabel || !axis.show) {
                    return;
                }

                var padding = opts.axisLabelPadding === undefined
                    ? defaultPadding
                    : opts.axisLabelPadding;

                var axisLabel = axisLabels[axisName];
                if (!axisLabel) {
                    axisLabel = new AxisLabel(axisName,
                        opts.position, padding,
                        plot.getPlaceholder()[0], opts.axisLabel, plot.getSurface());
                    axisLabels[axisName] = axisLabel;
                }

                axisLabel.calculateSize();

                // Incrementing the sizes of the tick labels.
                axis.labelHeight += axisLabel.height;
                axis.labelWidth += axisLabel.width;
            });

            // TODO - use the drawAxis hook
            plot.hooks.draw.push(function(plot, ctx) {
                $.each(plot.getAxes(), function(flotAxisName, axis) {
                    var opts = axis.options;
                    if (!opts || !opts.axisLabel || !axis.show) {
                        return;
                    }

                    var axisName = axis.direction + axis.n;
                    axisLabels[axisName].draw(axis.box);
                });
            });

            plot.hooks.shutdown.push(function(plot, eventHolder) {
                for (var axisName in axisLabels) {
                    axisLabels[axisName].cleanup();
                }
            });
        });
    };

    $.plot.plugins.push({
        init: init,
        options: options,
        name: 'axisLabels',
        version: '3.0'
    });
})(jQuery);


/***/ }),

/***/ "./node_modules/flot/source/jquery.flot.browser.js":
/*!*********************************************************!*\
  !*** ./node_modules/flot/source/jquery.flot.browser.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/** ## jquery.flot.browser.js

This plugin is used to make available some browser-related utility functions.

### Methods
*/

(function ($) {
    'use strict';

    var browser = {
        /**
        - getPageXY(e)

         Calculates the pageX and pageY using the screenX, screenY properties of the event
         and the scrolling of the page. This is needed because the pageX and pageY
         properties of the event are not correct while running tests in Edge. */
        getPageXY: function (e) {
            // This code is inspired from https://stackoverflow.com/a/3464890
            var doc = document.documentElement,
                pageX = e.clientX + (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0),
                pageY = e.clientY + (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);
            return { X: pageX, Y: pageY };
        },

        /**
        - getPixelRatio(context)

         This function returns the current pixel ratio defined by the product of desktop
         zoom and page zoom.
         Additional info: https://www.html5rocks.com/en/tutorials/canvas/hidpi/
        */
        getPixelRatio: function(context) {
            var devicePixelRatio = window.devicePixelRatio || 1,
                backingStoreRatio =
                context.webkitBackingStorePixelRatio ||
                context.mozBackingStorePixelRatio ||
                context.msBackingStorePixelRatio ||
                context.oBackingStorePixelRatio ||
                context.backingStorePixelRatio || 1;
            return devicePixelRatio / backingStoreRatio;
        },

        /**
        - isSafari, isMobileSafari, isOpera, isFirefox, isIE, isEdge, isChrome, isBlink

         This is a collection of functions, used to check if the code is running in a
         particular browser or Javascript engine.
        */
        isSafari: function() {
            // *** https://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser
            // Safari 3.0+ "[object HTMLElementConstructor]"
            return /constructor/i.test(window.top.HTMLElement) || (function (p) { return p.toString() === "[object SafariRemoteNotification]"; })(!window.top['safari'] || (typeof window.top.safari !== 'undefined' && window.top.safari.pushNotification));
        },

        isMobileSafari: function() {
            //isMobileSafari adapted from https://stackoverflow.com/questions/3007480/determine-if-user-navigated-from-mobile-safari
            return navigator.userAgent.match(/(iPod|iPhone|iPad)/) && navigator.userAgent.match(/AppleWebKit/);
        },

        isOpera: function() {
            // *** https://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser
            //Opera 8.0+
            return (!!window.opr && !!opr.addons) || !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;
        },

        isFirefox: function() {
            // *** https://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser
            // Firefox 1.0+
            return typeof InstallTrigger !== 'undefined';
        },

        isIE: function() {
            // *** https://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser
            // Internet Explorer 6-11
            return /*@cc_on!@*/ false || !!document.documentMode;
        },

        isEdge: function() {
            // *** https://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser
            // Edge 20+
            return !browser.isIE() && !!window.StyleMedia;
        },

        isChrome: function() {
            // *** https://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser
            // Chrome 1+
            return !!window.chrome && !!window.chrome.webstore;
        },

        isBlink: function() {
            // *** https://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser
            return (browser.isChrome() || browser.isOpera()) && !!window.CSS;
        }
    };

    $.plot.browser = browser;
})(jQuery);


/***/ }),

/***/ "./node_modules/flot/source/jquery.flot.categories.js":
/*!************************************************************!*\
  !*** ./node_modules/flot/source/jquery.flot.categories.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* Flot plugin for plotting textual data or categories.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Licensed under the MIT license.

Consider a dataset like [["February", 34], ["March", 20], ...]. This plugin
allows you to plot such a dataset directly.

To enable it, you must specify mode: "categories" on the axis with the textual
labels, e.g.

    $.plot("#placeholder", data, { xaxis: { mode: "categories" } });

By default, the labels are ordered as they are met in the data series. If you
need a different ordering, you can specify "categories" on the axis options
and list the categories there:

    xaxis: {
        mode: "categories",
        categories: ["February", "March", "April"]
    }

If you need to customize the distances between the categories, you can specify
"categories" as an object mapping labels to values

    xaxis: {
        mode: "categories",
        categories: { "February": 1, "March": 3, "April": 4 }
    }

If you don't specify all categories, the remaining categories will be numbered
from the max value plus 1 (with a spacing of 1 between each).

Internally, the plugin works by transforming the input data through an auto-
generated mapping where the first category becomes 0, the second 1, etc.
Hence, a point like ["February", 34] becomes [0, 34] internally in Flot (this
is visible in hover and click events that return numbers rather than the
category labels). The plugin also overrides the tick generator to spit out the
categories as ticks instead of the values.

If you need to map a value back to its label, the mapping is always accessible
as "categories" on the axis object, e.g. plot.getAxes().xaxis.categories.

*/

(function ($) {
    var options = {
        xaxis: {
            categories: null
        },
        yaxis: {
            categories: null
        }
    };

    function processRawData(plot, series, data, datapoints) {
        // if categories are enabled, we need to disable
        // auto-transformation to numbers so the strings are intact
        // for later processing

        var xCategories = series.xaxis.options.mode === "categories",
            yCategories = series.yaxis.options.mode === "categories";

        if (!(xCategories || yCategories)) {
            return;
        }

        var format = datapoints.format;

        if (!format) {
            // FIXME: auto-detection should really not be defined here
            var s = series;
            format = [];
            format.push({ x: true, number: true, required: true, computeRange: true});
            format.push({ y: true, number: true, required: true, computeRange: true });

            if (s.bars.show || (s.lines.show && s.lines.fill)) {
                var autoScale = !!((s.bars.show && s.bars.zero) || (s.lines.show && s.lines.zero));
                format.push({ y: true, number: true, required: false, defaultValue: 0, computeRange: autoScale });
                if (s.bars.horizontal) {
                    delete format[format.length - 1].y;
                    format[format.length - 1].x = true;
                }
            }

            datapoints.format = format;
        }

        for (var m = 0; m < format.length; ++m) {
            if (format[m].x && xCategories) {
                format[m].number = false;
            }

            if (format[m].y && yCategories) {
                format[m].number = false;
                format[m].computeRange = false;
            }
        }
    }

    function getNextIndex(categories) {
        var index = -1;

        for (var v in categories) {
            if (categories[v] > index) {
                index = categories[v];
            }
        }

        return index + 1;
    }

    function categoriesTickGenerator(axis) {
        var res = [];
        for (var label in axis.categories) {
            var v = axis.categories[label];
            if (v >= axis.min && v <= axis.max) {
                res.push([v, label]);
            }
        }

        res.sort(function (a, b) { return a[0] - b[0]; });

        return res;
    }

    function setupCategoriesForAxis(series, axis, datapoints) {
        if (series[axis].options.mode !== "categories") {
            return;
        }

        if (!series[axis].categories) {
            // parse options
            var c = {}, o = series[axis].options.categories || {};
            if ($.isArray(o)) {
                for (var i = 0; i < o.length; ++i) {
                    c[o[i]] = i;
                }
            } else {
                for (var v in o) {
                    c[v] = o[v];
                }
            }

            series[axis].categories = c;
        }

        // fix ticks
        if (!series[axis].options.ticks) {
            series[axis].options.ticks = categoriesTickGenerator;
        }

        transformPointsOnAxis(datapoints, axis, series[axis].categories);
    }

    function transformPointsOnAxis(datapoints, axis, categories) {
        // go through the points, transforming them
        var points = datapoints.points,
            ps = datapoints.pointsize,
            format = datapoints.format,
            formatColumn = axis.charAt(0),
            index = getNextIndex(categories);

        for (var i = 0; i < points.length; i += ps) {
            if (points[i] == null) {
                continue;
            }

            for (var m = 0; m < ps; ++m) {
                var val = points[i + m];

                if (val == null || !format[m][formatColumn]) {
                    continue;
                }

                if (!(val in categories)) {
                    categories[val] = index;
                    ++index;
                }

                points[i + m] = categories[val];
            }
        }
    }

    function processDatapoints(plot, series, datapoints) {
        setupCategoriesForAxis(series, "xaxis", datapoints);
        setupCategoriesForAxis(series, "yaxis", datapoints);
    }

    function init(plot) {
        plot.hooks.processRawData.push(processRawData);
        plot.hooks.processDatapoints.push(processDatapoints);
    }

    $.plot.plugins.push({
        init: init,
        options: options,
        name: 'categories',
        version: '1.0'
    });
})(jQuery);


/***/ }),

/***/ "./node_modules/flot/source/jquery.flot.composeImages.js":
/*!***************************************************************!*\
  !*** ./node_modules/flot/source/jquery.flot.composeImages.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** ## jquery.flot.composeImages.js

This plugin is used to expose a function used to overlap several canvases and
SVGs, for the purpose of creating a snaphot out of them.

### When composeImages is used:
When multiple canvases and SVGs have to be overlapped into a single image
and their offset on the page, must be preserved.

### Where can be used:
In creating a downloadable snapshot of the plots, axes, cursors etc of a graph.

### How it works:
The entry point is composeImages function. It expects an array of objects,
which should be either canvases or SVGs (or a mix). It does a prevalidation
of them, by verifying if they will be usable or not, later in the flow.
After selecting only usable sources, it passes them to getGenerateTempImg
function, which generates temporary images out of them. This function
expects that some of the passed sources (canvas or SVG) may still have
problems being converted to an image and makes sure the promises system,
used by composeImages function, moves forward. As an example, SVGs with
missing information from header or with unsupported content, may lead to
failure in generating the temporary image. Temporary images are required
mostly on extracting content from SVGs, but this is also where the x/y
offsets are extracted for each image which will be added. For SVGs in
particular, their CSS rules have to be applied.
After all temporary images are generated, they are overlapped using
getExecuteImgComposition function. This is where the destination canvas
is set to the proper dimensions. It is then output by composeImages.
This function returns a promise, which can be used to wait for the whole
composition process. It requires to be asynchronous, because this is how
temporary images load their data.
*/

(function($) {
    "use strict";
    const GENERALFAILURECALLBACKERROR = -100; //simply a negative number
    const SUCCESSFULIMAGEPREPARATION = 0;
    const EMPTYARRAYOFIMAGESOURCES = -1;
    const NEGATIVEIMAGESIZE = -2;
    var pixelRatio = 1;
    var browser = $.plot.browser;
    var getPixelRatio = browser.getPixelRatio;

    function composeImages(canvasOrSvgSources, destinationCanvas) {
        var validCanvasOrSvgSources = canvasOrSvgSources.filter(isValidSource);
        pixelRatio = getPixelRatio(destinationCanvas.getContext('2d'));

        var allImgCompositionPromises = validCanvasOrSvgSources.map(function(validCanvasOrSvgSource) {
            var tempImg = new Image();
            var currentPromise = new Promise(getGenerateTempImg(tempImg, validCanvasOrSvgSource));
            return currentPromise;
        });

        var lastPromise = Promise.all(allImgCompositionPromises).then(getExecuteImgComposition(destinationCanvas), failureCallback);
        return lastPromise;
    }

    function isValidSource(canvasOrSvgSource) {
        var isValidFromCanvas = true;
        var isValidFromContent = true;
        if ((canvasOrSvgSource === null) || (canvasOrSvgSource === undefined)) {
            isValidFromContent = false;
        } else {
            if (canvasOrSvgSource.tagName === 'CANVAS') {
                if ((canvasOrSvgSource.getBoundingClientRect().right === canvasOrSvgSource.getBoundingClientRect().left) ||
                    (canvasOrSvgSource.getBoundingClientRect().bottom === canvasOrSvgSource.getBoundingClientRect().top)) {
                    isValidFromCanvas = false;
                }
            }
        }
        return isValidFromContent && isValidFromCanvas && (window.getComputedStyle(canvasOrSvgSource).visibility === 'visible');
    }

    function getGenerateTempImg(tempImg, canvasOrSvgSource) {
        tempImg.sourceDescription = '<info className="' + canvasOrSvgSource.className + '" tagName="' + canvasOrSvgSource.tagName + '" id="' + canvasOrSvgSource.id + '">';
        tempImg.sourceComponent = canvasOrSvgSource;

        return function doGenerateTempImg(successCallbackFunc, failureCallbackFunc) {
            tempImg.onload = function(evt) {
                tempImg.successfullyLoaded = true;
                successCallbackFunc(tempImg);
            };

            tempImg.onabort = function(evt) {
                tempImg.successfullyLoaded = false;
                console.log('Can\'t generate temp image from ' + tempImg.sourceDescription + '. It is possible that it is missing some properties or its content is not supported by this browser. Source component:', tempImg.sourceComponent);
                successCallbackFunc(tempImg); //call successCallback, to allow snapshot of all working images
            };

            tempImg.onerror = function(evt) {
                tempImg.successfullyLoaded = false;
                console.log('Can\'t generate temp image from ' + tempImg.sourceDescription + '. It is possible that it is missing some properties or its content is not supported by this browser. Source component:', tempImg.sourceComponent);
                successCallbackFunc(tempImg); //call successCallback, to allow snapshot of all working images
            };

            generateTempImageFromCanvasOrSvg(canvasOrSvgSource, tempImg);
        };
    }

    function getExecuteImgComposition(destinationCanvas) {
        return function executeImgComposition(tempImgs) {
            var compositionResult = copyImgsToCanvas(tempImgs, destinationCanvas);
            return compositionResult;
        };
    }

    function copyCanvasToImg(canvas, img) {
        img.src = canvas.toDataURL('image/png');
    }

    function getCSSRules(document) {
        var styleSheets = document.styleSheets,
            rulesList = [];
        for (var i = 0; i < styleSheets.length; i++) {
            // CORS requests for style sheets throw and an exception on Chrome > 64
            try {
                // in Chrome, the external CSS files are empty when the page is directly loaded from disk
                var rules = styleSheets[i].cssRules || [];
                for (var j = 0; j < rules.length; j++) {
                    var rule = rules[j];
                    rulesList.push(rule.cssText);
                }
            } catch (e) {
                console.log('Failed to get some css rules');
            }
        }
        return rulesList;
    }

    function embedCSSRulesInSVG(rules, svg) {
        var text = [
            '<svg class="snapshot ' + svg.classList + '" width="' + svg.width.baseVal.value * pixelRatio + '" height="' + svg.height.baseVal.value * pixelRatio + '" viewBox="0 0 ' + svg.width.baseVal.value + ' ' + svg.height.baseVal.value + '" xmlns="http://www.w3.org/2000/svg">',
            '<style>',
            '/* <![CDATA[ */',
            rules.join('\n'),
            '/* ]]> */',
            '</style>',
            svg.innerHTML,
            '</svg>'
        ].join('\n');
        return text;
    }

    function copySVGToImgMostBrowsers(svg, img) {
        var rules = getCSSRules(document),
            source = embedCSSRulesInSVG(rules, svg);

        source = patchSVGSource(source);

        var blob = new Blob([source], {type: "image/svg+xml;charset=utf-8"}),
            domURL = self.URL || self.webkitURL || self,
            url = domURL.createObjectURL(blob);
        img.src = url;
    }

    function copySVGToImgSafari(svg, img) {
        // Use this method to convert a string buffer array to a binary string.
        // Do so by breaking up large strings into smaller substrings; this is necessary to avoid the
        // "maximum call stack size exceeded" exception that can happen when calling 'String.fromCharCode.apply'
        // with a very long array.
        function buildBinaryString (arrayBuffer) {
            var binaryString = "";
            const utf8Array = new Uint8Array(arrayBuffer);
            const blockSize = 16384;
            for (var i = 0; i < utf8Array.length; i = i + blockSize) {
                const binarySubString = String.fromCharCode.apply(null, utf8Array.subarray(i, i + blockSize));
                binaryString = binaryString + binarySubString;
            }
            return binaryString;
        };

        var rules = getCSSRules(document),
            source = embedCSSRulesInSVG(rules, svg),
            data,
            utf8BinaryString;

        source = patchSVGSource(source);

        // Encode the string as UTF-8 and convert it to a binary string. The UTF-8 encoding is required to
        // capture unicode characters correctly.
        utf8BinaryString = buildBinaryString(new (TextEncoder || TextEncoderLite)('utf-8').encode(source));

        data = "data:image/svg+xml;base64," + btoa(utf8BinaryString);
        img.src = data;
    }

    function patchSVGSource(svgSource) {
        var source = '';
        //add name spaces.
        if (!svgSource.match(/^<svg[^>]+xmlns="http:\/\/www\.w3\.org\/2000\/svg"/)) {
            source = svgSource.replace(/^<svg/, '<svg xmlns="http://www.w3.org/2000/svg"');
        }
        if (!svgSource.match(/^<svg[^>]+"http:\/\/www\.w3\.org\/1999\/xlink"/)) {
            source = svgSource.replace(/^<svg/, '<svg xmlns:xlink="http://www.w3.org/1999/xlink"');
        }

        //add xml declaration
        return '<?xml version="1.0" standalone="no"?>\r\n' + source;
    }

    function copySVGToImg(svg, img) {
        if (browser.isSafari() || browser.isMobileSafari()) {
            copySVGToImgSafari(svg, img);
        } else {
            copySVGToImgMostBrowsers(svg, img);
        }
    }

    function adaptDestSizeToZoom(destinationCanvas, sources) {
        function containsSVGs(source) {
            return source.srcImgTagName === 'svg';
        }

        if (sources.find(containsSVGs) !== undefined) {
            if (pixelRatio < 1) {
                destinationCanvas.width = destinationCanvas.width * pixelRatio;
                destinationCanvas.height = destinationCanvas.height * pixelRatio;
            }
        }
    }

    function prepareImagesToBeComposed(sources, destination) {
        var result = SUCCESSFULIMAGEPREPARATION;
        if (sources.length === 0) {
            result = EMPTYARRAYOFIMAGESOURCES; //nothing to do if called without sources
        } else {
            var minX = sources[0].genLeft;
            var minY = sources[0].genTop;
            var maxX = sources[0].genRight;
            var maxY = sources[0].genBottom;
            var i = 0;

            for (i = 1; i < sources.length; i++) {
                if (minX > sources[i].genLeft) {
                    minX = sources[i].genLeft;
                }

                if (minY > sources[i].genTop) {
                    minY = sources[i].genTop;
                }
            }

            for (i = 1; i < sources.length; i++) {
                if (maxX < sources[i].genRight) {
                    maxX = sources[i].genRight;
                }

                if (maxY < sources[i].genBottom) {
                    maxY = sources[i].genBottom;
                }
            }

            if ((maxX - minX <= 0) || (maxY - minY <= 0)) {
                result = NEGATIVEIMAGESIZE; //this might occur on hidden images
            } else {
                destination.width = Math.round(maxX - minX);
                destination.height = Math.round(maxY - minY);

                for (i = 0; i < sources.length; i++) {
                    sources[i].xCompOffset = sources[i].genLeft - minX;
                    sources[i].yCompOffset = sources[i].genTop - minY;
                }

                adaptDestSizeToZoom(destination, sources);
            }
        }
        return result;
    }

    function copyImgsToCanvas(sources, destination) {
        var prepareImagesResult = prepareImagesToBeComposed(sources, destination);
        if (prepareImagesResult === SUCCESSFULIMAGEPREPARATION) {
            var destinationCtx = destination.getContext('2d');

            for (var i = 0; i < sources.length; i++) {
                if (sources[i].successfullyLoaded === true) {
                    destinationCtx.drawImage(sources[i], sources[i].xCompOffset * pixelRatio, sources[i].yCompOffset * pixelRatio);
                }
            }
        }
        return prepareImagesResult;
    }

    function adnotateDestImgWithBoundingClientRect(srcCanvasOrSvg, destImg) {
        destImg.genLeft = srcCanvasOrSvg.getBoundingClientRect().left;
        destImg.genTop = srcCanvasOrSvg.getBoundingClientRect().top;

        if (srcCanvasOrSvg.tagName === 'CANVAS') {
            destImg.genRight = destImg.genLeft + srcCanvasOrSvg.width;
            destImg.genBottom = destImg.genTop + srcCanvasOrSvg.height;
        }

        if (srcCanvasOrSvg.tagName === 'svg') {
            destImg.genRight = srcCanvasOrSvg.getBoundingClientRect().right;
            destImg.genBottom = srcCanvasOrSvg.getBoundingClientRect().bottom;
        }
    }

    function generateTempImageFromCanvasOrSvg(srcCanvasOrSvg, destImg) {
        if (srcCanvasOrSvg.tagName === 'CANVAS') {
            copyCanvasToImg(srcCanvasOrSvg, destImg);
        }

        if (srcCanvasOrSvg.tagName === 'svg') {
            copySVGToImg(srcCanvasOrSvg, destImg);
        }

        destImg.srcImgTagName = srcCanvasOrSvg.tagName;
        adnotateDestImgWithBoundingClientRect(srcCanvasOrSvg, destImg);
    }

    function failureCallback() {
        return GENERALFAILURECALLBACKERROR;
    }

    // used for testing
    $.plot.composeImages = composeImages;

    function init(plot) {
        // used to extend the public API of the plot
        plot.composeImages = composeImages;
    }

    $.plot.plugins.push({
        init: init,
        name: 'composeImages',
        version: '1.0'
    });
})(jQuery);


/***/ }),

/***/ "./node_modules/flot/source/jquery.flot.crosshair.js":
/*!***********************************************************!*\
  !*** ./node_modules/flot/source/jquery.flot.crosshair.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* Flot plugin for showing crosshairs when the mouse hovers over the plot.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Licensed under the MIT license.

The plugin supports these options:

    crosshair: {
        mode: null or "x" or "y" or "xy"
        color: color
        lineWidth: number
    }

Set the mode to one of "x", "y" or "xy". The "x" mode enables a vertical
crosshair that lets you trace the values on the x axis, "y" enables a
horizontal crosshair and "xy" enables them both. "color" is the color of the
crosshair (default is "rgba(170, 0, 0, 0.80)"), "lineWidth" is the width of
the drawn lines (default is 1).

The plugin also adds four public methods:

  - setCrosshair( pos )

    Set the position of the crosshair. Note that this is cleared if the user
    moves the mouse. "pos" is in coordinates of the plot and should be on the
    form { x: xpos, y: ypos } (you can use x2/x3/... if you're using multiple
    axes), which is coincidentally the same format as what you get from a
    "plothover" event. If "pos" is null, the crosshair is cleared.

  - clearCrosshair()

    Clear the crosshair.

  - lockCrosshair(pos)

    Cause the crosshair to lock to the current location, no longer updating if
    the user moves the mouse. Optionally supply a position (passed on to
    setCrosshair()) to move it to.

    Example usage:

    var myFlot = $.plot( $("#graph"), ..., { crosshair: { mode: "x" } } };
    $("#graph").bind( "plothover", function ( evt, position, item ) {
        if ( item ) {
            // Lock the crosshair to the data point being hovered
            myFlot.lockCrosshair({
                x: item.datapoint[ 0 ],
                y: item.datapoint[ 1 ]
            });
        } else {
            // Return normal crosshair operation
            myFlot.unlockCrosshair();
        }
    });

  - unlockCrosshair()

    Free the crosshair to move again after locking it.
*/

(function ($) {
    var options = {
        crosshair: {
            mode: null, // one of null, "x", "y" or "xy",
            color: "rgba(170, 0, 0, 0.80)",
            lineWidth: 1
        }
    };

    function init(plot) {
        // position of crosshair in pixels
        var crosshair = {x: -1, y: -1, locked: false, highlighted: false};

        plot.setCrosshair = function setCrosshair(pos) {
            if (!pos) {
                crosshair.x = -1;
            } else {
                var o = plot.p2c(pos);
                crosshair.x = Math.max(0, Math.min(o.left, plot.width()));
                crosshair.y = Math.max(0, Math.min(o.top, plot.height()));
            }

            plot.triggerRedrawOverlay();
        };

        plot.clearCrosshair = plot.setCrosshair; // passes null for pos

        plot.lockCrosshair = function lockCrosshair(pos) {
            if (pos) {
                plot.setCrosshair(pos);
            }

            crosshair.locked = true;
        };

        plot.unlockCrosshair = function unlockCrosshair() {
            crosshair.locked = false;
            crosshair.rect = null;
        };

        function onMouseOut(e) {
            if (crosshair.locked) {
                return;
            }

            if (crosshair.x !== -1) {
                crosshair.x = -1;
                plot.triggerRedrawOverlay();
            }
        }

        function onMouseMove(e) {
            var offset = plot.offset();
            if (crosshair.locked) {
                var mouseX = Math.max(0, Math.min(e.pageX - offset.left, plot.width()));
                var mouseY = Math.max(0, Math.min(e.pageY - offset.top, plot.height()));

                if ((mouseX > crosshair.x - 4) && (mouseX < crosshair.x + 4) && (mouseY > crosshair.y - 4) && (mouseY < crosshair.y + 4)) {
                    if (!crosshair.highlighted) {
                        crosshair.highlighted = true;
                        plot.triggerRedrawOverlay();
                    }
                } else {
                    if (crosshair.highlighted) {
                        crosshair.highlighted = false;
                        plot.triggerRedrawOverlay();
                    }
                }
                return;
            }

            if (plot.getSelection && plot.getSelection()) {
                crosshair.x = -1; // hide the crosshair while selecting
                return;
            }

            crosshair.x = Math.max(0, Math.min(e.pageX - offset.left, plot.width()));
            crosshair.y = Math.max(0, Math.min(e.pageY - offset.top, plot.height()));
            plot.triggerRedrawOverlay();
        }

        plot.hooks.bindEvents.push(function (plot, eventHolder) {
            if (!plot.getOptions().crosshair.mode) {
                return;
            }

            eventHolder.mouseout(onMouseOut);
            eventHolder.mousemove(onMouseMove);
        });

        plot.hooks.drawOverlay.push(function (plot, ctx) {
            var c = plot.getOptions().crosshair;
            if (!c.mode) {
                return;
            }

            var plotOffset = plot.getPlotOffset();

            ctx.save();
            ctx.translate(plotOffset.left, plotOffset.top);

            if (crosshair.x !== -1) {
                var adj = plot.getOptions().crosshair.lineWidth % 2 ? 0.5 : 0;

                ctx.strokeStyle = c.color;
                ctx.lineWidth = c.lineWidth;
                ctx.lineJoin = "round";

                ctx.beginPath();
                if (c.mode.indexOf("x") !== -1) {
                    var drawX = Math.floor(crosshair.x) + adj;
                    ctx.moveTo(drawX, 0);
                    ctx.lineTo(drawX, plot.height());
                }
                if (c.mode.indexOf("y") !== -1) {
                    var drawY = Math.floor(crosshair.y) + adj;
                    ctx.moveTo(0, drawY);
                    ctx.lineTo(plot.width(), drawY);
                }
                if (crosshair.locked) {
                    if (crosshair.highlighted) ctx.fillStyle = 'orange';
                    else ctx.fillStyle = c.color;
                    ctx.fillRect(Math.floor(crosshair.x) + adj - 4, Math.floor(crosshair.y) + adj - 4, 8, 8);
                }
                ctx.stroke();
            }
            ctx.restore();
        });

        plot.hooks.shutdown.push(function (plot, eventHolder) {
            eventHolder.unbind("mouseout", onMouseOut);
            eventHolder.unbind("mousemove", onMouseMove);
        });
    }

    $.plot.plugins.push({
        init: init,
        options: options,
        name: 'crosshair',
        version: '1.0'
    });
})(jQuery);


/***/ }),

/***/ "./node_modules/flot/source/jquery.flot.drawSeries.js":
/*!************************************************************!*\
  !*** ./node_modules/flot/source/jquery.flot.drawSeries.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
## jquery.flot.drawSeries.js

This plugin is used by flot for drawing lines, plots, bars or area.

### Public methods
*/

(function($) {
    "use strict";

    function DrawSeries() {
        function plotLine(datapoints, xoffset, yoffset, axisx, axisy, ctx, steps) {
            var points = datapoints.points,
                ps = datapoints.pointsize,
                prevx = null,
                prevy = null;
            var x1 = 0.0,
                y1 = 0.0,
                x2 = 0.0,
                y2 = 0.0,
                mx = null,
                my = null,
                i = 0;

            ctx.beginPath();
            for (i = ps; i < points.length; i += ps) {
                x1 = points[i - ps];
                y1 = points[i - ps + 1];
                x2 = points[i];
                y2 = points[i + 1];

                if (x1 === null || x2 === null) {
                    mx = null;
                    my = null;
                    continue;
                }

                if (isNaN(x1) || isNaN(x2) || isNaN(y1) || isNaN(y2)) {
                    prevx = null;
                    prevy = null;
                    continue;
                }

                if (steps) {
                    if (mx !== null && my !== null) {
                        // if middle point exists, transfer p2 -> p1 and p1 -> mp
                        x2 = x1;
                        y2 = y1;
                        x1 = mx;
                        y1 = my;

                        // 'remove' middle point
                        mx = null;
                        my = null;

                        // subtract pointsize from i to have current point p1 handled again
                        i -= ps;
                    } else if (y1 !== y2 && x1 !== x2) {
                        // create a middle point
                        y2 = y1;
                        mx = x2;
                        my = y1;
                    }
                }

                // clip with ymin
                if (y1 <= y2 && y1 < axisy.min) {
                    if (y2 < axisy.min) {
                        // line segment is outside
                        continue;
                    }
                    // compute new intersection point
                    x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
                    y1 = axisy.min;
                } else if (y2 <= y1 && y2 < axisy.min) {
                    if (y1 < axisy.min) {
                        continue;
                    }

                    x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
                    y2 = axisy.min;
                }

                // clip with ymax
                if (y1 >= y2 && y1 > axisy.max) {
                    if (y2 > axisy.max) {
                        continue;
                    }

                    x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
                    y1 = axisy.max;
                } else if (y2 >= y1 && y2 > axisy.max) {
                    if (y1 > axisy.max) {
                        continue;
                    }

                    x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
                    y2 = axisy.max;
                }

                // clip with xmin
                if (x1 <= x2 && x1 < axisx.min) {
                    if (x2 < axisx.min) {
                        continue;
                    }

                    y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
                    x1 = axisx.min;
                } else if (x2 <= x1 && x2 < axisx.min) {
                    if (x1 < axisx.min) {
                        continue;
                    }

                    y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
                    x2 = axisx.min;
                }

                // clip with xmax
                if (x1 >= x2 && x1 > axisx.max) {
                    if (x2 > axisx.max) {
                        continue;
                    }

                    y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
                    x1 = axisx.max;
                } else if (x2 >= x1 && x2 > axisx.max) {
                    if (x1 > axisx.max) {
                        continue;
                    }

                    y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
                    x2 = axisx.max;
                }

                if (x1 !== prevx || y1 !== prevy) {
                    ctx.moveTo(axisx.p2c(x1) + xoffset, axisy.p2c(y1) + yoffset);
                }

                prevx = x2;
                prevy = y2;
                ctx.lineTo(axisx.p2c(x2) + xoffset, axisy.p2c(y2) + yoffset);
            }
            ctx.stroke();
        }

        function plotLineArea(datapoints, axisx, axisy, fillTowards, ctx, steps) {
            var points = datapoints.points,
                ps = datapoints.pointsize,
                bottom = fillTowards > axisy.min ? Math.min(axisy.max, fillTowards) : axisy.min,
                i = 0,
                ypos = 1,
                areaOpen = false,
                segmentStart = 0,
                segmentEnd = 0,
                mx = null,
                my = null;

            // we process each segment in two turns, first forward
            // direction to sketch out top, then once we hit the
            // end we go backwards to sketch the bottom
            while (true) {
                if (ps > 0 && i > points.length + ps) {
                    break;
                }

                i += ps; // ps is negative if going backwards

                var x1 = points[i - ps],
                    y1 = points[i - ps + ypos],
                    x2 = points[i],
                    y2 = points[i + ypos];

                if (ps === -2) {
                    /* going backwards and no value for the bottom provided in the series*/
                    y1 = y2 = bottom;
                }

                if (areaOpen) {
                    if (ps > 0 && x1 != null && x2 == null) {
                        // at turning point
                        segmentEnd = i;
                        ps = -ps;
                        ypos = 2;
                        continue;
                    }

                    if (ps < 0 && i === segmentStart + ps) {
                        // done with the reverse sweep
                        ctx.fill();
                        areaOpen = false;
                        ps = -ps;
                        ypos = 1;
                        i = segmentStart = segmentEnd + ps;
                        continue;
                    }
                }

                if (x1 == null || x2 == null) {
                    mx = null;
                    my = null;
                    continue;
                }

                if (steps) {
                    if (mx !== null && my !== null) {
                        // if middle point exists, transfer p2 -> p1 and p1 -> mp
                        x2 = x1;
                        y2 = y1;
                        x1 = mx;
                        y1 = my;

                        // 'remove' middle point
                        mx = null;
                        my = null;

                        // subtract pointsize from i to have current point p1 handled again
                        i -= ps;
                    } else if (y1 !== y2 && x1 !== x2) {
                        // create a middle point
                        y2 = y1;
                        mx = x2;
                        my = y1;
                    }
                }

                // clip x values

                // clip with xmin
                if (x1 <= x2 && x1 < axisx.min) {
                    if (x2 < axisx.min) {
                        continue;
                    }

                    y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
                    x1 = axisx.min;
                } else if (x2 <= x1 && x2 < axisx.min) {
                    if (x1 < axisx.min) {
                        continue;
                    }

                    y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
                    x2 = axisx.min;
                }

                // clip with xmax
                if (x1 >= x2 && x1 > axisx.max) {
                    if (x2 > axisx.max) {
                        continue;
                    }

                    y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
                    x1 = axisx.max;
                } else if (x2 >= x1 && x2 > axisx.max) {
                    if (x1 > axisx.max) {
                        continue;
                    }

                    y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
                    x2 = axisx.max;
                }

                if (!areaOpen) {
                    // open area
                    ctx.beginPath();
                    ctx.moveTo(axisx.p2c(x1), axisy.p2c(bottom));
                    areaOpen = true;
                }

                // now first check the case where both is outside
                if (y1 >= axisy.max && y2 >= axisy.max) {
                    ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.max));
                    ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.max));
                    continue;
                } else if (y1 <= axisy.min && y2 <= axisy.min) {
                    ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.min));
                    ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.min));
                    continue;
                }

                // else it's a bit more complicated, there might
                // be a flat maxed out rectangle first, then a
                // triangular cutout or reverse; to find these
                // keep track of the current x values
                var x1old = x1,
                    x2old = x2;

                // clip the y values, without shortcutting, we
                // go through all cases in turn

                // clip with ymin
                if (y1 <= y2 && y1 < axisy.min && y2 >= axisy.min) {
                    x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
                    y1 = axisy.min;
                } else if (y2 <= y1 && y2 < axisy.min && y1 >= axisy.min) {
                    x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
                    y2 = axisy.min;
                }

                // clip with ymax
                if (y1 >= y2 && y1 > axisy.max && y2 <= axisy.max) {
                    x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
                    y1 = axisy.max;
                } else if (y2 >= y1 && y2 > axisy.max && y1 <= axisy.max) {
                    x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
                    y2 = axisy.max;
                }

                // if the x value was changed we got a rectangle
                // to fill
                if (x1 !== x1old) {
                    ctx.lineTo(axisx.p2c(x1old), axisy.p2c(y1));
                    // it goes to (x1, y1), but we fill that below
                }

                // fill triangular section, this sometimes result
                // in redundant points if (x1, y1) hasn't changed
                // from previous line to, but we just ignore that
                ctx.lineTo(axisx.p2c(x1), axisy.p2c(y1));
                ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));

                // fill the other rectangle if it's there
                if (x2 !== x2old) {
                    ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));
                    ctx.lineTo(axisx.p2c(x2old), axisy.p2c(y2));
                }
            }
        }

        /**
        - drawSeriesLines(series, ctx, plotOffset, plotWidth, plotHeight, drawSymbol, getColorOrGradient)

         This function is used for drawing lines or area fill.  In case the series has line decimation function
         attached, before starting to draw, as an optimization the points will first be decimated.

         The series parameter contains the series to be drawn on ctx context. The plotOffset, plotWidth and
         plotHeight are the corresponding parameters of flot used to determine the drawing surface.
         The function getColorOrGradient is used to compute the fill style of lines and area.
        */
        function drawSeriesLines(series, ctx, plotOffset, plotWidth, plotHeight, drawSymbol, getColorOrGradient) {
            ctx.save();
            ctx.translate(plotOffset.left, plotOffset.top);
            ctx.lineJoin = "round";

            if (series.lines.dashes && ctx.setLineDash) {
                ctx.setLineDash(series.lines.dashes);
            }

            var datapoints = {
                format: series.datapoints.format,
                points: series.datapoints.points,
                pointsize: series.datapoints.pointsize
            };

            if (series.decimate) {
                datapoints.points = series.decimate(series, series.xaxis.min, series.xaxis.max, plotWidth, series.yaxis.min, series.yaxis.max, plotHeight);
            }

            var lw = series.lines.lineWidth;

            ctx.lineWidth = lw;
            ctx.strokeStyle = series.color;
            var fillStyle = getFillStyle(series.lines, series.color, 0, plotHeight, getColorOrGradient);
            if (fillStyle) {
                ctx.fillStyle = fillStyle;
                plotLineArea(datapoints, series.xaxis, series.yaxis, series.lines.fillTowards || 0, ctx, series.lines.steps);
            }

            if (lw > 0) {
                plotLine(datapoints, 0, 0, series.xaxis, series.yaxis, ctx, series.lines.steps);
            }

            ctx.restore();
        }

        /**
        - drawSeriesPoints(series, ctx, plotOffset, plotWidth, plotHeight, drawSymbol, getColorOrGradient)

         This function is used for drawing points using a given symbol. In case the series has points decimation
         function attached, before starting to draw, as an optimization the points will first be decimated.

         The series parameter contains the series to be drawn on ctx context. The plotOffset, plotWidth and
         plotHeight are the corresponding parameters of flot used to determine the drawing surface.
         The function drawSymbol is used to compute and draw the symbol chosen for the points.
        */
        function drawSeriesPoints(series, ctx, plotOffset, plotWidth, plotHeight, drawSymbol, getColorOrGradient) {
            function drawCircle(ctx, x, y, radius, shadow, fill) {
                ctx.moveTo(x + radius, y);
                ctx.arc(x, y, radius, 0, shadow ? Math.PI : Math.PI * 2, false);
            }
            drawCircle.fill = true;
            function plotPoints(datapoints, radius, fill, offset, shadow, axisx, axisy, drawSymbolFn) {
                var points = datapoints.points,
                    ps = datapoints.pointsize;

                ctx.beginPath();
                for (var i = 0; i < points.length; i += ps) {
                    var x = points[i],
                        y = points[i + 1];
                    if (x == null || x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max) {
                        continue;
                    }

                    x = axisx.p2c(x);
                    y = axisy.p2c(y) + offset;

                    drawSymbolFn(ctx, x, y, radius, shadow, fill);
                }
                if (drawSymbolFn.fill && !shadow) {
                    ctx.fill();
                }
                ctx.stroke();
            }

            ctx.save();
            ctx.translate(plotOffset.left, plotOffset.top);

            var datapoints = {
                format: series.datapoints.format,
                points: series.datapoints.points,
                pointsize: series.datapoints.pointsize
            };

            if (series.decimatePoints) {
                datapoints.points = series.decimatePoints(series, series.xaxis.min, series.xaxis.max, plotWidth, series.yaxis.min, series.yaxis.max, plotHeight);
            }

            var lw = series.points.lineWidth,
                radius = series.points.radius,
                symbol = series.points.symbol,
                drawSymbolFn;

            if (symbol === 'circle') {
                drawSymbolFn = drawCircle;
            } else if (typeof symbol === 'string' && drawSymbol && drawSymbol[symbol]) {
                drawSymbolFn = drawSymbol[symbol];
            } else if (typeof drawSymbol === 'function') {
                drawSymbolFn = drawSymbol;
            }

            // If the user sets the line width to 0, we change it to a very
            // small value. A line width of 0 seems to force the default of 1.

            if (lw === 0) {
                lw = 0.0001;
            }

            ctx.lineWidth = lw;
            ctx.fillStyle = getFillStyle(series.points, series.color, null, null, getColorOrGradient);
            ctx.strokeStyle = series.color;
            plotPoints(datapoints, radius,
                true, 0, false,
                series.xaxis, series.yaxis, drawSymbolFn);
            ctx.restore();
        }

        function drawBar(x, y, b, barLeft, barRight, fillStyleCallback, axisx, axisy, c, horizontal, lineWidth) {
            var left = x + barLeft,
                right = x + barRight,
                bottom = b, top = y,
                drawLeft, drawRight, drawTop, drawBottom = false,
                tmp;

            drawLeft = drawRight = drawTop = true;

            // in horizontal mode, we start the bar from the left
            // instead of from the bottom so it appears to be
            // horizontal rather than vertical
            if (horizontal) {
                drawBottom = drawRight = drawTop = true;
                drawLeft = false;
                left = b;
                right = x;
                top = y + barLeft;
                bottom = y + barRight;

                // account for negative bars
                if (right < left) {
                    tmp = right;
                    right = left;
                    left = tmp;
                    drawLeft = true;
                    drawRight = false;
                }
            } else {
                drawLeft = drawRight = drawTop = true;
                drawBottom = false;
                left = x + barLeft;
                right = x + barRight;
                bottom = b;
                top = y;

                // account for negative bars
                if (top < bottom) {
                    tmp = top;
                    top = bottom;
                    bottom = tmp;
                    drawBottom = true;
                    drawTop = false;
                }
            }

            // clip
            if (right < axisx.min || left > axisx.max ||
                top < axisy.min || bottom > axisy.max) {
                return;
            }

            if (left < axisx.min) {
                left = axisx.min;
                drawLeft = false;
            }

            if (right > axisx.max) {
                right = axisx.max;
                drawRight = false;
            }

            if (bottom < axisy.min) {
                bottom = axisy.min;
                drawBottom = false;
            }

            if (top > axisy.max) {
                top = axisy.max;
                drawTop = false;
            }

            left = axisx.p2c(left);
            bottom = axisy.p2c(bottom);
            right = axisx.p2c(right);
            top = axisy.p2c(top);

            // fill the bar
            if (fillStyleCallback) {
                c.fillStyle = fillStyleCallback(bottom, top);
                c.fillRect(left, top, right - left, bottom - top)
            }

            // draw outline
            if (lineWidth > 0 && (drawLeft || drawRight || drawTop || drawBottom)) {
                c.beginPath();

                // FIXME: inline moveTo is buggy with excanvas
                c.moveTo(left, bottom);
                if (drawLeft) {
                    c.lineTo(left, top);
                } else {
                    c.moveTo(left, top);
                }

                if (drawTop) {
                    c.lineTo(right, top);
                } else {
                    c.moveTo(right, top);
                }

                if (drawRight) {
                    c.lineTo(right, bottom);
                } else {
                    c.moveTo(right, bottom);
                }

                if (drawBottom) {
                    c.lineTo(left, bottom);
                } else {
                    c.moveTo(left, bottom);
                }

                c.stroke();
            }
        }

        /**
        - drawSeriesBars(series, ctx, plotOffset, plotWidth, plotHeight, drawSymbol, getColorOrGradient)

         This function is used for drawing series represented as bars. In case the series has decimation
         function attached, before starting to draw, as an optimization the points will first be decimated.

         The series parameter contains the series to be drawn on ctx context. The plotOffset, plotWidth and
         plotHeight are the corresponding parameters of flot used to determine the drawing surface.
         The function getColorOrGradient is used to compute the fill style of bars.
        */
        function drawSeriesBars(series, ctx, plotOffset, plotWidth, plotHeight, drawSymbol, getColorOrGradient) {
            function plotBars(datapoints, barLeft, barRight, fillStyleCallback, axisx, axisy) {
                var points = datapoints.points,
                    ps = datapoints.pointsize,
                    fillTowards = series.bars.fillTowards || 0,
                    defaultBottom = fillTowards > axisy.min ? Math.min(axisy.max, fillTowards) : axisy.min;

                for (var i = 0; i < points.length; i += ps) {
                    if (points[i] == null) {
                        continue;
                    }

                    // Use third point as bottom if pointsize is 3
                    var bottom = ps === 3 ? points[i + 2] : defaultBottom;
                    drawBar(points[i], points[i + 1], bottom, barLeft, barRight, fillStyleCallback, axisx, axisy, ctx, series.bars.horizontal, series.bars.lineWidth);
                }
            }

            ctx.save();
            ctx.translate(plotOffset.left, plotOffset.top);

            var datapoints = {
                format: series.datapoints.format,
                points: series.datapoints.points,
                pointsize: series.datapoints.pointsize
            };

            if (series.decimate) {
                datapoints.points = series.decimate(series, series.xaxis.min, series.xaxis.max, plotWidth);
            }

            ctx.lineWidth = series.bars.lineWidth;
            ctx.strokeStyle = series.color;

            var barLeft;
            var barWidth = series.bars.barWidth[0] || series.bars.barWidth;
            switch (series.bars.align) {
                case "left":
                    barLeft = 0;
                    break;
                case "right":
                    barLeft = -barWidth;
                    break;
                default:
                    barLeft = -barWidth / 2;
            }

            var fillStyleCallback = series.bars.fill ? function(bottom, top) {
                return getFillStyle(series.bars, series.color, bottom, top, getColorOrGradient);
            } : null;

            plotBars(datapoints, barLeft, barLeft + barWidth, fillStyleCallback, series.xaxis, series.yaxis);
            ctx.restore();
        }

        function getFillStyle(filloptions, seriesColor, bottom, top, getColorOrGradient) {
            var fill = filloptions.fill;
            if (!fill) {
                return null;
            }

            if (filloptions.fillColor) {
                return getColorOrGradient(filloptions.fillColor, bottom, top, seriesColor);
            }

            var c = $.color.parse(seriesColor);
            c.a = typeof fill === "number" ? fill : 0.4;
            c.normalize();
            return c.toString();
        }

        this.drawSeriesLines = drawSeriesLines;
        this.drawSeriesPoints = drawSeriesPoints;
        this.drawSeriesBars = drawSeriesBars;
        this.drawBar = drawBar;
    };

    $.plot.drawSeries = new DrawSeries();
})(jQuery);


/***/ }),

/***/ "./node_modules/flot/source/jquery.flot.errorbars.js":
/*!***********************************************************!*\
  !*** ./node_modules/flot/source/jquery.flot.errorbars.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* Flot plugin for plotting error bars.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Licensed under the MIT license.

Error bars are used to show standard deviation and other statistical
properties in a plot.

* Created by Rui Pereira  -  rui (dot) pereira (at) gmail (dot) com

This plugin allows you to plot error-bars over points. Set "errorbars" inside
the points series to the axis name over which there will be error values in
your data array (*even* if you do not intend to plot them later, by setting
"show: null" on xerr/yerr).

The plugin supports these options:

    series: {
        points: {
            errorbars: "x" or "y" or "xy",
            xerr: {
                show: null/false or true,
                asymmetric: null/false or true,
                upperCap: null or "-" or function,
                lowerCap: null or "-" or function,
                color: null or color,
                radius: null or number
            },
            yerr: { same options as xerr }
        }
    }

Each data point array is expected to be of the type:

    "x"  [ x, y, xerr ]
    "y"  [ x, y, yerr ]
    "xy" [ x, y, xerr, yerr ]

Where xerr becomes xerr_lower,xerr_upper for the asymmetric error case, and
equivalently for yerr. Eg., a datapoint for the "xy" case with symmetric
error-bars on X and asymmetric on Y would be:

    [ x, y, xerr, yerr_lower, yerr_upper ]

By default no end caps are drawn. Setting upperCap and/or lowerCap to "-" will
draw a small cap perpendicular to the error bar. They can also be set to a
user-defined drawing function, with (ctx, x, y, radius) as parameters, as eg.

    function drawSemiCircle( ctx, x, y, radius ) {
        ctx.beginPath();
        ctx.arc( x, y, radius, 0, Math.PI, false );
        ctx.moveTo( x - radius, y );
        ctx.lineTo( x + radius, y );
        ctx.stroke();
    }

Color and radius both default to the same ones of the points series if not
set. The independent radius parameter on xerr/yerr is useful for the case when
we may want to add error-bars to a line, without showing the interconnecting
points (with radius: 0), and still showing end caps on the error-bars.
shadowSize and lineWidth are derived as well from the points series.

*/

(function ($) {
    var options = {
        series: {
            points: {
                errorbars: null, //should be 'x', 'y' or 'xy'
                xerr: {err: 'x', show: null, asymmetric: null, upperCap: null, lowerCap: null, color: null, radius: null},
                yerr: {err: 'y', show: null, asymmetric: null, upperCap: null, lowerCap: null, color: null, radius: null}
            }
        }
    };

    function processRawData(plot, series, data, datapoints) {
        if (!series.points.errorbars) {
            return;
        }

        // x,y values
        var format = [
            { x: true, number: true, required: true },
            { y: true, number: true, required: true }
        ];

        var errors = series.points.errorbars;
        // error bars - first X then Y
        if (errors === 'x' || errors === 'xy') {
            // lower / upper error
            if (series.points.xerr.asymmetric) {
                format.push({ x: true, number: true, required: true });
                format.push({ x: true, number: true, required: true });
            } else {
                format.push({ x: true, number: true, required: true });
            }
        }
        if (errors === 'y' || errors === 'xy') {
            // lower / upper error
            if (series.points.yerr.asymmetric) {
                format.push({ y: true, number: true, required: true });
                format.push({ y: true, number: true, required: true });
            } else {
                format.push({ y: true, number: true, required: true });
            }
        }
        datapoints.format = format;
    }

    function parseErrors(series, i) {
        var points = series.datapoints.points;

        // read errors from points array
        var exl = null,
            exu = null,
            eyl = null,
            eyu = null;
        var xerr = series.points.xerr,
            yerr = series.points.yerr;

        var eb = series.points.errorbars;
        // error bars - first X
        if (eb === 'x' || eb === 'xy') {
            if (xerr.asymmetric) {
                exl = points[i + 2];
                exu = points[i + 3];
                if (eb === 'xy') {
                    if (yerr.asymmetric) {
                        eyl = points[i + 4];
                        eyu = points[i + 5];
                    } else {
                        eyl = points[i + 4];
                    }
                }
            } else {
                exl = points[i + 2];
                if (eb === 'xy') {
                    if (yerr.asymmetric) {
                        eyl = points[i + 3];
                        eyu = points[i + 4];
                    } else {
                        eyl = points[i + 3];
                    }
                }
            }
        // only Y
        } else {
            if (eb === 'y') {
                if (yerr.asymmetric) {
                    eyl = points[i + 2];
                    eyu = points[i + 3];
                } else {
                    eyl = points[i + 2];
                }
            }
        }

        // symmetric errors?
        if (exu == null) exu = exl;
        if (eyu == null) eyu = eyl;

        var errRanges = [exl, exu, eyl, eyu];
        // nullify if not showing
        if (!xerr.show) {
            errRanges[0] = null;
            errRanges[1] = null;
        }
        if (!yerr.show) {
            errRanges[2] = null;
            errRanges[3] = null;
        }
        return errRanges;
    }

    function drawSeriesErrors(plot, ctx, s) {
        var points = s.datapoints.points,
            ps = s.datapoints.pointsize,
            ax = [s.xaxis, s.yaxis],
            radius = s.points.radius,
            err = [s.points.xerr, s.points.yerr],
            tmp;

        //sanity check, in case some inverted axis hack is applied to flot
        var invertX = false;
        if (ax[0].p2c(ax[0].max) < ax[0].p2c(ax[0].min)) {
            invertX = true;
            tmp = err[0].lowerCap;
            err[0].lowerCap = err[0].upperCap;
            err[0].upperCap = tmp;
        }

        var invertY = false;
        if (ax[1].p2c(ax[1].min) < ax[1].p2c(ax[1].max)) {
            invertY = true;
            tmp = err[1].lowerCap;
            err[1].lowerCap = err[1].upperCap;
            err[1].upperCap = tmp;
        }

        for (var i = 0; i < s.datapoints.points.length; i += ps) {
            //parse
            var errRanges = parseErrors(s, i);

            //cycle xerr & yerr
            for (var e = 0; e < err.length; e++) {
                var minmax = [ax[e].min, ax[e].max];

                //draw this error?
                if (errRanges[e * err.length]) {
                    //data coordinates
                    var x = points[i],
                        y = points[i + 1];

                    //errorbar ranges
                    var upper = [x, y][e] + errRanges[e * err.length + 1],
                        lower = [x, y][e] - errRanges[e * err.length];

                    //points outside of the canvas
                    if (err[e].err === 'x') {
                        if (y > ax[1].max || y < ax[1].min || upper < ax[0].min || lower > ax[0].max) {
                            continue;
                        }
                    }

                    if (err[e].err === 'y') {
                        if (x > ax[0].max || x < ax[0].min || upper < ax[1].min || lower > ax[1].max) {
                            continue;
                        }
                    }

                    // prevent errorbars getting out of the canvas
                    var drawUpper = true,
                        drawLower = true;

                    if (upper > minmax[1]) {
                        drawUpper = false;
                        upper = minmax[1];
                    }
                    if (lower < minmax[0]) {
                        drawLower = false;
                        lower = minmax[0];
                    }

                    //sanity check, in case some inverted axis hack is applied to flot
                    if ((err[e].err === 'x' && invertX) || (err[e].err === 'y' && invertY)) {
                        //swap coordinates
                        tmp = lower;
                        lower = upper;
                        upper = tmp;
                        tmp = drawLower;
                        drawLower = drawUpper;
                        drawUpper = tmp;
                        tmp = minmax[0];
                        minmax[0] = minmax[1];
                        minmax[1] = tmp;
                    }

                    // convert to pixels
                    x = ax[0].p2c(x);
                    y = ax[1].p2c(y);
                    upper = ax[e].p2c(upper);
                    lower = ax[e].p2c(lower);
                    minmax[0] = ax[e].p2c(minmax[0]);
                    minmax[1] = ax[e].p2c(minmax[1]);

                    //same style as points by default
                    var lw = err[e].lineWidth ? err[e].lineWidth : s.points.lineWidth,
                        sw = s.points.shadowSize != null ? s.points.shadowSize : s.shadowSize;

                    //shadow as for points
                    if (lw > 0 && sw > 0) {
                        var w = sw / 2;
                        ctx.lineWidth = w;
                        ctx.strokeStyle = "rgba(0,0,0,0.1)";
                        drawError(ctx, err[e], x, y, upper, lower, drawUpper, drawLower, radius, w + w / 2, minmax);

                        ctx.strokeStyle = "rgba(0,0,0,0.2)";
                        drawError(ctx, err[e], x, y, upper, lower, drawUpper, drawLower, radius, w / 2, minmax);
                    }

                    ctx.strokeStyle = err[e].color
                        ? err[e].color
                        : s.color;
                    ctx.lineWidth = lw;
                    //draw it
                    drawError(ctx, err[e], x, y, upper, lower, drawUpper, drawLower, radius, 0, minmax);
                }
            }
        }
    }

    function drawError(ctx, err, x, y, upper, lower, drawUpper, drawLower, radius, offset, minmax) {
        //shadow offset
        y += offset;
        upper += offset;
        lower += offset;

        // error bar - avoid plotting over circles
        if (err.err === 'x') {
            if (upper > x + radius) drawPath(ctx, [[upper, y], [Math.max(x + radius, minmax[0]), y]]);
            else drawUpper = false;

            if (lower < x - radius) drawPath(ctx, [[Math.min(x - radius, minmax[1]), y], [lower, y]]);
            else drawLower = false;
        } else {
            if (upper < y - radius) drawPath(ctx, [[x, upper], [x, Math.min(y - radius, minmax[0])]]);
            else drawUpper = false;

            if (lower > y + radius) drawPath(ctx, [[x, Math.max(y + radius, minmax[1])], [x, lower]]);
            else drawLower = false;
        }

        //internal radius value in errorbar, allows to plot radius 0 points and still keep proper sized caps
        //this is a way to get errorbars on lines without visible connecting dots
        radius = err.radius != null
            ? err.radius
            : radius;

        // upper cap
        if (drawUpper) {
            if (err.upperCap === '-') {
                if (err.err === 'x') drawPath(ctx, [[upper, y - radius], [upper, y + radius]]);
                else drawPath(ctx, [[x - radius, upper], [x + radius, upper]]);
            } else if ($.isFunction(err.upperCap)) {
                if (err.err === 'x') err.upperCap(ctx, upper, y, radius);
                else err.upperCap(ctx, x, upper, radius);
            }
        }
        // lower cap
        if (drawLower) {
            if (err.lowerCap === '-') {
                if (err.err === 'x') drawPath(ctx, [[lower, y - radius], [lower, y + radius]]);
                else drawPath(ctx, [[x - radius, lower], [x + radius, lower]]);
            } else if ($.isFunction(err.lowerCap)) {
                if (err.err === 'x') err.lowerCap(ctx, lower, y, radius);
                else err.lowerCap(ctx, x, lower, radius);
            }
        }
    }

    function drawPath(ctx, pts) {
        ctx.beginPath();
        ctx.moveTo(pts[0][0], pts[0][1]);
        for (var p = 1; p < pts.length; p++) {
            ctx.lineTo(pts[p][0], pts[p][1]);
        }

        ctx.stroke();
    }

    function draw(plot, ctx) {
        var plotOffset = plot.getPlotOffset();

        ctx.save();
        ctx.translate(plotOffset.left, plotOffset.top);
        $.each(plot.getData(), function (i, s) {
            if (s.points.errorbars && (s.points.xerr.show || s.points.yerr.show)) {
                drawSeriesErrors(plot, ctx, s);
            }
        });
        ctx.restore();
    }

    function init(plot) {
        plot.hooks.processRawData.push(processRawData);
        plot.hooks.draw.push(draw);
    }

    $.plot.plugins.push({
        init: init,
        options: options,
        name: 'errorbars',
        version: '1.0'
    });
})(jQuery);


/***/ }),

/***/ "./node_modules/flot/source/jquery.flot.fillbetween.js":
/*!*************************************************************!*\
  !*** ./node_modules/flot/source/jquery.flot.fillbetween.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* Flot plugin for computing bottoms for filled line and bar charts.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Licensed under the MIT license.

The case: you've got two series that you want to fill the area between. In Flot
terms, you need to use one as the fill bottom of the other. You can specify the
bottom of each data point as the third coordinate manually, or you can use this
plugin to compute it for you.

In order to name the other series, you need to give it an id, like this:

    var dataset = [
        { data: [ ... ], id: "foo" } ,         // use default bottom
        { data: [ ... ], fillBetween: "foo" }, // use first dataset as bottom
    ];

    $.plot($("#placeholder"), dataset, { lines: { show: true, fill: true }});

As a convenience, if the id given is a number that doesn't appear as an id in
the series, it is interpreted as the index in the array instead (so fillBetween:
0 can also mean the first series).

Internally, the plugin modifies the datapoints in each series. For line series,
extra data points might be inserted through interpolation. Note that at points
where the bottom line is not defined (due to a null point or start/end of line),
the current line will show a gap too. The algorithm comes from the
jquery.flot.stack.js plugin, possibly some code could be shared.

*/

(function ($) {
    var options = {
        series: {
            fillBetween: null // or number
        }
    };

    function init(plot) {
        function findBottomSeries(s, allseries) {
            var i;

            for (i = 0; i < allseries.length; ++i) {
                if (allseries[ i ].id === s.fillBetween) {
                    return allseries[ i ];
                }
            }

            if (typeof s.fillBetween === "number") {
                if (s.fillBetween < 0 || s.fillBetween >= allseries.length) {
                    return null;
                }
                return allseries[ s.fillBetween ];
            }

            return null;
        }

        function computeFormat(plot, s, data, datapoints) {
            if (s.fillBetween == null) {
                return;
            }

            var format = datapoints.format;
            var plotHasId = function(id) {
                var plotData = plot.getData();
                for (var i = 0; i < plotData.length; i++) {
                    if (plotData[i].id === id) {
                        return true;
                    }
                }

                return false;
            }

            if (!format) {
                format = [];

                format.push({
                    x: true,
                    number: true,
                    computeRange: s.xaxis.options.autoScale !== 'none',
                    required: true
                });
                format.push({
                    y: true,
                    number: true,
                    computeRange: s.yaxis.options.autoScale !== 'none',
                    required: true
                });

                if (s.fillBetween !== undefined && s.fillBetween !== '' && plotHasId(s.fillBetween) && s.fillBetween !== s.id) {
                    format.push({
                        x: false,
                        y: true,
                        number: true,
                        required: false,
                        computeRange: s.yaxis.options.autoScale !== 'none',
                        defaultValue: 0
                    });
                }

                datapoints.format = format;
            }
        }

        function computeFillBottoms(plot, s, datapoints) {
            if (s.fillBetween == null) {
                return;
            }

            var other = findBottomSeries(s, plot.getData());

            if (!other) {
                return;
            }

            var ps = datapoints.pointsize,
                points = datapoints.points,
                otherps = other.datapoints.pointsize,
                otherpoints = other.datapoints.points,
                newpoints = [],
                px, py, intery, qx, qy, bottom,
                withlines = s.lines.show,
                withbottom = ps > 2 && datapoints.format[2].y,
                withsteps = withlines && s.lines.steps,
                fromgap = true,
                i = 0,
                j = 0,
                l, m;

            while (true) {
                if (i >= points.length) {
                    break;
                }

                l = newpoints.length;

                if (points[ i ] == null) {
                    // copy gaps
                    for (m = 0; m < ps; ++m) {
                        newpoints.push(points[ i + m ]);
                    }

                    i += ps;
                } else if (j >= otherpoints.length) {
                    // for lines, we can't use the rest of the points
                    if (!withlines) {
                        for (m = 0; m < ps; ++m) {
                            newpoints.push(points[ i + m ]);
                        }
                    }

                    i += ps;
                } else if (otherpoints[ j ] == null) {
                    // oops, got a gap
                    for (m = 0; m < ps; ++m) {
                        newpoints.push(null);
                    }

                    fromgap = true;
                    j += otherps;
                } else {
                    // cases where we actually got two points
                    px = points[ i ];
                    py = points[ i + 1 ];
                    qx = otherpoints[ j ];
                    qy = otherpoints[ j + 1 ];
                    bottom = 0;

                    if (px === qx) {
                        for (m = 0; m < ps; ++m) {
                            newpoints.push(points[ i + m ]);
                        }

                        //newpoints[ l + 1 ] += qy;
                        bottom = qy;

                        i += ps;
                        j += otherps;
                    } else if (px > qx) {
                        // we got past point below, might need to
                        // insert interpolated extra point

                        if (withlines && i > 0 && points[ i - ps ] != null) {
                            intery = py + (points[ i - ps + 1 ] - py) * (qx - px) / (points[ i - ps ] - px);
                            newpoints.push(qx);
                            newpoints.push(intery);
                            for (m = 2; m < ps; ++m) {
                                newpoints.push(points[ i + m ]);
                            }
                            bottom = qy;
                        }

                        j += otherps;
                    } else {
                        // px < qx
                        // if we come from a gap, we just skip this point

                        if (fromgap && withlines) {
                            i += ps;
                            continue;
                        }

                        for (m = 0; m < ps; ++m) {
                            newpoints.push(points[ i + m ]);
                        }

                        // we might be able to interpolate a point below,
                        // this can give us a better y

                        if (withlines && j > 0 && otherpoints[ j - otherps ] != null) {
                            bottom = qy + (otherpoints[ j - otherps + 1 ] - qy) * (px - qx) / (otherpoints[ j - otherps ] - qx);
                        }

                        //newpoints[l + 1] += bottom;

                        i += ps;
                    }

                    fromgap = false;

                    if (l !== newpoints.length && withbottom) {
                        newpoints[ l + 2 ] = bottom;
                    }
                }

                // maintain the line steps invariant

                if (withsteps && l !== newpoints.length && l > 0 &&
                    newpoints[ l ] !== null &&
                    newpoints[ l ] !== newpoints[ l - ps ] &&
                    newpoints[ l + 1 ] !== newpoints[ l - ps + 1 ]) {
                    for (m = 0; m < ps; ++m) {
                        newpoints[ l + ps + m ] = newpoints[ l + m ];
                    }
                    newpoints[ l + 1 ] = newpoints[ l - ps + 1 ];
                }
            }

            datapoints.points = newpoints;
        }

        plot.hooks.processRawData.push(computeFormat);
        plot.hooks.processDatapoints.push(computeFillBottoms);
    }

    $.plot.plugins.push({
        init: init,
        options: options,
        name: "fillbetween",
        version: "1.0"
    });
})(jQuery);


/***/ }),

/***/ "./node_modules/flot/source/jquery.flot.flatdata.js":
/*!**********************************************************!*\
  !*** ./node_modules/flot/source/jquery.flot.flatdata.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* Support for flat 1D data series.

A 1D flat data series is a data series in the form of a regular 1D array. The
main reason for using a flat data series is that it performs better, consumes
less memory and generates less garbage collection than the regular flot format.

Example:

    plot.setData([[[0,0], [1,1], [2,2], [3,3]]]); // regular flot format
    plot.setData([{flatdata: true, data: [0, 1, 2, 3]}]); // flatdata format

Set series.flatdata to true to enable this plugin.

You can use series.start to specify the starting index of the series (default is 0)
You can use series.step to specify the interval between consecutive indexes of the series (default is 1)
*/

/* global jQuery*/

(function ($) {
    'use strict';

    function process1DRawData(plot, series, data, datapoints) {
        if (series.flatdata === true) {
            var start = series.start || 0;
            var step = typeof series.step === 'number' ? series.step : 1;
            datapoints.pointsize = 2;
            for (var i = 0, j = 0; i < data.length; i++, j += 2) {
                datapoints.points[j] = start + (i * step);
                datapoints.points[j + 1] = data[i];
            }
            if (datapoints.points !== undefined) {
                datapoints.points.length = data.length * 2;
            } else {
                datapoints.points = [];
            }
        }
    }

    $.plot.plugins.push({
        init: function(plot) {
            plot.hooks.processRawData.push(process1DRawData);
        },
        name: 'flatdata',
        version: '0.0.2'
    });
})(jQuery);


/***/ }),

/***/ "./node_modules/flot/source/jquery.flot.hover.js":
/*!*******************************************************!*\
  !*** ./node_modules/flot/source/jquery.flot.hover.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* global jQuery */

/**
## jquery.flot.hover.js

This plugin is used for mouse hover and tap on a point of plot series.
It supports the following options:
```js
grid: {
    hoverable: false, //to trigger plothover event on mouse hover or tap on a point
    clickable: false //to trigger plotclick event on mouse hover
}
```

It listens to native mouse move event or click, as well as artificial generated
tap and touchevent.

When the mouse is over a point or a tap on a point is performed, that point or
the correscponding bar will be highlighted and a "plothover" event will be generated.

Custom "touchevent" is triggered when any touch interaction is made. Hover plugin
handles this events by unhighlighting all of the previously highlighted points and generates
"plothovercleanup" event to notify any part that is handling plothover (for exemple to cleanup
the tooltip from webcharts).
*/

(function($) {
    'use strict';

    var options = {
        grid: {
            hoverable: false,
            clickable: false
        }
    };

    var browser = $.plot.browser;

    var eventType = {
        click: 'click',
        hover: 'hover'
    }

    function init(plot) {
        var lastMouseMoveEvent;
        var highlights = [];

        function bindEvents(plot, eventHolder) {
            var o = plot.getOptions();

            if (o.grid.hoverable || o.grid.clickable) {
                eventHolder[0].addEventListener('touchevent', triggerCleanupEvent, false);
                eventHolder[0].addEventListener('tap', generatePlothoverEvent, false);
            }

            if (o.grid.clickable) {
                eventHolder.bind("click", onClick);
            }

            if (o.grid.hoverable) {
                eventHolder.bind("mousemove", onMouseMove);

                // Use bind, rather than .mouseleave, because we officially
                // still support jQuery 1.2.6, which doesn't define a shortcut
                // for mouseenter or mouseleave.  This was a bug/oversight that
                // was fixed somewhere around 1.3.x.  We can return to using
                // .mouseleave when we drop support for 1.2.6.

                eventHolder.bind("mouseleave", onMouseLeave);
            }
        }

        function shutdown(plot, eventHolder) {
            eventHolder[0].removeEventListener('tap', generatePlothoverEvent);
            eventHolder[0].removeEventListener('touchevent', triggerCleanupEvent);
            eventHolder.unbind("mousemove", onMouseMove);
            eventHolder.unbind("mouseleave", onMouseLeave);
            eventHolder.unbind("click", onClick);
            highlights = [];
        }

        function generatePlothoverEvent(e) {
            var o = plot.getOptions(),
                newEvent = new CustomEvent('mouseevent');

            //transform from touch event to mouse event format
            newEvent.pageX = e.detail.changedTouches[0].pageX;
            newEvent.pageY = e.detail.changedTouches[0].pageY;
            newEvent.clientX = e.detail.changedTouches[0].clientX;
            newEvent.clientY = e.detail.changedTouches[0].clientY;

            if (o.grid.hoverable) {
                doTriggerClickHoverEvent(newEvent, eventType.hover, 30);
            }
            return false;
        }

        function doTriggerClickHoverEvent(event, eventType, searchDistance) {
            var series = plot.getData();
            if (event !== undefined &&
                series.length > 0 &&
                series[0].xaxis.c2p !== undefined &&
                series[0].yaxis.c2p !== undefined) {
                var eventToTrigger = "plot" + eventType;
                var seriesFlag = eventType + "able";
                triggerClickHoverEvent(eventToTrigger, event,
                    function(i) {
                        return series[i][seriesFlag] !== false;
                    }, searchDistance);
            }
        }

        function onMouseMove(e) {
            lastMouseMoveEvent = e;
            plot.getPlaceholder()[0].lastMouseMoveEvent = e;
            doTriggerClickHoverEvent(e, eventType.hover);
        }

        function onMouseLeave(e) {
            lastMouseMoveEvent = undefined;
            plot.getPlaceholder()[0].lastMouseMoveEvent = undefined;
            triggerClickHoverEvent("plothover", e,
                function(i) {
                    return false;
                });
        }

        function onClick(e) {
            doTriggerClickHoverEvent(e, eventType.click);
        }

        function triggerCleanupEvent() {
            plot.unhighlight();
            plot.getPlaceholder().trigger('plothovercleanup');
        }

        // trigger click or hover event (they send the same parameters
        // so we share their code)
        function triggerClickHoverEvent(eventname, event, seriesFilter, searchDistance) {
            var options = plot.getOptions(),
                offset = plot.offset(),
                page = browser.getPageXY(event),
                canvasX = page.X - offset.left,
                canvasY = page.Y - offset.top,
                pos = plot.c2p({
                    left: canvasX,
                    top: canvasY
                }),
                distance = searchDistance !== undefined ? searchDistance : options.grid.mouseActiveRadius;

            pos.pageX = page.X;
            pos.pageY = page.Y;

            var items = plot.findNearbyItems(canvasX, canvasY, seriesFilter, distance);
            var item = items[0];

            for (let i = 1; i < items.length; ++i) {
                if (item.distance === undefined ||
                    items[i].distance < item.distance) {
                    item = items[i];
                }
            }

            if (item) {
                // fill in mouse pos for any listeners out there
                item.pageX = parseInt(item.series.xaxis.p2c(item.datapoint[0]) + offset.left, 10);
                item.pageY = parseInt(item.series.yaxis.p2c(item.datapoint[1]) + offset.top, 10);
            } else {
                item = null;
            }

            if (options.grid.autoHighlight) {
                // clear auto-highlights
                for (let i = 0; i < highlights.length; ++i) {
                    var h = highlights[i];
                    if ((h.auto === eventname &&
                        !(item && h.series === item.series &&
                            h.point[0] === item.datapoint[0] &&
                            h.point[1] === item.datapoint[1])) || !item) {
                        unhighlight(h.series, h.point);
                    }
                }

                if (item) {
                    highlight(item.series, item.datapoint, eventname);
                }
            }

            plot.getPlaceholder().trigger(eventname, [pos, item, items]);
        }

        function highlight(s, point, auto) {
            if (typeof s === "number") {
                s = plot.getData()[s];
            }

            if (typeof point === "number") {
                var ps = s.datapoints.pointsize;
                point = s.datapoints.points.slice(ps * point, ps * (point + 1));
            }

            var i = indexOfHighlight(s, point);
            if (i === -1) {
                highlights.push({
                    series: s,
                    point: point,
                    auto: auto
                });

                plot.triggerRedrawOverlay();
            } else if (!auto) {
                highlights[i].auto = false;
            }
        }

        function unhighlight(s, point) {
            if (s == null && point == null) {
                highlights = [];
                plot.triggerRedrawOverlay();
                return;
            }

            if (typeof s === "number") {
                s = plot.getData()[s];
            }

            if (typeof point === "number") {
                var ps = s.datapoints.pointsize;
                point = s.datapoints.points.slice(ps * point, ps * (point + 1));
            }

            var i = indexOfHighlight(s, point);
            if (i !== -1) {
                highlights.splice(i, 1);

                plot.triggerRedrawOverlay();
            }
        }

        function indexOfHighlight(s, p) {
            for (var i = 0; i < highlights.length; ++i) {
                var h = highlights[i];
                if (h.series === s &&
                    h.point[0] === p[0] &&
                    h.point[1] === p[1]) {
                    return i;
                }
            }

            return -1;
        }

        function processDatapoints() {
            triggerCleanupEvent();
            doTriggerClickHoverEvent(lastMouseMoveEvent, eventType.hover);
        }

        function setupGrid() {
            doTriggerClickHoverEvent(lastMouseMoveEvent, eventType.hover);
        }

        function drawOverlay(plot, octx, overlay) {
            var plotOffset = plot.getPlotOffset(),
                i, hi;

            octx.save();
            octx.translate(plotOffset.left, plotOffset.top);
            for (i = 0; i < highlights.length; ++i) {
                hi = highlights[i];

                if (hi.series.bars.show) drawBarHighlight(hi.series, hi.point, octx);
                else drawPointHighlight(hi.series, hi.point, octx, plot);
            }
            octx.restore();
        }

        function drawPointHighlight(series, point, octx, plot) {
            var x = point[0],
                y = point[1],
                axisx = series.xaxis,
                axisy = series.yaxis,
                highlightColor = (typeof series.highlightColor === "string") ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString();

            if (x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max) {
                return;
            }

            var pointRadius = series.points.radius + series.points.lineWidth / 2;
            octx.lineWidth = pointRadius;
            octx.strokeStyle = highlightColor;
            var radius = 1.5 * pointRadius;
            x = axisx.p2c(x);
            y = axisy.p2c(y);

            octx.beginPath();
            var symbol = series.points.symbol;
            if (symbol === 'circle') {
                octx.arc(x, y, radius, 0, 2 * Math.PI, false);
            } else if (typeof symbol === 'string' && plot.drawSymbol && plot.drawSymbol[symbol]) {
                plot.drawSymbol[symbol](octx, x, y, radius, false);
            }

            octx.closePath();
            octx.stroke();
        }

        function drawBarHighlight(series, point, octx) {
            var highlightColor = (typeof series.highlightColor === "string") ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString(),
                fillStyle = highlightColor,
                barLeft;

            var barWidth = series.bars.barWidth[0] || series.bars.barWidth;
            switch (series.bars.align) {
                case "left":
                    barLeft = 0;
                    break;
                case "right":
                    barLeft = -barWidth;
                    break;
                default:
                    barLeft = -barWidth / 2;
            }

            octx.lineWidth = series.bars.lineWidth;
            octx.strokeStyle = highlightColor;

            var fillTowards = series.bars.fillTowards || 0,
                bottom = fillTowards > series.yaxis.min ? Math.min(series.yaxis.max, fillTowards) : series.yaxis.min;

            $.plot.drawSeries.drawBar(point[0], point[1], point[2] || bottom, barLeft, barLeft + barWidth,
                function() {
                    return fillStyle;
                }, series.xaxis, series.yaxis, octx, series.bars.horizontal, series.bars.lineWidth);
        }

        function initHover(plot, options) {
            plot.highlight = highlight;
            plot.unhighlight = unhighlight;
            if (options.grid.hoverable || options.grid.clickable) {
                plot.hooks.drawOverlay.push(drawOverlay);
                plot.hooks.processDatapoints.push(processDatapoints);
                plot.hooks.setupGrid.push(setupGrid);
            }

            lastMouseMoveEvent = plot.getPlaceholder()[0].lastMouseMoveEvent;
        }

        plot.hooks.bindEvents.push(bindEvents);
        plot.hooks.shutdown.push(shutdown);
        plot.hooks.processOptions.push(initHover);
    }

    $.plot.plugins.push({
        init: init,
        options: options,
        name: 'hover',
        version: '0.1'
    });
})(jQuery);


/***/ }),

/***/ "./node_modules/flot/source/jquery.flot.image.js":
/*!*******************************************************!*\
  !*** ./node_modules/flot/source/jquery.flot.image.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* Flot plugin for plotting images.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Licensed under the MIT license.

The data syntax is [ [ image, x1, y1, x2, y2 ], ... ] where (x1, y1) and
(x2, y2) are where you intend the two opposite corners of the image to end up
in the plot. Image must be a fully loaded Javascript image (you can make one
with new Image()). If the image is not complete, it's skipped when plotting.

There are two helpers included for retrieving images. The easiest work the way
that you put in URLs instead of images in the data, like this:

    [ "myimage.png", 0, 0, 10, 10 ]

Then call $.plot.image.loadData( data, options, callback ) where data and
options are the same as you pass in to $.plot. This loads the images, replaces
the URLs in the data with the corresponding images and calls "callback" when
all images are loaded (or failed loading). In the callback, you can then call
$.plot with the data set. See the included example.

A more low-level helper, $.plot.image.load(urls, callback) is also included.
Given a list of URLs, it calls callback with an object mapping from URL to
Image object when all images are loaded or have failed loading.

The plugin supports these options:

    series: {
        images: {
            show: boolean
            anchor: "corner" or "center"
            alpha: [ 0, 1 ]
        }
    }

They can be specified for a specific series:

    $.plot( $("#placeholder"), [{
        data: [ ... ],
        images: { ... }
    ])

Note that because the data format is different from usual data points, you
can't use images with anything else in a specific data series.

Setting "anchor" to "center" causes the pixels in the image to be anchored at
the corner pixel centers inside of at the pixel corners, effectively letting
half a pixel stick out to each side in the plot.

A possible future direction could be support for tiling for large images (like
Google Maps).

*/

(function ($) {
    var options = {
        series: {
            images: {
                show: false,
                alpha: 1,
                anchor: "corner" // or "center"
            }
        }
    };

    $.plot.image = {};

    $.plot.image.loadDataImages = function (series, options, callback) {
        var urls = [], points = [];

        var defaultShow = options.series.images.show;

        $.each(series, function (i, s) {
            if (!(defaultShow || s.images.show)) {
                return;
            }

            if (s.data) {
                s = s.data;
            }

            $.each(s, function (i, p) {
                if (typeof p[0] === "string") {
                    urls.push(p[0]);
                    points.push(p);
                }
            });
        });

        $.plot.image.load(urls, function (loadedImages) {
            $.each(points, function (i, p) {
                var url = p[0];
                if (loadedImages[url]) {
                    p[0] = loadedImages[url];
                }
            });

            callback();
        });
    }

    $.plot.image.load = function (urls, callback) {
        var missing = urls.length, loaded = {};
        if (missing === 0) {
            callback({});
        }

        $.each(urls, function (i, url) {
            var handler = function () {
                --missing;
                loaded[url] = this;

                if (missing === 0) {
                    callback(loaded);
                }
            };

            $('<img />').load(handler).error(handler).attr('src', url);
        });
    };

    function drawSeries(plot, ctx, series) {
        var plotOffset = plot.getPlotOffset();

        if (!series.images || !series.images.show) {
            return;
        }

        var points = series.datapoints.points,
            ps = series.datapoints.pointsize;

        for (var i = 0; i < points.length; i += ps) {
            var img = points[i],
                x1 = points[i + 1], y1 = points[i + 2],
                x2 = points[i + 3], y2 = points[i + 4],
                xaxis = series.xaxis, yaxis = series.yaxis,
                tmp;

            // actually we should check img.complete, but it
            // appears to be a somewhat unreliable indicator in
            // IE6 (false even after load event)
            if (!img || img.width <= 0 || img.height <= 0) {
                continue;
            }

            if (x1 > x2) {
                tmp = x2;
                x2 = x1;
                x1 = tmp;
            }
            if (y1 > y2) {
                tmp = y2;
                y2 = y1;
                y1 = tmp;
            }

            // if the anchor is at the center of the pixel, expand the
            // image by 1/2 pixel in each direction
            if (series.images.anchor === "center") {
                tmp = 0.5 * (x2 - x1) / (img.width - 1);
                x1 -= tmp;
                x2 += tmp;
                tmp = 0.5 * (y2 - y1) / (img.height - 1);
                y1 -= tmp;
                y2 += tmp;
            }

            // clip
            if (x1 === x2 || y1 === y2 ||
                x1 >= xaxis.max || x2 <= xaxis.min ||
                y1 >= yaxis.max || y2 <= yaxis.min) {
                continue;
            }

            var sx1 = 0, sy1 = 0, sx2 = img.width, sy2 = img.height;
            if (x1 < xaxis.min) {
                sx1 += (sx2 - sx1) * (xaxis.min - x1) / (x2 - x1);
                x1 = xaxis.min;
            }

            if (x2 > xaxis.max) {
                sx2 += (sx2 - sx1) * (xaxis.max - x2) / (x2 - x1);
                x2 = xaxis.max;
            }

            if (y1 < yaxis.min) {
                sy2 += (sy1 - sy2) * (yaxis.min - y1) / (y2 - y1);
                y1 = yaxis.min;
            }

            if (y2 > yaxis.max) {
                sy1 += (sy1 - sy2) * (yaxis.max - y2) / (y2 - y1);
                y2 = yaxis.max;
            }

            x1 = xaxis.p2c(x1);
            x2 = xaxis.p2c(x2);
            y1 = yaxis.p2c(y1);
            y2 = yaxis.p2c(y2);

            // the transformation may have swapped us
            if (x1 > x2) {
                tmp = x2;
                x2 = x1;
                x1 = tmp;
            }
            if (y1 > y2) {
                tmp = y2;
                y2 = y1;
                y1 = tmp;
            }

            tmp = ctx.globalAlpha;
            ctx.globalAlpha *= series.images.alpha;
            ctx.drawImage(img,
                          sx1, sy1, sx2 - sx1, sy2 - sy1,
                          x1 + plotOffset.left, y1 + plotOffset.top,
                          x2 - x1, y2 - y1);
            ctx.globalAlpha = tmp;
        }
    }

    function processRawData(plot, series, data, datapoints) {
        if (!series.images.show) {
            return;
        }

        // format is Image, x1, y1, x2, y2 (opposite corners)
        datapoints.format = [
            { required: true },
            { x: true, number: true, required: true },
            { y: true, number: true, required: true },
            { x: true, number: true, required: true },
            { y: true, number: true, required: true }
        ];
    }

    function init(plot) {
        plot.hooks.processRawData.push(processRawData);
        plot.hooks.drawSeries.push(drawSeries);
    }

    $.plot.plugins.push({
        init: init,
        options: options,
        name: 'image',
        version: '1.1'
    });
})(jQuery);


/***/ }),

/***/ "./node_modules/flot/source/jquery.flot.js":
/*!*************************************************!*\
  !*** ./node_modules/flot/source/jquery.flot.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* Javascript plotting library for jQuery, version 3.0.0.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Licensed under the MIT license.

*/

// the actual Flot code
(function($) {
    "use strict";

    var Canvas = window.Flot.Canvas;

    function defaultTickGenerator(axis) {
        var ticks = [],
            start = $.plot.saturated.saturate($.plot.saturated.floorInBase(axis.min, axis.tickSize)),
            i = 0,
            v = Number.NaN,
            prev;

        if (start === -Number.MAX_VALUE) {
            ticks.push(start);
            start = $.plot.saturated.floorInBase(axis.min + axis.tickSize, axis.tickSize);
        }

        do {
            prev = v;
            //v = start + i * axis.tickSize;
            v = $.plot.saturated.multiplyAdd(axis.tickSize, i, start);
            ticks.push(v);
            ++i;
        } while (v < axis.max && v !== prev);

        return ticks;
    }

    function defaultTickFormatter(value, axis, precision) {
        var oldTickDecimals = axis.tickDecimals,
            expPosition = ("" + value).indexOf("e");

        if (expPosition !== -1) {
            return expRepTickFormatter(value, axis, precision);
        }

        if (precision > 0) {
            axis.tickDecimals = precision;
        }

        var factor = axis.tickDecimals ? parseFloat('1e' + axis.tickDecimals) : 1,
            formatted = "" + Math.round(value * factor) / factor;

        // If tickDecimals was specified, ensure that we have exactly that
        // much precision; otherwise default to the value's own precision.
        if (axis.tickDecimals != null) {
            var decimal = formatted.indexOf("."),
                decimalPrecision = decimal === -1 ? 0 : formatted.length - decimal - 1;
            if (decimalPrecision < axis.tickDecimals) {
                var decimals = ("" + factor).substr(1, axis.tickDecimals - decimalPrecision);
                formatted = (decimalPrecision ? formatted : formatted + ".") + decimals;
            }
        }

        axis.tickDecimals = oldTickDecimals;
        return formatted;
    };

    function expRepTickFormatter(value, axis, precision) {
        var expPosition = ("" + value).indexOf("e"),
            exponentValue = parseInt(("" + value).substr(expPosition + 1)),
            tenExponent = expPosition !== -1 ? exponentValue : (value > 0 ? Math.floor(Math.log(value) / Math.LN10) : 0),
            roundWith = parseFloat('1e' + tenExponent),
            x = value / roundWith;

        if (precision) {
            var updatedPrecision = recomputePrecision(value, precision);
            return (value / roundWith).toFixed(updatedPrecision) + 'e' + tenExponent;
        }

        if (axis.tickDecimals > 0) {
            return x.toFixed(recomputePrecision(value, axis.tickDecimals)) + 'e' + tenExponent;
        }
        return x.toFixed() + 'e' + tenExponent;
    }

    function recomputePrecision(num, precision) {
        //for numbers close to zero, the precision from flot will be a big number
        //while for big numbers, the precision will be negative
        var log10Value = Math.log(Math.abs(num)) * Math.LOG10E,
            newPrecision = Math.abs(log10Value + precision);

        return newPrecision <= 20 ? Math.floor(newPrecision) : 20;
    }

    ///////////////////////////////////////////////////////////////////////////
    // The top-level container for the entire plot.
    function Plot(placeholder, data_, options_, plugins) {
        // data is on the form:
        //   [ series1, series2 ... ]
        // where series is either just the data as [ [x1, y1], [x2, y2], ... ]
        // or { data: [ [x1, y1], [x2, y2], ... ], label: "some label", ... }

        var series = [],
            options = {
                // the color theme used for graphs
                colors: ["#edc240", "#afd8f8", "#cb4b4b", "#4da74d", "#9440ed"],
                xaxis: {
                    show: null, // null = auto-detect, true = always, false = never
                    position: "bottom", // or "top"
                    mode: null, // null or "time"
                    font: null, // null (derived from CSS in placeholder) or object like { size: 11, lineHeight: 13, style: "italic", weight: "bold", family: "sans-serif", variant: "small-caps" }
                    color: null, // base color, labels, ticks
                    tickColor: null, // possibly different color of ticks, e.g. "rgba(0,0,0,0.15)"
                    transform: null, // null or f: number -> number to transform axis
                    inverseTransform: null, // if transform is set, this should be the inverse function
                    min: null, // min. value to show, null means set automatically
                    max: null, // max. value to show, null means set automatically
                    autoScaleMargin: null, // margin in % to add if autoScale option is on "loose" mode,
                    autoScale: "exact", // Available modes: "none", "loose", "exact", "sliding-window"
                    windowSize: null, // null or number. This is the size of sliding-window.
                    growOnly: null, // grow only, useful for smoother auto-scale, the scales will grow to accomodate data but won't shrink back.
                    ticks: null, // either [1, 3] or [[1, "a"], 3] or (fn: axis info -> ticks) or app. number of ticks for auto-ticks
                    tickFormatter: null, // fn: number -> string
                    showTickLabels: "major", // "none", "endpoints", "major", "all"
                    labelWidth: null, // size of tick labels in pixels
                    labelHeight: null,
                    reserveSpace: null, // whether to reserve space even if axis isn't shown
                    tickLength: null, // size in pixels of major tick marks
                    showMinorTicks: null, // true = show minor tick marks, false = hide minor tick marks
                    showTicks: null, // true = show tick marks, false = hide all tick marks
                    gridLines: null, // true = show grid lines, false = hide grid lines
                    alignTicksWithAxis: null, // axis number or null for no sync
                    tickDecimals: null, // no. of decimals, null means auto
                    tickSize: null, // number or [number, "unit"]
                    minTickSize: null, // number or [number, "unit"]
                    offset: { below: 0, above: 0 }, // the plot drawing offset. this is calculated by the flot.navigate for each axis
                    boxPosition: { centerX: 0, centerY: 0 } //position of the axis on the corresponding axis box
                },
                yaxis: {
                    autoScaleMargin: 0.02, // margin in % to add if autoScale option is on "loose" mode
                    autoScale: "loose", // Available modes: "none", "loose", "exact"
                    growOnly: null, // grow only, useful for smoother auto-scale, the scales will grow to accomodate data but won't shrink back.
                    position: "left", // or "right"
                    showTickLabels: "major", // "none", "endpoints", "major", "all"
                    offset: { below: 0, above: 0 }, // the plot drawing offset. this is calculated by the flot.navigate for each axis
                    boxPosition: { centerX: 0, centerY: 0 } //position of the axis on the corresponding axis box
                },
                xaxes: [],
                yaxes: [],
                series: {
                    points: {
                        show: false,
                        radius: 3,
                        lineWidth: 2, // in pixels
                        fill: true,
                        fillColor: "#ffffff",
                        symbol: 'circle' // or callback
                    },
                    lines: {
                        // we don't put in show: false so we can see
                        // whether lines were actively disabled
                        lineWidth: 1, // in pixels
                        fill: false,
                        fillColor: null,
                        steps: false
                        // Omit 'zero', so we can later default its value to
                        // match that of the 'fill' option.
                    },
                    bars: {
                        show: false,
                        lineWidth: 2, // in pixels
                        // barWidth: number or [number, absolute]
                        // when 'absolute' is false, 'number' is relative to the minimum distance between points for the series
                        // when 'absolute' is true, 'number' is considered to be in units of the x-axis
                        horizontal: false,
                        barWidth: 0.8,
                        fill: true,
                        fillColor: null,
                        align: "left", // "left", "right", or "center"
                        zero: true
                    },
                    shadowSize: 3,
                    highlightColor: null
                },
                grid: {
                    show: true,
                    aboveData: false,
                    color: "#545454", // primary color used for outline and labels
                    backgroundColor: null, // null for transparent, else color
                    borderColor: null, // set if different from the grid color
                    tickColor: null, // color for the ticks, e.g. "rgba(0,0,0,0.15)"
                    margin: 0, // distance from the canvas edge to the grid
                    labelMargin: 5, // in pixels
                    axisMargin: 8, // in pixels
                    borderWidth: 1, // in pixels
                    minBorderMargin: null, // in pixels, null means taken from points radius
                    markings: null, // array of ranges or fn: axes -> array of ranges
                    markingsColor: "#f4f4f4",
                    markingsLineWidth: 2,
                    // interactive stuff
                    clickable: false,
                    hoverable: false,
                    autoHighlight: true, // highlight in case mouse is near
                    mouseActiveRadius: 15 // how far the mouse can be away to activate an item
                },
                interaction: {
                    redrawOverlayInterval: 1000 / 60 // time between updates, -1 means in same flow
                },
                hooks: {}
            },
            surface = null, // the canvas for the plot itself
            overlay = null, // canvas for interactive stuff on top of plot
            eventHolder = null, // jQuery object that events should be bound to
            ctx = null,
            octx = null,
            xaxes = [],
            yaxes = [],
            plotOffset = {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0
            },
            plotWidth = 0,
            plotHeight = 0,
            hooks = {
                processOptions: [],
                processRawData: [],
                processDatapoints: [],
                processOffset: [],
                setupGrid: [],
                adjustSeriesDataRange: [],
                setRange: [],
                drawBackground: [],
                drawSeries: [],
                drawAxis: [],
                draw: [],
                findNearbyItems: [],
                axisReserveSpace: [],
                bindEvents: [],
                drawOverlay: [],
                resize: [],
                shutdown: []
            },
            plot = this;

        var eventManager = {};

        // interactive features

        var redrawTimeout = null;

        // public functions
        plot.setData = setData;
        plot.setupGrid = setupGrid;
        plot.draw = draw;
        plot.getPlaceholder = function() {
            return placeholder;
        };
        plot.getCanvas = function() {
            return surface.element;
        };
        plot.getSurface = function() {
            return surface;
        };
        plot.getEventHolder = function() {
            return eventHolder[0];
        };
        plot.getPlotOffset = function() {
            return plotOffset;
        };
        plot.width = function() {
            return plotWidth;
        };
        plot.height = function() {
            return plotHeight;
        };
        plot.offset = function() {
            var o = eventHolder.offset();
            o.left += plotOffset.left;
            o.top += plotOffset.top;
            return o;
        };
        plot.getData = function() {
            return series;
        };
        plot.getAxes = function() {
            var res = {};
            $.each(xaxes.concat(yaxes), function(_, axis) {
                if (axis) {
                    res[axis.direction + (axis.n !== 1 ? axis.n : "") + "axis"] = axis;
                }
            });
            return res;
        };
        plot.getXAxes = function() {
            return xaxes;
        };
        plot.getYAxes = function() {
            return yaxes;
        };
        plot.c2p = canvasToCartesianAxisCoords;
        plot.p2c = cartesianAxisToCanvasCoords;
        plot.getOptions = function() {
            return options;
        };
        plot.triggerRedrawOverlay = triggerRedrawOverlay;
        plot.pointOffset = function(point) {
            return {
                left: parseInt(xaxes[axisNumber(point, "x") - 1].p2c(+point.x) + plotOffset.left, 10),
                top: parseInt(yaxes[axisNumber(point, "y") - 1].p2c(+point.y) + plotOffset.top, 10)
            };
        };
        plot.shutdown = shutdown;
        plot.destroy = function() {
            shutdown();
            placeholder.removeData("plot").empty();

            series = [];
            options = null;
            surface = null;
            overlay = null;
            eventHolder = null;
            ctx = null;
            octx = null;
            xaxes = [];
            yaxes = [];
            hooks = null;
            plot = null;
        };

        plot.resize = function() {
            var width = placeholder.width(),
                height = placeholder.height();
            surface.resize(width, height);
            overlay.resize(width, height);

            executeHooks(hooks.resize, [width, height]);
        };

        plot.clearTextCache = function () {
            surface.clearCache();
            overlay.clearCache();
        };

        plot.autoScaleAxis = autoScaleAxis;
        plot.computeRangeForDataSeries = computeRangeForDataSeries;
        plot.adjustSeriesDataRange = adjustSeriesDataRange;
        plot.findNearbyItem = findNearbyItem;
        plot.findNearbyItems = findNearbyItems;
        plot.findNearbyInterpolationPoint = findNearbyInterpolationPoint;
        plot.computeValuePrecision = computeValuePrecision;
        plot.computeTickSize = computeTickSize;
        plot.addEventHandler = addEventHandler;

        // public attributes
        plot.hooks = hooks;

        // initialize
        var MINOR_TICKS_COUNT_CONSTANT = $.plot.uiConstants.MINOR_TICKS_COUNT_CONSTANT;
        var TICK_LENGTH_CONSTANT = $.plot.uiConstants.TICK_LENGTH_CONSTANT;
        initPlugins(plot);
        setupCanvases();
        parseOptions(options_);
        setData(data_);
        setupGrid(true);
        draw();
        bindEvents();

        function executeHooks(hook, args) {
            args = [plot].concat(args);
            for (var i = 0; i < hook.length; ++i) {
                hook[i].apply(this, args);
            }
        }

        function initPlugins() {
            // References to key classes, allowing plugins to modify them

            var classes = {
                Canvas: Canvas
            };

            for (var i = 0; i < plugins.length; ++i) {
                var p = plugins[i];
                p.init(plot, classes);
                if (p.options) {
                    $.extend(true, options, p.options);
                }
            }
        }

        function parseOptions(opts) {
            $.extend(true, options, opts);

            // $.extend merges arrays, rather than replacing them.  When less
            // colors are provided than the size of the default palette, we
            // end up with those colors plus the remaining defaults, which is
            // not expected behavior; avoid it by replacing them here.

            if (opts && opts.colors) {
                options.colors = opts.colors;
            }

            if (options.xaxis.color == null) {
                options.xaxis.color = $.color.parse(options.grid.color).scale('a', 0.22).toString();
            }

            if (options.yaxis.color == null) {
                options.yaxis.color = $.color.parse(options.grid.color).scale('a', 0.22).toString();
            }

            if (options.xaxis.tickColor == null) {
                // grid.tickColor for back-compatibility
                options.xaxis.tickColor = options.grid.tickColor || options.xaxis.color;
            }

            if (options.yaxis.tickColor == null) {
                // grid.tickColor for back-compatibility
                options.yaxis.tickColor = options.grid.tickColor || options.yaxis.color;
            }

            if (options.grid.borderColor == null) {
                options.grid.borderColor = options.grid.color;
            }

            if (options.grid.tickColor == null) {
                options.grid.tickColor = $.color.parse(options.grid.color).scale('a', 0.22).toString();
            }

            // Fill in defaults for axis options, including any unspecified
            // font-spec fields, if a font-spec was provided.

            // If no x/y axis options were provided, create one of each anyway,
            // since the rest of the code assumes that they exist.

            var i, axisOptions, axisCount,
                fontSize = placeholder.css("font-size"),
                fontSizeDefault = fontSize ? +fontSize.replace("px", "") : 13,
                fontDefaults = {
                    style: placeholder.css("font-style"),
                    size: Math.round(0.8 * fontSizeDefault),
                    variant: placeholder.css("font-variant"),
                    weight: placeholder.css("font-weight"),
                    family: placeholder.css("font-family")
                };

            axisCount = options.xaxes.length || 1;
            for (i = 0; i < axisCount; ++i) {
                axisOptions = options.xaxes[i];
                if (axisOptions && !axisOptions.tickColor) {
                    axisOptions.tickColor = axisOptions.color;
                }

                axisOptions = $.extend(true, {}, options.xaxis, axisOptions);
                options.xaxes[i] = axisOptions;

                if (axisOptions.font) {
                    axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);
                    if (!axisOptions.font.color) {
                        axisOptions.font.color = axisOptions.color;
                    }
                    if (!axisOptions.font.lineHeight) {
                        axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);
                    }
                }
            }

            axisCount = options.yaxes.length || 1;
            for (i = 0; i < axisCount; ++i) {
                axisOptions = options.yaxes[i];
                if (axisOptions && !axisOptions.tickColor) {
                    axisOptions.tickColor = axisOptions.color;
                }

                axisOptions = $.extend(true, {}, options.yaxis, axisOptions);
                options.yaxes[i] = axisOptions;

                if (axisOptions.font) {
                    axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);
                    if (!axisOptions.font.color) {
                        axisOptions.font.color = axisOptions.color;
                    }
                    if (!axisOptions.font.lineHeight) {
                        axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);
                    }
                }
            }

            // save options on axes for future reference
            for (i = 0; i < options.xaxes.length; ++i) {
                getOrCreateAxis(xaxes, i + 1).options = options.xaxes[i];
            }

            for (i = 0; i < options.yaxes.length; ++i) {
                getOrCreateAxis(yaxes, i + 1).options = options.yaxes[i];
            }

            //process boxPosition options used for axis.box size
            $.each(allAxes(), function(_, axis) {
                axis.boxPosition = axis.options.boxPosition || {centerX: 0, centerY: 0};
            });

            // add hooks from options
            for (var n in hooks) {
                if (options.hooks[n] && options.hooks[n].length) {
                    hooks[n] = hooks[n].concat(options.hooks[n]);
                }
            }

            executeHooks(hooks.processOptions, [options]);
        }

        function setData(d) {
            var oldseries = series;
            series = parseData(d);
            fillInSeriesOptions();
            processData(oldseries);
        }

        function parseData(d) {
            var res = [];
            for (var i = 0; i < d.length; ++i) {
                var s = $.extend(true, {}, options.series);

                if (d[i].data != null) {
                    s.data = d[i].data; // move the data instead of deep-copy
                    delete d[i].data;

                    $.extend(true, s, d[i]);

                    d[i].data = s.data;
                } else {
                    s.data = d[i];
                }

                res.push(s);
            }

            return res;
        }

        function axisNumber(obj, coord) {
            var a = obj[coord + "axis"];
            if (typeof a === "object") {
                // if we got a real axis, extract number
                a = a.n;
            }

            if (typeof a !== "number") {
                a = 1; // default to first axis
            }

            return a;
        }

        function allAxes() {
            // return flat array without annoying null entries
            return xaxes.concat(yaxes).filter(function(a) {
                return a;
            });
        }

        // canvas to axis for cartesian axes
        function canvasToCartesianAxisCoords(pos) {
            // return an object with x/y corresponding to all used axes
            var res = {},
                i, axis;
            for (i = 0; i < xaxes.length; ++i) {
                axis = xaxes[i];
                if (axis && axis.used) {
                    res["x" + axis.n] = axis.c2p(pos.left);
                }
            }

            for (i = 0; i < yaxes.length; ++i) {
                axis = yaxes[i];
                if (axis && axis.used) {
                    res["y" + axis.n] = axis.c2p(pos.top);
                }
            }

            if (res.x1 !== undefined) {
                res.x = res.x1;
            }

            if (res.y1 !== undefined) {
                res.y = res.y1;
            }

            return res;
        }

        // axis to canvas for cartesian axes
        function cartesianAxisToCanvasCoords(pos) {
            // get canvas coords from the first pair of x/y found in pos
            var res = {},
                i, axis, key;

            for (i = 0; i < xaxes.length; ++i) {
                axis = xaxes[i];
                if (axis && axis.used) {
                    key = "x" + axis.n;
                    if (pos[key] == null && axis.n === 1) {
                        key = "x";
                    }

                    if (pos[key] != null) {
                        res.left = axis.p2c(pos[key]);
                        break;
                    }
                }
            }

            for (i = 0; i < yaxes.length; ++i) {
                axis = yaxes[i];
                if (axis && axis.used) {
                    key = "y" + axis.n;
                    if (pos[key] == null && axis.n === 1) {
                        key = "y";
                    }

                    if (pos[key] != null) {
                        res.top = axis.p2c(pos[key]);
                        break;
                    }
                }
            }

            return res;
        }

        function getOrCreateAxis(axes, number) {
            if (!axes[number - 1]) {
                axes[number - 1] = {
                    n: number, // save the number for future reference
                    direction: axes === xaxes ? "x" : "y",
                    options: $.extend(true, {}, axes === xaxes ? options.xaxis : options.yaxis)
                };
            }

            return axes[number - 1];
        }

        function fillInSeriesOptions() {
            var neededColors = series.length,
                maxIndex = -1,
                i;

            // Subtract the number of series that already have fixed colors or
            // color indexes from the number that we still need to generate.

            for (i = 0; i < series.length; ++i) {
                var sc = series[i].color;
                if (sc != null) {
                    neededColors--;
                    if (typeof sc === "number" && sc > maxIndex) {
                        maxIndex = sc;
                    }
                }
            }

            // If any of the series have fixed color indexes, then we need to
            // generate at least as many colors as the highest index.

            if (neededColors <= maxIndex) {
                neededColors = maxIndex + 1;
            }

            // Generate all the colors, using first the option colors and then
            // variations on those colors once they're exhausted.

            var c, colors = [],
                colorPool = options.colors,
                colorPoolSize = colorPool.length,
                variation = 0,
                definedColors = Math.max(0, series.length - neededColors);

            for (i = 0; i < neededColors; i++) {
                c = $.color.parse(colorPool[(definedColors + i) % colorPoolSize] || "#666");

                // Each time we exhaust the colors in the pool we adjust
                // a scaling factor used to produce more variations on
                // those colors. The factor alternates negative/positive
                // to produce lighter/darker colors.

                // Reset the variation after every few cycles, or else
                // it will end up producing only white or black colors.

                if (i % colorPoolSize === 0 && i) {
                    if (variation >= 0) {
                        if (variation < 0.5) {
                            variation = -variation - 0.2;
                        } else variation = 0;
                    } else variation = -variation;
                }

                colors[i] = c.scale('rgb', 1 + variation);
            }

            // Finalize the series options, filling in their colors

            var colori = 0,
                s;
            for (i = 0; i < series.length; ++i) {
                s = series[i];

                // assign colors
                if (s.color == null) {
                    s.color = colors[colori].toString();
                    ++colori;
                } else if (typeof s.color === "number") {
                    s.color = colors[s.color].toString();
                }

                // turn on lines automatically in case nothing is set
                if (s.lines.show == null) {
                    var v, show = true;
                    for (v in s) {
                        if (s[v] && s[v].show) {
                            show = false;
                            break;
                        }
                    }

                    if (show) {
                        s.lines.show = true;
                    }
                }

                // If nothing was provided for lines.zero, default it to match
                // lines.fill, since areas by default should extend to zero.

                if (s.lines.zero == null) {
                    s.lines.zero = !!s.lines.fill;
                }

                // setup axes
                s.xaxis = getOrCreateAxis(xaxes, axisNumber(s, "x"));
                s.yaxis = getOrCreateAxis(yaxes, axisNumber(s, "y"));
            }
        }

        function processData(prevSeries) {
            var topSentry = Number.POSITIVE_INFINITY,
                bottomSentry = Number.NEGATIVE_INFINITY,
                i, j, k, m,
                s, points, ps, val, f, p,
                data, format;

            function updateAxis(axis, min, max) {
                if (min < axis.datamin && min !== -Infinity) {
                    axis.datamin = min;
                }

                if (max > axis.datamax && max !== Infinity) {
                    axis.datamax = max;
                }
            }

            function reusePoints(prevSeries, i) {
                if (prevSeries && prevSeries[i] && prevSeries[i].datapoints && prevSeries[i].datapoints.points) {
                    return prevSeries[i].datapoints.points;
                }

                return [];
            }

            $.each(allAxes(), function(_, axis) {
                // init axis
                if (axis.options.growOnly !== true) {
                    axis.datamin = topSentry;
                    axis.datamax = bottomSentry;
                } else {
                    if (axis.datamin === undefined) {
                        axis.datamin = topSentry;
                    }
                    if (axis.datamax === undefined) {
                        axis.datamax = bottomSentry;
                    }
                }
                axis.used = false;
            });

            for (i = 0; i < series.length; ++i) {
                s = series[i];
                s.datapoints = {
                    points: []
                };

                if (s.datapoints.points.length === 0) {
                    s.datapoints.points = reusePoints(prevSeries, i);
                }

                executeHooks(hooks.processRawData, [s, s.data, s.datapoints]);
            }

            // first pass: clean and copy data
            for (i = 0; i < series.length; ++i) {
                s = series[i];

                data = s.data;
                format = s.datapoints.format;

                if (!format) {
                    format = [];
                    // find out how to copy
                    format.push({
                        x: true,
                        y: false,
                        number: true,
                        required: true,
                        computeRange: s.xaxis.options.autoScale !== 'none',
                        defaultValue: null
                    });

                    format.push({
                        x: false,
                        y: true,
                        number: true,
                        required: true,
                        computeRange: s.yaxis.options.autoScale !== 'none',
                        defaultValue: null
                    });

                    if (s.stack || s.bars.show || (s.lines.show && s.lines.fill)) {
                        var expectedPs = s.datapoints.pointsize != null ? s.datapoints.pointsize : (s.data && s.data[0] && s.data[0].length ? s.data[0].length : 3);
                        if (expectedPs > 2) {
                            format.push({
                                x: false,
                                y: true,
                                number: true,
                                required: false,
                                computeRange: s.yaxis.options.autoScale !== 'none',
                                defaultValue: 0
                            });
                        }
                    }

                    s.datapoints.format = format;
                }

                s.xaxis.used = s.yaxis.used = true;

                if (s.datapoints.pointsize != null) continue; // already filled in

                s.datapoints.pointsize = format.length;
                ps = s.datapoints.pointsize;
                points = s.datapoints.points;

                for (j = k = 0; j < data.length; ++j, k += ps) {
                    p = data[j];

                    var nullify = p == null;
                    if (!nullify) {
                        for (m = 0; m < ps; ++m) {
                            val = p[m];
                            f = format[m];

                            if (f) {
                                if (f.number && val != null) {
                                    val = +val; // convert to number
                                    if (isNaN(val)) {
                                        val = null;
                                    }
                                }

                                if (val == null) {
                                    if (f.required) nullify = true;

                                    if (f.defaultValue != null) val = f.defaultValue;
                                }
                            }

                            points[k + m] = val;
                        }
                    }

                    if (nullify) {
                        for (m = 0; m < ps; ++m) {
                            val = points[k + m];
                            if (val != null) {
                                f = format[m];
                                // extract min/max info
                                if (f.computeRange) {
                                    if (f.x) {
                                        updateAxis(s.xaxis, val, val);
                                    }
                                    if (f.y) {
                                        updateAxis(s.yaxis, val, val);
                                    }
                                }
                            }
                            points[k + m] = null;
                        }
                    }
                }

                points.length = k; //trims the internal buffer to the correct length
            }

            // give the hooks a chance to run
            for (i = 0; i < series.length; ++i) {
                s = series[i];

                executeHooks(hooks.processDatapoints, [s, s.datapoints]);
            }

            // second pass: find datamax/datamin for auto-scaling
            for (i = 0; i < series.length; ++i) {
                s = series[i];
                format = s.datapoints.format;

                if (format.every(function (f) { return !f.computeRange; })) {
                    continue;
                }

                var range = plot.adjustSeriesDataRange(s,
                    plot.computeRangeForDataSeries(s));

                executeHooks(hooks.adjustSeriesDataRange, [s, range]);

                updateAxis(s.xaxis, range.xmin, range.xmax);
                updateAxis(s.yaxis, range.ymin, range.ymax);
            }

            $.each(allAxes(), function(_, axis) {
                if (axis.datamin === topSentry) {
                    axis.datamin = null;
                }

                if (axis.datamax === bottomSentry) {
                    axis.datamax = null;
                }
            });
        }

        function setupCanvases() {
            // Make sure the placeholder is clear of everything except canvases
            // from a previous plot in this container that we'll try to re-use.

            placeholder.css("padding", 0) // padding messes up the positioning
                .children().filter(function() {
                    return !$(this).hasClass("flot-overlay") && !$(this).hasClass('flot-base');
                }).remove();

            if (placeholder.css("position") === 'static') {
                placeholder.css("position", "relative"); // for positioning labels and overlay
            }

            surface = new Canvas("flot-base", placeholder[0]);
            overlay = new Canvas("flot-overlay", placeholder[0]); // overlay canvas for interactive features

            ctx = surface.context;
            octx = overlay.context;

            // define which element we're listening for events on
            eventHolder = $(overlay.element).unbind();

            // If we're re-using a plot object, shut down the old one

            var existing = placeholder.data("plot");

            if (existing) {
                existing.shutdown();
                overlay.clear();
            }

            // save in case we get replotted
            placeholder.data("plot", plot);
        }

        function bindEvents() {
            executeHooks(hooks.bindEvents, [eventHolder]);
        }

        function addEventHandler(event, handler, eventHolder, priority) {
            var key = eventHolder + event;
            var eventList = eventManager[key] || [];

            eventList.push({"event": event, "handler": handler, "eventHolder": eventHolder, "priority": priority});
            eventList.sort((a, b) => b.priority - a.priority);
            eventList.forEach(eventData => {
                eventData.eventHolder.unbind(eventData.event, eventData.handler);
                eventData.eventHolder.bind(eventData.event, eventData.handler);
            });

            eventManager[key] = eventList;
        }

        function shutdown() {
            if (redrawTimeout) {
                clearTimeout(redrawTimeout);
            }

            executeHooks(hooks.shutdown, [eventHolder]);
        }

        function setTransformationHelpers(axis) {
            // set helper functions on the axis, assumes plot area
            // has been computed already

            function identity(x) {
                return x;
            }

            var s, m, t = axis.options.transform || identity,
                it = axis.options.inverseTransform;

            // precompute how much the axis is scaling a point
            // in canvas space
            if (axis.direction === "x") {
                if (isFinite(t(axis.max) - t(axis.min))) {
                    s = axis.scale = plotWidth / Math.abs(t(axis.max) - t(axis.min));
                } else {
                    s = axis.scale = 1 / Math.abs($.plot.saturated.delta(t(axis.min), t(axis.max), plotWidth));
                }
                m = Math.min(t(axis.max), t(axis.min));
            } else {
                if (isFinite(t(axis.max) - t(axis.min))) {
                    s = axis.scale = plotHeight / Math.abs(t(axis.max) - t(axis.min));
                } else {
                    s = axis.scale = 1 / Math.abs($.plot.saturated.delta(t(axis.min), t(axis.max), plotHeight));
                }
                s = -s;
                m = Math.max(t(axis.max), t(axis.min));
            }

            // data point to canvas coordinate
            if (t === identity) {
                // slight optimization
                axis.p2c = function(p) {
                    if (isFinite(p - m)) {
                        return (p - m) * s;
                    } else {
                        return (p / 4 - m / 4) * s * 4;
                    }
                };
            } else {
                axis.p2c = function(p) {
                    var tp = t(p);

                    if (isFinite(tp - m)) {
                        return (tp - m) * s;
                    } else {
                        return (tp / 4 - m / 4) * s * 4;
                    }
                };
            }

            // canvas coordinate to data point
            if (!it) {
                axis.c2p = function(c) {
                    return m + c / s;
                };
            } else {
                axis.c2p = function(c) {
                    return it(m + c / s);
                };
            }
        }

        function measureTickLabels(axis) {
            var opts = axis.options,
                ticks = opts.showTickLabels !== 'none' && axis.ticks ? axis.ticks : [],
                showMajorTickLabels = opts.showTickLabels === 'major' || opts.showTickLabels === 'all',
                showEndpointsTickLabels = opts.showTickLabels === 'endpoints' || opts.showTickLabels === 'all',
                labelWidth = opts.labelWidth || 0,
                labelHeight = opts.labelHeight || 0,
                legacyStyles = axis.direction + "Axis " + axis.direction + axis.n + "Axis",
                layer = "flot-" + axis.direction + "-axis flot-" + axis.direction + axis.n + "-axis " + legacyStyles,
                font = opts.font || "flot-tick-label tickLabel";

            for (var i = 0; i < ticks.length; ++i) {
                var t = ticks[i];
                var label = t.label;

                if (!t.label ||
                    (showMajorTickLabels === false && i > 0 && i < ticks.length - 1) ||
                    (showEndpointsTickLabels === false && (i === 0 || i === ticks.length - 1))) {
                    continue;
                }

                if (typeof t.label === 'object') {
                    label = t.label.name;
                }

                var info = surface.getTextInfo(layer, label, font);

                labelWidth = Math.max(labelWidth, info.width);
                labelHeight = Math.max(labelHeight, info.height);
            }

            axis.labelWidth = opts.labelWidth || labelWidth;
            axis.labelHeight = opts.labelHeight || labelHeight;
        }

        function allocateAxisBoxFirstPhase(axis) {
            // find the bounding box of the axis by looking at label
            // widths/heights and ticks, make room by diminishing the
            // plotOffset; this first phase only looks at one
            // dimension per axis, the other dimension depends on the
            // other axes so will have to wait

            // here reserve additional space
            executeHooks(hooks.axisReserveSpace, [axis]);

            var lw = axis.labelWidth,
                lh = axis.labelHeight,
                pos = axis.options.position,
                isXAxis = axis.direction === "x",
                tickLength = axis.options.tickLength,
                showTicks = axis.options.showTicks,
                showMinorTicks = axis.options.showMinorTicks,
                gridLines = axis.options.gridLines,
                axisMargin = options.grid.axisMargin,
                padding = options.grid.labelMargin,
                innermost = true,
                outermost = true,
                found = false;

            // Determine the axis's position in its direction and on its side

            $.each(isXAxis ? xaxes : yaxes, function(i, a) {
                if (a && (a.show || a.reserveSpace)) {
                    if (a === axis) {
                        found = true;
                    } else if (a.options.position === pos) {
                        if (found) {
                            outermost = false;
                        } else {
                            innermost = false;
                        }
                    }
                }
            });

            // The outermost axis on each side has no margin
            if (outermost) {
                axisMargin = 0;
            }

            // Set the default tickLength if necessary
            if (tickLength == null) {
                tickLength = TICK_LENGTH_CONSTANT;
            }

            // By default, major tick marks are visible
            if (showTicks == null) {
                showTicks = true;
            }

            // By default, minor tick marks are visible
            if (showMinorTicks == null) {
                showMinorTicks = true;
            }

            // By default, grid lines are visible
            if (gridLines == null) {
                if (innermost) {
                    gridLines = true;
                } else {
                    gridLines = false;
                }
            }

            if (!isNaN(+tickLength)) {
                padding += showTicks ? +tickLength : 0;
            }

            if (isXAxis) {
                lh += padding;

                if (pos === "bottom") {
                    plotOffset.bottom += lh + axisMargin;
                    axis.box = {
                        top: surface.height - plotOffset.bottom,
                        height: lh
                    };
                } else {
                    axis.box = {
                        top: plotOffset.top + axisMargin,
                        height: lh
                    };
                    plotOffset.top += lh + axisMargin;
                }
            } else {
                lw += padding;

                if (pos === "left") {
                    axis.box = {
                        left: plotOffset.left + axisMargin,
                        width: lw
                    };
                    plotOffset.left += lw + axisMargin;
                } else {
                    plotOffset.right += lw + axisMargin;
                    axis.box = {
                        left: surface.width - plotOffset.right,
                        width: lw
                    };
                }
            }

            // save for future reference
            axis.position = pos;
            axis.tickLength = tickLength;
            axis.showMinorTicks = showMinorTicks;
            axis.showTicks = showTicks;
            axis.gridLines = gridLines;
            axis.box.padding = padding;
            axis.innermost = innermost;
        }

        function allocateAxisBoxSecondPhase(axis) {
            // now that all axis boxes have been placed in one
            // dimension, we can set the remaining dimension coordinates
            if (axis.direction === "x") {
                axis.box.left = plotOffset.left - axis.labelWidth / 2;
                axis.box.width = surface.width - plotOffset.left - plotOffset.right + axis.labelWidth;
            } else {
                axis.box.top = plotOffset.top - axis.labelHeight / 2;
                axis.box.height = surface.height - plotOffset.bottom - plotOffset.top + axis.labelHeight;
            }
        }

        function adjustLayoutForThingsStickingOut() {
            // possibly adjust plot offset to ensure everything stays
            // inside the canvas and isn't clipped off

            var minMargin = options.grid.minBorderMargin,
                i;

            // check stuff from the plot (FIXME: this should just read
            // a value from the series, otherwise it's impossible to
            // customize)
            if (minMargin == null) {
                minMargin = 0;
                for (i = 0; i < series.length; ++i) {
                    minMargin = Math.max(minMargin, 2 * (series[i].points.radius + series[i].points.lineWidth / 2));
                }
            }

            var a, offset = {},
                margins = {
                    left: minMargin,
                    right: minMargin,
                    top: minMargin,
                    bottom: minMargin
                };

            // check axis labels, note we don't check the actual
            // labels but instead use the overall width/height to not
            // jump as much around with replots
            $.each(allAxes(), function(_, axis) {
                if (axis.reserveSpace && axis.ticks && axis.ticks.length) {
                    if (axis.direction === "x") {
                        margins.left = Math.max(margins.left, axis.labelWidth / 2);
                        margins.right = Math.max(margins.right, axis.labelWidth / 2);
                    } else {
                        margins.bottom = Math.max(margins.bottom, axis.labelHeight / 2);
                        margins.top = Math.max(margins.top, axis.labelHeight / 2);
                    }
                }
            });

            for (a in margins) {
                offset[a] = margins[a] - plotOffset[a];
            }
            $.each(xaxes.concat(yaxes), function(_, axis) {
                alignAxisWithGrid(axis, offset, function (offset) {
                    return offset > 0;
                });
            });

            plotOffset.left = Math.ceil(Math.max(margins.left, plotOffset.left));
            plotOffset.right = Math.ceil(Math.max(margins.right, plotOffset.right));
            plotOffset.top = Math.ceil(Math.max(margins.top, plotOffset.top));
            plotOffset.bottom = Math.ceil(Math.max(margins.bottom, plotOffset.bottom));
        }

        function alignAxisWithGrid(axis, offset, isValid) {
            if (axis.direction === "x") {
                if (axis.position === "bottom" && isValid(offset.bottom)) {
                    axis.box.top -= Math.ceil(offset.bottom);
                }
                if (axis.position === "top" && isValid(offset.top)) {
                    axis.box.top += Math.ceil(offset.top);
                }
            } else {
                if (axis.position === "left" && isValid(offset.left)) {
                    axis.box.left += Math.ceil(offset.left);
                }
                if (axis.position === "right" && isValid(offset.right)) {
                    axis.box.left -= Math.ceil(offset.right);
                }
            }
        }

        function setupGrid(autoScale) {
            var i, a, axes = allAxes(),
                showGrid = options.grid.show;

            // Initialize the plot's offset from the edge of the canvas

            for (a in plotOffset) {
                plotOffset[a] = 0;
            }

            executeHooks(hooks.processOffset, [plotOffset]);

            // If the grid is visible, add its border width to the offset
            for (a in plotOffset) {
                if (typeof (options.grid.borderWidth) === "object") {
                    plotOffset[a] += showGrid ? options.grid.borderWidth[a] : 0;
                } else {
                    plotOffset[a] += showGrid ? options.grid.borderWidth : 0;
                }
            }

            $.each(axes, function(_, axis) {
                var axisOpts = axis.options;
                axis.show = axisOpts.show == null ? axis.used : axisOpts.show;
                axis.reserveSpace = axisOpts.reserveSpace == null ? axis.show : axisOpts.reserveSpace;
                setupTickFormatter(axis);
                executeHooks(hooks.setRange, [axis, autoScale]);
                setRange(axis, autoScale);
            });

            if (showGrid) {
                plotWidth = surface.width - plotOffset.left - plotOffset.right;
                plotHeight = surface.height - plotOffset.bottom - plotOffset.top;

                var allocatedAxes = $.grep(axes, function(axis) {
                    return axis.show || axis.reserveSpace;
                });

                $.each(allocatedAxes, function(_, axis) {
                    // make the ticks
                    setupTickGeneration(axis);
                    setMajorTicks(axis);
                    snapRangeToTicks(axis, axis.ticks, series);

                    //for computing the endpoints precision, transformationHelpers are needed
                    setTransformationHelpers(axis);
                    setEndpointTicks(axis, series);

                    // find labelWidth/Height for axis
                    measureTickLabels(axis);
                });

                // with all dimensions calculated, we can compute the
                // axis bounding boxes, start from the outside
                // (reverse order)
                for (i = allocatedAxes.length - 1; i >= 0; --i) {
                    allocateAxisBoxFirstPhase(allocatedAxes[i]);
                }

                // make sure we've got enough space for things that
                // might stick out
                adjustLayoutForThingsStickingOut();

                $.each(allocatedAxes, function(_, axis) {
                    allocateAxisBoxSecondPhase(axis);
                });
            }

            //adjust axis and plotOffset according to grid.margins
            if (options.grid.margin) {
                for (a in plotOffset) {
                    var margin = options.grid.margin || 0;
                    plotOffset[a] += typeof margin === "number" ? margin : (margin[a] || 0);
                }
                $.each(xaxes.concat(yaxes), function(_, axis) {
                    alignAxisWithGrid(axis, options.grid.margin, function(offset) {
                        return offset !== undefined && offset !== null;
                    });
                });
            }

            //after adjusting the axis, plot width and height will be modified
            plotWidth = surface.width - plotOffset.left - plotOffset.right;
            plotHeight = surface.height - plotOffset.bottom - plotOffset.top;

            // now we got the proper plot dimensions, we can compute the scaling
            $.each(axes, function(_, axis) {
                setTransformationHelpers(axis);
            });

            if (showGrid) {
                drawAxisLabels();
            }

            executeHooks(hooks.setupGrid, []);
        }

        function widenMinMax(minimum, maximum) {
            var min = (minimum === undefined ? null : minimum);
            var max = (maximum === undefined ? null : maximum);
            var delta = max - min;
            if (delta === 0.0) {
                // degenerate case
                var widen = max === 0 ? 1 : 0.01;
                var wmin = null;
                if (min == null) {
                    wmin -= widen;
                }

                // always widen max if we couldn't widen min to ensure we
                // don't fall into min == max which doesn't work
                if (max == null || min != null) {
                    max += widen;
                }

                if (wmin != null) {
                    min = wmin;
                }
            }

            return {
                min: min,
                max: max
            };
        }

        function autoScaleAxis(axis) {
            var opts = axis.options,
                min = opts.min,
                max = opts.max,
                datamin = axis.datamin,
                datamax = axis.datamax,
                delta;

            switch (opts.autoScale) {
                case "none":
                    min = +(opts.min != null ? opts.min : datamin);
                    max = +(opts.max != null ? opts.max : datamax);
                    break;
                case "loose":
                    if (datamin != null && datamax != null) {
                        min = datamin;
                        max = datamax;
                        delta = $.plot.saturated.saturate(max - min);
                        var margin = ((typeof opts.autoScaleMargin === 'number') ? opts.autoScaleMargin : 0.02);
                        min = $.plot.saturated.saturate(min - delta * margin);
                        max = $.plot.saturated.saturate(max + delta * margin);

                        // make sure we don't go below zero if all values are positive
                        if (min < 0 && datamin >= 0) {
                            min = 0;
                        }
                    } else {
                        min = opts.min;
                        max = opts.max;
                    }
                    break;
                case "exact":
                    min = (datamin != null ? datamin : opts.min);
                    max = (datamax != null ? datamax : opts.max);
                    break;
                case "sliding-window":
                    if (datamax > max) {
                        // move the window to fit the new data,
                        // keeping the axis range constant
                        max = datamax;
                        min = Math.max(datamax - (opts.windowSize || 100), min);
                    }
                    break;
            }

            var widenedMinMax = widenMinMax(min, max);
            min = widenedMinMax.min;
            max = widenedMinMax.max;

            // grow loose or grow exact supported
            if (opts.growOnly === true && opts.autoScale !== "none" && opts.autoScale !== "sliding-window") {
                min = (min < datamin) ? min : (datamin !== null ? datamin : min);
                max = (max > datamax) ? max : (datamax !== null ? datamax : max);
            }

            axis.autoScaledMin = min;
            axis.autoScaledMax = max;
        }

        function setRange(axis, autoScale) {
            var min = typeof axis.options.min === 'number' ? axis.options.min : axis.min,
                max = typeof axis.options.max === 'number' ? axis.options.max : axis.max,
                plotOffset = axis.options.offset;

            if (autoScale) {
                autoScaleAxis(axis);
                min = axis.autoScaledMin;
                max = axis.autoScaledMax;
            }

            min = (min != null ? min : -1) + (plotOffset.below || 0);
            max = (max != null ? max : 1) + (plotOffset.above || 0);

            if (min > max) {
                var tmp = min;
                min = max;
                max = tmp;
                axis.options.offset = { above: 0, below: 0 };
            }

            axis.min = $.plot.saturated.saturate(min);
            axis.max = $.plot.saturated.saturate(max);
        }

        function computeValuePrecision (min, max, direction, ticks, tickDecimals) {
            var noTicks = fixupNumberOfTicks(direction, surface, ticks);

            var delta = $.plot.saturated.delta(min, max, noTicks),
                dec = -Math.floor(Math.log(delta) / Math.LN10);

            //if it is called with tickDecimals, then the precision should not be greather then that
            if (tickDecimals && dec > tickDecimals) {
                dec = tickDecimals;
            }

            var magn = parseFloat('1e' + (-dec)),
                norm = delta / magn;

            if (norm > 2.25 && norm < 3 && (dec + 1) <= tickDecimals) {
                //we need an extra decimals when tickSize is 2.5
                ++dec;
            }

            return isFinite(dec) ? dec : 0;
        };

        function computeTickSize (min, max, noTicks, tickDecimals) {
            var delta = $.plot.saturated.delta(min, max, noTicks),
                dec = -Math.floor(Math.log(delta) / Math.LN10);

            //if it is called with tickDecimals, then the precision should not be greather then that
            if (tickDecimals && dec > tickDecimals) {
                dec = tickDecimals;
            }

            var magn = parseFloat('1e' + (-dec)),
                norm = delta / magn, // norm is between 1.0 and 10.0
                size;

            if (norm < 1.5) {
                size = 1;
            } else if (norm < 3) {
                size = 2;
                if (norm > 2.25 && (tickDecimals == null || (dec + 1) <= tickDecimals)) {
                    size = 2.5;
                }
            } else if (norm < 7.5) {
                size = 5;
            } else {
                size = 10;
            }

            size *= magn;
            return size;
        }

        function getAxisTickSize(min, max, direction, options, tickDecimals) {
            var noTicks;

            if (typeof options.ticks === "number" && options.ticks > 0) {
                noTicks = options.ticks;
            } else {
            // heuristic based on the model a*sqrt(x) fitted to
            // some data points that seemed reasonable
                noTicks = 0.3 * Math.sqrt(direction === "x" ? surface.width : surface.height);
            }

            var size = computeTickSize(min, max, noTicks, tickDecimals);

            if (options.minTickSize != null && size < options.minTickSize) {
                size = options.minTickSize;
            }

            return options.tickSize || size;
        };

        function fixupNumberOfTicks(direction, surface, ticksOption) {
            var noTicks;

            if (typeof ticksOption === "number" && ticksOption > 0) {
                noTicks = ticksOption;
            } else {
                noTicks = 0.3 * Math.sqrt(direction === "x" ? surface.width : surface.height);
            }

            return noTicks;
        }

        function setupTickFormatter(axis) {
            var opts = axis.options;
            if (!axis.tickFormatter) {
                if (typeof opts.tickFormatter === 'function') {
                    axis.tickFormatter = function() {
                        var args = Array.prototype.slice.call(arguments);
                        return "" + opts.tickFormatter.apply(null, args);
                    };
                } else {
                    axis.tickFormatter = defaultTickFormatter;
                }
            }
        }

        function setupTickGeneration(axis) {
            var opts = axis.options;
            var noTicks;

            noTicks = fixupNumberOfTicks(axis.direction, surface, opts.ticks);

            axis.delta = $.plot.saturated.delta(axis.min, axis.max, noTicks);
            var precision = plot.computeValuePrecision(axis.min, axis.max, axis.direction, noTicks, opts.tickDecimals);

            axis.tickDecimals = Math.max(0, opts.tickDecimals != null ? opts.tickDecimals : precision);
            axis.tickSize = getAxisTickSize(axis.min, axis.max, axis.direction, opts, opts.tickDecimals);

            // Flot supports base-10 axes; any other mode else is handled by a plug-in,
            // like flot.time.js.

            if (!axis.tickGenerator) {
                if (typeof opts.tickGenerator === 'function') {
                    axis.tickGenerator = opts.tickGenerator;
                } else {
                    axis.tickGenerator = defaultTickGenerator;
                }
            }

            if (opts.alignTicksWithAxis != null) {
                var otherAxis = (axis.direction === "x" ? xaxes : yaxes)[opts.alignTicksWithAxis - 1];
                if (otherAxis && otherAxis.used && otherAxis !== axis) {
                    // consider snapping min/max to outermost nice ticks
                    var niceTicks = axis.tickGenerator(axis, plot);
                    if (niceTicks.length > 0) {
                        if (opts.min == null) {
                            axis.min = Math.min(axis.min, niceTicks[0]);
                        }

                        if (opts.max == null && niceTicks.length > 1) {
                            axis.max = Math.max(axis.max, niceTicks[niceTicks.length - 1]);
                        }
                    }

                    axis.tickGenerator = function(axis) {
                        // copy ticks, scaled to this axis
                        var ticks = [],
                            v, i;
                        for (i = 0; i < otherAxis.ticks.length; ++i) {
                            v = (otherAxis.ticks[i].v - otherAxis.min) / (otherAxis.max - otherAxis.min);
                            v = axis.min + v * (axis.max - axis.min);
                            ticks.push(v);
                        }
                        return ticks;
                    };

                    // we might need an extra decimal since forced
                    // ticks don't necessarily fit naturally
                    if (!axis.mode && opts.tickDecimals == null) {
                        var extraDec = Math.max(0, -Math.floor(Math.log(axis.delta) / Math.LN10) + 1),
                            ts = axis.tickGenerator(axis, plot);

                        // only proceed if the tick interval rounded
                        // with an extra decimal doesn't give us a
                        // zero at end
                        if (!(ts.length > 1 && /\..*0$/.test((ts[1] - ts[0]).toFixed(extraDec)))) {
                            axis.tickDecimals = extraDec;
                        }
                    }
                }
            }
        }

        function setMajorTicks(axis) {
            var oticks = axis.options.ticks,
                ticks = [];
            if (oticks == null || (typeof oticks === "number" && oticks > 0)) {
                ticks = axis.tickGenerator(axis, plot);
            } else if (oticks) {
                if ($.isFunction(oticks)) {
                // generate the ticks
                    ticks = oticks(axis);
                } else {
                    ticks = oticks;
                }
            }

            // clean up/labelify the supplied ticks, copy them over
            var i, v;
            axis.ticks = [];
            for (i = 0; i < ticks.length; ++i) {
                var label = null;
                var t = ticks[i];
                if (typeof t === "object") {
                    v = +t[0];
                    if (t.length > 1) {
                        label = t[1];
                    }
                } else {
                    v = +t;
                }

                if (!isNaN(v)) {
                    axis.ticks.push(
                        newTick(v, label, axis, 'major'));
                }
            }
        }

        function newTick(v, label, axis, type) {
            if (label === null) {
                switch (type) {
                    case 'min':
                    case 'max':
                        //improving the precision of endpoints
                        var precision = getEndpointPrecision(v, axis);
                        label = isFinite(precision) ? axis.tickFormatter(v, axis, precision, plot) : axis.tickFormatter(v, axis, precision, plot);
                        break;
                    case 'major':
                        label = axis.tickFormatter(v, axis, undefined, plot);
                }
            }
            return {
                v: v,
                label: label
            };
        }

        function snapRangeToTicks(axis, ticks, series) {
            var anyDataInSeries = function(series) {
                return series.some(e => e.datapoints.points.length > 0);
            }

            if (axis.options.autoScale === "loose" && ticks.length > 0 && anyDataInSeries(series)) {
                // snap to ticks
                axis.min = Math.min(axis.min, ticks[0].v);
                axis.max = Math.max(axis.max, ticks[ticks.length - 1].v);
            }
        }

        function getEndpointPrecision(value, axis) {
            var canvas1 = Math.floor(axis.p2c(value)),
                canvas2 = axis.direction === "x" ? canvas1 + 1 : canvas1 - 1,
                point1 = axis.c2p(canvas1),
                point2 = axis.c2p(canvas2),
                precision = computeValuePrecision(point1, point2, axis.direction, 1);

            return precision;
        }

        function setEndpointTicks(axis, series) {
            if (isValidEndpointTick(axis, series)) {
                axis.ticks.unshift(newTick(axis.min, null, axis, 'min'));
                axis.ticks.push(newTick(axis.max, null, axis, 'max'));
            }
        }

        function isValidEndpointTick(axis, series) {
            if (axis.options.showTickLabels === 'endpoints') {
                return true;
            }
            if (axis.options.showTickLabels === 'all') {
                var associatedSeries = series.filter(function(s) {
                        return s.bars.horizontal ? s.yaxis === axis : s.xaxis === axis;
                    }),
                    notAllBarSeries = associatedSeries.some(function(s) {
                        return !s.bars.show;
                    });
                return associatedSeries.length === 0 || notAllBarSeries;
            }
            if (axis.options.showTickLabels === 'major' || axis.options.showTickLabels === 'none') {
                return false;
            }
        }

        function draw() {
            surface.clear();
            executeHooks(hooks.drawBackground, [ctx]);

            var grid = options.grid;

            // draw background, if any
            if (grid.show && grid.backgroundColor) {
                drawBackground();
            }

            if (grid.show && !grid.aboveData) {
                drawGrid();
            }

            for (var i = 0; i < series.length; ++i) {
                executeHooks(hooks.drawSeries, [ctx, series[i], i, getColorOrGradient]);
                drawSeries(series[i]);
            }

            executeHooks(hooks.draw, [ctx]);

            if (grid.show && grid.aboveData) {
                drawGrid();
            }

            surface.render();

            // A draw implies that either the axes or data have changed, so we
            // should probably update the overlay highlights as well.
            triggerRedrawOverlay();
        }

        function extractRange(ranges, coord) {
            var axis, from, to, key, axes = allAxes();

            for (var i = 0; i < axes.length; ++i) {
                axis = axes[i];
                if (axis.direction === coord) {
                    key = coord + axis.n + "axis";
                    if (!ranges[key] && axis.n === 1) {
                        // support x1axis as xaxis
                        key = coord + "axis";
                    }

                    if (ranges[key]) {
                        from = ranges[key].from;
                        to = ranges[key].to;
                        break;
                    }
                }
            }

            // backwards-compat stuff - to be removed in future
            if (!ranges[key]) {
                axis = coord === "x" ? xaxes[0] : yaxes[0];
                from = ranges[coord + "1"];
                to = ranges[coord + "2"];
            }

            // auto-reverse as an added bonus
            if (from != null && to != null && from > to) {
                var tmp = from;
                from = to;
                to = tmp;
            }

            return {
                from: from,
                to: to,
                axis: axis
            };
        }

        function drawBackground() {
            ctx.save();
            ctx.translate(plotOffset.left, plotOffset.top);

            ctx.fillStyle = getColorOrGradient(options.grid.backgroundColor, plotHeight, 0, "rgba(255, 255, 255, 0)");
            ctx.fillRect(0, 0, plotWidth, plotHeight);
            ctx.restore();
        }

        function drawMarkings() {
            // draw markings
            var markings = options.grid.markings,
                axes;

            if (markings) {
                if ($.isFunction(markings)) {
                    axes = plot.getAxes();
                    // xmin etc. is backwards compatibility, to be
                    // removed in the future
                    axes.xmin = axes.xaxis.min;
                    axes.xmax = axes.xaxis.max;
                    axes.ymin = axes.yaxis.min;
                    axes.ymax = axes.yaxis.max;

                    markings = markings(axes);
                }

                var i;
                for (i = 0; i < markings.length; ++i) {
                    var m = markings[i],
                        xrange = extractRange(m, "x"),
                        yrange = extractRange(m, "y");

                    // fill in missing
                    if (xrange.from == null) {
                        xrange.from = xrange.axis.min;
                    }

                    if (xrange.to == null) {
                        xrange.to = xrange.axis.max;
                    }

                    if (yrange.from == null) {
                        yrange.from = yrange.axis.min;
                    }

                    if (yrange.to == null) {
                        yrange.to = yrange.axis.max;
                    }

                    // clip
                    if (xrange.to < xrange.axis.min || xrange.from > xrange.axis.max ||
                        yrange.to < yrange.axis.min || yrange.from > yrange.axis.max) {
                        continue;
                    }

                    xrange.from = Math.max(xrange.from, xrange.axis.min);
                    xrange.to = Math.min(xrange.to, xrange.axis.max);
                    yrange.from = Math.max(yrange.from, yrange.axis.min);
                    yrange.to = Math.min(yrange.to, yrange.axis.max);

                    var xequal = xrange.from === xrange.to,
                        yequal = yrange.from === yrange.to;

                    if (xequal && yequal) {
                        continue;
                    }

                    // then draw
                    xrange.from = Math.floor(xrange.axis.p2c(xrange.from));
                    xrange.to = Math.floor(xrange.axis.p2c(xrange.to));
                    yrange.from = Math.floor(yrange.axis.p2c(yrange.from));
                    yrange.to = Math.floor(yrange.axis.p2c(yrange.to));

                    if (xequal || yequal) {
                        var lineWidth = m.lineWidth || options.grid.markingsLineWidth,
                            subPixel = lineWidth % 2 ? 0.5 : 0;
                        ctx.beginPath();
                        ctx.strokeStyle = m.color || options.grid.markingsColor;
                        ctx.lineWidth = lineWidth;
                        if (xequal) {
                            ctx.moveTo(xrange.to + subPixel, yrange.from);
                            ctx.lineTo(xrange.to + subPixel, yrange.to);
                        } else {
                            ctx.moveTo(xrange.from, yrange.to + subPixel);
                            ctx.lineTo(xrange.to, yrange.to + subPixel);
                        }
                        ctx.stroke();
                    } else {
                        ctx.fillStyle = m.color || options.grid.markingsColor;
                        ctx.fillRect(xrange.from, yrange.to,
                            xrange.to - xrange.from,
                            yrange.from - yrange.to);
                    }
                }
            }
        }

        function findEdges(axis) {
            var box = axis.box,
                x = 0,
                y = 0;

            // find the edges
            if (axis.direction === "x") {
                x = 0;
                y = box.top - plotOffset.top + (axis.position === "top" ? box.height : 0);
            } else {
                y = 0;
                x = box.left - plotOffset.left + (axis.position === "left" ? box.width : 0) + axis.boxPosition.centerX;
            }

            return {
                x: x,
                y: y
            };
        };

        function alignPosition(lineWidth, pos) {
            return ((lineWidth % 2) !== 0) ? Math.floor(pos) + 0.5 : pos;
        };

        function drawTickBar(axis) {
            ctx.lineWidth = 1;
            var edges = findEdges(axis),
                x = edges.x,
                y = edges.y;

            // draw tick bar
            if (axis.show) {
                var xoff = 0,
                    yoff = 0;

                ctx.strokeStyle = axis.options.color;
                ctx.beginPath();
                if (axis.direction === "x") {
                    xoff = plotWidth + 1;
                } else {
                    yoff = plotHeight + 1;
                }

                if (axis.direction === "x") {
                    y = alignPosition(ctx.lineWidth, y);
                } else {
                    x = alignPosition(ctx.lineWidth, x);
                }

                ctx.moveTo(x, y);
                ctx.lineTo(x + xoff, y + yoff);
                ctx.stroke();
            }
        };

        function drawTickMarks(axis) {
            var t = axis.tickLength,
                minorTicks = axis.showMinorTicks,
                minorTicksNr = MINOR_TICKS_COUNT_CONSTANT,
                edges = findEdges(axis),
                x = edges.x,
                y = edges.y,
                i = 0;

            // draw major tick marks
            ctx.strokeStyle = axis.options.color;
            ctx.beginPath();

            for (i = 0; i < axis.ticks.length; ++i) {
                var v = axis.ticks[i].v,
                    xoff = 0,
                    yoff = 0,
                    xminor = 0,
                    yminor = 0,
                    j;

                if (!isNaN(v) && v >= axis.min && v <= axis.max) {
                    if (axis.direction === "x") {
                        x = axis.p2c(v);
                        yoff = t;

                        if (axis.position === "top") {
                            yoff = -yoff;
                        }
                    } else {
                        y = axis.p2c(v);
                        xoff = t;

                        if (axis.position === "left") {
                            xoff = -xoff;
                        }
                    }

                    if (axis.direction === "x") {
                        x = alignPosition(ctx.lineWidth, x);
                    } else {
                        y = alignPosition(ctx.lineWidth, y);
                    }

                    ctx.moveTo(x, y);
                    ctx.lineTo(x + xoff, y + yoff);
                }

                //draw minor tick marks
                if (minorTicks === true && i < axis.ticks.length - 1) {
                    var v1 = axis.ticks[i].v,
                        v2 = axis.ticks[i + 1].v,
                        step = (v2 - v1) / (minorTicksNr + 1);

                    for (j = 1; j <= minorTicksNr; j++) {
                        // compute minor tick position
                        if (axis.direction === "x") {
                            yminor = t / 2; // minor ticks are half length
                            x = alignPosition(ctx.lineWidth, axis.p2c(v1 + j * step))

                            if (axis.position === "top") {
                                yminor = -yminor;
                            }

                            // don't go over the plot borders
                            if ((x < 0) || (x > plotWidth)) {
                                continue;
                            }
                        } else {
                            xminor = t / 2; // minor ticks are half length
                            y = alignPosition(ctx.lineWidth, axis.p2c(v1 + j * step));

                            if (axis.position === "left") {
                                xminor = -xminor;
                            }

                            // don't go over the plot borders
                            if ((y < 0) || (y > plotHeight)) {
                                continue;
                            }
                        }

                        ctx.moveTo(x, y);
                        ctx.lineTo(x + xminor, y + yminor);
                    }
                }
            }

            ctx.stroke();
        };

        function drawGridLines(axis) {
            // check if the line will be overlapped with a border
            var overlappedWithBorder = function (value) {
                var bw = options.grid.borderWidth;
                return (((typeof bw === "object" && bw[axis.position] > 0) || bw > 0) && (value === axis.min || value === axis.max));
            };

            ctx.strokeStyle = options.grid.tickColor;
            ctx.beginPath();
            var i;
            for (i = 0; i < axis.ticks.length; ++i) {
                var v = axis.ticks[i].v,
                    xoff = 0,
                    yoff = 0,
                    x = 0,
                    y = 0;

                if (isNaN(v) || v < axis.min || v > axis.max) continue;

                // skip those lying on the axes if we got a border
                if (overlappedWithBorder(v)) continue;

                if (axis.direction === "x") {
                    x = axis.p2c(v);
                    y = plotHeight;
                    yoff = -plotHeight;
                } else {
                    x = 0;
                    y = axis.p2c(v);
                    xoff = plotWidth;
                }

                if (axis.direction === "x") {
                    x = alignPosition(ctx.lineWidth, x);
                } else {
                    y = alignPosition(ctx.lineWidth, y);
                }

                ctx.moveTo(x, y);
                ctx.lineTo(x + xoff, y + yoff);
            }

            ctx.stroke();
        };

        function drawBorder() {
            // If either borderWidth or borderColor is an object, then draw the border
            // line by line instead of as one rectangle
            var bw = options.grid.borderWidth,
                bc = options.grid.borderColor;

            if (typeof bw === "object" || typeof bc === "object") {
                if (typeof bw !== "object") {
                    bw = {
                        top: bw,
                        right: bw,
                        bottom: bw,
                        left: bw
                    };
                }
                if (typeof bc !== "object") {
                    bc = {
                        top: bc,
                        right: bc,
                        bottom: bc,
                        left: bc
                    };
                }

                if (bw.top > 0) {
                    ctx.strokeStyle = bc.top;
                    ctx.lineWidth = bw.top;
                    ctx.beginPath();
                    ctx.moveTo(0 - bw.left, 0 - bw.top / 2);
                    ctx.lineTo(plotWidth, 0 - bw.top / 2);
                    ctx.stroke();
                }

                if (bw.right > 0) {
                    ctx.strokeStyle = bc.right;
                    ctx.lineWidth = bw.right;
                    ctx.beginPath();
                    ctx.moveTo(plotWidth + bw.right / 2, 0 - bw.top);
                    ctx.lineTo(plotWidth + bw.right / 2, plotHeight);
                    ctx.stroke();
                }

                if (bw.bottom > 0) {
                    ctx.strokeStyle = bc.bottom;
                    ctx.lineWidth = bw.bottom;
                    ctx.beginPath();
                    ctx.moveTo(plotWidth + bw.right, plotHeight + bw.bottom / 2);
                    ctx.lineTo(0, plotHeight + bw.bottom / 2);
                    ctx.stroke();
                }

                if (bw.left > 0) {
                    ctx.strokeStyle = bc.left;
                    ctx.lineWidth = bw.left;
                    ctx.beginPath();
                    ctx.moveTo(0 - bw.left / 2, plotHeight + bw.bottom);
                    ctx.lineTo(0 - bw.left / 2, 0);
                    ctx.stroke();
                }
            } else {
                ctx.lineWidth = bw;
                ctx.strokeStyle = options.grid.borderColor;
                ctx.strokeRect(-bw / 2, -bw / 2, plotWidth + bw, plotHeight + bw);
            }
        };

        function drawGrid() {
            var axes, bw;

            ctx.save();
            ctx.translate(plotOffset.left, plotOffset.top);

            drawMarkings();

            axes = allAxes();
            bw = options.grid.borderWidth;

            for (var j = 0; j < axes.length; ++j) {
                var axis = axes[j];

                if (!axis.show) {
                    continue;
                }

                drawTickBar(axis);
                if (axis.showTicks === true) {
                    drawTickMarks(axis);
                }

                if (axis.gridLines === true) {
                    drawGridLines(axis, bw);
                }
            }

            // draw border
            if (bw) {
                drawBorder();
            }

            ctx.restore();
        }

        function drawAxisLabels() {
            $.each(allAxes(), function(_, axis) {
                var box = axis.box,
                    legacyStyles = axis.direction + "Axis " + axis.direction + axis.n + "Axis",
                    layer = "flot-" + axis.direction + "-axis flot-" + axis.direction + axis.n + "-axis " + legacyStyles,
                    font = axis.options.font || "flot-tick-label tickLabel",
                    i, x, y, halign, valign, info,
                    margin = 3,
                    nullBox = {x: NaN, y: NaN, width: NaN, height: NaN}, newLabelBox, labelBoxes = [],
                    overlapping = function(x11, y11, x12, y12, x21, y21, x22, y22) {
                        return ((x11 <= x21 && x21 <= x12) || (x21 <= x11 && x11 <= x22)) &&
                               ((y11 <= y21 && y21 <= y12) || (y21 <= y11 && y11 <= y22));
                    },
                    overlapsOtherLabels = function(newLabelBox, previousLabelBoxes) {
                        return previousLabelBoxes.some(function(labelBox) {
                            return overlapping(
                                newLabelBox.x, newLabelBox.y, newLabelBox.x + newLabelBox.width, newLabelBox.y + newLabelBox.height,
                                labelBox.x, labelBox.y, labelBox.x + labelBox.width, labelBox.y + labelBox.height);
                        });
                    },
                    drawAxisLabel = function (tick, labelBoxes) {
                        if (!tick || !tick.label || tick.v < axis.min || tick.v > axis.max) {
                            return nullBox;
                        }

                        info = surface.getTextInfo(layer, tick.label, font);

                        if (axis.direction === "x") {
                            halign = "center";
                            x = plotOffset.left + axis.p2c(tick.v);
                            if (axis.position === "bottom") {
                                y = box.top + box.padding - axis.boxPosition.centerY;
                            } else {
                                y = box.top + box.height - box.padding + axis.boxPosition.centerY;
                                valign = "bottom";
                            }
                            newLabelBox = {x: x - info.width / 2 - margin, y: y - margin, width: info.width + 2 * margin, height: info.height + 2 * margin};
                        } else {
                            valign = "middle";
                            y = plotOffset.top + axis.p2c(tick.v);
                            if (axis.position === "left") {
                                x = box.left + box.width - box.padding - axis.boxPosition.centerX;
                                halign = "right";
                            } else {
                                x = box.left + box.padding + axis.boxPosition.centerX;
                            }
                            newLabelBox = {x: x - info.width / 2 - margin, y: y - margin, width: info.width + 2 * margin, height: info.height + 2 * margin};
                        }

                        if (overlapsOtherLabels(newLabelBox, labelBoxes)) {
                            return nullBox;
                        }

                        surface.addText(layer, x, y, tick.label, font, null, null, halign, valign);

                        return newLabelBox;
                    };

                // Remove text before checking for axis.show and ticks.length;
                // otherwise plugins, like flot-tickrotor, that draw their own
                // tick labels will end up with both theirs and the defaults.

                surface.removeText(layer);

                executeHooks(hooks.drawAxis, [axis, surface]);

                if (!axis.show) {
                    return;
                }

                switch (axis.options.showTickLabels) {
                    case 'none':
                        break;
                    case 'endpoints':
                        labelBoxes.push(drawAxisLabel(axis.ticks[0], labelBoxes));
                        labelBoxes.push(drawAxisLabel(axis.ticks[axis.ticks.length - 1], labelBoxes));
                        break;
                    case 'major':
                        labelBoxes.push(drawAxisLabel(axis.ticks[0], labelBoxes));
                        labelBoxes.push(drawAxisLabel(axis.ticks[axis.ticks.length - 1], labelBoxes));
                        for (i = 1; i < axis.ticks.length - 1; ++i) {
                            labelBoxes.push(drawAxisLabel(axis.ticks[i], labelBoxes));
                        }
                        break;
                    case 'all':
                        labelBoxes.push(drawAxisLabel(axis.ticks[0], []));
                        labelBoxes.push(drawAxisLabel(axis.ticks[axis.ticks.length - 1], labelBoxes));
                        for (i = 1; i < axis.ticks.length - 1; ++i) {
                            labelBoxes.push(drawAxisLabel(axis.ticks[i], labelBoxes));
                        }
                        break;
                }
            });
        }

        function drawSeries(series) {
            if (series.lines.show) {
                $.plot.drawSeries.drawSeriesLines(series, ctx, plotOffset, plotWidth, plotHeight, plot.drawSymbol, getColorOrGradient);
            }

            if (series.bars.show) {
                $.plot.drawSeries.drawSeriesBars(series, ctx, plotOffset, plotWidth, plotHeight, plot.drawSymbol, getColorOrGradient);
            }

            if (series.points.show) {
                $.plot.drawSeries.drawSeriesPoints(series, ctx, plotOffset, plotWidth, plotHeight, plot.drawSymbol, getColorOrGradient);
            }
        }

        function computeRangeForDataSeries(series, force, isValid) {
            var points = series.datapoints.points,
                ps = series.datapoints.pointsize,
                format = series.datapoints.format,
                topSentry = Number.POSITIVE_INFINITY,
                bottomSentry = Number.NEGATIVE_INFINITY,
                range = {
                    xmin: topSentry,
                    ymin: topSentry,
                    xmax: bottomSentry,
                    ymax: bottomSentry
                };

            for (var j = 0; j < points.length; j += ps) {
                if (points[j] === null) {
                    continue;
                }

                if (typeof (isValid) === 'function' && !isValid(points[j])) {
                    continue;
                }

                for (var m = 0; m < ps; ++m) {
                    var val = points[j + m],
                        f = format[m];
                    if (f === null || f === undefined) {
                        continue;
                    }

                    if (typeof (isValid) === 'function' && !isValid(val)) {
                        continue;
                    }

                    if ((!force && !f.computeRange) || val === Infinity || val === -Infinity) {
                        continue;
                    }

                    if (f.x === true) {
                        if (val < range.xmin) {
                            range.xmin = val;
                        }

                        if (val > range.xmax) {
                            range.xmax = val;
                        }
                    }

                    if (f.y === true) {
                        if (val < range.ymin) {
                            range.ymin = val;
                        }

                        if (val > range.ymax) {
                            range.ymax = val;
                        }
                    }
                }
            }

            return range;
        };

        function adjustSeriesDataRange(series, range) {
            if (series.bars.show) {
                // make sure we got room for the bar on the dancing floor
                var delta;

                // update bar width if needed
                var useAbsoluteBarWidth = series.bars.barWidth[1];
                if (series.datapoints && series.datapoints.points && !useAbsoluteBarWidth) {
                    computeBarWidth(series);
                }

                var barWidth = series.bars.barWidth[0] || series.bars.barWidth;
                switch (series.bars.align) {
                    case "left":
                        delta = 0;
                        break;
                    case "right":
                        delta = -barWidth;
                        break;
                    default:
                        delta = -barWidth / 2;
                }

                if (series.bars.horizontal) {
                    range.ymin += delta;
                    range.ymax += delta + barWidth;
                } else {
                    range.xmin += delta;
                    range.xmax += delta + barWidth;
                }
            }

            if ((series.bars.show && series.bars.zero) || (series.lines.show && series.lines.zero)) {
                var ps = series.datapoints.pointsize;

                // make sure the 0 point is included in the computed y range when requested
                if (ps <= 2) {
                    /*if ps > 0 the points were already taken into account for autoScale */
                    range.ymin = Math.min(0, range.ymin);
                    range.ymax = Math.max(0, range.ymax);
                }
            }

            return range;
        };

        function computeBarWidth(series) {
            var xValues = [];
            var pointsize = series.datapoints.pointsize, minDistance = Number.MAX_VALUE;

            if (series.datapoints.points.length <= pointsize) {
                minDistance = 1;
            }

            var start = series.bars.horizontal ? 1 : 0;
            for (let j = start; j < series.datapoints.points.length; j += pointsize) {
                if (isFinite(series.datapoints.points[j]) && series.datapoints.points[j] !== null) {
                    xValues.push(series.datapoints.points[j]);
                }
            }

            function onlyUnique(value, index, self) {
                return self.indexOf(value) === index;
            }

            xValues = xValues.filter(onlyUnique);
            xValues.sort(function(a, b) { return a - b });

            for (let j = 1; j < xValues.length; j++) {
                var distance = Math.abs(xValues[j] - xValues[j - 1]);
                if (distance < minDistance && isFinite(distance)) {
                    minDistance = distance;
                }
            }

            if (typeof series.bars.barWidth === "number") {
                series.bars.barWidth = series.bars.barWidth * minDistance;
            } else {
                series.bars.barWidth[0] = series.bars.barWidth[0] * minDistance;
            }
        }

        function findNearbyItems(mouseX, mouseY, seriesFilter, radius, computeDistance) {
            var items = findItems(mouseX, mouseY, seriesFilter, radius, computeDistance);
            for (var i = 0; i < series.length; ++i) {
                if (seriesFilter(i)) {
                    executeHooks(hooks.findNearbyItems, [mouseX, mouseY, series, i, radius, computeDistance, items]);
                }
            }

            return items.sort((a, b) => {
                if (b.distance === undefined) {
                    return -1;
                } else if (a.distance === undefined && b.distance !== undefined) {
                    return 1;
                }

                return a.distance - b.distance;
            });
        }

        function findNearbyItem(mouseX, mouseY, seriesFilter, radius, computeDistance) {
            var items = findNearbyItems(mouseX, mouseY, seriesFilter, radius, computeDistance);
            return items[0] !== undefined ? items[0] : null;
        }

        // returns the data item the mouse is over/ the cursor is closest to, or null if none is found
        function findItems(mouseX, mouseY, seriesFilter, radius, computeDistance) {
            var i, foundItems = [],
                items = [],
                smallestDistance = radius * radius + 1;

            for (i = series.length - 1; i >= 0; --i) {
                if (!seriesFilter(i)) continue;

                var s = series[i];
                if (!s.datapoints) return;

                var foundPoint = false;
                if (s.lines.show || s.points.show) {
                    var found = findNearbyPoint(s, mouseX, mouseY, radius, computeDistance);
                    if (found) {
                        items.push({ seriesIndex: i, dataIndex: found.dataIndex, distance: found.distance });
                        foundPoint = true;
                    }
                }

                if (s.bars.show && !foundPoint) { // no other point can be nearby
                    var foundIndex = findNearbyBar(s, mouseX, mouseY);
                    if (foundIndex >= 0) {
                        items.push({ seriesIndex: i, dataIndex: foundIndex, distance: smallestDistance });
                    }
                }
            }

            for (i = 0; i < items.length; i++) {
                var seriesIndex = items[i].seriesIndex;
                var dataIndex = items[i].dataIndex;
                var itemDistance = items[i].distance;
                var ps = series[seriesIndex].datapoints.pointsize;

                foundItems.push({
                    datapoint: series[seriesIndex].datapoints.points.slice(dataIndex * ps, (dataIndex + 1) * ps),
                    dataIndex: dataIndex,
                    series: series[seriesIndex],
                    seriesIndex: seriesIndex,
                    distance: Math.sqrt(itemDistance)
                });
            }

            return foundItems;
        }

        function findNearbyPoint (series, mouseX, mouseY, maxDistance, computeDistance) {
            var mx = series.xaxis.c2p(mouseX),
                my = series.yaxis.c2p(mouseY),
                maxx = maxDistance / series.xaxis.scale,
                maxy = maxDistance / series.yaxis.scale,
                points = series.datapoints.points,
                ps = series.datapoints.pointsize,
                smallestDistance = Number.POSITIVE_INFINITY;

            // with inverse transforms, we can't use the maxx/maxy
            // optimization, sadly
            if (series.xaxis.options.inverseTransform) {
                maxx = Number.MAX_VALUE;
            }

            if (series.yaxis.options.inverseTransform) {
                maxy = Number.MAX_VALUE;
            }

            var found = null;
            for (var j = 0; j < points.length; j += ps) {
                var x = points[j];
                var y = points[j + 1];
                if (x == null) {
                    continue;
                }

                if (x - mx > maxx || x - mx < -maxx ||
                    y - my > maxy || y - my < -maxy) {
                    continue;
                }

                // We have to calculate distances in pixels, not in
                // data units, because the scales of the axes may be different
                var dx = Math.abs(series.xaxis.p2c(x) - mouseX);
                var dy = Math.abs(series.yaxis.p2c(y) - mouseY);
                var dist = computeDistance ? computeDistance(dx, dy) : dx * dx + dy * dy;

                // use <= to ensure last point takes precedence
                // (last generally means on top of)
                if (dist < smallestDistance) {
                    smallestDistance = dist;
                    found = { dataIndex: j / ps, distance: dist };
                }
            }

            return found;
        }

        function findNearbyBar (series, mouseX, mouseY) {
            var barLeft, barRight,
                barWidth = series.bars.barWidth[0] || series.bars.barWidth,
                mx = series.xaxis.c2p(mouseX),
                my = series.yaxis.c2p(mouseY),
                points = series.datapoints.points,
                ps = series.datapoints.pointsize;

            switch (series.bars.align) {
                case "left":
                    barLeft = 0;
                    break;
                case "right":
                    barLeft = -barWidth;
                    break;
                default:
                    barLeft = -barWidth / 2;
            }

            barRight = barLeft + barWidth;

            var fillTowards = series.bars.fillTowards || 0;
            var defaultBottom = fillTowards > series.yaxis.min ? Math.min(series.yaxis.max, fillTowards) : series.yaxis.min;

            var foundIndex = -1;
            for (var j = 0; j < points.length; j += ps) {
                var x = points[j], y = points[j + 1];
                if (x == null) {
                    continue;
                }

                var bottom = ps === 3 ? points[j + 2] : defaultBottom;
                // for a bar graph, the cursor must be inside the bar
                if (series.bars.horizontal
                    ? (mx <= Math.max(bottom, x) && mx >= Math.min(bottom, x) &&
                        my >= y + barLeft && my <= y + barRight)
                    : (mx >= x + barLeft && mx <= x + barRight &&
                        my >= Math.min(bottom, y) && my <= Math.max(bottom, y))) {
                    foundIndex = j / ps;
                }
            }

            return foundIndex;
        }

        function findNearbyInterpolationPoint(posX, posY, seriesFilter) {
            var i, j, dist, dx, dy, ps,
                item,
                smallestDistance = Number.MAX_VALUE;

            for (i = 0; i < series.length; ++i) {
                if (!seriesFilter(i)) {
                    continue;
                }
                var points = series[i].datapoints.points;
                ps = series[i].datapoints.pointsize;

                // if the data is coming from positive -> negative, reverse the comparison
                const comparer = points[points.length - ps] < points[0]
                    ? function (x1, x2) { return x1 > x2 }
                    : function (x1, x2) { return x2 > x1 };

                // do not interpolate outside the bounds of the data.
                if (comparer(posX, points[0])) {
                    continue;
                }

                // Find the nearest points, x-wise
                for (j = ps; j < points.length; j += ps) {
                    if (comparer(posX, points[j])) {
                        break;
                    }
                }

                // Now Interpolate
                var y,
                    p1x = points[j - ps],
                    p1y = points[j - ps + 1],
                    p2x = points[j],
                    p2y = points[j + 1];

                if ((p1x === undefined) || (p2x === undefined) ||
                    (p1y === undefined) || (p2y === undefined)) {
                    continue;
                }

                if (p1x === p2x) {
                    y = p2y
                } else {
                    y = p1y + (p2y - p1y) * (posX - p1x) / (p2x - p1x);
                }

                posY = y;

                dx = Math.abs(series[i].xaxis.p2c(p2x) - posX);
                dy = Math.abs(series[i].yaxis.p2c(p2y) - posY);
                dist = dx * dx + dy * dy;

                if (dist < smallestDistance) {
                    smallestDistance = dist;
                    item = [posX, posY, i, j];
                }
            }

            if (item) {
                i = item[2];
                j = item[3];
                ps = series[i].datapoints.pointsize;
                points = series[i].datapoints.points;
                p1x = points[j - ps];
                p1y = points[j - ps + 1];
                p2x = points[j];
                p2y = points[j + 1];

                return {
                    datapoint: [item[0], item[1]],
                    leftPoint: [p1x, p1y],
                    rightPoint: [p2x, p2y],
                    seriesIndex: i
                };
            }

            return null;
        }

        function triggerRedrawOverlay() {
            var t = options.interaction.redrawOverlayInterval;
            if (t === -1) { // skip event queue
                drawOverlay();
                return;
            }

            if (!redrawTimeout) {
                redrawTimeout = setTimeout(function() {
                    drawOverlay(plot);
                }, t);
            }
        }

        function drawOverlay(plot) {
            redrawTimeout = null;

            if (!octx) {
                return;
            }
            overlay.clear();
            executeHooks(hooks.drawOverlay, [octx, overlay]);
            var event = new CustomEvent('onDrawingDone');
            plot.getEventHolder().dispatchEvent(event);
            plot.getPlaceholder().trigger('drawingdone');
        }

        function getColorOrGradient(spec, bottom, top, defaultColor) {
            if (typeof spec === "string") {
                return spec;
            } else {
                // assume this is a gradient spec; IE currently only
                // supports a simple vertical gradient properly, so that's
                // what we support too
                var gradient = ctx.createLinearGradient(0, top, 0, bottom);

                for (var i = 0, l = spec.colors.length; i < l; ++i) {
                    var c = spec.colors[i];
                    if (typeof c !== "string") {
                        var co = $.color.parse(defaultColor);
                        if (c.brightness != null) {
                            co = co.scale('rgb', c.brightness);
                        }

                        if (c.opacity != null) {
                            co.a *= c.opacity;
                        }

                        c = co.toString();
                    }
                    gradient.addColorStop(i / (l - 1), c);
                }

                return gradient;
            }
        }
    }

    // Add the plot function to the top level of the jQuery object

    $.plot = function(placeholder, data, options) {
        var plot = new Plot($(placeholder), data, options, $.plot.plugins);
        return plot;
    };

    $.plot.version = "3.0.0";

    $.plot.plugins = [];

    // Also add the plot function as a chainable property
    $.fn.plot = function(data, options) {
        return this.each(function() {
            $.plot(this, data, options);
        });
    };

    $.plot.linearTickGenerator = defaultTickGenerator;
    $.plot.defaultTickFormatter = defaultTickFormatter;
    $.plot.expRepTickFormatter = expRepTickFormatter;
})(jQuery);


/***/ }),

/***/ "./node_modules/flot/source/jquery.flot.legend.js":
/*!********************************************************!*\
  !*** ./node_modules/flot/source/jquery.flot.legend.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* Flot plugin for drawing legends.

*/

(function($) {
    var defaultOptions = {
        legend: {
            show: false,
            noColumns: 1,
            labelFormatter: null, // fn: string -> string
            container: null, // container (as jQuery object) to put legend in, null means default on top of graph
            position: 'ne', // position of default legend container within plot
            margin: 5, // distance from grid edge to default legend container within plot
            sorted: null // default to no legend sorting
        }
    };

    function insertLegend(plot, options, placeholder, legendEntries) {
        // clear before redraw
        if (options.legend.container != null) {
            $(options.legend.container).html('');
        } else {
            placeholder.find('.legend').remove();
        }

        if (!options.legend.show) {
            return;
        }

        // Save the legend entries in legend options
        var entries = options.legend.legendEntries = legendEntries,
            plotOffset = options.legend.plotOffset = plot.getPlotOffset(),
            html = [],
            entry, labelHtml, iconHtml,
            j = 0,
            i,
            pos = "",
            p = options.legend.position,
            m = options.legend.margin,
            shape = {
                name: '',
                label: '',
                xPos: '',
                yPos: ''
            };

        html[j++] = '<svg class="legendLayer" style="width:inherit;height:inherit;">';
        html[j++] = '<rect class="background" width="100%" height="100%"/>';
        html[j++] = svgShapeDefs;

        var left = 0;
        var columnWidths = [];
        var style = window.getComputedStyle(document.querySelector('body'));
        for (i = 0; i < entries.length; ++i) {
            let columnIndex = i % options.legend.noColumns;
            entry = entries[i];
            shape.label = entry.label;
            var info = plot.getSurface().getTextInfo('', shape.label, {
                style: style.fontStyle,
                variant: style.fontVariant,
                weight: style.fontWeight,
                size: parseInt(style.fontSize),
                lineHeight: parseInt(style.lineHeight),
                family: style.fontFamily
            });

            var labelWidth = info.width;
            // 36px = 1.5em + 6px margin
            var iconWidth = 48;
            if (columnWidths[columnIndex]) {
                if (labelWidth > columnWidths[columnIndex]) {
                    columnWidths[columnIndex] = labelWidth + iconWidth;
                }
            } else {
                columnWidths[columnIndex] = labelWidth + iconWidth;
            }
        }

        // Generate html for icons and labels from a list of entries
        for (i = 0; i < entries.length; ++i) {
            let columnIndex = i % options.legend.noColumns;
            entry = entries[i];
            iconHtml = '';
            shape.label = entry.label;
            shape.xPos = (left + 3) + 'px';
            left += columnWidths[columnIndex];
            if ((i + 1) % options.legend.noColumns === 0) {
                left = 0;
            }
            shape.yPos = Math.floor(i / options.legend.noColumns) * 1.5 + 'em';
            // area
            if (entry.options.lines.show && entry.options.lines.fill) {
                shape.name = 'area';
                shape.fillColor = entry.color;
                iconHtml += getEntryIconHtml(shape);
            }
            // bars
            if (entry.options.bars.show) {
                shape.name = 'bar';
                shape.fillColor = entry.color;
                iconHtml += getEntryIconHtml(shape);
            }
            // lines
            if (entry.options.lines.show && !entry.options.lines.fill) {
                shape.name = 'line';
                shape.strokeColor = entry.color;
                shape.strokeWidth = entry.options.lines.lineWidth;
                iconHtml += getEntryIconHtml(shape);
            }
            // points
            if (entry.options.points.show) {
                shape.name = entry.options.points.symbol;
                shape.strokeColor = entry.color;
                shape.fillColor = entry.options.points.fillColor;
                shape.strokeWidth = entry.options.points.lineWidth;
                iconHtml += getEntryIconHtml(shape);
            }

            labelHtml = '<text x="' + shape.xPos + '" y="' + shape.yPos + '" text-anchor="start"><tspan dx="2em" dy="1.2em">' + shape.label + '</tspan></text>'
            html[j++] = '<g>' + iconHtml + labelHtml + '</g>';
        }

        html[j++] = '</svg>';
        if (m[0] == null) {
            m = [m, m];
        }

        if (p.charAt(0) === 'n') {
            pos += 'top:' + (m[1] + plotOffset.top) + 'px;';
        } else if (p.charAt(0) === 's') {
            pos += 'bottom:' + (m[1] + plotOffset.bottom) + 'px;';
        }

        if (p.charAt(1) === 'e') {
            pos += 'right:' + (m[0] + plotOffset.right) + 'px;';
        } else if (p.charAt(1) === 'w') {
            pos += 'left:' + (m[0] + plotOffset.left) + 'px;';
        }

        var width = 6;
        for (i = 0; i < columnWidths.length; ++i) {
            width += columnWidths[i];
        }

        var legendEl,
            height = Math.ceil(entries.length / options.legend.noColumns) * 1.6;
        if (!options.legend.container) {
            legendEl = $('<div class="legend" style="position:absolute;' + pos + '">' + html.join('') + '</div>').appendTo(placeholder);
            legendEl.css('width', width + 'px');
            legendEl.css('height', height + 'em');
            legendEl.css('pointerEvents', 'none');
        } else {
            legendEl = $(html.join('')).appendTo(options.legend.container)[0];
            options.legend.container.style.width = width + 'px';
            options.legend.container.style.height = height + 'em';
        }
    }

    // Generate html for a shape
    function getEntryIconHtml(shape) {
        var html = '',
            name = shape.name,
            x = shape.xPos,
            y = shape.yPos,
            fill = shape.fillColor,
            stroke = shape.strokeColor,
            width = shape.strokeWidth;
        switch (name) {
            case 'circle':
                html = '<use xlink:href="#circle" class="legendIcon" ' +
                    'x="' + x + '" ' +
                    'y="' + y + '" ' +
                    'fill="' + fill + '" ' +
                    'stroke="' + stroke + '" ' +
                    'stroke-width="' + width + '" ' +
                    'width="1.5em" height="1.5em"' +
                    '/>';
                break;
            case 'diamond':
                html = '<use xlink:href="#diamond" class="legendIcon" ' +
                    'x="' + x + '" ' +
                    'y="' + y + '" ' +
                    'fill="' + fill + '" ' +
                    'stroke="' + stroke + '" ' +
                    'stroke-width="' + width + '" ' +
                    'width="1.5em" height="1.5em"' +
                    '/>';
                break;
            case 'cross':
                html = '<use xlink:href="#cross" class="legendIcon" ' +
                    'x="' + x + '" ' +
                    'y="' + y + '" ' +
                    // 'fill="' + fill + '" ' +
                    'stroke="' + stroke + '" ' +
                    'stroke-width="' + width + '" ' +
                    'width="1.5em" height="1.5em"' +
                    '/>';
                break;
            case 'rectangle':
                html = '<use xlink:href="#rectangle" class="legendIcon" ' +
                    'x="' + x + '" ' +
                    'y="' + y + '" ' +
                    'fill="' + fill + '" ' +
                    'stroke="' + stroke + '" ' +
                    'stroke-width="' + width + '" ' +
                    'width="1.5em" height="1.5em"' +
                    '/>';
                break;
            case 'plus':
                html = '<use xlink:href="#plus" class="legendIcon" ' +
                    'x="' + x + '" ' +
                    'y="' + y + '" ' +
                    // 'fill="' + fill + '" ' +
                    'stroke="' + stroke + '" ' +
                    'stroke-width="' + width + '" ' +
                    'width="1.5em" height="1.5em"' +
                    '/>';
                break;
            case 'bar':
                html = '<use xlink:href="#bars" class="legendIcon" ' +
                    'x="' + x + '" ' +
                    'y="' + y + '" ' +
                    'fill="' + fill + '" ' +
                    // 'stroke="' + stroke + '" ' +
                    // 'stroke-width="' + width + '" ' +
                    'width="1.5em" height="1.5em"' +
                    '/>';
                break;
            case 'area':
                html = '<use xlink:href="#area" class="legendIcon" ' +
                    'x="' + x + '" ' +
                    'y="' + y + '" ' +
                    'fill="' + fill + '" ' +
                    // 'stroke="' + stroke + '" ' +
                    // 'stroke-width="' + width + '" ' +
                    'width="1.5em" height="1.5em"' +
                    '/>';
                break;
            case 'line':
                html = '<use xlink:href="#line" class="legendIcon" ' +
                    'x="' + x + '" ' +
                    'y="' + y + '" ' +
                    // 'fill="' + fill + '" ' +
                    'stroke="' + stroke + '" ' +
                    'stroke-width="' + width + '" ' +
                    'width="1.5em" height="1.5em"' +
                    '/>';
                break;
            default:
                // default is circle
                html = '<use xlink:href="#circle" class="legendIcon" ' +
                    'x="' + x + '" ' +
                    'y="' + y + '" ' +
                    'fill="' + fill + '" ' +
                    'stroke="' + stroke + '" ' +
                    'stroke-width="' + width + '" ' +
                    'width="1.5em" height="1.5em"' +
                    '/>';
        }

        return html;
    }

    // Define svg symbols for shapes
    var svgShapeDefs = '' +
        '<defs>' +
            '<symbol id="line" fill="none" viewBox="-5 -5 25 25">' +
                '<polyline points="0,15 5,5 10,10 15,0"/>' +
            '</symbol>' +

            '<symbol id="area" stroke-width="1" viewBox="-5 -5 25 25">' +
                '<polyline points="0,15 5,5 10,10 15,0, 15,15, 0,15"/>' +
            '</symbol>' +

            '<symbol id="bars" stroke-width="1" viewBox="-5 -5 25 25">' +
                '<polyline points="1.5,15.5 1.5,12.5, 4.5,12.5 4.5,15.5 6.5,15.5 6.5,3.5, 9.5,3.5 9.5,15.5 11.5,15.5 11.5,7.5 14.5,7.5 14.5,15.5 1.5,15.5"/>' +
            '</symbol>' +

            '<symbol id="circle" viewBox="-5 -5 25 25">' +
                '<circle cx="0" cy="15" r="2.5"/>' +
                '<circle cx="5" cy="5" r="2.5"/>' +
                '<circle cx="10" cy="10" r="2.5"/>' +
                '<circle cx="15" cy="0" r="2.5"/>' +
            '</symbol>' +

            '<symbol id="rectangle" viewBox="-5 -5 25 25">' +
                '<rect x="-2.1" y="12.9" width="4.2" height="4.2"/>' +
                '<rect x="2.9" y="2.9" width="4.2" height="4.2"/>' +
                '<rect x="7.9" y="7.9" width="4.2" height="4.2"/>' +
                '<rect x="12.9" y="-2.1" width="4.2" height="4.2"/>' +
            '</symbol>' +

            '<symbol id="diamond" viewBox="-5 -5 25 25">' +
                '<path d="M-3,15 L0,12 L3,15, L0,18 Z"/>' +
                '<path d="M2,5 L5,2 L8,5, L5,8 Z"/>' +
                '<path d="M7,10 L10,7 L13,10, L10,13 Z"/>' +
                '<path d="M12,0 L15,-3 L18,0, L15,3 Z"/>' +
            '</symbol>' +

            '<symbol id="cross" fill="none" viewBox="-5 -5 25 25">' +
                '<path d="M-2.1,12.9 L2.1,17.1, M2.1,12.9 L-2.1,17.1 Z"/>' +
                '<path d="M2.9,2.9 L7.1,7.1 M7.1,2.9 L2.9,7.1 Z"/>' +
                '<path d="M7.9,7.9 L12.1,12.1 M12.1,7.9 L7.9,12.1 Z"/>' +
                '<path d="M12.9,-2.1 L17.1,2.1 M17.1,-2.1 L12.9,2.1 Z"/>' +
            '</symbol>' +

            '<symbol id="plus" fill="none" viewBox="-5 -5 25 25">' +
                '<path d="M0,12 L0,18, M-3,15 L3,15 Z"/>' +
                '<path d="M5,2 L5,8 M2,5 L8,5 Z"/>' +
                '<path d="M10,7 L10,13 M7,10 L13,10 Z"/>' +
                '<path d="M15,-3 L15,3 M12,0 L18,0 Z"/>' +
            '</symbol>' +
        '</defs>';

    // Generate a list of legend entries in their final order
    function getLegendEntries(series, labelFormatter, sorted) {
        var lf = labelFormatter,
            legendEntries = series.reduce(function(validEntries, s, i) {
                var labelEval = (lf ? lf(s.label, s) : s.label)
                if (s.hasOwnProperty("label") ? labelEval : true) {
                    var entry = {
                        label: labelEval || 'Plot ' + (i + 1),
                        color: s.color,
                        options: {
                            lines: s.lines,
                            points: s.points,
                            bars: s.bars
                        }
                    }
                    validEntries.push(entry)
                }
                return validEntries;
            }, []);

        // Sort the legend using either the default or a custom comparator
        if (sorted) {
            if ($.isFunction(sorted)) {
                legendEntries.sort(sorted);
            } else if (sorted === 'reverse') {
                legendEntries.reverse();
            } else {
                var ascending = (sorted !== 'descending');
                legendEntries.sort(function(a, b) {
                    return a.label === b.label
                        ? 0
                        : ((a.label < b.label) !== ascending ? 1 : -1 // Logical XOR
                        );
                });
            }
        }

        return legendEntries;
    }

    // return false if opts1 same as opts2
    function checkOptions(opts1, opts2) {
        for (var prop in opts1) {
            if (opts1.hasOwnProperty(prop)) {
                if (opts1[prop] !== opts2[prop]) {
                    return true;
                }
            }
        }
        return false;
    }

    // Compare two lists of legend entries
    function shouldRedraw(oldEntries, newEntries) {
        if (!oldEntries || !newEntries) {
            return true;
        }

        if (oldEntries.length !== newEntries.length) {
            return true;
        }
        var i, newEntry, oldEntry, newOpts, oldOpts;
        for (i = 0; i < newEntries.length; i++) {
            newEntry = newEntries[i];
            oldEntry = oldEntries[i];

            if (newEntry.label !== oldEntry.label) {
                return true;
            }

            if (newEntry.color !== oldEntry.color) {
                return true;
            }

            // check for changes in lines options
            newOpts = newEntry.options.lines;
            oldOpts = oldEntry.options.lines;
            if (checkOptions(newOpts, oldOpts)) {
                return true;
            }

            // check for changes in points options
            newOpts = newEntry.options.points;
            oldOpts = oldEntry.options.points;
            if (checkOptions(newOpts, oldOpts)) {
                return true;
            }

            // check for changes in bars options
            newOpts = newEntry.options.bars;
            oldOpts = oldEntry.options.bars;
            if (checkOptions(newOpts, oldOpts)) {
                return true;
            }
        }

        return false;
    }

    function init(plot) {
        plot.hooks.setupGrid.push(function (plot) {
            var options = plot.getOptions();
            var series = plot.getData(),
                labelFormatter = options.legend.labelFormatter,
                oldEntries = options.legend.legendEntries,
                oldPlotOffset = options.legend.plotOffset,
                newEntries = getLegendEntries(series, labelFormatter, options.legend.sorted),
                newPlotOffset = plot.getPlotOffset();

            if (shouldRedraw(oldEntries, newEntries) ||
                checkOptions(oldPlotOffset, newPlotOffset)) {
                insertLegend(plot, options, plot.getPlaceholder(), newEntries);
            }
        });
    }

    $.plot.plugins.push({
        init: init,
        options: defaultOptions,
        name: 'legend',
        version: '1.0'
    });
})(jQuery);


/***/ }),

/***/ "./node_modules/flot/source/jquery.flot.logaxis.js":
/*!*********************************************************!*\
  !*** ./node_modules/flot/source/jquery.flot.logaxis.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* Pretty handling of log axes.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Copyright (c) 2015 Ciprian Ceteras cipix2000@gmail.com.
Copyright (c) 2017 Raluca Portase
Licensed under the MIT license.

Set axis.mode to "log" to enable.
*/

/* global jQuery*/

/**
## jquery.flot.logaxis
This plugin is used to create logarithmic axis. This includes tick generation,
formatters and transformers to and from logarithmic representation.

### Methods and hooks
*/

(function ($) {
    'use strict';

    var options = {
        xaxis: {}
    };

    /*tick generators and formatters*/
    var PREFERRED_LOG_TICK_VALUES = computePreferedLogTickValues(Number.MAX_VALUE, 10),
        EXTENDED_LOG_TICK_VALUES = computePreferedLogTickValues(Number.MAX_VALUE, 4);

    function computePreferedLogTickValues(endLimit, rangeStep) {
        var log10End = Math.floor(Math.log(endLimit) * Math.LOG10E) - 1,
            log10Start = -log10End,
            val, range, vals = [];

        for (var power = log10Start; power <= log10End; power++) {
            range = parseFloat('1e' + power);
            for (var mult = 1; mult < 9; mult += rangeStep) {
                val = range * mult;
                vals.push(val);
            }
        }
        return vals;
    }

    /**
    - logTickGenerator(plot, axis, noTicks)

    Generates logarithmic ticks, depending on axis range.
    In case the number of ticks that can be generated is less than the expected noTicks/4,
    a linear tick generation is used.
    */
    var logTickGenerator = function (plot, axis, noTicks) {
        var ticks = [],
            minIdx = -1,
            maxIdx = -1,
            surface = plot.getCanvas(),
            logTickValues = PREFERRED_LOG_TICK_VALUES,
            min = clampAxis(axis, plot),
            max = axis.max;

        if (!noTicks) {
            noTicks = 0.3 * Math.sqrt(axis.direction === "x" ? surface.width : surface.height);
        }

        PREFERRED_LOG_TICK_VALUES.some(function (val, i) {
            if (val >= min) {
                minIdx = i;
                return true;
            } else {
                return false;
            }
        });

        PREFERRED_LOG_TICK_VALUES.some(function (val, i) {
            if (val >= max) {
                maxIdx = i;
                return true;
            } else {
                return false;
            }
        });

        if (maxIdx === -1) {
            maxIdx = PREFERRED_LOG_TICK_VALUES.length - 1;
        }

        if (maxIdx - minIdx <= noTicks / 4 && logTickValues.length !== EXTENDED_LOG_TICK_VALUES.length) {
            //try with multiple of 5 for tick values
            logTickValues = EXTENDED_LOG_TICK_VALUES;
            minIdx *= 2;
            maxIdx *= 2;
        }

        var lastDisplayed = null,
            inverseNoTicks = 1 / noTicks,
            tickValue, pixelCoord, tick;

        // Count the number of tick values would appear, if we can get at least
        // nTicks / 4 accept them.
        if (maxIdx - minIdx >= noTicks / 4) {
            for (var idx = maxIdx; idx >= minIdx; idx--) {
                tickValue = logTickValues[idx];
                pixelCoord = (Math.log(tickValue) - Math.log(min)) / (Math.log(max) - Math.log(min));
                tick = tickValue;

                if (lastDisplayed === null) {
                    lastDisplayed = {
                        pixelCoord: pixelCoord,
                        idealPixelCoord: pixelCoord
                    };
                } else {
                    if (Math.abs(pixelCoord - lastDisplayed.pixelCoord) >= inverseNoTicks) {
                        lastDisplayed = {
                            pixelCoord: pixelCoord,
                            idealPixelCoord: lastDisplayed.idealPixelCoord - inverseNoTicks
                        };
                    } else {
                        tick = null;
                    }
                }

                if (tick) {
                    ticks.push(tick);
                }
            }
            // Since we went in backwards order.
            ticks.reverse();
        } else {
            var tickSize = plot.computeTickSize(min, max, noTicks),
                customAxis = {min: min, max: max, tickSize: tickSize};
            ticks = $.plot.linearTickGenerator(customAxis);
        }

        return ticks;
    };

    var clampAxis = function (axis, plot) {
        var min = axis.min,
            max = axis.max;

        if (min <= 0) {
            //for empty graph if axis.min is not strictly positive make it 0.1
            if (axis.datamin === null) {
                min = axis.min = 0.1;
            } else {
                min = processAxisOffset(plot, axis);
            }

            if (max < min) {
                axis.max = axis.datamax !== null ? axis.datamax : axis.options.max;
                axis.options.offset.below = 0;
                axis.options.offset.above = 0;
            }
        }

        return min;
    }

    /**
    - logTickFormatter(value, axis, precision)

    This is the corresponding tickFormatter of the logaxis.
    For a number greater that 10^6 or smaller than 10^(-3), this will be drawn
    with e representation
    */
    var logTickFormatter = function (value, axis, precision) {
        var tenExponent = value > 0 ? Math.floor(Math.log(value) / Math.LN10) : 0;

        if (precision) {
            if ((tenExponent >= -4) && (tenExponent <= 7)) {
                return $.plot.defaultTickFormatter(value, axis, precision);
            } else {
                return $.plot.expRepTickFormatter(value, axis, precision);
            }
        }
        if ((tenExponent >= -4) && (tenExponent <= 7)) {
            //if we have float numbers, return a limited length string(ex: 0.0009 is represented as 0.000900001)
            var formattedValue = tenExponent < 0 ? value.toFixed(-tenExponent) : value.toFixed(tenExponent + 2);
            if (formattedValue.indexOf('.') !== -1) {
                var lastZero = formattedValue.lastIndexOf('0');

                while (lastZero === formattedValue.length - 1) {
                    formattedValue = formattedValue.slice(0, -1);
                    lastZero = formattedValue.lastIndexOf('0');
                }

                //delete the dot if is last
                if (formattedValue.indexOf('.') === formattedValue.length - 1) {
                    formattedValue = formattedValue.slice(0, -1);
                }
            }
            return formattedValue;
        } else {
            return $.plot.expRepTickFormatter(value, axis);
        }
    };

    /*logaxis caracteristic functions*/
    var logTransform = function (v) {
        if (v < PREFERRED_LOG_TICK_VALUES[0]) {
            v = PREFERRED_LOG_TICK_VALUES[0];
        }

        return Math.log(v);
    };

    var logInverseTransform = function (v) {
        return Math.exp(v);
    };

    var invertedTransform = function (v) {
        return -v;
    }

    var invertedLogTransform = function (v) {
        return -logTransform(v);
    }

    var invertedLogInverseTransform = function (v) {
        return logInverseTransform(-v);
    }

    /**
    - setDataminRange(plot, axis)

    It is used for clamping the starting point of a logarithmic axis.
    This will set the axis datamin range to 0.1 or to the first datapoint greater then 0.
    The function is usefull since the logarithmic representation can not show
    values less than or equal to 0.
    */
    function setDataminRange(plot, axis) {
        if (axis.options.mode === 'log' && axis.datamin <= 0) {
            if (axis.datamin === null) {
                axis.datamin = 0.1;
            } else {
                axis.datamin = processAxisOffset(plot, axis);
            }
        }
    }

    function processAxisOffset(plot, axis) {
        var series = plot.getData(),
            range = series
                .filter(function(series) {
                    return series.xaxis === axis || series.yaxis === axis;
                })
                .map(function(series) {
                    return plot.computeRangeForDataSeries(series, null, isValid);
                }),
            min = axis.direction === 'x'
                ? Math.min(0.1, range && range[0] ? range[0].xmin : 0.1)
                : Math.min(0.1, range && range[0] ? range[0].ymin : 0.1);

        axis.min = min;

        return min;
    }

    function isValid(a) {
        return a > 0;
    }

    function init(plot) {
        plot.hooks.processOptions.push(function (plot) {
            $.each(plot.getAxes(), function (axisName, axis) {
                var opts = axis.options;
                if (opts.mode === 'log') {
                    axis.tickGenerator = function (axis) {
                        var noTicks = 11;
                        return logTickGenerator(plot, axis, noTicks);
                    };
                    if (typeof axis.options.tickFormatter !== 'function') {
                        axis.options.tickFormatter = logTickFormatter;
                    }
                    axis.options.transform = opts.inverted ? invertedLogTransform : logTransform;
                    axis.options.inverseTransform = opts.inverted ? invertedLogInverseTransform : logInverseTransform;
                    axis.options.autoScaleMargin = 0;
                    plot.hooks.setRange.push(setDataminRange);
                } else if (opts.inverted) {
                    axis.options.transform = invertedTransform;
                    axis.options.inverseTransform = invertedTransform;
                }
            });
        });
    }

    $.plot.plugins.push({
        init: init,
        options: options,
        name: 'log',
        version: '0.1'
    });

    $.plot.logTicksGenerator = logTickGenerator;
    $.plot.logTickFormatter = logTickFormatter;
})(jQuery);


/***/ }),

/***/ "./node_modules/flot/source/jquery.flot.navigate.js":
/*!**********************************************************!*\
  !*** ./node_modules/flot/source/jquery.flot.navigate.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* Flot plugin for adding the ability to pan and zoom the plot.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Copyright (c) 2016 Ciprian Ceteras.
Copyright (c) 2017 Raluca Portase.
Licensed under the MIT license.

*/

/**
## jquery.flot.navigate.js

This flot plugin is used for adding the ability to pan and zoom the plot.
A higher level overview is available at [interactions](interactions.md) documentation.

The default behaviour is scrollwheel up/down to zoom in, drag
to pan. The plugin defines plot.zoom({ center }), plot.zoomOut() and
plot.pan( offset ) so you easily can add custom controls. It also fires
"plotpan" and "plotzoom" events, useful for synchronizing plots.

The plugin supports these options:
```js
    zoom: {
        interactive: false,
        active: false,
        amount: 1.5         // 2 = 200% (zoom in), 0.5 = 50% (zoom out)
    }

    pan: {
        interactive: false,
        active: false,
        cursor: "move",     // CSS mouse cursor value used when dragging, e.g. "pointer"
        frameRate: 60,
        mode: "smart"       // enable smart pan mode
    }

    xaxis: {
        axisZoom: true, //zoom axis when mouse over it is allowed
        plotZoom: true, //zoom axis is allowed for plot zoom
        axisPan: true, //pan axis when mouse over it is allowed
        plotPan: true, //pan axis is allowed for plot pan
        panRange: [undefined, undefined], // no limit on pan range, or [min, max] in axis units
        zoomRange: [undefined, undefined], // no limit on zoom range, or [closest zoom, furthest zoom] in axis units
    }

    yaxis: {
        axisZoom: true, //zoom axis when mouse over it is allowed
        plotZoom: true, //zoom axis is allowed for plot zoom
        axisPan: true, //pan axis when mouse over it is allowed
        plotPan: true //pan axis is allowed for plot pan
        panRange: [undefined, undefined], // no limit on pan range, or [min, max] in axis units
        zoomRange: [undefined, undefined], // no limit on zoom range, or [closest zoom, furthest zoom] in axis units
    }
```
**interactive** enables the built-in drag/click behaviour. If you enable
interactive for pan, then you'll have a basic plot that supports moving
around; the same for zoom.

**active** is true after a touch tap on plot. This enables plot navigation.
Once activated, zoom and pan cannot be deactivated. When the plot becomes active,
"plotactivated" event is triggered.

**amount** specifies the default amount to zoom in (so 1.5 = 150%) relative to
the current viewport.

**cursor** is a standard CSS mouse cursor string used for visual feedback to the
user when dragging.

**frameRate** specifies the maximum number of times per second the plot will
update itself while the user is panning around on it (set to null to disable
intermediate pans, the plot will then not update until the mouse button is
released).

**mode** a string specifies the pan mode for mouse interaction. Accepted values:
'manual': no pan hint or direction snapping;
'smart': The graph shows pan hint bar and the pan movement will snap
to one direction when the drag direction is close to it;
'smartLock'. The graph shows pan hint bar and the pan movement will always
snap to a direction that the drag diorection started with.

Example API usage:
```js
    plot = $.plot(...);

    // zoom default amount in on the pixel ( 10, 20 )
    plot.zoom({ center: { left: 10, top: 20 } });

    // zoom out again
    plot.zoomOut({ center: { left: 10, top: 20 } });

    // zoom 200% in on the pixel (10, 20)
    plot.zoom({ amount: 2, center: { left: 10, top: 20 } });

    // pan 100 pixels to the left (changing x-range in a positive way) and 20 down
    plot.pan({ left: -100, top: 20 })
```

Here, "center" specifies where the center of the zooming should happen. Note
that this is defined in pixel space, not the space of the data points (you can
use the p2c helpers on the axes in Flot to help you convert between these).

**amount** is the amount to zoom the viewport relative to the current range, so
1 is 100% (i.e. no change), 1.5 is 150% (zoom in), 0.7 is 70% (zoom out). You
can set the default in the options.
*/

/* eslint-enable */
(function($) {
    'use strict';

    var options = {
        zoom: {
            interactive: false,
            active: false,
            amount: 1.5 // how much to zoom relative to current position, 2 = 200% (zoom in), 0.5 = 50% (zoom out)
        },
        pan: {
            interactive: false,
            active: false,
            cursor: "move",
            frameRate: 60,
            mode: 'smart'
        },
        recenter: {
            interactive: true
        },
        xaxis: {
            axisZoom: true, //zoom axis when mouse over it is allowed
            plotZoom: true, //zoom axis is allowed for plot zoom
            axisPan: true, //pan axis when mouse over it is allowed
            plotPan: true, //pan axis is allowed for plot pan
            panRange: [undefined, undefined], // no limit on pan range, or [min, max] in axis units
            zoomRange: [undefined, undefined] // no limit on zoom range, or [closest zoom, furthest zoom] in axis units
        },
        yaxis: {
            axisZoom: true,
            plotZoom: true,
            axisPan: true,
            plotPan: true,
            panRange: [undefined, undefined], // no limit on pan range, or [min, max] in axis units
            zoomRange: [undefined, undefined] // no limit on zoom range, or [closest zoom, furthest zoom] in axis units
        }
    };

    var saturated = $.plot.saturated;
    var browser = $.plot.browser;
    var SNAPPING_CONSTANT = $.plot.uiConstants.SNAPPING_CONSTANT;
    var PANHINT_LENGTH_CONSTANT = $.plot.uiConstants.PANHINT_LENGTH_CONSTANT;

    function init(plot) {
        plot.hooks.processOptions.push(initNevigation);
    }

    function initNevigation(plot, options) {
        var panAxes = null;
        var canDrag = false;
        var useManualPan = options.pan.mode === 'manual',
            smartPanLock = options.pan.mode === 'smartLock',
            useSmartPan = smartPanLock || options.pan.mode === 'smart';

        function onZoomClick(e, zoomOut, amount) {
            var page = browser.getPageXY(e);

            var c = plot.offset();
            c.left = page.X - c.left;
            c.top = page.Y - c.top;

            var ec = plot.getPlaceholder().offset();
            ec.left = page.X - ec.left;
            ec.top = page.Y - ec.top;

            var axes = plot.getXAxes().concat(plot.getYAxes()).filter(function (axis) {
                var box = axis.box;
                if (box !== undefined) {
                    return (ec.left > box.left) && (ec.left < box.left + box.width) &&
                        (ec.top > box.top) && (ec.top < box.top + box.height);
                }
            });

            if (axes.length === 0) {
                axes = undefined;
            }

            if (zoomOut) {
                plot.zoomOut({
                    center: c,
                    axes: axes,
                    amount: amount
                });
            } else {
                plot.zoom({
                    center: c,
                    axes: axes,
                    amount: amount
                });
            }
        }

        var prevCursor = 'default',
            panHint = null,
            panTimeout = null,
            plotState,
            prevDragPosition = { x: 0, y: 0 },
            isPanAction = false;

        function onMouseWheel(e, delta) {
            var maxAbsoluteDeltaOnMac = 1,
                isMacScroll = Math.abs(e.originalEvent.deltaY) <= maxAbsoluteDeltaOnMac,
                defaultNonMacScrollAmount = null,
                macMagicRatio = 50,
                amount = isMacScroll ? 1 + Math.abs(e.originalEvent.deltaY) / macMagicRatio : defaultNonMacScrollAmount;

            if (isPanAction) {
                onDragEnd(e);
            }

            if (plot.getOptions().zoom.active) {
                e.preventDefault();
                onZoomClick(e, delta < 0, amount);
                return false;
            }
        }

        plot.navigationState = function(startPageX, startPageY) {
            var axes = this.getAxes();
            var result = {};
            Object.keys(axes).forEach(function(axisName) {
                var axis = axes[axisName];
                result[axisName] = {
                    navigationOffset: { below: axis.options.offset.below || 0,
                        above: axis.options.offset.above || 0},
                    axisMin: axis.min,
                    axisMax: axis.max,
                    diagMode: false
                }
            });

            result.startPageX = startPageX || 0;
            result.startPageY = startPageY || 0;
            return result;
        }

        function onMouseDown(e) {
            canDrag = true;
        }

        function onMouseUp(e) {
            canDrag = false;
        }

        function isLeftMouseButtonPressed(e) {
            return e.button === 0;
        }

        function onDragStart(e) {
            if (!canDrag || !isLeftMouseButtonPressed(e)) {
                return false;
            }

            isPanAction = true;
            var page = browser.getPageXY(e);

            var ec = plot.getPlaceholder().offset();
            ec.left = page.X - ec.left;
            ec.top = page.Y - ec.top;

            panAxes = plot.getXAxes().concat(plot.getYAxes()).filter(function (axis) {
                var box = axis.box;
                if (box !== undefined) {
                    return (ec.left > box.left) && (ec.left < box.left + box.width) &&
                        (ec.top > box.top) && (ec.top < box.top + box.height);
                }
            });

            if (panAxes.length === 0) {
                panAxes = undefined;
            }

            var c = plot.getPlaceholder().css('cursor');
            if (c) {
                prevCursor = c;
            }

            plot.getPlaceholder().css('cursor', plot.getOptions().pan.cursor);

            if (useSmartPan) {
                plotState = plot.navigationState(page.X, page.Y);
            } else if (useManualPan) {
                prevDragPosition.x = page.X;
                prevDragPosition.y = page.Y;
            }
        }

        function onDrag(e) {
            if (!isPanAction) {
                return;
            }

            var page = browser.getPageXY(e);
            var frameRate = plot.getOptions().pan.frameRate;

            if (frameRate === -1) {
                if (useSmartPan) {
                    plot.smartPan({
                        x: plotState.startPageX - page.X,
                        y: plotState.startPageY - page.Y
                    }, plotState, panAxes, false, smartPanLock);
                } else if (useManualPan) {
                    plot.pan({
                        left: prevDragPosition.x - page.X,
                        top: prevDragPosition.y - page.Y,
                        axes: panAxes
                    });
                    prevDragPosition.x = page.X;
                    prevDragPosition.y = page.Y;
                }
                return;
            }

            if (panTimeout || !frameRate) return;

            panTimeout = setTimeout(function() {
                if (useSmartPan) {
                    plot.smartPan({
                        x: plotState.startPageX - page.X,
                        y: plotState.startPageY - page.Y
                    }, plotState, panAxes, false, smartPanLock);
                } else if (useManualPan) {
                    plot.pan({
                        left: prevDragPosition.x - page.X,
                        top: prevDragPosition.y - page.Y,
                        axes: panAxes
                    });
                    prevDragPosition.x = page.X;
                    prevDragPosition.y = page.Y;
                }

                panTimeout = null;
            }, 1 / frameRate * 1000);
        }

        function onDragEnd(e) {
            if (!isPanAction) {
                return;
            }

            if (panTimeout) {
                clearTimeout(panTimeout);
                panTimeout = null;
            }

            isPanAction = false;
            var page = browser.getPageXY(e);

            plot.getPlaceholder().css('cursor', prevCursor);

            if (useSmartPan) {
                plot.smartPan({
                    x: plotState.startPageX - page.X,
                    y: plotState.startPageY - page.Y
                }, plotState, panAxes, false, smartPanLock);
                plot.smartPan.end();
            } else if (useManualPan) {
                plot.pan({
                    left: prevDragPosition.x - page.X,
                    top: prevDragPosition.y - page.Y,
                    axes: panAxes
                });
                prevDragPosition.x = 0;
                prevDragPosition.y = 0;
            }
        }

        function onDblClick(e) {
            plot.activate();
            var o = plot.getOptions()

            if (!o.recenter.interactive) { return; }

            var axes = plot.getTouchedAxis(e.clientX, e.clientY),
                event;

            plot.recenter({ axes: axes[0] ? axes : null });

            if (axes[0]) {
                event = new $.Event('re-center', { detail: {
                    axisTouched: axes[0]
                }});
            } else {
                event = new $.Event('re-center', { detail: e });
            }
            plot.getPlaceholder().trigger(event);
        }

        function onClick(e) {
            plot.activate();

            if (isPanAction) {
                onDragEnd(e);
            }

            return false;
        }

        plot.activate = function() {
            var o = plot.getOptions();
            if (!o.pan.active || !o.zoom.active) {
                o.pan.active = true;
                o.zoom.active = true;
                plot.getPlaceholder().trigger("plotactivated", [plot]);
            }
        }

        function bindEvents(plot, eventHolder) {
            var o = plot.getOptions();
            if (o.zoom.interactive) {
                eventHolder.mousewheel(onMouseWheel);
            }

            if (o.pan.interactive) {
                plot.addEventHandler("dragstart", onDragStart, eventHolder, 0);
                plot.addEventHandler("drag", onDrag, eventHolder, 0);
                plot.addEventHandler("dragend", onDragEnd, eventHolder, 0);
                eventHolder.bind("mousedown", onMouseDown);
                eventHolder.bind("mouseup", onMouseUp);
            }

            eventHolder.dblclick(onDblClick);
            eventHolder.click(onClick);
        }

        plot.zoomOut = function(args) {
            if (!args) {
                args = {};
            }

            if (!args.amount) {
                args.amount = plot.getOptions().zoom.amount;
            }

            args.amount = 1 / args.amount;
            plot.zoom(args);
        };

        plot.zoom = function(args) {
            if (!args) {
                args = {};
            }

            var c = args.center,
                amount = args.amount || plot.getOptions().zoom.amount,
                w = plot.width(),
                h = plot.height(),
                axes = args.axes || plot.getAxes();

            if (!c) {
                c = {
                    left: w / 2,
                    top: h / 2
                };
            }

            var xf = c.left / w,
                yf = c.top / h,
                minmax = {
                    x: {
                        min: c.left - xf * w / amount,
                        max: c.left + (1 - xf) * w / amount
                    },
                    y: {
                        min: c.top - yf * h / amount,
                        max: c.top + (1 - yf) * h / amount
                    }
                };

            for (var key in axes) {
                if (!axes.hasOwnProperty(key)) {
                    continue;
                }

                var axis = axes[key],
                    opts = axis.options,
                    min = minmax[axis.direction].min,
                    max = minmax[axis.direction].max,
                    navigationOffset = axis.options.offset;

                //skip axis without axisZoom when zooming only on certain axis or axis without plotZoom for zoom on entire plot
                if ((!opts.axisZoom && args.axes) || (!args.axes && !opts.plotZoom)) {
                    continue;
                }

                min = $.plot.saturated.saturate(axis.c2p(min));
                max = $.plot.saturated.saturate(axis.c2p(max));
                if (min > max) {
                    // make sure min < max
                    var tmp = min;
                    min = max;
                    max = tmp;
                }

                // test for zoom limits zoomRange: [min,max]
                if (opts.zoomRange) {
                    // zoomed in too far
                    if (max - min < opts.zoomRange[0]) {
                        continue;
                    }
                    // zoomed out to far
                    if (max - min > opts.zoomRange[1]) {
                        continue;
                    }
                }

                var offsetBelow = $.plot.saturated.saturate(navigationOffset.below - (axis.min - min));
                var offsetAbove = $.plot.saturated.saturate(navigationOffset.above - (axis.max - max));
                opts.offset = { below: offsetBelow, above: offsetAbove };
            };

            plot.setupGrid(true);
            plot.draw();

            if (!args.preventEvent) {
                plot.getPlaceholder().trigger("plotzoom", [plot, args]);
            }
        };

        plot.pan = function(args) {
            var delta = {
                x: +args.left,
                y: +args.top
            };

            if (isNaN(delta.x)) delta.x = 0;
            if (isNaN(delta.y)) delta.y = 0;

            $.each(args.axes || plot.getAxes(), function(_, axis) {
                var opts = axis.options,
                    d = delta[axis.direction];

                //skip axis without axisPan when panning only on certain axis or axis without plotPan for pan the entire plot
                if ((!opts.axisPan && args.axes) || (!opts.plotPan && !args.axes)) {
                    return;
                }

                // calc min delta (revealing left edge of plot)
                var minD = axis.p2c(opts.panRange[0]) - axis.p2c(axis.min);
                // calc max delta (revealing right edge of plot)
                var maxD = axis.p2c(opts.panRange[1]) - axis.p2c(axis.max);
                // limit delta to min or max if enabled
                if (opts.panRange[0] !== undefined && d >= maxD) d = maxD;
                if (opts.panRange[1] !== undefined && d <= minD) d = minD;

                if (d !== 0) {
                    var navigationOffsetBelow = saturated.saturate(axis.c2p(axis.p2c(axis.min) + d) - axis.c2p(axis.p2c(axis.min))),
                        navigationOffsetAbove = saturated.saturate(axis.c2p(axis.p2c(axis.max) + d) - axis.c2p(axis.p2c(axis.max)));

                    if (!isFinite(navigationOffsetBelow)) {
                        navigationOffsetBelow = 0;
                    }

                    if (!isFinite(navigationOffsetAbove)) {
                        navigationOffsetAbove = 0;
                    }

                    opts.offset = {
                        below: saturated.saturate(navigationOffsetBelow + (opts.offset.below || 0)),
                        above: saturated.saturate(navigationOffsetAbove + (opts.offset.above || 0))
                    };
                }
            });

            plot.setupGrid(true);
            plot.draw();
            if (!args.preventEvent) {
                plot.getPlaceholder().trigger("plotpan", [plot, args]);
            }
        };

        plot.recenter = function(args) {
            $.each(args.axes || plot.getAxes(), function(_, axis) {
                if (args.axes) {
                    if (this.direction === 'x') {
                        axis.options.offset = { below: 0 };
                    } else if (this.direction === 'y') {
                        axis.options.offset = { above: 0 };
                    }
                } else {
                    axis.options.offset = { below: 0, above: 0 };
                }
            });
            plot.setupGrid(true);
            plot.draw();
        };

        var shouldSnap = function(delta) {
            return (Math.abs(delta.y) < SNAPPING_CONSTANT && Math.abs(delta.x) >= SNAPPING_CONSTANT) ||
                (Math.abs(delta.x) < SNAPPING_CONSTANT && Math.abs(delta.y) >= SNAPPING_CONSTANT);
        }

        // adjust delta so the pan action is constrained on the vertical or horizontal direction
        // it the movements in the other direction are small
        var adjustDeltaToSnap = function(delta) {
            if (Math.abs(delta.x) < SNAPPING_CONSTANT && Math.abs(delta.y) >= SNAPPING_CONSTANT) {
                return {x: 0, y: delta.y};
            }

            if (Math.abs(delta.y) < SNAPPING_CONSTANT && Math.abs(delta.x) >= SNAPPING_CONSTANT) {
                return {x: delta.x, y: 0};
            }

            return delta;
        }

        var lockedDirection = null;
        var lockDeltaDirection = function(delta) {
            if (!lockedDirection && Math.max(Math.abs(delta.x), Math.abs(delta.y)) >= SNAPPING_CONSTANT) {
                lockedDirection = Math.abs(delta.x) < Math.abs(delta.y) ? 'y' : 'x';
            }

            switch (lockedDirection) {
                case 'x':
                    return { x: delta.x, y: 0 };
                case 'y':
                    return { x: 0, y: delta.y };
                default:
                    return { x: 0, y: 0 };
            }
        }

        var isDiagonalMode = function(delta) {
            if (Math.abs(delta.x) > 0 && Math.abs(delta.y) > 0) {
                return true;
            }
            return false;
        }

        var restoreAxisOffset = function(axes, initialState, delta) {
            var axis;
            Object.keys(axes).forEach(function(axisName) {
                axis = axes[axisName];
                if (delta[axis.direction] === 0) {
                    axis.options.offset.below = initialState[axisName].navigationOffset.below;
                    axis.options.offset.above = initialState[axisName].navigationOffset.above;
                }
            });
        }

        var prevDelta = { x: 0, y: 0 };
        plot.smartPan = function(delta, initialState, panAxes, preventEvent, smartLock) {
            var snap = smartLock ? true : shouldSnap(delta),
                axes = plot.getAxes(),
                opts;
            delta = smartLock ? lockDeltaDirection(delta) : adjustDeltaToSnap(delta);

            if (isDiagonalMode(delta)) {
                initialState.diagMode = true;
            }

            if (snap && initialState.diagMode === true) {
                initialState.diagMode = false;
                restoreAxisOffset(axes, initialState, delta);
            }

            if (snap) {
                panHint = {
                    start: {
                        x: initialState.startPageX - plot.offset().left + plot.getPlotOffset().left,
                        y: initialState.startPageY - plot.offset().top + plot.getPlotOffset().top
                    },
                    end: {
                        x: initialState.startPageX - delta.x - plot.offset().left + plot.getPlotOffset().left,
                        y: initialState.startPageY - delta.y - plot.offset().top + plot.getPlotOffset().top
                    }
                }
            } else {
                panHint = {
                    start: {
                        x: initialState.startPageX - plot.offset().left + plot.getPlotOffset().left,
                        y: initialState.startPageY - plot.offset().top + plot.getPlotOffset().top
                    },
                    end: false
                }
            }

            if (isNaN(delta.x)) delta.x = 0;
            if (isNaN(delta.y)) delta.y = 0;

            if (panAxes) {
                axes = panAxes;
            }

            var axis, axisMin, axisMax, p, d;
            Object.keys(axes).forEach(function(axisName) {
                axis = axes[axisName];
                axisMin = axis.min;
                axisMax = axis.max;
                opts = axis.options;

                d = delta[axis.direction];
                p = prevDelta[axis.direction];

                //skip axis without axisPan when panning only on certain axis or axis without plotPan for pan the entire plot
                if ((!opts.axisPan && panAxes) || (!panAxes && !opts.plotPan)) {
                    return;
                }

                // calc min delta (revealing left edge of plot)
                var minD = p + axis.p2c(opts.panRange[0]) - axis.p2c(axisMin);
                // calc max delta (revealing right edge of plot)
                var maxD = p + axis.p2c(opts.panRange[1]) - axis.p2c(axisMax);
                // limit delta to min or max if enabled
                if (opts.panRange[0] !== undefined && d >= maxD) d = maxD;
                if (opts.panRange[1] !== undefined && d <= minD) d = minD;

                if (d !== 0) {
                    var navigationOffsetBelow = saturated.saturate(axis.c2p(axis.p2c(axisMin) - (p - d)) - axis.c2p(axis.p2c(axisMin))),
                        navigationOffsetAbove = saturated.saturate(axis.c2p(axis.p2c(axisMax) - (p - d)) - axis.c2p(axis.p2c(axisMax)));

                    if (!isFinite(navigationOffsetBelow)) {
                        navigationOffsetBelow = 0;
                    }

                    if (!isFinite(navigationOffsetAbove)) {
                        navigationOffsetAbove = 0;
                    }

                    axis.options.offset.below = saturated.saturate(navigationOffsetBelow + (axis.options.offset.below || 0));
                    axis.options.offset.above = saturated.saturate(navigationOffsetAbove + (axis.options.offset.above || 0));
                }
            });

            prevDelta = delta;
            plot.setupGrid(true);
            plot.draw();

            if (!preventEvent) {
                plot.getPlaceholder().trigger("plotpan", [plot, delta, panAxes, initialState]);
            }
        };

        plot.smartPan.end = function() {
            panHint = null;
            lockedDirection = null;
            prevDelta = { x: 0, y: 0 };
            plot.triggerRedrawOverlay();
        }

        function shutdown(plot, eventHolder) {
            eventHolder.unbind("mousewheel", onMouseWheel);
            eventHolder.unbind("mousedown", onMouseDown);
            eventHolder.unbind("mouseup", onMouseUp);
            eventHolder.unbind("dragstart", onDragStart);
            eventHolder.unbind("drag", onDrag);
            eventHolder.unbind("dragend", onDragEnd);
            eventHolder.unbind("dblclick", onDblClick);
            eventHolder.unbind("click", onClick);

            if (panTimeout) clearTimeout(panTimeout);
        }

        function drawOverlay(plot, ctx) {
            if (panHint) {
                ctx.strokeStyle = 'rgba(96, 160, 208, 0.7)';
                ctx.lineWidth = 2;
                ctx.lineJoin = "round";
                var startx = Math.round(panHint.start.x),
                    starty = Math.round(panHint.start.y),
                    endx, endy;

                if (panAxes) {
                    if (panAxes[0].direction === 'x') {
                        endy = Math.round(panHint.start.y);
                        endx = Math.round(panHint.end.x);
                    } else if (panAxes[0].direction === 'y') {
                        endx = Math.round(panHint.start.x);
                        endy = Math.round(panHint.end.y);
                    }
                } else {
                    endx = Math.round(panHint.end.x);
                    endy = Math.round(panHint.end.y);
                }

                ctx.beginPath();

                if (panHint.end === false) {
                    ctx.moveTo(startx, starty - PANHINT_LENGTH_CONSTANT);
                    ctx.lineTo(startx, starty + PANHINT_LENGTH_CONSTANT);

                    ctx.moveTo(startx + PANHINT_LENGTH_CONSTANT, starty);
                    ctx.lineTo(startx - PANHINT_LENGTH_CONSTANT, starty);
                } else {
                    var dirX = starty === endy;

                    ctx.moveTo(startx - (dirX ? 0 : PANHINT_LENGTH_CONSTANT), starty - (dirX ? PANHINT_LENGTH_CONSTANT : 0));
                    ctx.lineTo(startx + (dirX ? 0 : PANHINT_LENGTH_CONSTANT), starty + (dirX ? PANHINT_LENGTH_CONSTANT : 0));

                    ctx.moveTo(startx, starty);
                    ctx.lineTo(endx, endy);

                    ctx.moveTo(endx - (dirX ? 0 : PANHINT_LENGTH_CONSTANT), endy - (dirX ? PANHINT_LENGTH_CONSTANT : 0));
                    ctx.lineTo(endx + (dirX ? 0 : PANHINT_LENGTH_CONSTANT), endy + (dirX ? PANHINT_LENGTH_CONSTANT : 0));
                }

                ctx.stroke();
            }
        }

        plot.getTouchedAxis = function(touchPointX, touchPointY) {
            var ec = plot.getPlaceholder().offset();
            ec.left = touchPointX - ec.left;
            ec.top = touchPointY - ec.top;

            var axis = plot.getXAxes().concat(plot.getYAxes()).filter(function (axis) {
                var box = axis.box;
                if (box !== undefined) {
                    return (ec.left > box.left) && (ec.left < box.left + box.width) &&
                            (ec.top > box.top) && (ec.top < box.top + box.height);
                }
            });

            return axis;
        }

        plot.hooks.drawOverlay.push(drawOverlay);
        plot.hooks.bindEvents.push(bindEvents);
        plot.hooks.shutdown.push(shutdown);
    }

    $.plot.plugins.push({
        init: init,
        options: options,
        name: 'navigate',
        version: '1.3'
    });
})(jQuery);


/***/ }),

/***/ "./node_modules/flot/source/jquery.flot.pie.js":
/*!*****************************************************!*\
  !*** ./node_modules/flot/source/jquery.flot.pie.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* Flot plugin for rendering pie charts.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Licensed under the MIT license.

The plugin assumes that each series has a single data value, and that each
value is a positive integer or zero.  Negative numbers don't make sense for a
pie chart, and have unpredictable results.  The values do NOT need to be
passed in as percentages; the plugin will calculate the total and per-slice
percentages internally.

* Created by Brian Medendorp

* Updated with contributions from btburnett3, Anthony Aragues and Xavi Ivars

The plugin supports these options:

    series: {
        pie: {
            show: true/false
            radius: 0-1 for percentage of fullsize, or a specified pixel length, or 'auto'
            innerRadius: 0-1 for percentage of fullsize or a specified pixel length, for creating a donut effect
            startAngle: 0-2 factor of PI used for starting angle (in radians) i.e 3/2 starts at the top, 0 and 2 have the same result
            tilt: 0-1 for percentage to tilt the pie, where 1 is no tilt, and 0 is completely flat (nothing will show)
            offset: {
                top: integer value to move the pie up or down
                left: integer value to move the pie left or right, or 'auto'
            },
            stroke: {
                color: any hexidecimal color value (other formats may or may not work, so best to stick with something like '#FFF')
                width: integer pixel width of the stroke
            },
            label: {
                show: true/false, or 'auto'
                formatter:  a user-defined function that modifies the text/style of the label text
                radius: 0-1 for percentage of fullsize, or a specified pixel length
                background: {
                    color: any hexidecimal color value (other formats may or may not work, so best to stick with something like '#000')
                    opacity: 0-1
                },
                threshold: 0-1 for the percentage value at which to hide labels (if they're too small)
            },
            combine: {
                threshold: 0-1 for the percentage value at which to combine slices (if they're too small)
                color: any hexidecimal color value (other formats may or may not work, so best to stick with something like '#CCC'), if null, the plugin will automatically use the color of the first slice to be combined
                label: any text value of what the combined slice should be labeled
            }
            highlight: {
                opacity: 0-1
            }
        }
    }

More detail and specific examples can be found in the included HTML file.

*/

(function($) {
    // Maximum redraw attempts when fitting labels within the plot

    var REDRAW_ATTEMPTS = 10;

    // Factor by which to shrink the pie when fitting labels within the plot

    var REDRAW_SHRINK = 0.95;

    function init(plot) {
        var canvas = null,
            target = null,
            options = null,
            maxRadius = null,
            centerLeft = null,
            centerTop = null,
            processed = false,
            ctx = null;

        // interactive variables

        var highlights = [];

        // add hook to determine if pie plugin in enabled, and then perform necessary operations

        plot.hooks.processOptions.push(function(plot, options) {
            if (options.series.pie.show) {
                options.grid.show = false;

                // set labels.show

                if (options.series.pie.label.show === "auto") {
                    if (options.legend.show) {
                        options.series.pie.label.show = false;
                    } else {
                        options.series.pie.label.show = true;
                    }
                }

                // set radius

                if (options.series.pie.radius === "auto") {
                    if (options.series.pie.label.show) {
                        options.series.pie.radius = 3 / 4;
                    } else {
                        options.series.pie.radius = 1;
                    }
                }

                // ensure sane tilt

                if (options.series.pie.tilt > 1) {
                    options.series.pie.tilt = 1;
                } else if (options.series.pie.tilt < 0) {
                    options.series.pie.tilt = 0;
                }
            }
        });

        plot.hooks.bindEvents.push(function(plot, eventHolder) {
            var options = plot.getOptions();
            if (options.series.pie.show) {
                if (options.grid.hoverable) {
                    eventHolder.unbind("mousemove").mousemove(onMouseMove);
                    eventHolder.bind("mouseleave", onMouseMove);
                }
                if (options.grid.clickable) {
                    eventHolder.unbind("click").click(onClick);
                }
            }
        });

        plot.hooks.shutdown.push(function (plot, eventHolder) {
            eventHolder.unbind("mousemove", onMouseMove);
            eventHolder.unbind("mouseleave", onMouseMove);
            eventHolder.unbind("click", onClick);
            highlights = [];
        });

        plot.hooks.processDatapoints.push(function(plot, series, data, datapoints) {
            var options = plot.getOptions();
            if (options.series.pie.show) {
                processDatapoints(plot, series, data, datapoints);
            }
        });

        plot.hooks.drawOverlay.push(function(plot, octx) {
            var options = plot.getOptions();
            if (options.series.pie.show) {
                drawOverlay(plot, octx);
            }
        });

        plot.hooks.draw.push(function(plot, newCtx) {
            var options = plot.getOptions();
            if (options.series.pie.show) {
                draw(plot, newCtx);
            }
        });

        function processDatapoints(plot, series, datapoints) {
            if (!processed) {
                processed = true;
                canvas = plot.getCanvas();
                target = $(canvas).parent();
                options = plot.getOptions();
                plot.setData(combine(plot.getData()));
            }
        }

        function combine(data) {
            var total = 0,
                combined = 0,
                numCombined = 0,
                color = options.series.pie.combine.color,
                newdata = [],
                i,
                value;

            // Fix up the raw data from Flot, ensuring the data is numeric

            for (i = 0; i < data.length; ++i) {
                value = data[i].data;

                // If the data is an array, we'll assume that it's a standard
                // Flot x-y pair, and are concerned only with the second value.

                // Note how we use the original array, rather than creating a
                // new one; this is more efficient and preserves any extra data
                // that the user may have stored in higher indexes.

                if ($.isArray(value) && value.length === 1) {
                    value = value[0];
                }

                if ($.isArray(value)) {
                    // Equivalent to $.isNumeric() but compatible with jQuery < 1.7
                    if (!isNaN(parseFloat(value[1])) && isFinite(value[1])) {
                        value[1] = +value[1];
                    } else {
                        value[1] = 0;
                    }
                } else if (!isNaN(parseFloat(value)) && isFinite(value)) {
                    value = [1, +value];
                } else {
                    value = [1, 0];
                }

                data[i].data = [value];
            }

            // Sum up all the slices, so we can calculate percentages for each

            for (i = 0; i < data.length; ++i) {
                total += data[i].data[0][1];
            }

            // Count the number of slices with percentages below the combine
            // threshold; if it turns out to be just one, we won't combine.

            for (i = 0; i < data.length; ++i) {
                value = data[i].data[0][1];
                if (value / total <= options.series.pie.combine.threshold) {
                    combined += value;
                    numCombined++;
                    if (!color) {
                        color = data[i].color;
                    }
                }
            }

            for (i = 0; i < data.length; ++i) {
                value = data[i].data[0][1];
                if (numCombined < 2 || value / total > options.series.pie.combine.threshold) {
                    newdata.push(
                        $.extend(data[i], {     /* extend to allow keeping all other original data values
                                                   and using them e.g. in labelFormatter. */
                            data: [[1, value]],
                            color: data[i].color,
                            label: data[i].label,
                            angle: value * Math.PI * 2 / total,
                            percent: value / (total / 100)
                        })
                    );
                }
            }

            if (numCombined > 1) {
                newdata.push({
                    data: [[1, combined]],
                    color: color,
                    label: options.series.pie.combine.label,
                    angle: combined * Math.PI * 2 / total,
                    percent: combined / (total / 100)
                });
            }

            return newdata;
        }

        function draw(plot, newCtx) {
            if (!target) {
                return; // if no series were passed
            }

            var canvasWidth = plot.getPlaceholder().width(),
                canvasHeight = plot.getPlaceholder().height(),
                legendWidth = target.children().filter(".legend").children().width() || 0;

            ctx = newCtx;

            // WARNING: HACK! REWRITE THIS CODE AS SOON AS POSSIBLE!

            // When combining smaller slices into an 'other' slice, we need to
            // add a new series.  Since Flot gives plugins no way to modify the
            // list of series, the pie plugin uses a hack where the first call
            // to processDatapoints results in a call to setData with the new
            // list of series, then subsequent processDatapoints do nothing.

            // The plugin-global 'processed' flag is used to control this hack;
            // it starts out false, and is set to true after the first call to
            // processDatapoints.

            // Unfortunately this turns future setData calls into no-ops; they
            // call processDatapoints, the flag is true, and nothing happens.

            // To fix this we'll set the flag back to false here in draw, when
            // all series have been processed, so the next sequence of calls to
            // processDatapoints once again starts out with a slice-combine.
            // This is really a hack; in 0.9 we need to give plugins a proper
            // way to modify series before any processing begins.

            processed = false;

            // calculate maximum radius and center point
            maxRadius = Math.min(canvasWidth, canvasHeight / options.series.pie.tilt) / 2;
            centerTop = canvasHeight / 2 + options.series.pie.offset.top;
            centerLeft = canvasWidth / 2;

            if (options.series.pie.offset.left === "auto") {
                if (options.legend.position.match("w")) {
                    centerLeft += legendWidth / 2;
                } else {
                    centerLeft -= legendWidth / 2;
                }
                if (centerLeft < maxRadius) {
                    centerLeft = maxRadius;
                } else if (centerLeft > canvasWidth - maxRadius) {
                    centerLeft = canvasWidth - maxRadius;
                }
            } else {
                centerLeft += options.series.pie.offset.left;
            }

            var slices = plot.getData(),
                attempts = 0;

            // Keep shrinking the pie's radius until drawPie returns true,
            // indicating that all the labels fit, or we try too many times.
            do {
                if (attempts > 0) {
                    maxRadius *= REDRAW_SHRINK;
                }
                attempts += 1;
                clear();
                if (options.series.pie.tilt <= 0.8) {
                    drawShadow();
                }
            } while (!drawPie() && attempts < REDRAW_ATTEMPTS)

            if (attempts >= REDRAW_ATTEMPTS) {
                clear();
                target.prepend("<div class='error'>Could not draw pie with labels contained inside canvas</div>");
            }

            if (plot.setSeries && plot.insertLegend) {
                plot.setSeries(slices);
                plot.insertLegend();
            }

            // we're actually done at this point, just defining internal functions at this point
            function clear() {
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                target.children().filter(".pieLabel, .pieLabelBackground").remove();
            }

            function drawShadow() {
                var shadowLeft = options.series.pie.shadow.left;
                var shadowTop = options.series.pie.shadow.top;
                var edge = 10;
                var alpha = options.series.pie.shadow.alpha;
                var radius = options.series.pie.radius > 1 ? options.series.pie.radius : maxRadius * options.series.pie.radius;

                if (radius >= canvasWidth / 2 - shadowLeft || radius * options.series.pie.tilt >= canvasHeight / 2 - shadowTop || radius <= edge) {
                    return;    // shadow would be outside canvas, so don't draw it
                }

                ctx.save();
                ctx.translate(shadowLeft, shadowTop);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = "#000";

                // center and rotate to starting position
                ctx.translate(centerLeft, centerTop);
                ctx.scale(1, options.series.pie.tilt);

                //radius -= edge;
                for (var i = 1; i <= edge; i++) {
                    ctx.beginPath();
                    ctx.arc(0, 0, radius, 0, Math.PI * 2, false);
                    ctx.fill();
                    radius -= i;
                }

                ctx.restore();
            }

            function drawPie() {
                var startAngle = Math.PI * options.series.pie.startAngle;
                var radius = options.series.pie.radius > 1 ? options.series.pie.radius : maxRadius * options.series.pie.radius;
                var i;
                // center and rotate to starting position

                ctx.save();
                ctx.translate(centerLeft, centerTop);
                ctx.scale(1, options.series.pie.tilt);
                //ctx.rotate(startAngle); // start at top; -- This doesn't work properly in Opera

                // draw slices
                ctx.save();

                var currentAngle = startAngle;
                for (i = 0; i < slices.length; ++i) {
                    slices[i].startAngle = currentAngle;
                    drawSlice(slices[i].angle, slices[i].color, true);
                }

                ctx.restore();

                // draw slice outlines
                if (options.series.pie.stroke.width > 0) {
                    ctx.save();
                    ctx.lineWidth = options.series.pie.stroke.width;
                    currentAngle = startAngle;
                    for (i = 0; i < slices.length; ++i) {
                        drawSlice(slices[i].angle, options.series.pie.stroke.color, false);
                    }

                    ctx.restore();
                }

                // draw donut hole
                drawDonutHole(ctx);

                ctx.restore();

                // Draw the labels, returning true if they fit within the plot
                if (options.series.pie.label.show) {
                    return drawLabels();
                } else return true;

                function drawSlice(angle, color, fill) {
                    if (angle <= 0 || isNaN(angle)) {
                        return;
                    }

                    if (fill) {
                        ctx.fillStyle = color;
                    } else {
                        ctx.strokeStyle = color;
                        ctx.lineJoin = "round";
                    }

                    ctx.beginPath();
                    if (Math.abs(angle - Math.PI * 2) > 0.000000001) {
                        ctx.moveTo(0, 0); // Center of the pie
                    }

                    //ctx.arc(0, 0, radius, 0, angle, false); // This doesn't work properly in Opera
                    ctx.arc(0, 0, radius, currentAngle, currentAngle + angle / 2, false);
                    ctx.arc(0, 0, radius, currentAngle + angle / 2, currentAngle + angle, false);
                    ctx.closePath();
                    //ctx.rotate(angle); // This doesn't work properly in Opera
                    currentAngle += angle;

                    if (fill) {
                        ctx.fill();
                    } else {
                        ctx.stroke();
                    }
                }

                function drawLabels() {
                    var currentAngle = startAngle;
                    var radius = options.series.pie.label.radius > 1 ? options.series.pie.label.radius : maxRadius * options.series.pie.label.radius;

                    for (var i = 0; i < slices.length; ++i) {
                        if (slices[i].percent >= options.series.pie.label.threshold * 100) {
                            if (!drawLabel(slices[i], currentAngle, i)) {
                                return false;
                            }
                        }
                        currentAngle += slices[i].angle;
                    }

                    return true;

                    function drawLabel(slice, startAngle, index) {
                        if (slice.data[0][1] === 0) {
                            return true;
                        }

                        // format label text
                        var lf = options.legend.labelFormatter, text, plf = options.series.pie.label.formatter;

                        if (lf) {
                            text = lf(slice.label, slice);
                        } else {
                            text = slice.label;
                        }

                        if (plf) {
                            text = plf(text, slice);
                        }

                        var halfAngle = ((startAngle + slice.angle) + startAngle) / 2;
                        var x = centerLeft + Math.round(Math.cos(halfAngle) * radius);
                        var y = centerTop + Math.round(Math.sin(halfAngle) * radius) * options.series.pie.tilt;

                        var html = "<span class='pieLabel' id='pieLabel" + index + "' style='position:absolute;top:" + y + "px;left:" + x + "px;'>" + text + "</span>";
                        target.append(html);

                        var label = target.children("#pieLabel" + index);
                        var labelTop = (y - label.height() / 2);
                        var labelLeft = (x - label.width() / 2);

                        label.css("top", labelTop);
                        label.css("left", labelLeft);

                        // check to make sure that the label is not outside the canvas
                        if (0 - labelTop > 0 || 0 - labelLeft > 0 || canvasHeight - (labelTop + label.height()) < 0 || canvasWidth - (labelLeft + label.width()) < 0) {
                            return false;
                        }

                        if (options.series.pie.label.background.opacity !== 0) {
                            // put in the transparent background separately to avoid blended labels and label boxes
                            var c = options.series.pie.label.background.color;
                            if (c == null) {
                                c = slice.color;
                            }

                            var pos = "top:" + labelTop + "px;left:" + labelLeft + "px;";
                            $("<div class='pieLabelBackground' style='position:absolute;width:" + label.width() + "px;height:" + label.height() + "px;" + pos + "background-color:" + c + ";'></div>")
                                .css("opacity", options.series.pie.label.background.opacity)
                                .insertBefore(label);
                        }

                        return true;
                    } // end individual label function
                } // end drawLabels function
            } // end drawPie function
        } // end draw function

        // Placed here because it needs to be accessed from multiple locations

        function drawDonutHole(layer) {
            if (options.series.pie.innerRadius > 0) {
                // subtract the center
                layer.save();
                var innerRadius = options.series.pie.innerRadius > 1 ? options.series.pie.innerRadius : maxRadius * options.series.pie.innerRadius;
                layer.globalCompositeOperation = "destination-out"; // this does not work with excanvas, but it will fall back to using the stroke color
                layer.beginPath();
                layer.fillStyle = options.series.pie.stroke.color;
                layer.arc(0, 0, innerRadius, 0, Math.PI * 2, false);
                layer.fill();
                layer.closePath();
                layer.restore();

                // add inner stroke
                layer.save();
                layer.beginPath();
                layer.strokeStyle = options.series.pie.stroke.color;
                layer.arc(0, 0, innerRadius, 0, Math.PI * 2, false);
                layer.stroke();
                layer.closePath();
                layer.restore();

                // TODO: add extra shadow inside hole (with a mask) if the pie is tilted.
            }
        }

        //-- Additional Interactive related functions --

        function isPointInPoly(poly, pt) {
            for (var c = false, i = -1, l = poly.length, j = l - 1; ++i < l; j = i) {
                ((poly[i][1] <= pt[1] && pt[1] < poly[j][1]) ||
                (poly[j][1] <= pt[1] && pt[1] < poly[i][1])) &&
                (pt[0] < (poly[j][0] - poly[i][0]) * (pt[1] - poly[i][1]) / (poly[j][1] - poly[i][1]) + poly[i][0]) &&
                (c = !c);
            }
            return c;
        }

        function findNearbySlice(mouseX, mouseY) {
            var slices = plot.getData(),
                options = plot.getOptions(),
                radius = options.series.pie.radius > 1 ? options.series.pie.radius : maxRadius * options.series.pie.radius,
                x, y;

            for (var i = 0; i < slices.length; ++i) {
                var s = slices[i];
                if (s.pie.show) {
                    ctx.save();
                    ctx.beginPath();
                    ctx.moveTo(0, 0); // Center of the pie
                    //ctx.scale(1, options.series.pie.tilt);    // this actually seems to break everything when here.
                    ctx.arc(0, 0, radius, s.startAngle, s.startAngle + s.angle / 2, false);
                    ctx.arc(0, 0, radius, s.startAngle + s.angle / 2, s.startAngle + s.angle, false);
                    ctx.closePath();
                    x = mouseX - centerLeft;
                    y = mouseY - centerTop;

                    if (ctx.isPointInPath) {
                        if (ctx.isPointInPath(mouseX - centerLeft, mouseY - centerTop)) {
                            ctx.restore();
                            return {
                                datapoint: [s.percent, s.data],
                                dataIndex: 0,
                                series: s,
                                seriesIndex: i
                            };
                        }
                    } else {
                        // excanvas for IE doesn;t support isPointInPath, this is a workaround.
                        var p1X = radius * Math.cos(s.startAngle),
                            p1Y = radius * Math.sin(s.startAngle),
                            p2X = radius * Math.cos(s.startAngle + s.angle / 4),
                            p2Y = radius * Math.sin(s.startAngle + s.angle / 4),
                            p3X = radius * Math.cos(s.startAngle + s.angle / 2),
                            p3Y = radius * Math.sin(s.startAngle + s.angle / 2),
                            p4X = radius * Math.cos(s.startAngle + s.angle / 1.5),
                            p4Y = radius * Math.sin(s.startAngle + s.angle / 1.5),
                            p5X = radius * Math.cos(s.startAngle + s.angle),
                            p5Y = radius * Math.sin(s.startAngle + s.angle),
                            arrPoly = [[0, 0], [p1X, p1Y], [p2X, p2Y], [p3X, p3Y], [p4X, p4Y], [p5X, p5Y]],
                            arrPoint = [x, y];

                        // TODO: perhaps do some mathmatical trickery here with the Y-coordinate to compensate for pie tilt?

                        if (isPointInPoly(arrPoly, arrPoint)) {
                            ctx.restore();
                            return {
                                datapoint: [s.percent, s.data],
                                dataIndex: 0,
                                series: s,
                                seriesIndex: i
                            };
                        }
                    }

                    ctx.restore();
                }
            }

            return null;
        }

        function onMouseMove(e) {
            triggerClickHoverEvent("plothover", e);
        }

        function onClick(e) {
            triggerClickHoverEvent("plotclick", e);
        }

        // trigger click or hover event (they send the same parameters so we share their code)

        function triggerClickHoverEvent(eventname, e) {
            var offset = plot.offset();
            var canvasX = parseInt(e.pageX - offset.left);
            var canvasY = parseInt(e.pageY - offset.top);
            var item = findNearbySlice(canvasX, canvasY);

            if (options.grid.autoHighlight) {
                // clear auto-highlights
                for (var i = 0; i < highlights.length; ++i) {
                    var h = highlights[i];
                    if (h.auto === eventname && !(item && h.series === item.series)) {
                        unhighlight(h.series);
                    }
                }
            }

            // highlight the slice

            if (item) {
                highlight(item.series, eventname);
            }

            // trigger any hover bind events

            var pos = { pageX: e.pageX, pageY: e.pageY };
            target.trigger(eventname, [pos, item]);
        }

        function highlight(s, auto) {
            //if (typeof s == "number") {
            //    s = series[s];
            //}

            var i = indexOfHighlight(s);

            if (i === -1) {
                highlights.push({ series: s, auto: auto });
                plot.triggerRedrawOverlay();
            } else if (!auto) {
                highlights[i].auto = false;
            }
        }

        function unhighlight(s) {
            if (s == null) {
                highlights = [];
                plot.triggerRedrawOverlay();
            }

            //if (typeof s == "number") {
            //    s = series[s];
            //}

            var i = indexOfHighlight(s);

            if (i !== -1) {
                highlights.splice(i, 1);
                plot.triggerRedrawOverlay();
            }
        }

        function indexOfHighlight(s) {
            for (var i = 0; i < highlights.length; ++i) {
                var h = highlights[i];
                if (h.series === s) {
                    return i;
                }
            }
            return -1;
        }

        function drawOverlay(plot, octx) {
            var options = plot.getOptions();
            var radius = options.series.pie.radius > 1 ? options.series.pie.radius : maxRadius * options.series.pie.radius;

            octx.save();
            octx.translate(centerLeft, centerTop);
            octx.scale(1, options.series.pie.tilt);

            for (var i = 0; i < highlights.length; ++i) {
                drawHighlight(highlights[i].series);
            }

            drawDonutHole(octx);

            octx.restore();

            function drawHighlight(series) {
                if (series.angle <= 0 || isNaN(series.angle)) {
                    return;
                }

                //octx.fillStyle = parseColor(options.series.pie.highlight.color).scale(null, null, null, options.series.pie.highlight.opacity).toString();
                octx.fillStyle = "rgba(255, 255, 255, " + options.series.pie.highlight.opacity + ")"; // this is temporary until we have access to parseColor
                octx.beginPath();
                if (Math.abs(series.angle - Math.PI * 2) > 0.000000001) {
                    octx.moveTo(0, 0); // Center of the pie
                }
                octx.arc(0, 0, radius, series.startAngle, series.startAngle + series.angle / 2, false);
                octx.arc(0, 0, radius, series.startAngle + series.angle / 2, series.startAngle + series.angle, false);
                octx.closePath();
                octx.fill();
            }
        }
    } // end init (plugin body)

    // define pie specific options and their default values
    var options = {
        series: {
            pie: {
                show: false,
                radius: "auto",    // actual radius of the visible pie (based on full calculated radius if <=1, or hard pixel value)
                innerRadius: 0, /* for donut */
                startAngle: 3 / 2,
                tilt: 1,
                shadow: {
                    left: 5,    // shadow left offset
                    top: 15,    // shadow top offset
                    alpha: 0.02    // shadow alpha
                },
                offset: {
                    top: 0,
                    left: "auto"
                },
                stroke: {
                    color: "#fff",
                    width: 1
                },
                label: {
                    show: "auto",
                    formatter: function(label, slice) {
                        return "<div style='font-size:x-small;text-align:center;padding:2px;color:" + slice.color + ";'>" + label + "<br/>" + Math.round(slice.percent) + "%</div>";
                    },    // formatter function
                    radius: 1,    // radius at which to place the labels (based on full calculated radius if <=1, or hard pixel value)
                    background: {
                        color: null,
                        opacity: 0
                    },
                    threshold: 0    // percentage at which to hide the label (i.e. the slice is too narrow)
                },
                combine: {
                    threshold: -1,    // percentage at which to combine little slices into one larger slice
                    color: null,    // color to give the new slice (auto-generated if null)
                    label: "Other"    // label to give the new slice
                },
                highlight: {
                    //color: "#fff",        // will add this functionality once parseColor is available
                    opacity: 0.5
                }
            }
        }
    };

    $.plot.plugins.push({
        init: init,
        options: options,
        name: "pie",
        version: "1.1"
    });
})(jQuery);


/***/ }),

/***/ "./node_modules/flot/source/jquery.flot.resize.js":
/*!********************************************************!*\
  !*** ./node_modules/flot/source/jquery.flot.resize.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* eslint-disable */
/* Flot plugin for automatically redrawing plots as the placeholder resizes.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Licensed under the MIT license.

It works by listening for changes on the placeholder div (through the jQuery
resize event plugin) - if the size changes, it will redraw the plot.

There are no options. If you need to disable the plugin for some plots, you
can just fix the size of their placeholders.

*/

/* Inline dependency:
 * jQuery resize event - v1.1 - 3/14/2010
 * http://benalman.com/projects/jquery-resize-plugin/
 *
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */
(function($,e,t){"$:nomunge";var i=[],n=$.resize=$.extend($.resize,{}),a,r=false,s="setTimeout",u="resize",m=u+"-special-event",o="pendingDelay",l="activeDelay",f="throttleWindow";n[o]=200;n[l]=20;n[f]=true;$.event.special[u]={setup:function(){if(!n[f]&&this[s]){return false}var e=$(this);i.push(this);e.data(m,{w:e.width(),h:e.height()});if(i.length===1){a=t;h()}},teardown:function(){if(!n[f]&&this[s]){return false}var e=$(this);for(var t=i.length-1;t>=0;t--){if(i[t]==this){i.splice(t,1);break}}e.removeData(m);if(!i.length){if(r){cancelAnimationFrame(a)}else{clearTimeout(a)}a=null}},add:function(e){if(!n[f]&&this[s]){return false}var i;function a(e,n,a){var r=$(this),s=r.data(m)||{};s.w=n!==t?n:r.width();s.h=a!==t?a:r.height();i.apply(this,arguments)}if($.isFunction(e)){i=e;return a}else{i=e.handler;e.handler=a}}};function h(t){if(r===true){r=t||1}for(var s=i.length-1;s>=0;s--){var l=$(i[s]);if(l[0]==e||l.is(":visible")){var f=l.width(),c=l.height(),d=l.data(m);if(d&&(f!==d.w||c!==d.h)){l.trigger(u,[d.w=f,d.h=c]);r=t||true}}else{d=l.data(m);d.w=0;d.h=0}}if(a!==null){if(r&&(t==null||t-r<1e3)){a=e.requestAnimationFrame(h)}else{a=setTimeout(h,n[o]);r=false}}}if(!e.requestAnimationFrame){e.requestAnimationFrame=function(){return e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(t,i){return e.setTimeout(function(){t((new Date).getTime())},n[l])}}()}if(!e.cancelAnimationFrame){e.cancelAnimationFrame=function(){return e.webkitCancelRequestAnimationFrame||e.mozCancelRequestAnimationFrame||e.oCancelRequestAnimationFrame||e.msCancelRequestAnimationFrame||clearTimeout}()}})(jQuery,window);

/* eslint-enable */
(function ($) {
    var options = { }; // no options

    function init(plot) {
        function onResize() {
            var placeholder = plot.getPlaceholder();

            // somebody might have hidden us and we can't plot
            // when we don't have the dimensions
            if (placeholder.width() === 0 || placeholder.height() === 0) return;

            plot.resize();
            plot.setupGrid();
            plot.draw();
        }

        function bindEvents(plot, eventHolder) {
            plot.getPlaceholder().resize(onResize);
        }

        function shutdown(plot, eventHolder) {
            plot.getPlaceholder().unbind("resize", onResize);
        }

        plot.hooks.bindEvents.push(bindEvents);
        plot.hooks.shutdown.push(shutdown);
    }

    $.plot.plugins.push({
        init: init,
        options: options,
        name: 'resize',
        version: '1.0'
    });
})(jQuery);


/***/ }),

/***/ "./node_modules/flot/source/jquery.flot.saturated.js":
/*!***********************************************************!*\
  !*** ./node_modules/flot/source/jquery.flot.saturated.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

(function ($) {
    'use strict';
    var saturated = {
        saturate: function (a) {
            if (a === Infinity) {
                return Number.MAX_VALUE;
            }

            if (a === -Infinity) {
                return -Number.MAX_VALUE;
            }

            return a;
        },
        delta: function(min, max, noTicks) {
            return ((max - min) / noTicks) === Infinity ? (max / noTicks - min / noTicks) : (max - min) / noTicks
        },
        multiply: function (a, b) {
            return saturated.saturate(a * b);
        },
        // returns c * bInt * a. Beahves properly in the case where c is negative
        // and bInt * a is bigger that Number.MAX_VALUE (Infinity)
        multiplyAdd: function (a, bInt, c) {
            if (isFinite(a * bInt)) {
                return saturated.saturate(a * bInt + c);
            } else {
                var result = c;

                for (var i = 0; i < bInt; i++) {
                    result += a;
                }

                return saturated.saturate(result);
            }
        },
        // round to nearby lower multiple of base
        floorInBase: function(n, base) {
            return base * Math.floor(n / base);
        }
    };

    $.plot.saturated = saturated;
})(jQuery);


/***/ }),

/***/ "./node_modules/flot/source/jquery.flot.selection.js":
/*!***********************************************************!*\
  !*** ./node_modules/flot/source/jquery.flot.selection.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* Flot plugin for selecting regions of a plot.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Licensed under the MIT license.

The plugin supports these options:

selection: {
    mode: null or "x" or "y" or "xy" or "smart",
    color: color,
    shape: "round" or "miter" or "bevel",
    visualization: "fill" or "focus",
    displaySelectionDecorations: true or false,
    minSize: number of pixels
}

Selection support is enabled by setting the mode to one of "x", "y" or "xy".
In "x" mode, the user will only be able to specify the x range, similarly for
"y" mode. For "xy", the selection becomes a rectangle where both ranges can be
specified. "color" is color of the selection (if you need to change the color
later on, you can get to it with plot.getOptions().selection.color). "shape"
is the shape of the corners of the selection.

The way how the selection is visualized, can be changed by using the option
"visualization". Flot currently supports two modes: "focus" and "fill". The
option "focus" draws a colored bezel around the selected area while keeping
the selected area clear. The option "fill" highlights (i.e., fills) the
selected area with a colored highlight.

There are optional selection decorations (handles) that are rendered with the
"focus" visualization option. The selection decoration is rendered by default
but can be turned off by setting displaySelectionDecorations to false.

"minSize" is the minimum size a selection can be in pixels. This value can
be customized to determine the smallest size a selection can be and still
have the selection rectangle be displayed. When customizing this value, the
fact that it refers to pixels, not axis units must be taken into account.
Thus, for example, if there is a bar graph in time mode with BarWidth set to 1
minute, setting "minSize" to 1 will not make the minimum selection size 1
minute, but rather 1 pixel. Note also that setting "minSize" to 0 will prevent
"plotunselected" events from being fired when the user clicks the mouse without
dragging.

When selection support is enabled, a "plotselected" event will be emitted on
the DOM element you passed into the plot function. The event handler gets a
parameter with the ranges selected on the axes, like this:

    placeholder.bind( "plotselected", function( event, ranges ) {
        alert("You selected " + ranges.xaxis.from + " to " + ranges.xaxis.to)
        // similar for yaxis - with multiple axes, the extra ones are in
        // x2axis, x3axis, ...
    });

The "plotselected" event is only fired when the user has finished making the
selection. A "plotselecting" event is fired during the process with the same
parameters as the "plotselected" event, in case you want to know what's
happening while it's happening,

A "plotunselected" event with no arguments is emitted when the user clicks the
mouse to remove the selection. As stated above, setting "minSize" to 0 will
destroy this behavior.

The plugin allso adds the following methods to the plot object:

- setSelection( ranges, preventEvent )

  Set the selection rectangle. The passed in ranges is on the same form as
  returned in the "plotselected" event. If the selection mode is "x", you
  should put in either an xaxis range, if the mode is "y" you need to put in
  an yaxis range and both xaxis and yaxis if the selection mode is "xy", like
  this:

    setSelection({ xaxis: { from: 0, to: 10 }, yaxis: { from: 40, to: 60 } });

  setSelection will trigger the "plotselected" event when called. If you don't
  want that to happen, e.g. if you're inside a "plotselected" handler, pass
  true as the second parameter. If you are using multiple axes, you can
  specify the ranges on any of those, e.g. as x2axis/x3axis/... instead of
  xaxis, the plugin picks the first one it sees.

- clearSelection( preventEvent )

  Clear the selection rectangle. Pass in true to avoid getting a
  "plotunselected" event.

- getSelection()

  Returns the current selection in the same format as the "plotselected"
  event. If there's currently no selection, the function returns null.

*/

(function ($) {
    function init(plot) {
        var selection = {
            first: {x: -1, y: -1},
            second: {x: -1, y: -1},
            show: false,
            currentMode: 'xy',
            active: false
        };

        var SNAPPING_CONSTANT = $.plot.uiConstants.SNAPPING_CONSTANT;

        // FIXME: The drag handling implemented here should be
        // abstracted out, there's some similar code from a library in
        // the navigation plugin, this should be massaged a bit to fit
        // the Flot cases here better and reused. Doing this would
        // make this plugin much slimmer.
        var savedhandlers = {};

        function onDrag(e) {
            if (selection.active) {
                updateSelection(e);

                plot.getPlaceholder().trigger("plotselecting", [ getSelection() ]);
            }
        }

        function onDragStart(e) {
            var o = plot.getOptions();
            // only accept left-click
            if (e.which !== 1 || o.selection.mode === null) return;

            // reinitialize currentMode
            selection.currentMode = 'xy';

            // cancel out any text selections
            document.body.focus();

            // prevent text selection and drag in old-school browsers
            if (document.onselectstart !== undefined && savedhandlers.onselectstart == null) {
                savedhandlers.onselectstart = document.onselectstart;
                document.onselectstart = function () { return false; };
            }
            if (document.ondrag !== undefined && savedhandlers.ondrag == null) {
                savedhandlers.ondrag = document.ondrag;
                document.ondrag = function () { return false; };
            }

            setSelectionPos(selection.first, e);

            selection.active = true;
        }

        function onDragEnd(e) {
            // revert drag stuff for old-school browsers
            if (document.onselectstart !== undefined) {
                document.onselectstart = savedhandlers.onselectstart;
            }

            if (document.ondrag !== undefined) {
                document.ondrag = savedhandlers.ondrag;
            }

            // no more dragging
            selection.active = false;
            updateSelection(e);

            if (selectionIsSane()) {
                triggerSelectedEvent();
            } else {
                // this counts as a clear
                plot.getPlaceholder().trigger("plotunselected", [ ]);
                plot.getPlaceholder().trigger("plotselecting", [ null ]);
            }

            return false;
        }

        function getSelection() {
            if (!selectionIsSane()) return null;

            if (!selection.show) return null;

            var r = {},
                c1 = {x: selection.first.x, y: selection.first.y},
                c2 = {x: selection.second.x, y: selection.second.y};

            if (selectionDirection(plot) === 'x') {
                c1.y = 0;
                c2.y = plot.height();
            }

            if (selectionDirection(plot) === 'y') {
                c1.x = 0;
                c2.x = plot.width();
            }

            $.each(plot.getAxes(), function (name, axis) {
                if (axis.used) {
                    var p1 = axis.c2p(c1[axis.direction]), p2 = axis.c2p(c2[axis.direction]);
                    r[name] = { from: Math.min(p1, p2), to: Math.max(p1, p2) };
                }
            });
            return r;
        }

        function triggerSelectedEvent() {
            var r = getSelection();

            plot.getPlaceholder().trigger("plotselected", [ r ]);

            // backwards-compat stuff, to be removed in future
            if (r.xaxis && r.yaxis) {
                plot.getPlaceholder().trigger("selected", [ { x1: r.xaxis.from, y1: r.yaxis.from, x2: r.xaxis.to, y2: r.yaxis.to } ]);
            }
        }

        function clamp(min, value, max) {
            return value < min ? min : (value > max ? max : value);
        }

        function selectionDirection(plot) {
            var o = plot.getOptions();

            if (o.selection.mode === 'smart') {
                return selection.currentMode;
            } else {
                return o.selection.mode;
            }
        }

        function updateMode(pos) {
            if (selection.first) {
                var delta = {
                    x: pos.x - selection.first.x,
                    y: pos.y - selection.first.y
                };

                if (Math.abs(delta.x) < SNAPPING_CONSTANT) {
                    selection.currentMode = 'y';
                } else if (Math.abs(delta.y) < SNAPPING_CONSTANT) {
                    selection.currentMode = 'x';
                } else {
                    selection.currentMode = 'xy';
                }
            }
        }

        function setSelectionPos(pos, e) {
            var offset = plot.getPlaceholder().offset();
            var plotOffset = plot.getPlotOffset();
            pos.x = clamp(0, e.pageX - offset.left - plotOffset.left, plot.width());
            pos.y = clamp(0, e.pageY - offset.top - plotOffset.top, plot.height());

            if (pos !== selection.first) updateMode(pos);

            if (selectionDirection(plot) === "y") {
                pos.x = pos === selection.first ? 0 : plot.width();
            }

            if (selectionDirection(plot) === "x") {
                pos.y = pos === selection.first ? 0 : plot.height();
            }
        }

        function updateSelection(pos) {
            if (pos.pageX == null) return;

            setSelectionPos(selection.second, pos);
            if (selectionIsSane()) {
                selection.show = true;
                plot.triggerRedrawOverlay();
            } else clearSelection(true);
        }

        function clearSelection(preventEvent) {
            if (selection.show) {
                selection.show = false;
                selection.currentMode = '';
                plot.triggerRedrawOverlay();
                if (!preventEvent) {
                    plot.getPlaceholder().trigger("plotunselected", [ ]);
                }
            }
        }

        // function taken from markings support in Flot
        function extractRange(ranges, coord) {
            var axis, from, to, key, axes = plot.getAxes();

            for (var k in axes) {
                axis = axes[k];
                if (axis.direction === coord) {
                    key = coord + axis.n + "axis";
                    if (!ranges[key] && axis.n === 1) {
                        // support x1axis as xaxis
                        key = coord + "axis";
                    }

                    if (ranges[key]) {
                        from = ranges[key].from;
                        to = ranges[key].to;
                        break;
                    }
                }
            }

            // backwards-compat stuff - to be removed in future
            if (!ranges[key]) {
                axis = coord === "x" ? plot.getXAxes()[0] : plot.getYAxes()[0];
                from = ranges[coord + "1"];
                to = ranges[coord + "2"];
            }

            // auto-reverse as an added bonus
            if (from != null && to != null && from > to) {
                var tmp = from;
                from = to;
                to = tmp;
            }

            return { from: from, to: to, axis: axis };
        }

        function setSelection(ranges, preventEvent) {
            var range;

            if (selectionDirection(plot) === "y") {
                selection.first.x = 0;
                selection.second.x = plot.width();
            } else {
                range = extractRange(ranges, "x");
                selection.first.x = range.axis.p2c(range.from);
                selection.second.x = range.axis.p2c(range.to);
            }

            if (selectionDirection(plot) === "x") {
                selection.first.y = 0;
                selection.second.y = plot.height();
            } else {
                range = extractRange(ranges, "y");
                selection.first.y = range.axis.p2c(range.from);
                selection.second.y = range.axis.p2c(range.to);
            }

            selection.show = true;
            plot.triggerRedrawOverlay();
            if (!preventEvent && selectionIsSane()) {
                triggerSelectedEvent();
            }
        }

        function selectionIsSane() {
            var minSize = plot.getOptions().selection.minSize;
            return Math.abs(selection.second.x - selection.first.x) >= minSize &&
                Math.abs(selection.second.y - selection.first.y) >= minSize;
        }

        plot.clearSelection = clearSelection;
        plot.setSelection = setSelection;
        plot.getSelection = getSelection;

        plot.hooks.bindEvents.push(function(plot, eventHolder) {
            var o = plot.getOptions();
            if (o.selection.mode != null) {
                plot.addEventHandler("dragstart", onDragStart, eventHolder, 0);
                plot.addEventHandler("drag", onDrag, eventHolder, 0);
                plot.addEventHandler("dragend", onDragEnd, eventHolder, 0);
            }
        });

        function drawSelectionDecorations(ctx, x, y, w, h, oX, oY, mode) {
            var spacing = 3;
            var fullEarWidth = 15;
            var earWidth = Math.max(0, Math.min(fullEarWidth, w / 2 - 2, h / 2 - 2));
            ctx.fillStyle = '#ffffff';

            if (mode === 'xy') {
                ctx.beginPath();
                ctx.moveTo(x, y + earWidth);
                ctx.lineTo(x - 3, y + earWidth);
                ctx.lineTo(x - 3, y - 3);
                ctx.lineTo(x + earWidth, y - 3);
                ctx.lineTo(x + earWidth, y);
                ctx.lineTo(x, y);
                ctx.closePath();

                ctx.moveTo(x, y + h - earWidth);
                ctx.lineTo(x - 3, y + h - earWidth);
                ctx.lineTo(x - 3, y + h + 3);
                ctx.lineTo(x + earWidth, y + h + 3);
                ctx.lineTo(x + earWidth, y + h);
                ctx.lineTo(x, y + h);
                ctx.closePath();

                ctx.moveTo(x + w, y + earWidth);
                ctx.lineTo(x + w + 3, y + earWidth);
                ctx.lineTo(x + w + 3, y - 3);
                ctx.lineTo(x + w - earWidth, y - 3);
                ctx.lineTo(x + w - earWidth, y);
                ctx.lineTo(x + w, y);
                ctx.closePath();

                ctx.moveTo(x + w, y + h - earWidth);
                ctx.lineTo(x + w + 3, y + h - earWidth);
                ctx.lineTo(x + w + 3, y + h + 3);
                ctx.lineTo(x + w - earWidth, y + h + 3);
                ctx.lineTo(x + w - earWidth, y + h);
                ctx.lineTo(x + w, y + h);
                ctx.closePath();

                ctx.stroke();
                ctx.fill();
            }

            x = oX;
            y = oY;

            if (mode === 'x') {
                ctx.beginPath();
                ctx.moveTo(x, y + fullEarWidth);
                ctx.lineTo(x, y - fullEarWidth);
                ctx.lineTo(x - spacing, y - fullEarWidth);
                ctx.lineTo(x - spacing, y + fullEarWidth);
                ctx.closePath();

                ctx.moveTo(x + w, y + fullEarWidth);
                ctx.lineTo(x + w, y - fullEarWidth);
                ctx.lineTo(x + w + spacing, y - fullEarWidth);
                ctx.lineTo(x + w + spacing, y + fullEarWidth);
                ctx.closePath();
                ctx.stroke();
                ctx.fill();
            }

            if (mode === 'y') {
                ctx.beginPath();

                ctx.moveTo(x - fullEarWidth, y);
                ctx.lineTo(x + fullEarWidth, y);
                ctx.lineTo(x + fullEarWidth, y - spacing);
                ctx.lineTo(x - fullEarWidth, y - spacing);
                ctx.closePath();

                ctx.moveTo(x - fullEarWidth, y + h);
                ctx.lineTo(x + fullEarWidth, y + h);
                ctx.lineTo(x + fullEarWidth, y + h + spacing);
                ctx.lineTo(x - fullEarWidth, y + h + spacing);
                ctx.closePath();
                ctx.stroke();
                ctx.fill();
            }
        }

        plot.hooks.drawOverlay.push(function (plot, ctx) {
            // draw selection
            if (selection.show && selectionIsSane()) {
                var plotOffset = plot.getPlotOffset();
                var o = plot.getOptions();

                ctx.save();
                ctx.translate(plotOffset.left, plotOffset.top);

                var c = $.color.parse(o.selection.color);
                var visualization = o.selection.visualization;
                var displaySelectionDecorations = o.selection.displaySelectionDecorations;

                var scalingFactor = 1;

                // use a dimmer scaling factor if visualization is "fill"
                if (visualization === "fill") {
                    scalingFactor = 0.8;
                }

                ctx.strokeStyle = c.scale('a', scalingFactor).toString();
                ctx.lineWidth = 1;
                ctx.lineJoin = o.selection.shape;
                ctx.fillStyle = c.scale('a', 0.4).toString();

                var x = Math.min(selection.first.x, selection.second.x) + 0.5,
                    oX = x,
                    y = Math.min(selection.first.y, selection.second.y) + 0.5,
                    oY = y,
                    w = Math.abs(selection.second.x - selection.first.x) - 1,
                    h = Math.abs(selection.second.y - selection.first.y) - 1;

                if (selectionDirection(plot) === 'x') {
                    h += y;
                    y = 0;
                }

                if (selectionDirection(plot) === 'y') {
                    w += x;
                    x = 0;
                }

                if (visualization === "fill") {
                    ctx.fillRect(x, y, w, h);
                    ctx.strokeRect(x, y, w, h);
                } else {
                    ctx.fillRect(0, 0, plot.width(), plot.height());
                    ctx.clearRect(x, y, w, h);

                    if (displaySelectionDecorations) {
                        drawSelectionDecorations(ctx, x, y, w, h, oX, oY, selectionDirection(plot));
                    }
                }

                ctx.restore();
            }
        });

        plot.hooks.shutdown.push(function (plot, eventHolder) {
            eventHolder.unbind("dragstart", onDragStart);
            eventHolder.unbind("drag", onDrag);
            eventHolder.unbind("dragend", onDragEnd);
        });
    }

    $.plot.plugins.push({
        init: init,
        options: {
            selection: {
                mode: null, // one of null, "x", "y" or "xy"
                visualization: "focus", // "focus" or "fill"
                displaySelectionDecorations: true, // true or false (currently only relevant for the focus visualization)
                color: "#888888",
                shape: "round", // one of "round", "miter", or "bevel"
                minSize: 5 // minimum number of pixels
            }
        },
        name: 'selection',
        version: '1.1'
    });
})(jQuery);


/***/ }),

/***/ "./node_modules/flot/source/jquery.flot.stack.js":
/*!*******************************************************!*\
  !*** ./node_modules/flot/source/jquery.flot.stack.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* Flot plugin for stacking data sets rather than overlaying them.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Licensed under the MIT license.

The plugin assumes the data is sorted on x (or y if stacking horizontally).
For line charts, it is assumed that if a line has an undefined gap (from a
null point), then the line above it should have the same gap - insert zeros
instead of "null" if you want another behaviour. This also holds for the start
and end of the chart. Note that stacking a mix of positive and negative values
in most instances doesn't make sense (so it looks weird).

Two or more series are stacked when their "stack" attribute is set to the same
key (which can be any number or string or just "true"). To specify the default
stack, you can set the stack option like this:

    series: {
        stack: null/false, true, or a key (number/string)
    }

You can also specify it for a single series, like this:

    $.plot( $("#placeholder"), [{
        data: [ ... ],
        stack: true
    }])

The stacking order is determined by the order of the data series in the array
(later series end up on top of the previous).

Internally, the plugin modifies the datapoints in each series, adding an
offset to the y value. For line series, extra data points are inserted through
interpolation. If there's a second y value, it's also adjusted (e.g for bar
charts or filled areas).

*/

(function ($) {
    var options = {
        series: { stack: null } // or number/string
    };

    function init(plot) {
        function findMatchingSeries(s, allseries) {
            var res = null;
            for (var i = 0; i < allseries.length; ++i) {
                if (s === allseries[i]) break;

                if (allseries[i].stack === s.stack) {
                    res = allseries[i];
                }
            }

            return res;
        }

        function addBottomPoints (s, datapoints) {
            var formattedPoints = [];
            for (var i = 0; i < datapoints.points.length; i += 2) {
                formattedPoints.push(datapoints.points[i]);
                formattedPoints.push(datapoints.points[i + 1]);
                formattedPoints.push(0);
            }

            datapoints.format.push({
                x: false,
                y: true,
                number: true,
                required: false,
                computeRange: s.yaxis.options.autoScale !== 'none',
                defaultValue: 0
            });
            datapoints.points = formattedPoints;
            datapoints.pointsize = 3;
        }

        function stackData(plot, s, datapoints) {
            if (s.stack == null || s.stack === false) return;

            var needsBottom = s.bars.show || (s.lines.show && s.lines.fill);
            var hasBottom = datapoints.pointsize > 2 && (s.bars.horizontal ? datapoints.format[2].x : datapoints.format[2].y);
            // Series data is missing bottom points - need to format
            if (needsBottom && !hasBottom) {
                addBottomPoints(s, datapoints);
            }

            var other = findMatchingSeries(s, plot.getData());
            if (!other) return;

            var ps = datapoints.pointsize,
                points = datapoints.points,
                otherps = other.datapoints.pointsize,
                otherpoints = other.datapoints.points,
                newpoints = [],
                px, py, intery, qx, qy, bottom,
                withlines = s.lines.show,
                horizontal = s.bars.horizontal,
                withsteps = withlines && s.lines.steps,
                fromgap = true,
                keyOffset = horizontal ? 1 : 0,
                accumulateOffset = horizontal ? 0 : 1,
                i = 0, j = 0, l, m;

            while (true) {
                if (i >= points.length) break;

                l = newpoints.length;

                if (points[i] == null) {
                    // copy gaps
                    for (m = 0; m < ps; ++m) {
                        newpoints.push(points[i + m]);
                    }

                    i += ps;
                } else if (j >= otherpoints.length) {
                    // for lines, we can't use the rest of the points
                    if (!withlines) {
                        for (m = 0; m < ps; ++m) {
                            newpoints.push(points[i + m]);
                        }
                    }

                    i += ps;
                } else if (otherpoints[j] == null) {
                    // oops, got a gap
                    for (m = 0; m < ps; ++m) {
                        newpoints.push(null);
                    }

                    fromgap = true;
                    j += otherps;
                } else {
                    // cases where we actually got two points
                    px = points[i + keyOffset];
                    py = points[i + accumulateOffset];
                    qx = otherpoints[j + keyOffset];
                    qy = otherpoints[j + accumulateOffset];
                    bottom = 0;

                    if (px === qx) {
                        for (m = 0; m < ps; ++m) {
                            newpoints.push(points[i + m]);
                        }

                        newpoints[l + accumulateOffset] += qy;
                        bottom = qy;

                        i += ps;
                        j += otherps;
                    } else if (px > qx) {
                        // we got past point below, might need to
                        // insert interpolated extra point
                        if (withlines && i > 0 && points[i - ps] != null) {
                            intery = py + (points[i - ps + accumulateOffset] - py) * (qx - px) / (points[i - ps + keyOffset] - px);
                            newpoints.push(qx);
                            newpoints.push(intery + qy);
                            for (m = 2; m < ps; ++m) {
                                newpoints.push(points[i + m]);
                            }

                            bottom = qy;
                        }

                        j += otherps;
                    } else { // px < qx
                        if (fromgap && withlines) {
                            // if we come from a gap, we just skip this point
                            i += ps;
                            continue;
                        }

                        for (m = 0; m < ps; ++m) {
                            newpoints.push(points[i + m]);
                        }

                        // we might be able to interpolate a point below,
                        // this can give us a better y
                        if (withlines && j > 0 && otherpoints[j - otherps] != null) {
                            bottom = qy + (otherpoints[j - otherps + accumulateOffset] - qy) * (px - qx) / (otherpoints[j - otherps + keyOffset] - qx);
                        }

                        newpoints[l + accumulateOffset] += bottom;

                        i += ps;
                    }

                    fromgap = false;

                    if (l !== newpoints.length && needsBottom) {
                        newpoints[l + 2] += bottom;
                    }
                }

                // maintain the line steps invariant
                if (withsteps && l !== newpoints.length && l > 0 &&
                    newpoints[l] !== null &&
                    newpoints[l] !== newpoints[l - ps] &&
                    newpoints[l + 1] !== newpoints[l - ps + 1]) {
                    for (m = 0; m < ps; ++m) {
                        newpoints[l + ps + m] = newpoints[l + m];
                    }

                    newpoints[l + 1] = newpoints[l - ps + 1];
                }
            }

            datapoints.points = newpoints;
        }

        plot.hooks.processDatapoints.push(stackData);
    }

    $.plot.plugins.push({
        init: init,
        options: options,
        name: 'stack',
        version: '1.2'
    });
})(jQuery);


/***/ }),

/***/ "./node_modules/flot/source/jquery.flot.symbol.js":
/*!********************************************************!*\
  !*** ./node_modules/flot/source/jquery.flot.symbol.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* Flot plugin that adds some extra symbols for plotting points.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Licensed under the MIT license.

The symbols are accessed as strings through the standard symbol options:

    series: {
        points: {
            symbol: "square" // or "diamond", "triangle", "cross", "plus", "ellipse", "rectangle"
        }
    }

*/

(function ($) {
    // we normalize the area of each symbol so it is approximately the
    // same as a circle of the given radius

    var square = function (ctx, x, y, radius, shadow) {
            // pi * r^2 = (2s)^2  =>  s = r * sqrt(pi)/2
            var size = radius * Math.sqrt(Math.PI) / 2;
            ctx.rect(x - size, y - size, size + size, size + size);
        },
        rectangle = function (ctx, x, y, radius, shadow) {
            // pi * r^2 = (2s)^2  =>  s = r * sqrt(pi)/2
            var size = radius * Math.sqrt(Math.PI) / 2;
            ctx.rect(x - size, y - size, size + size, size + size);
        },
        diamond = function (ctx, x, y, radius, shadow) {
            // pi * r^2 = 2s^2  =>  s = r * sqrt(pi/2)
            var size = radius * Math.sqrt(Math.PI / 2);
            ctx.moveTo(x - size, y);
            ctx.lineTo(x, y - size);
            ctx.lineTo(x + size, y);
            ctx.lineTo(x, y + size);
            ctx.lineTo(x - size, y);
            ctx.lineTo(x, y - size);
        },
        triangle = function (ctx, x, y, radius, shadow) {
            // pi * r^2 = 1/2 * s^2 * sin (pi / 3)  =>  s = r * sqrt(2 * pi / sin(pi / 3))
            var size = radius * Math.sqrt(2 * Math.PI / Math.sin(Math.PI / 3));
            var height = size * Math.sin(Math.PI / 3);
            ctx.moveTo(x - size / 2, y + height / 2);
            ctx.lineTo(x + size / 2, y + height / 2);
            if (!shadow) {
                ctx.lineTo(x, y - height / 2);
                ctx.lineTo(x - size / 2, y + height / 2);
                ctx.lineTo(x + size / 2, y + height / 2);
            }
        },
        cross = function (ctx, x, y, radius, shadow) {
            // pi * r^2 = (2s)^2  =>  s = r * sqrt(pi)/2
            var size = radius * Math.sqrt(Math.PI) / 2;
            ctx.moveTo(x - size, y - size);
            ctx.lineTo(x + size, y + size);
            ctx.moveTo(x - size, y + size);
            ctx.lineTo(x + size, y - size);
        },
        ellipse = function(ctx, x, y, radius, shadow, fill) {
            if (!shadow) {
                ctx.moveTo(x + radius, y);
                ctx.arc(x, y, radius, 0, Math.PI * 2, false);
            }
        },
        plus = function (ctx, x, y, radius, shadow) {
            var size = radius * Math.sqrt(Math.PI / 2);
            ctx.moveTo(x - size, y);
            ctx.lineTo(x + size, y);
            ctx.moveTo(x, y + size);
            ctx.lineTo(x, y - size);
        },
        handlers = {
            square: square,
            rectangle: rectangle,
            diamond: diamond,
            triangle: triangle,
            cross: cross,
            ellipse: ellipse,
            plus: plus
        };

    square.fill = true;
    rectangle.fill = true;
    diamond.fill = true;
    triangle.fill = true;
    ellipse.fill = true;

    function init(plot) {
        plot.drawSymbol = handlers;
    }

    $.plot.plugins.push({
        init: init,
        name: 'symbols',
        version: '1.0'
    });
})(jQuery);


/***/ }),

/***/ "./node_modules/flot/source/jquery.flot.threshold.js":
/*!***********************************************************!*\
  !*** ./node_modules/flot/source/jquery.flot.threshold.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* Flot plugin for thresholding data.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Licensed under the MIT license.

The plugin supports these options:

    series: {
        threshold: {
            below: number
            color: colorspec
        }
    }

It can also be applied to a single series, like this:

    $.plot( $("#placeholder"), [{
        data: [ ... ],
        threshold: { ... }
    }])

An array can be passed for multiple thresholding, like this:

    threshold: [{
        below: number1
        color: color1
    },{
        below: number2
        color: color2
    }]

These multiple threshold objects can be passed in any order since they are
sorted by the processing function.

The data points below "below" are drawn with the specified color. This makes
it easy to mark points below 0, e.g. for budget data.

Internally, the plugin works by splitting the data into two series, above and
below the threshold. The extra series below the threshold will have its label
cleared and the special "originSeries" attribute set to the original series.
You may need to check for this in hover events.

*/

(function ($) {
    var options = {
        series: { threshold: null } // or { below: number, color: color spec}
    };

    function init(plot) {
        function thresholdData(plot, s, datapoints, below, color) {
            var ps = datapoints.pointsize, i, x, y, p, prevp,
                thresholded = $.extend({}, s); // note: shallow copy

            thresholded.datapoints = { points: [], pointsize: ps, format: datapoints.format };
            thresholded.label = null;
            thresholded.color = color;
            thresholded.threshold = null;
            thresholded.originSeries = s;
            thresholded.data = [];

            var origpoints = datapoints.points,
                addCrossingPoints = s.lines.show;

            var threspoints = [];
            var newpoints = [];
            var m;

            for (i = 0; i < origpoints.length; i += ps) {
                x = origpoints[i];
                y = origpoints[i + 1];

                prevp = p;
                if (y < below) p = threspoints;
                else p = newpoints;

                if (addCrossingPoints && prevp !== p &&
                    x !== null && i > 0 &&
                    origpoints[i - ps] != null) {
                    var interx = x + (below - y) * (x - origpoints[i - ps]) / (y - origpoints[i - ps + 1]);
                    prevp.push(interx);
                    prevp.push(below);
                    for (m = 2; m < ps; ++m) {
                        prevp.push(origpoints[i + m]);
                    }

                    p.push(null); // start new segment
                    p.push(null);
                    for (m = 2; m < ps; ++m) {
                        p.push(origpoints[i + m]);
                    }

                    p.push(interx);
                    p.push(below);
                    for (m = 2; m < ps; ++m) {
                        p.push(origpoints[i + m]);
                    }
                }

                p.push(x);
                p.push(y);
                for (m = 2; m < ps; ++m) {
                    p.push(origpoints[i + m]);
                }
            }

            datapoints.points = newpoints;
            thresholded.datapoints.points = threspoints;

            if (thresholded.datapoints.points.length > 0) {
                var origIndex = $.inArray(s, plot.getData());
                // Insert newly-generated series right after original one (to prevent it from becoming top-most)
                plot.getData().splice(origIndex + 1, 0, thresholded);
            }

            // FIXME: there are probably some edge cases left in bars
        }

        function processThresholds(plot, s, datapoints) {
            if (!s.threshold) return;
            if (s.threshold instanceof Array) {
                s.threshold.sort(function(a, b) {
                    return a.below - b.below;
                });

                $(s.threshold).each(function(i, th) {
                    thresholdData(plot, s, datapoints, th.below, th.color);
                });
            } else {
                thresholdData(plot, s, datapoints, s.threshold.below, s.threshold.color);
            }
        }

        plot.hooks.processDatapoints.push(processThresholds);
    }

    $.plot.plugins.push({
        init: init,
        options: options,
        name: 'threshold',
        version: '1.2'
    });
})(jQuery);


/***/ }),

/***/ "./node_modules/flot/source/jquery.flot.time.js":
/*!******************************************************!*\
  !*** ./node_modules/flot/source/jquery.flot.time.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* Pretty handling of time axes.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Licensed under the MIT license.

Set axis.mode to "time" to enable. See the section "Time series data" in
API.txt for details.
*/

(function($) {
    'use strict';

    var options = {
        xaxis: {
            timezone: null, // "browser" for local to the client or timezone for timezone-js
            timeformat: null, // format string to use
            twelveHourClock: false, // 12 or 24 time in time mode
            monthNames: null, // list of names of months
            timeBase: 'seconds' // are the values in given in mircoseconds, milliseconds or seconds
        },
        yaxis: {
            timeBase: 'seconds'
        }
    };

    var floorInBase = $.plot.saturated.floorInBase;

    // Method to provide microsecond support to Date like classes.
    var CreateMicroSecondDate = function(DateType, microEpoch) {
        var newDate = new DateType(microEpoch);

        var oldSetTime = newDate.setTime.bind(newDate);
        newDate.update = function(microEpoch) {
            oldSetTime(microEpoch);

            // Round epoch to 3 decimal accuracy
            microEpoch = Math.round(microEpoch * 1000) / 1000;

            // Microseconds are stored as integers
            this.microseconds = 1000 * (microEpoch - Math.floor(microEpoch));
        };

        var oldGetTime = newDate.getTime.bind(newDate);
        newDate.getTime = function () {
            var microEpoch = oldGetTime() + this.microseconds / 1000;
            return microEpoch;
        };

        newDate.setTime = function (microEpoch) {
            this.update(microEpoch);
        };

        newDate.getMicroseconds = function() {
            return this.microseconds;
        };

        newDate.setMicroseconds = function(microseconds) {
            var epochWithoutMicroseconds = oldGetTime();
            var newEpoch = epochWithoutMicroseconds + microseconds / 1000;
            this.update(newEpoch);
        };

        newDate.setUTCMicroseconds = function(microseconds) { this.setMicroseconds(microseconds); }

        newDate.getUTCMicroseconds = function() { return this.getMicroseconds(); }

        newDate.microseconds = null;
        newDate.microEpoch = null;
        newDate.update(microEpoch);
        return newDate;
    }

    // Returns a string with the date d formatted according to fmt.
    // A subset of the Open Group's strftime format is supported.

    function formatDate(d, fmt, monthNames, dayNames) {
        if (typeof d.strftime === "function") {
            return d.strftime(fmt);
        }

        var leftPad = function(n, pad) {
            n = "" + n;
            pad = "" + (pad == null ? "0" : pad);
            return n.length === 1 ? pad + n : n;
        };

        var formatSubSeconds = function(milliseconds, microseconds, numberDecimalPlaces) {
            var totalMicroseconds = milliseconds * 1000 + microseconds;
            var formattedString;
            if (numberDecimalPlaces < 6 && numberDecimalPlaces > 0) {
                var magnitude = parseFloat('1e' + (numberDecimalPlaces - 6));
                totalMicroseconds = Math.round(Math.round(totalMicroseconds * magnitude) / magnitude);
                formattedString = ('00000' + totalMicroseconds).slice(-6, -(6 - numberDecimalPlaces));
            } else {
                totalMicroseconds = Math.round(totalMicroseconds)
                formattedString = ('00000' + totalMicroseconds).slice(-6);
            }
            return formattedString;
        };

        var r = [];
        var escape = false;
        var hours = d.getHours();
        var isAM = hours < 12;

        if (!monthNames) {
            monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        }

        if (!dayNames) {
            dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
        }

        var hours12;
        if (hours > 12) {
            hours12 = hours - 12;
        } else if (hours === 0) {
            hours12 = 12;
        } else {
            hours12 = hours;
        }

        var decimals = -1;
        for (var i = 0; i < fmt.length; ++i) {
            var c = fmt.charAt(i);

            if (!isNaN(Number(c)) && Number(c) > 0) {
                decimals = Number(c);
            } else if (escape) {
                switch (c) {
                    case 'a': c = "" + dayNames[d.getDay()]; break;
                    case 'b': c = "" + monthNames[d.getMonth()]; break;
                    case 'd': c = leftPad(d.getDate()); break;
                    case 'e': c = leftPad(d.getDate(), " "); break;
                    case 'h': // For back-compat with 0.7; remove in 1.0
                    case 'H': c = leftPad(hours); break;
                    case 'I': c = leftPad(hours12); break;
                    case 'l': c = leftPad(hours12, " "); break;
                    case 'm': c = leftPad(d.getMonth() + 1); break;
                    case 'M': c = leftPad(d.getMinutes()); break;
                    // quarters not in Open Group's strftime specification
                    case 'q':
                        c = "" + (Math.floor(d.getMonth() / 3) + 1); break;
                    case 'S': c = leftPad(d.getSeconds()); break;
                    case 's': c = "" + formatSubSeconds(d.getMilliseconds(), d.getMicroseconds(), decimals); break;
                    case 'y': c = leftPad(d.getFullYear() % 100); break;
                    case 'Y': c = "" + d.getFullYear(); break;
                    case 'p': c = (isAM) ? ("" + "am") : ("" + "pm"); break;
                    case 'P': c = (isAM) ? ("" + "AM") : ("" + "PM"); break;
                    case 'w': c = "" + d.getDay(); break;
                }
                r.push(c);
                escape = false;
            } else {
                if (c === "%") {
                    escape = true;
                } else {
                    r.push(c);
                }
            }
        }

        return r.join("");
    }

    // To have a consistent view of time-based data independent of which time
    // zone the client happens to be in we need a date-like object independent
    // of time zones.  This is done through a wrapper that only calls the UTC
    // versions of the accessor methods.

    function makeUtcWrapper(d) {
        function addProxyMethod(sourceObj, sourceMethod, targetObj, targetMethod) {
            sourceObj[sourceMethod] = function() {
                return targetObj[targetMethod].apply(targetObj, arguments);
            };
        }

        var utc = {
            date: d
        };

        // support strftime, if found
        if (d.strftime !== undefined) {
            addProxyMethod(utc, "strftime", d, "strftime");
        }

        addProxyMethod(utc, "getTime", d, "getTime");
        addProxyMethod(utc, "setTime", d, "setTime");

        var props = ["Date", "Day", "FullYear", "Hours", "Minutes", "Month", "Seconds", "Milliseconds", "Microseconds"];

        for (var p = 0; p < props.length; p++) {
            addProxyMethod(utc, "get" + props[p], d, "getUTC" + props[p]);
            addProxyMethod(utc, "set" + props[p], d, "setUTC" + props[p]);
        }

        return utc;
    }

    // select time zone strategy.  This returns a date-like object tied to the
    // desired timezone
    function dateGenerator(ts, opts) {
        var maxDateValue = 8640000000000000;

        if (opts && opts.timeBase === 'seconds') {
            ts *= 1000;
        } else if (opts.timeBase === 'microseconds') {
            ts /= 1000;
        }

        if (ts > maxDateValue) {
            ts = maxDateValue;
        } else if (ts < -maxDateValue) {
            ts = -maxDateValue;
        }

        if (opts.timezone === "browser") {
            return CreateMicroSecondDate(Date, ts);
        } else if (!opts.timezone || opts.timezone === "utc") {
            return makeUtcWrapper(CreateMicroSecondDate(Date, ts));
        } else if (typeof timezoneJS !== "undefined" && typeof timezoneJS.Date !== "undefined") {
            var d = CreateMicroSecondDate(timezoneJS.Date, ts);
            // timezone-js is fickle, so be sure to set the time zone before
            // setting the time.
            d.setTimezone(opts.timezone);
            d.setTime(ts);
            return d;
        } else {
            return makeUtcWrapper(CreateMicroSecondDate(Date, ts));
        }
    }

    // map of app. size of time units in seconds
    var timeUnitSizeSeconds = {
        "microsecond": 0.000001,
        "millisecond": 0.001,
        "second": 1,
        "minute": 60,
        "hour": 60 * 60,
        "day": 24 * 60 * 60,
        "month": 30 * 24 * 60 * 60,
        "quarter": 3 * 30 * 24 * 60 * 60,
        "year": 365.2425 * 24 * 60 * 60
    };

    // map of app. size of time units in milliseconds
    var timeUnitSizeMilliseconds = {
        "microsecond": 0.001,
        "millisecond": 1,
        "second": 1000,
        "minute": 60 * 1000,
        "hour": 60 * 60 * 1000,
        "day": 24 * 60 * 60 * 1000,
        "month": 30 * 24 * 60 * 60 * 1000,
        "quarter": 3 * 30 * 24 * 60 * 60 * 1000,
        "year": 365.2425 * 24 * 60 * 60 * 1000
    };

    // map of app. size of time units in microseconds
    var timeUnitSizeMicroseconds = {
        "microsecond": 1,
        "millisecond": 1000,
        "second": 1000000,
        "minute": 60 * 1000000,
        "hour": 60 * 60 * 1000000,
        "day": 24 * 60 * 60 * 1000000,
        "month": 30 * 24 * 60 * 60 * 1000000,
        "quarter": 3 * 30 * 24 * 60 * 60 * 1000000,
        "year": 365.2425 * 24 * 60 * 60 * 1000000
    };

    // the allowed tick sizes, after 1 year we use
    // an integer algorithm

    var baseSpec = [
        [1, "microsecond"], [2, "microsecond"], [5, "microsecond"], [10, "microsecond"],
        [25, "microsecond"], [50, "microsecond"], [100, "microsecond"], [250, "microsecond"], [500, "microsecond"],
        [1, "millisecond"], [2, "millisecond"], [5, "millisecond"], [10, "millisecond"],
        [25, "millisecond"], [50, "millisecond"], [100, "millisecond"], [250, "millisecond"], [500, "millisecond"],
        [1, "second"], [2, "second"], [5, "second"], [10, "second"],
        [30, "second"],
        [1, "minute"], [2, "minute"], [5, "minute"], [10, "minute"],
        [30, "minute"],
        [1, "hour"], [2, "hour"], [4, "hour"],
        [8, "hour"], [12, "hour"],
        [1, "day"], [2, "day"], [3, "day"],
        [0.25, "month"], [0.5, "month"], [1, "month"],
        [2, "month"]
    ];

    // we don't know which variant(s) we'll need yet, but generating both is
    // cheap

    var specMonths = baseSpec.concat([[3, "month"], [6, "month"],
        [1, "year"]]);
    var specQuarters = baseSpec.concat([[1, "quarter"], [2, "quarter"],
        [1, "year"]]);

    function dateTickGenerator(axis) {
        var opts = axis.options,
            ticks = [],
            d = dateGenerator(axis.min, opts),
            minSize = 0;

        // make quarter use a possibility if quarters are
        // mentioned in either of these options
        var spec = (opts.tickSize && opts.tickSize[1] ===
            "quarter") ||
            (opts.minTickSize && opts.minTickSize[1] ===
            "quarter") ? specQuarters : specMonths;

        var timeUnitSize;
        if (opts.timeBase === 'seconds') {
            timeUnitSize = timeUnitSizeSeconds;
        } else if (opts.timeBase === 'microseconds') {
            timeUnitSize = timeUnitSizeMicroseconds;
        } else {
            timeUnitSize = timeUnitSizeMilliseconds;
        }

        if (opts.minTickSize !== null && opts.minTickSize !== undefined) {
            if (typeof opts.tickSize === "number") {
                minSize = opts.tickSize;
            } else {
                minSize = opts.minTickSize[0] * timeUnitSize[opts.minTickSize[1]];
            }
        }

        for (var i = 0; i < spec.length - 1; ++i) {
            if (axis.delta < (spec[i][0] * timeUnitSize[spec[i][1]] +
                spec[i + 1][0] * timeUnitSize[spec[i + 1][1]]) / 2 &&
                spec[i][0] * timeUnitSize[spec[i][1]] >= minSize) {
                break;
            }
        }

        var size = spec[i][0];
        var unit = spec[i][1];
        // special-case the possibility of several years
        if (unit === "year") {
            // if given a minTickSize in years, just use it,
            // ensuring that it's an integer

            if (opts.minTickSize !== null && opts.minTickSize !== undefined && opts.minTickSize[1] === "year") {
                size = Math.floor(opts.minTickSize[0]);
            } else {
                var magn = parseFloat('1e' + Math.floor(Math.log(axis.delta / timeUnitSize.year) / Math.LN10));
                var norm = (axis.delta / timeUnitSize.year) / magn;

                if (norm < 1.5) {
                    size = 1;
                } else if (norm < 3) {
                    size = 2;
                } else if (norm < 7.5) {
                    size = 5;
                } else {
                    size = 10;
                }

                size *= magn;
            }

            // minimum size for years is 1

            if (size < 1) {
                size = 1;
            }
        }

        axis.tickSize = opts.tickSize || [size, unit];
        var tickSize = axis.tickSize[0];
        unit = axis.tickSize[1];

        var step = tickSize * timeUnitSize[unit];

        if (unit === "microsecond") {
            d.setMicroseconds(floorInBase(d.getMicroseconds(), tickSize));
        } else if (unit === "millisecond") {
            d.setMilliseconds(floorInBase(d.getMilliseconds(), tickSize));
        } else if (unit === "second") {
            d.setSeconds(floorInBase(d.getSeconds(), tickSize));
        } else if (unit === "minute") {
            d.setMinutes(floorInBase(d.getMinutes(), tickSize));
        } else if (unit === "hour") {
            d.setHours(floorInBase(d.getHours(), tickSize));
        } else if (unit === "month") {
            d.setMonth(floorInBase(d.getMonth(), tickSize));
        } else if (unit === "quarter") {
            d.setMonth(3 * floorInBase(d.getMonth() / 3,
                tickSize));
        } else if (unit === "year") {
            d.setFullYear(floorInBase(d.getFullYear(), tickSize));
        }

        // reset smaller components

        if (step >= timeUnitSize.millisecond) {
            if (step >= timeUnitSize.second) {
                d.setMicroseconds(0);
            } else {
                d.setMicroseconds(d.getMilliseconds() * 1000);
            }
        }
        if (step >= timeUnitSize.minute) {
            d.setSeconds(0);
        }
        if (step >= timeUnitSize.hour) {
            d.setMinutes(0);
        }
        if (step >= timeUnitSize.day) {
            d.setHours(0);
        }
        if (step >= timeUnitSize.day * 4) {
            d.setDate(1);
        }
        if (step >= timeUnitSize.month * 2) {
            d.setMonth(floorInBase(d.getMonth(), 3));
        }
        if (step >= timeUnitSize.quarter * 2) {
            d.setMonth(floorInBase(d.getMonth(), 6));
        }
        if (step >= timeUnitSize.year) {
            d.setMonth(0);
        }

        var carry = 0;
        var v = Number.NaN;
        var v1000;
        var prev;
        do {
            prev = v;
            v1000 = d.getTime();
            if (opts && opts.timeBase === 'seconds') {
                v = v1000 / 1000;
            } else if (opts && opts.timeBase === 'microseconds') {
                v = v1000 * 1000;
            } else {
                v = v1000;
            }

            ticks.push(v);

            if (unit === "month" || unit === "quarter") {
                if (tickSize < 1) {
                    // a bit complicated - we'll divide the
                    // month/quarter up but we need to take
                    // care of fractions so we don't end up in
                    // the middle of a day
                    d.setDate(1);
                    var start = d.getTime();
                    d.setMonth(d.getMonth() +
                        (unit === "quarter" ? 3 : 1));
                    var end = d.getTime();
                    d.setTime((v + carry * timeUnitSize.hour + (end - start) * tickSize));
                    carry = d.getHours();
                    d.setHours(0);
                } else {
                    d.setMonth(d.getMonth() +
                        tickSize * (unit === "quarter" ? 3 : 1));
                }
            } else if (unit === "year") {
                d.setFullYear(d.getFullYear() + tickSize);
            } else {
                if (opts.timeBase === 'seconds') {
                    d.setTime((v + step) * 1000);
                } else if (opts.timeBase === 'microseconds') {
                    d.setTime((v + step) / 1000);
                } else {
                    d.setTime(v + step);
                }
            }
        } while (v < axis.max && v !== prev);

        return ticks;
    };

    function init(plot) {
        plot.hooks.processOptions.push(function (plot) {
            $.each(plot.getAxes(), function(axisName, axis) {
                var opts = axis.options;
                if (opts.mode === "time") {
                    axis.tickGenerator = dateTickGenerator;

                    // if a tick formatter is already provided do not overwrite it
                    if ('tickFormatter' in opts && typeof opts.tickFormatter === 'function') return;

                    axis.tickFormatter = function (v, axis) {
                        var d = dateGenerator(v, axis.options);

                        // first check global format
                        if (opts.timeformat != null) {
                            return formatDate(d, opts.timeformat, opts.monthNames, opts.dayNames);
                        }

                        // possibly use quarters if quarters are mentioned in
                        // any of these places
                        var useQuarters = (axis.options.tickSize &&
                                axis.options.tickSize[1] === "quarter") ||
                            (axis.options.minTickSize &&
                                axis.options.minTickSize[1] === "quarter");

                        var timeUnitSize;
                        if (opts.timeBase === 'seconds') {
                            timeUnitSize = timeUnitSizeSeconds;
                        } else if (opts.timeBase === 'microseconds') {
                            timeUnitSize = timeUnitSizeMicroseconds;
                        } else {
                            timeUnitSize = timeUnitSizeMilliseconds;
                        }

                        var t = axis.tickSize[0] * timeUnitSize[axis.tickSize[1]];
                        var span = axis.max - axis.min;
                        var suffix = (opts.twelveHourClock) ? " %p" : "";
                        var hourCode = (opts.twelveHourClock) ? "%I" : "%H";
                        var factor;
                        var fmt;

                        if (opts.timeBase === 'seconds') {
                            factor = 1;
                        } else if (opts.timeBase === 'microseconds') {
                            factor = 1000000
                        } else {
                            factor = 1000;
                        }

                        if (t < timeUnitSize.second) {
                            var decimals = -Math.floor(Math.log10(t / factor))

                            // the two-and-halves require an additional decimal
                            if (String(t).indexOf('25') > -1) {
                                decimals++;
                            }

                            fmt = "%S.%" + decimals + "s";
                        } else
                        if (t < timeUnitSize.minute) {
                            fmt = hourCode + ":%M:%S" + suffix;
                        } else if (t < timeUnitSize.day) {
                            if (span < 2 * timeUnitSize.day) {
                                fmt = hourCode + ":%M" + suffix;
                            } else {
                                fmt = "%b %d " + hourCode + ":%M" + suffix;
                            }
                        } else if (t < timeUnitSize.month) {
                            fmt = "%b %d";
                        } else if ((useQuarters && t < timeUnitSize.quarter) ||
                            (!useQuarters && t < timeUnitSize.year)) {
                            if (span < timeUnitSize.year) {
                                fmt = "%b";
                            } else {
                                fmt = "%b %Y";
                            }
                        } else if (useQuarters && t < timeUnitSize.year) {
                            if (span < timeUnitSize.year) {
                                fmt = "Q%q";
                            } else {
                                fmt = "Q%q %Y";
                            }
                        } else {
                            fmt = "%Y";
                        }

                        var rt = formatDate(d, fmt, opts.monthNames, opts.dayNames);

                        return rt;
                    };
                }
            });
        });
    }

    $.plot.plugins.push({
        init: init,
        options: options,
        name: 'time',
        version: '1.0'
    });

    // Time-axis support used to be in Flot core, which exposed the
    // formatDate function on the plot object.  Various plugins depend
    // on the function, so we need to re-expose it here.

    $.plot.formatDate = formatDate;
    $.plot.dateGenerator = dateGenerator;
    $.plot.dateTickGenerator = dateTickGenerator;
    $.plot.makeUtcWrapper = makeUtcWrapper;
})(jQuery);


/***/ }),

/***/ "./node_modules/flot/source/jquery.flot.touch.js":
/*!*******************************************************!*\
  !*** ./node_modules/flot/source/jquery.flot.touch.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/* global jQuery */

(function($) {
    'use strict';

    var options = {
        propagateSupportedGesture: false
    };

    function init(plot) {
        plot.hooks.processOptions.push(initTouchNavigation);
    }

    function initTouchNavigation(plot, options) {
        var gestureState = {
                twoTouches: false,
                currentTapStart: { x: 0, y: 0 },
                currentTapEnd: { x: 0, y: 0 },
                prevTap: { x: 0, y: 0 },
                currentTap: { x: 0, y: 0 },
                interceptedLongTap: false,
                isUnsupportedGesture: false,
                prevTapTime: null,
                tapStartTime: null,
                longTapTriggerId: null
            },
            maxDistanceBetweenTaps = 20,
            maxIntervalBetweenTaps = 500,
            maxLongTapDistance = 20,
            minLongTapDuration = 1500,
            pressedTapDuration = 125,
            mainEventHolder;

        function interpretGestures(e) {
            var o = plot.getOptions();

            if (!o.pan.active && !o.zoom.active) {
                return;
            }

            updateOnMultipleTouches(e);
            mainEventHolder.dispatchEvent(new CustomEvent('touchevent', { detail: e }));

            if (isPinchEvent(e)) {
                executeAction(e, 'pinch');
            } else {
                executeAction(e, 'pan');
                if (!wasPinchEvent(e)) {
                    if (isDoubleTap(e)) {
                        executeAction(e, 'doubleTap');
                    }
                    executeAction(e, 'tap');
                    executeAction(e, 'longTap');
                }
            }
        }

        function executeAction(e, gesture) {
            switch (gesture) {
                case 'pan':
                    pan[e.type](e);
                    break;
                case 'pinch':
                    pinch[e.type](e);
                    break;
                case 'doubleTap':
                    doubleTap.onDoubleTap(e);
                    break;
                case 'longTap':
                    longTap[e.type](e);
                    break;
                case 'tap':
                    tap[e.type](e);
                    break;
            }
        }

        function bindEvents(plot, eventHolder) {
            mainEventHolder = eventHolder[0];
            eventHolder[0].addEventListener('touchstart', interpretGestures, false);
            eventHolder[0].addEventListener('touchmove', interpretGestures, false);
            eventHolder[0].addEventListener('touchend', interpretGestures, false);
        }

        function shutdown(plot, eventHolder) {
            eventHolder[0].removeEventListener('touchstart', interpretGestures);
            eventHolder[0].removeEventListener('touchmove', interpretGestures);
            eventHolder[0].removeEventListener('touchend', interpretGestures);
            if (gestureState.longTapTriggerId) {
                clearTimeout(gestureState.longTapTriggerId);
                gestureState.longTapTriggerId = null;
            }
        }

        var pan = {
            touchstart: function(e) {
                updatePrevForDoubleTap();
                updateCurrentForDoubleTap(e);
                updateStateForLongTapStart(e);

                mainEventHolder.dispatchEvent(new CustomEvent('panstart', { detail: e }));
            },

            touchmove: function(e) {
                preventEventBehaviors(e);

                updateCurrentForDoubleTap(e);
                updateStateForLongTapEnd(e);

                if (!gestureState.isUnsupportedGesture) {
                    mainEventHolder.dispatchEvent(new CustomEvent('pandrag', { detail: e }));
                }
            },

            touchend: function(e) {
                preventEventBehaviors(e);

                if (wasPinchEvent(e)) {
                    mainEventHolder.dispatchEvent(new CustomEvent('pinchend', { detail: e }));
                    mainEventHolder.dispatchEvent(new CustomEvent('panstart', { detail: e }));
                } else if (noTouchActive(e)) {
                    mainEventHolder.dispatchEvent(new CustomEvent('panend', { detail: e }));
                }
            }
        };

        var pinch = {
            touchstart: function(e) {
                mainEventHolder.dispatchEvent(new CustomEvent('pinchstart', { detail: e }));
            },

            touchmove: function(e) {
                preventEventBehaviors(e);
                gestureState.twoTouches = isPinchEvent(e);
                if (!gestureState.isUnsupportedGesture) {
                    mainEventHolder.dispatchEvent(new CustomEvent('pinchdrag', { detail: e }));
                }
            },

            touchend: function(e) {
                preventEventBehaviors(e);
            }
        };

        var doubleTap = {
            onDoubleTap: function(e) {
                preventEventBehaviors(e);
                mainEventHolder.dispatchEvent(new CustomEvent('doubletap', { detail: e }));
            }
        };

        var longTap = {
            touchstart: function(e) {
                longTap.waitForLongTap(e);
            },

            touchmove: function(e) {
            },

            touchend: function(e) {
                if (gestureState.longTapTriggerId) {
                    clearTimeout(gestureState.longTapTriggerId);
                    gestureState.longTapTriggerId = null;
                }
            },

            isLongTap: function(e) {
                var currentTime = new Date().getTime(),
                    tapDuration = currentTime - gestureState.tapStartTime;
                if (tapDuration >= minLongTapDuration && !gestureState.interceptedLongTap) {
                    if (distance(gestureState.currentTapStart.x, gestureState.currentTapStart.y, gestureState.currentTapEnd.x, gestureState.currentTapEnd.y) < maxLongTapDistance) {
                        gestureState.interceptedLongTap = true;
                        return true;
                    }
                }
                return false;
            },

            waitForLongTap: function(e) {
                var longTapTrigger = function() {
                    if (longTap.isLongTap(e)) {
                        mainEventHolder.dispatchEvent(new CustomEvent('longtap', { detail: e }));
                    }
                    gestureState.longTapTriggerId = null;
                };
                if (!gestureState.longTapTriggerId) {
                    gestureState.longTapTriggerId = setTimeout(longTapTrigger, minLongTapDuration);
                }
            }
        };

        var tap = {
            touchstart: function(e) {
                gestureState.tapStartTime = new Date().getTime();
            },

            touchmove: function(e) {
            },

            touchend: function(e) {
                if (tap.isTap(e)) {
                    mainEventHolder.dispatchEvent(new CustomEvent('tap', { detail: e }));
                    preventEventBehaviors(e);
                }
            },

            isTap: function(e) {
                var currentTime = new Date().getTime(),
                    tapDuration = currentTime - gestureState.tapStartTime;
                if (tapDuration <= pressedTapDuration) {
                    if (distance(gestureState.currentTapStart.x, gestureState.currentTapStart.y, gestureState.currentTapEnd.x, gestureState.currentTapEnd.y) < maxLongTapDistance) {
                        return true;
                    }
                }
                return false;
            }
        };

        if (options.pan.enableTouch === true || options.zoom.enableTouch) {
            plot.hooks.bindEvents.push(bindEvents);
            plot.hooks.shutdown.push(shutdown);
        };

        function updatePrevForDoubleTap() {
            gestureState.prevTap = {
                x: gestureState.currentTap.x,
                y: gestureState.currentTap.y
            };
        };

        function updateCurrentForDoubleTap(e) {
            gestureState.currentTap = {
                x: e.touches[0].pageX,
                y: e.touches[0].pageY
            };
        }

        function updateStateForLongTapStart(e) {
            gestureState.tapStartTime = new Date().getTime();
            gestureState.interceptedLongTap = false;
            gestureState.currentTapStart = {
                x: e.touches[0].pageX,
                y: e.touches[0].pageY
            };
            gestureState.currentTapEnd = {
                x: e.touches[0].pageX,
                y: e.touches[0].pageY
            };
        };

        function updateStateForLongTapEnd(e) {
            gestureState.currentTapEnd = {
                x: e.touches[0].pageX,
                y: e.touches[0].pageY
            };
        };

        function isDoubleTap(e) {
            var currentTime = new Date().getTime(),
                intervalBetweenTaps = currentTime - gestureState.prevTapTime;

            if (intervalBetweenTaps >= 0 && intervalBetweenTaps < maxIntervalBetweenTaps) {
                if (distance(gestureState.prevTap.x, gestureState.prevTap.y, gestureState.currentTap.x, gestureState.currentTap.y) < maxDistanceBetweenTaps) {
                    e.firstTouch = gestureState.prevTap;
                    e.secondTouch = gestureState.currentTap;
                    return true;
                }
            }
            gestureState.prevTapTime = currentTime;
            return false;
        }

        function preventEventBehaviors(e) {
            if (!gestureState.isUnsupportedGesture) {
                e.preventDefault();
                if (!plot.getOptions().propagateSupportedGesture) {
                    e.stopPropagation();
                }
            }
        }

        function distance(x1, y1, x2, y2) {
            return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
        }

        function noTouchActive(e) {
            return (e.touches && e.touches.length === 0);
        }

        function wasPinchEvent(e) {
            return (gestureState.twoTouches && e.touches.length === 1);
        }

        function updateOnMultipleTouches(e) {
            if (e.touches.length >= 3) {
                gestureState.isUnsupportedGesture = true;
            } else {
                gestureState.isUnsupportedGesture = false;
            }
        }

        function isPinchEvent(e) {
            if (e.touches && e.touches.length >= 2) {
                if (e.touches[0].target === plot.getEventHolder() &&
                    e.touches[1].target === plot.getEventHolder()) {
                    return true;
                }
            }
            return false;
        }
    }

    $.plot.plugins.push({
        init: init,
        options: options,
        name: 'navigateTouch',
        version: '0.3'
    });
})(jQuery);


/***/ }),

/***/ "./node_modules/flot/source/jquery.flot.touchNavigate.js":
/*!***************************************************************!*\
  !*** ./node_modules/flot/source/jquery.flot.touchNavigate.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* global jQuery */

(function($) {
    'use strict';

    var options = {
        zoom: {
            enableTouch: false
        },
        pan: {
            enableTouch: false,
            touchMode: 'manual'
        },
        recenter: {
            enableTouch: true
        }
    };

    var ZOOM_DISTANCE_MARGIN = $.plot.uiConstants.ZOOM_DISTANCE_MARGIN;

    function init(plot) {
        plot.hooks.processOptions.push(initTouchNavigation);
    }

    function initTouchNavigation(plot, options) {
        var gestureState = {
                zoomEnable: false,
                prevDistance: null,
                prevTapTime: 0,
                prevPanPosition: { x: 0, y: 0 },
                prevTapPosition: { x: 0, y: 0 }
            },
            navigationState = {
                prevTouchedAxis: 'none',
                currentTouchedAxis: 'none',
                touchedAxis: null,
                navigationConstraint: 'unconstrained',
                initialState: null
            },
            useManualPan = options.pan.interactive && options.pan.touchMode === 'manual',
            smartPanLock = options.pan.touchMode === 'smartLock',
            useSmartPan = options.pan.interactive && (smartPanLock || options.pan.touchMode === 'smart'),
            pan, pinch, doubleTap;

        function bindEvents(plot, eventHolder) {
            var o = plot.getOptions();

            if (o.zoom.interactive && o.zoom.enableTouch) {
                eventHolder[0].addEventListener('pinchstart', pinch.start, false);
                eventHolder[0].addEventListener('pinchdrag', pinch.drag, false);
                eventHolder[0].addEventListener('pinchend', pinch.end, false);
            }

            if (o.pan.interactive && o.pan.enableTouch) {
                eventHolder[0].addEventListener('panstart', pan.start, false);
                eventHolder[0].addEventListener('pandrag', pan.drag, false);
                eventHolder[0].addEventListener('panend', pan.end, false);
            }

            if ((o.recenter.interactive && o.recenter.enableTouch)) {
                eventHolder[0].addEventListener('doubletap', doubleTap.recenterPlot, false);
            }
        }

        function shutdown(plot, eventHolder) {
            eventHolder[0].removeEventListener('panstart', pan.start);
            eventHolder[0].removeEventListener('pandrag', pan.drag);
            eventHolder[0].removeEventListener('panend', pan.end);
            eventHolder[0].removeEventListener('pinchstart', pinch.start);
            eventHolder[0].removeEventListener('pinchdrag', pinch.drag);
            eventHolder[0].removeEventListener('pinchend', pinch.end);
            eventHolder[0].removeEventListener('doubletap', doubleTap.recenterPlot);
        }

        pan = {
            start: function(e) {
                presetNavigationState(e, 'pan', gestureState);
                updateData(e, 'pan', gestureState, navigationState);

                if (useSmartPan) {
                    var point = getPoint(e, 'pan');
                    navigationState.initialState = plot.navigationState(point.x, point.y);
                }
            },

            drag: function(e) {
                presetNavigationState(e, 'pan', gestureState);

                if (useSmartPan) {
                    var point = getPoint(e, 'pan');
                    plot.smartPan({
                        x: navigationState.initialState.startPageX - point.x,
                        y: navigationState.initialState.startPageY - point.y
                    }, navigationState.initialState, navigationState.touchedAxis, false, smartPanLock);
                } else if (useManualPan) {
                    plot.pan({
                        left: -delta(e, 'pan', gestureState).x,
                        top: -delta(e, 'pan', gestureState).y,
                        axes: navigationState.touchedAxis
                    });
                    updatePrevPanPosition(e, 'pan', gestureState, navigationState);
                }
            },

            end: function(e) {
                presetNavigationState(e, 'pan', gestureState);

                if (useSmartPan) {
                    plot.smartPan.end();
                }

                if (wasPinchEvent(e, gestureState)) {
                    updateprevPanPosition(e, 'pan', gestureState, navigationState);
                }
            }
        };

        var pinchDragTimeout;
        pinch = {
            start: function(e) {
                if (pinchDragTimeout) {
                    clearTimeout(pinchDragTimeout);
                    pinchDragTimeout = null;
                }
                presetNavigationState(e, 'pinch', gestureState);
                setPrevDistance(e, gestureState);
                updateData(e, 'pinch', gestureState, navigationState);
            },

            drag: function(e) {
                if (pinchDragTimeout) {
                    return;
                }
                pinchDragTimeout = setTimeout(function() {
                    presetNavigationState(e, 'pinch', gestureState);
                    plot.pan({
                        left: -delta(e, 'pinch', gestureState).x,
                        top: -delta(e, 'pinch', gestureState).y,
                        axes: navigationState.touchedAxis
                    });
                    updatePrevPanPosition(e, 'pinch', gestureState, navigationState);

                    var dist = pinchDistance(e);

                    if (gestureState.zoomEnable || Math.abs(dist - gestureState.prevDistance) > ZOOM_DISTANCE_MARGIN) {
                        zoomPlot(plot, e, gestureState, navigationState);

                        //activate zoom mode
                        gestureState.zoomEnable = true;
                    }
                    pinchDragTimeout = null;
                }, 1000 / 60);
            },

            end: function(e) {
                if (pinchDragTimeout) {
                    clearTimeout(pinchDragTimeout);
                    pinchDragTimeout = null;
                }
                presetNavigationState(e, 'pinch', gestureState);
                gestureState.prevDistance = null;
            }
        };

        doubleTap = {
            recenterPlot: function(e) {
                if (e && e.detail && e.detail.type === 'touchstart') {
                    // only do not recenter for touch start;
                    recenterPlotOnDoubleTap(plot, e, gestureState, navigationState);
                }
            }
        };

        if (options.pan.enableTouch === true || options.zoom.enableTouch === true) {
            plot.hooks.bindEvents.push(bindEvents);
            plot.hooks.shutdown.push(shutdown);
        }

        function presetNavigationState(e, gesture, gestureState) {
            navigationState.touchedAxis = getAxis(plot, e, gesture, navigationState);
            if (noAxisTouched(navigationState)) {
                navigationState.navigationConstraint = 'unconstrained';
            } else {
                navigationState.navigationConstraint = 'axisConstrained';
            }
        }
    }

    $.plot.plugins.push({
        init: init,
        options: options,
        name: 'navigateTouch',
        version: '0.3'
    });

    function recenterPlotOnDoubleTap(plot, e, gestureState, navigationState) {
        checkAxesForDoubleTap(plot, e, navigationState);
        if ((navigationState.currentTouchedAxis === 'x' && navigationState.prevTouchedAxis === 'x') ||
            (navigationState.currentTouchedAxis === 'y' && navigationState.prevTouchedAxis === 'y') ||
            (navigationState.currentTouchedAxis === 'none' && navigationState.prevTouchedAxis === 'none')) {
            var event;

            plot.recenter({ axes: navigationState.touchedAxis });

            if (navigationState.touchedAxis) {
                event = new $.Event('re-center', { detail: { axisTouched: navigationState.touchedAxis } });
            } else {
                event = new $.Event('re-center', { detail: e });
            }
            plot.getPlaceholder().trigger(event);
        }
    }

    function checkAxesForDoubleTap(plot, e, navigationState) {
        var axis = plot.getTouchedAxis(e.detail.firstTouch.x, e.detail.firstTouch.y);
        if (axis[0] !== undefined) {
            navigationState.prevTouchedAxis = axis[0].direction;
        }

        axis = plot.getTouchedAxis(e.detail.secondTouch.x, e.detail.secondTouch.y);
        if (axis[0] !== undefined) {
            navigationState.touchedAxis = axis;
            navigationState.currentTouchedAxis = axis[0].direction;
        }

        if (noAxisTouched(navigationState)) {
            navigationState.touchedAxis = null;
            navigationState.prevTouchedAxis = 'none';
            navigationState.currentTouchedAxis = 'none';
        }
    }

    function zoomPlot(plot, e, gestureState, navigationState) {
        var offset = plot.offset(),
            center = {
                left: 0,
                top: 0
            },
            zoomAmount = pinchDistance(e) / gestureState.prevDistance,
            dist = pinchDistance(e);

        center.left = getPoint(e, 'pinch').x - offset.left;
        center.top = getPoint(e, 'pinch').y - offset.top;

        // send the computed touched axis to the zoom function so that it only zooms on that one
        plot.zoom({
            center: center,
            amount: zoomAmount,
            axes: navigationState.touchedAxis
        });
        gestureState.prevDistance = dist;
    }

    function wasPinchEvent(e, gestureState) {
        return (gestureState.zoomEnable && e.detail.touches.length === 1);
    }

    function getAxis(plot, e, gesture, navigationState) {
        if (e.type === 'pinchstart') {
            var axisTouch1 = plot.getTouchedAxis(e.detail.touches[0].pageX, e.detail.touches[0].pageY);
            var axisTouch2 = plot.getTouchedAxis(e.detail.touches[1].pageX, e.detail.touches[1].pageY);

            if (axisTouch1.length === axisTouch2.length && axisTouch1.toString() === axisTouch2.toString()) {
                return axisTouch1;
            }
        } else if (e.type === 'panstart') {
            return plot.getTouchedAxis(e.detail.touches[0].pageX, e.detail.touches[0].pageY);
        } else if (e.type === 'pinchend') {
            //update axis since instead on pinch, a pan event is made
            return plot.getTouchedAxis(e.detail.touches[0].pageX, e.detail.touches[0].pageY);
        } else {
            return navigationState.touchedAxis;
        }
    }

    function noAxisTouched(navigationState) {
        return (!navigationState.touchedAxis || navigationState.touchedAxis.length === 0);
    }

    function setPrevDistance(e, gestureState) {
        gestureState.prevDistance = pinchDistance(e);
    }

    function updateData(e, gesture, gestureState, navigationState) {
        var axisDir,
            point = getPoint(e, gesture);

        switch (navigationState.navigationConstraint) {
            case 'unconstrained':
                navigationState.touchedAxis = null;
                gestureState.prevTapPosition = {
                    x: gestureState.prevPanPosition.x,
                    y: gestureState.prevPanPosition.y
                };
                gestureState.prevPanPosition = {
                    x: point.x,
                    y: point.y
                };
                break;
            case 'axisConstrained':
                axisDir = navigationState.touchedAxis[0].direction;
                navigationState.currentTouchedAxis = axisDir;
                gestureState.prevTapPosition[axisDir] = gestureState.prevPanPosition[axisDir];
                gestureState.prevPanPosition[axisDir] = point[axisDir];
                break;
            default:
                break;
        }
    }

    function distance(x1, y1, x2, y2) {
        return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
    }

    function pinchDistance(e) {
        var t1 = e.detail.touches[0],
            t2 = e.detail.touches[1];
        return distance(t1.pageX, t1.pageY, t2.pageX, t2.pageY);
    }

    function updatePrevPanPosition(e, gesture, gestureState, navigationState) {
        var point = getPoint(e, gesture);

        switch (navigationState.navigationConstraint) {
            case 'unconstrained':
                gestureState.prevPanPosition.x = point.x;
                gestureState.prevPanPosition.y = point.y;
                break;
            case 'axisConstrained':
                gestureState.prevPanPosition[navigationState.currentTouchedAxis] =
                point[navigationState.currentTouchedAxis];
                break;
            default:
                break;
        }
    }

    function delta(e, gesture, gestureState) {
        var point = getPoint(e, gesture);

        return {
            x: point.x - gestureState.prevPanPosition.x,
            y: point.y - gestureState.prevPanPosition.y
        }
    }

    function getPoint(e, gesture) {
        if (gesture === 'pinch') {
            return {
                x: (e.detail.touches[0].pageX + e.detail.touches[1].pageX) / 2,
                y: (e.detail.touches[0].pageY + e.detail.touches[1].pageY) / 2
            }
        } else {
            return {
                x: e.detail.touches[0].pageX,
                y: e.detail.touches[0].pageY
            }
        }
    }
})(jQuery);


/***/ }),

/***/ "./node_modules/flot/source/jquery.flot.uiConstants.js":
/*!*************************************************************!*\
  !*** ./node_modules/flot/source/jquery.flot.uiConstants.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

(function ($) {
    'use strict';
    $.plot.uiConstants = {
        SNAPPING_CONSTANT: 20,
        PANHINT_LENGTH_CONSTANT: 10,
        MINOR_TICKS_COUNT_CONSTANT: 4,
        TICK_LENGTH_CONSTANT: 10,
        ZOOM_DISTANCE_MARGIN: 25
    };
})(jQuery);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmxvdC1wbHVnaW5zL2Rpc3Qvc291cmNlL21pc2MvanF1ZXJ5LmZsb3QudG9vbHRpcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmxvdC9saWIvanF1ZXJ5Lm1vdXNld2hlZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Zsb3Qvc291cmNlL2pxdWVyeS5jYW52YXN3cmFwcGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mbG90L3NvdXJjZS9qcXVlcnkuY29sb3JoZWxwZXJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mbG90L3NvdXJjZS9qcXVlcnkuZmxvdC5heGlzbGFiZWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mbG90L3NvdXJjZS9qcXVlcnkuZmxvdC5icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mbG90L3NvdXJjZS9qcXVlcnkuZmxvdC5jYXRlZ29yaWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mbG90L3NvdXJjZS9qcXVlcnkuZmxvdC5jb21wb3NlSW1hZ2VzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mbG90L3NvdXJjZS9qcXVlcnkuZmxvdC5jcm9zc2hhaXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Zsb3Qvc291cmNlL2pxdWVyeS5mbG90LmRyYXdTZXJpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Zsb3Qvc291cmNlL2pxdWVyeS5mbG90LmVycm9yYmFycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmxvdC9zb3VyY2UvanF1ZXJ5LmZsb3QuZmlsbGJldHdlZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Zsb3Qvc291cmNlL2pxdWVyeS5mbG90LmZsYXRkYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mbG90L3NvdXJjZS9qcXVlcnkuZmxvdC5ob3Zlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmxvdC9zb3VyY2UvanF1ZXJ5LmZsb3QuaW1hZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Zsb3Qvc291cmNlL2pxdWVyeS5mbG90LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mbG90L3NvdXJjZS9qcXVlcnkuZmxvdC5sZWdlbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Zsb3Qvc291cmNlL2pxdWVyeS5mbG90LmxvZ2F4aXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Zsb3Qvc291cmNlL2pxdWVyeS5mbG90Lm5hdmlnYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mbG90L3NvdXJjZS9qcXVlcnkuZmxvdC5waWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Zsb3Qvc291cmNlL2pxdWVyeS5mbG90LnJlc2l6ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmxvdC9zb3VyY2UvanF1ZXJ5LmZsb3Quc2F0dXJhdGVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mbG90L3NvdXJjZS9qcXVlcnkuZmxvdC5zZWxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Zsb3Qvc291cmNlL2pxdWVyeS5mbG90LnN0YWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mbG90L3NvdXJjZS9qcXVlcnkuZmxvdC5zeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Zsb3Qvc291cmNlL2pxdWVyeS5mbG90LnRocmVzaG9sZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmxvdC9zb3VyY2UvanF1ZXJ5LmZsb3QudGltZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmxvdC9zb3VyY2UvanF1ZXJ5LmZsb3QudG91Y2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Zsb3Qvc291cmNlL2pxdWVyeS5mbG90LnRvdWNoTmF2aWdhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Zsb3Qvc291cmNlL2pxdWVyeS5mbG90LnVpQ29uc3RhbnRzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1REFBdUQ7O0FBRXZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLHVCQUF1QjtBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9HQUFvRyxLQUFLO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRCxvRUFBb0U7O0FBRXBFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsd0JBQXdCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLG1FQUFtRTtBQUN4RyxxQ0FBcUM7O0FBRXJDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLCtDQUErQztBQUNwRjtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtELHFCQUFxQjs7QUFFdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQSxtQ0FBbUMsSUFBSSxJQUFJLEdBQUc7QUFDOUM7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxrQ0FBa0M7QUFDbEMsNkJBQTZCLElBQUksSUFBSSxHQUFHO0FBQ3hDLDZCQUE2QixJQUFJLElBQUksR0FBRztBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsQ0FBQzs7Ozs7Ozs7Ozs7O0FDN2xCRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsNkJBQTZCLEdBQUc7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxHQUFHO0FBQ3hDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLHFDQUFxQyxHQUFHO0FBQ3hDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQyxpQ0FBaUM7QUFDakUsZ0NBQWdDLDRCQUE0Qjs7QUFFNUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDLG1DQUFtQztBQUNsRiwrQ0FBK0Msc0NBQXNDOztBQUVyRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7Ozs7Ozs7Ozs7O0FDckZEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1FQUFtRTtBQUNuRTtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseURBQXlELGNBQWM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDs7QUFFQSxrRUFBa0U7QUFDbEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUMsY0FBYztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7OztBQ3BpQkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsY0FBYztBQUN6QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsY0FBYztBQUN6QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixJQUFJLGVBQWUsSUFBSSxlQUFlLElBQUk7QUFDeEU7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLElBQUksZUFBZSxJQUFJLGVBQWUsSUFBSTtBQUN6RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLEVBQUUsY0FBYyxFQUFFLGNBQWMsRUFBRTtBQUMvRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7OztBQ3RNRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFF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QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQztBQUMzQyxhQUFhO0FBQ2I7QUFDQTs7QUFFQSwyQkFBMkIsb0JBQW9CO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixvQkFBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOzs7Ozs7Ozs7Ozs7QUN6VUQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVUsbUJBQW1CO0FBQzdCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRDQUE0QyxhQUFhLFlBQVksRUFBRTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7Ozs7Ozs7Ozs7O0FDek1EO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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OztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7Ozs7Ozs7Ozs7OztBQ3RXRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCLGFBQWEsd0NBQXdDO0FBQ3JELGFBQWEsd0NBQXdDO0FBQ3JELGFBQWEsd0NBQXdDO0FBQ3JELGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7Ozs7Ozs7Ozs7O0FDeFBEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixxQkFBcUI7QUFDbEQsa0NBQWtDLHlCQUF5QjtBQUMzRCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHFCQUFxQjtBQUNsRCxrQ0FBa0MseUJBQXlCO0FBQzNELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsb0JBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIscUJBQXFCO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLG1CQUFtQjtBQUNsRDtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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QUFDVCw0REFBNEQ7QUFDNUQ7O0FBRUE7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOzs7Ozs7Ozs7Ozs7QUNwYkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0MsbUJBQW1CO0FBQ3ZEO0FBQ0EsOEJBQThCLFVBQVU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZUFBZTtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7OztBQ3pTRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxVQUFVLG9CQUFvQixFQUFFOztBQUUvQztBQUNBLGtCQUFrQixVQUFVLG9CQUFvQixFQUFFOztBQUVsRDtBQUNBLGVBQWUscUJBQXFCLG9CQUFvQixFQUFFOztBQUUxRDtBQUNBLGNBQWMsc0JBQXNCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2Qyw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEMsUUFBUTs7QUFFbEQ7QUFDQTs7QUFFQSwyQkFBMkIsOEJBQThCOztBQUV6RDtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLGtCQUFrQjtBQUNsQixhQUFhO0FBQ2Isa0RBQWtELFlBQVk7QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQyxxQkFBcUI7QUFDckIsK0NBQStDO0FBQy9DO0FBQ0EsaUJBQWlCO0FBQ2pCLDJDQUEyQztBQUMzQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7Ozs7Ozs7Ozs7O0FDajBCRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsdUJBQXVCLGlCQUFpQjtBQUN4Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7O0FBRXpCLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5RUFBeUU7QUFDekU7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsV0FBVztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsaUJBQWlCOztBQUUxRDtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQkFBbUI7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDOztBQUVBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyxtQkFBbUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrR0FBK0csZ0JBQWdCLGlCQUFpQjtBQUNoSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOERBQThELHlCQUF5QjtBQUN2Rix3RkFBd0YsOEJBQThCLGdDQUFnQyxzQ0FBc0M7QUFDNUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG1FQUFtRSxTQUFTO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLHVCQUF1QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHVCQUF1QjtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsaUNBQWlDLHdCQUF3QjtBQUN6RDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQix1QkFBdUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsdUJBQXVCO0FBQ2xEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxR0FBcUc7QUFDckc7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsa0JBQWtCLFlBQVksMEJBQTBCO0FBQ3RILHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7Ozs7Ozs7Ozs7OztBQ3p4QkQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVksd0NBQXdDLCtHQUErRyxTQUFTLFFBQVEsVUFBVSxvQkFBb0IsaUJBQWlCLG1CQUFtQixhQUFhLGNBQWMsYUFBYSxVQUFVLHlCQUF5QixFQUFFLGlCQUFpQixJQUFJLEtBQUsscUJBQXFCLG1CQUFtQixhQUFhLGNBQWMscUJBQXFCLEtBQUssS0FBSyxlQUFlLGNBQWMsT0FBTyxnQkFBZ0IsY0FBYyxNQUFNLHdCQUF3QixLQUFLLGdCQUFnQixRQUFRLGlCQUFpQixtQkFBbUIsYUFBYSxNQUFNLGtCQUFrQiw4QkFBOEIsc0JBQXNCLHVCQUF1Qix3QkFBd0Isb0JBQW9CLElBQUksU0FBUyxLQUFLLFlBQVksZUFBZSxjQUFjLGFBQWEsT0FBTyxxQkFBcUIsS0FBSyxLQUFLLGNBQWMsOEJBQThCLHlDQUF5QywwQkFBMEIsMkJBQTJCLFdBQVcsS0FBSyxZQUFZLE1BQU0sT0FBTyxhQUFhLDBCQUEwQiw2QkFBNkIsS0FBSyxxQkFBcUIsVUFBVSw2QkFBNkIsbUNBQW1DLHFJQUFxSSwrQkFBK0Isd0JBQXdCLFFBQVEsR0FBRyw0QkFBNEIsa0NBQWtDLDRKQUE0SixJQUFJOztBQUUzbkQ7QUFDQTtBQUNBLG1CQUFtQixHQUFHOztBQUV0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7Ozs7Ozs7Ozs7O0FDM0REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQSwrQkFBK0IsVUFBVTtBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7OztBQzFDRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTLGtCQUFrQixVQUFVLG1CQUFtQixFQUFFOztBQUU1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQyxxQkFBcUIsYUFBYTtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGNBQWM7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGNBQWM7QUFDN0Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsc0JBQXNCO0FBQ3RCLHNCQUFzQiwyQ0FBMkM7QUFDakUsc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw2REFBNkQscUVBQXFFO0FBQ2xJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNB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Q0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7Ozs7Ozs7Ozs7O0FDL1REOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxhQUFhO0FBQy9DLGtDQUFrQztBQUNsQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixvQ0FBb0M7O0FBRS9EO0FBQ0Esa0RBQWtELFVBQVUsMkNBQTJDLEVBQUU7QUFDekcsYUFBYTtBQUNiLGtEQUFrRCxZQUFZO0FBQzlEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7OztBQ3ZXRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6InZlbmRvcnN+d2lkZ2V0LXRpbWVjaGFydC1qcy5jaHVuay5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBqcXVlcnkuZmxvdC50b29sdGlwXG4gKiBcbiAqIGRlc2NyaXB0aW9uOiBlYXN5LXRvLXVzZSB0b29sdGlwcyBmb3IgRmxvdCBjaGFydHNcbiAqIHZlcnNpb246IDAuOS4wXG4gKiBhdXRob3JzOiBLcnp5c3p0b2YgVXJiYXMgQGtyenlzdSBbbXl2aWV3cy5wbF0sRXZhbiBTdGVpbmtlcmNobmVyIEBSb3VuZGFyb3VuZFxuICogd2Vic2l0ZTogaHR0cHM6Ly9naXRodWIuY29tL2tyenlzdS9mbG90LnRvb2x0aXBcbiAqIFxuICogYnVpbGQgb24gMjAxNi0wNy0yNlxuICogcmVsZWFzZWQgdW5kZXIgTUlUIExpY2Vuc2UsIDIwMTJcbiovIFxuKGZ1bmN0aW9uICgkKSB7XG4gICAgLy8gcGx1Z2luIG9wdGlvbnMsIGRlZmF1bHQgdmFsdWVzXG4gICAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgICBzaG93OiBmYWxzZSxcbiAgICAgICAgICAgIGNzc0NsYXNzOiBcImZsb3RUaXBcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IFwiJXMgfCBYOiAleCB8IFk6ICV5XCIsXG4gICAgICAgICAgICAvLyBhbGxvd2VkIHRlbXBsYXRlcyBhcmU6XG4gICAgICAgICAgICAvLyAlcyAtPiBzZXJpZXMgbGFiZWwsXG4gICAgICAgICAgICAvLyAlYyAtPiBzZXJpZXMgY29sb3IsXG4gICAgICAgICAgICAvLyAlbHggLT4geCBheGlzIGxhYmVsIChyZXF1aXJlcyBmbG90LWF4aXNsYWJlbHMgcGx1Z2luIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrcmNvdGUvZmxvdC1heGlzbGFiZWxzKSxcbiAgICAgICAgICAgIC8vICVseSAtPiB5IGF4aXMgbGFiZWwgKHJlcXVpcmVzIGZsb3QtYXhpc2xhYmVscyBwbHVnaW4gaHR0cHM6Ly9naXRodWIuY29tL21hcmtyY290ZS9mbG90LWF4aXNsYWJlbHMpLFxuICAgICAgICAgICAgLy8gJXggLT4gWCB2YWx1ZSxcbiAgICAgICAgICAgIC8vICV5IC0+IFkgdmFsdWUsXG4gICAgICAgICAgICAvLyAleC4yIC0+IHByZWNpc2lvbiBvZiBYIHZhbHVlLFxuICAgICAgICAgICAgLy8gJXAgLT4gcGVyY2VudFxuICAgICAgICAgICAgLy8gJW4gLT4gdmFsdWUgKG5vdCBwZXJjZW50KSBvZiBwaWUgY2hhcnRcbiAgICAgICAgICAgIHhEYXRlRm9ybWF0OiBudWxsLFxuICAgICAgICAgICAgeURhdGVGb3JtYXQ6IG51bGwsXG4gICAgICAgICAgICBtb250aE5hbWVzOiBudWxsLFxuICAgICAgICAgICAgZGF5TmFtZXM6IG51bGwsXG4gICAgICAgICAgICBzaGlmdHM6IHtcbiAgICAgICAgICAgICAgICB4OiAxMCxcbiAgICAgICAgICAgICAgICB5OiAyMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlZmF1bHRUaGVtZTogdHJ1ZSxcbiAgICAgICAgICAgIHNuYXA6IHRydWUsXG4gICAgICAgICAgICBsaW5lczogZmFsc2UsXG4gICAgICAgICAgICBjbGlja1RpcHM6IGZhbHNlLFxuXG4gICAgICAgICAgICAvLyBjYWxsYmFja3NcbiAgICAgICAgICAgIG9uSG92ZXI6IGZ1bmN0aW9uIChmbG90SXRlbSwgJHRvb2x0aXBFbCkge30sXG5cbiAgICAgICAgICAgICRjb21wYXQ6IGZhbHNlXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gZHVtbXkgZGVmYXVsdCBvcHRpb25zIG9iamVjdCBmb3IgbGVnYWN5IGNvZGUgKDwwLjguNSkgLSBpcyBkZWxldGVkIGxhdGVyXG4gICAgZGVmYXVsdE9wdGlvbnMudG9vbHRpcE9wdHMgPSBkZWZhdWx0T3B0aW9ucy50b29sdGlwO1xuXG4gICAgLy8gb2JqZWN0XG4gICAgdmFyIEZsb3RUb29sdGlwID0gZnVuY3Rpb24gKHBsb3QpIHtcbiAgICAgICAgLy8gdmFyaWFibGVzXG4gICAgICAgIHRoaXMudGlwUG9zaXRpb24gPSB7eDogMCwgeTogMH07XG5cbiAgICAgICAgdGhpcy5pbml0KHBsb3QpO1xuICAgIH07XG5cbiAgICAvLyBtYWluIHBsdWdpbiBmdW5jdGlvblxuICAgIEZsb3RUb29sdGlwLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKHBsb3QpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgIC8vIGRldGVjdCBvdGhlciBmbG90IHBsdWdpbnNcbiAgICAgICAgdmFyIHBsb3RQbHVnaW5zTGVuZ3RoID0gJC5wbG90LnBsdWdpbnMubGVuZ3RoO1xuICAgICAgICB0aGlzLnBsb3RQbHVnaW5zID0gW107XG5cbiAgICAgICAgaWYgKHBsb3RQbHVnaW5zTGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBwID0gMDsgcCA8IHBsb3RQbHVnaW5zTGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBsb3RQbHVnaW5zLnB1c2goJC5wbG90LnBsdWdpbnNbcF0ubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwbG90Lmhvb2tzLmJpbmRFdmVudHMucHVzaChmdW5jdGlvbiAocGxvdCwgZXZlbnRIb2xkZXIpIHtcblxuICAgICAgICAgICAgLy8gZ2V0IHBsb3Qgb3B0aW9uc1xuICAgICAgICAgICAgdGhhdC5wbG90T3B0aW9ucyA9IHBsb3QuZ2V0T3B0aW9ucygpO1xuXG4gICAgICAgICAgICAvLyBmb3IgbGVnYWN5ICg8MC44LjUpIGltcGxlbWVudGF0aW9uc1xuICAgICAgICAgICAgaWYgKHR5cGVvZih0aGF0LnBsb3RPcHRpb25zLnRvb2x0aXApID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICB0aGF0LnBsb3RPcHRpb25zLnRvb2x0aXBPcHRzLnNob3cgPSB0aGF0LnBsb3RPcHRpb25zLnRvb2x0aXA7XG4gICAgICAgICAgICAgICAgdGhhdC5wbG90T3B0aW9ucy50b29sdGlwID0gdGhhdC5wbG90T3B0aW9ucy50b29sdGlwT3B0cztcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhhdC5wbG90T3B0aW9ucy50b29sdGlwT3B0cztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgbm90IGVuYWJsZWQgcmV0dXJuXG4gICAgICAgICAgICBpZiAodGhhdC5wbG90T3B0aW9ucy50b29sdGlwLnNob3cgPT09IGZhbHNlIHx8IHR5cGVvZiB0aGF0LnBsb3RPcHRpb25zLnRvb2x0aXAuc2hvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcblxuICAgICAgICAgICAgLy8gc2hvcnRjdXQgdG8gYWNjZXNzIHRvb2x0aXAgb3B0aW9uc1xuICAgICAgICAgICAgdGhhdC50b29sdGlwT3B0aW9ucyA9IHRoYXQucGxvdE9wdGlvbnMudG9vbHRpcDtcblxuICAgICAgICAgICAgaWYgKHRoYXQudG9vbHRpcE9wdGlvbnMuJGNvbXBhdCkge1xuICAgICAgICAgICAgICAgIHRoYXQud2Z1bmMgPSAnd2lkdGgnO1xuICAgICAgICAgICAgICAgIHRoYXQuaGZ1bmMgPSAnaGVpZ2h0JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhhdC53ZnVuYyA9ICdpbm5lcldpZHRoJztcbiAgICAgICAgICAgICAgICB0aGF0LmhmdW5jID0gJ2lubmVySGVpZ2h0JztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY3JlYXRlIHRvb2x0aXAgRE9NIGVsZW1lbnRcbiAgICAgICAgICAgIHZhciAkdGlwID0gdGhhdC5nZXREb21FbGVtZW50KCk7XG5cbiAgICAgICAgICAgIC8vIGJpbmQgZXZlbnRcbiAgICAgICAgICAgICQoIHBsb3QuZ2V0UGxhY2Vob2xkZXIoKSApLmJpbmQoXCJwbG90aG92ZXJcIiwgcGxvdGhvdmVyKTtcbiAgICAgICAgICAgIGlmICh0aGF0LnRvb2x0aXBPcHRpb25zLmNsaWNrVGlwcykge1xuICAgICAgICAgICAgICAgICQoIHBsb3QuZ2V0UGxhY2Vob2xkZXIoKSApLmJpbmQoXCJwbG90Y2xpY2tcIiwgcGxvdGNsaWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoYXQuY2xpY2ttb2RlID0gZmFsc2U7XG5cbiAgICAgICAgICAgICQoZXZlbnRIb2xkZXIpLmJpbmQoJ21vdXNlbW92ZScsIG1vdXNlTW92ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHBsb3QuaG9va3Muc2h1dGRvd24ucHVzaChmdW5jdGlvbiAocGxvdCwgZXZlbnRIb2xkZXIpe1xuICAgICAgICAgICAgJChwbG90LmdldFBsYWNlaG9sZGVyKCkpLnVuYmluZChcInBsb3Rob3ZlclwiLCBwbG90aG92ZXIpO1xuICAgICAgICAgICAgJChwbG90LmdldFBsYWNlaG9sZGVyKCkpLnVuYmluZChcInBsb3RjbGlja1wiLCBwbG90Y2xpY2spO1xuICAgICAgICAgICAgcGxvdC5yZW1vdmVUb29sdGlwKCk7XG4gICAgICAgICAgICAkKGV2ZW50SG9sZGVyKS51bmJpbmQoXCJtb3VzZW1vdmVcIiwgbW91c2VNb3ZlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZnVuY3Rpb24gbW91c2VNb3ZlKGUpe1xuICAgICAgICAgICAgdmFyIHBvcyA9IHt9O1xuICAgICAgICAgICAgcG9zLnggPSBlLnBhZ2VYO1xuICAgICAgICAgICAgcG9zLnkgPSBlLnBhZ2VZO1xuICAgICAgICAgICAgcGxvdC5zZXRUb29sdGlwUG9zaXRpb24ocG9zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiAgb3BlbiB0aGUgdG9vbHRpcCAoaWYgbm90IGFscmVhZHkgb3BlbikgYW5kIGZyZWV6ZSBpdCBvbiB0aGUgY3VycmVudCBwb3NpdGlvbiB0aWxsIHRoZSBuZXh0IGNsaWNrXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBwbG90Y2xpY2soZXZlbnQsIHBvcywgaXRlbSkge1xuICAgICAgICAgICAgaWYgKCEgdGhhdC5jbGlja21vZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBpdCBpcyB0aGUgY2xpY2sgYWN0aXZhdGluZyB0aGUgY2xpY2t0aXBcbiAgICAgICAgICAgICAgICBwbG90aG92ZXIoZXZlbnQsIHBvcywgaXRlbSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoYXQuZ2V0RG9tRWxlbWVudCgpLmlzKFwiOnZpc2libGVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgJChwbG90LmdldFBsYWNlaG9sZGVyKCkpLnVuYmluZChcInBsb3Rob3ZlclwiLCBwbG90aG92ZXIpO1xuICAgICAgICAgICAgICAgICAgICB0aGF0LmNsaWNrbW9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpdCBpcyB0aGUgY2xpY2sgZGVhY3RpdmF0aW5nIHRoZSBjbGlja3RpcFxuICAgICAgICAgICAgICAgICQoIHBsb3QuZ2V0UGxhY2Vob2xkZXIoKSApLmJpbmQoXCJwbG90aG92ZXJcIiwgcGxvdGhvdmVyKTtcbiAgICAgICAgICAgICAgICBwbG90LmhpZGVUb29sdGlwKCk7XG4gICAgICAgICAgICAgICAgdGhhdC5jbGlja21vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBsb3Rob3ZlcihldmVudCwgcG9zLCBpdGVtKSB7XG4gICAgICAgICAgICAvLyBTaW1wbGUgZGlzdGFuY2UgZm9ybXVsYS5cbiAgICAgICAgICAgIHZhciBsaW5lRGlzdGFuY2UgPSBmdW5jdGlvbiAocDF4LCBwMXksIHAyeCwgcDJ5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydCgocDJ4IC0gcDF4KSAqIChwMnggLSBwMXgpICsgKHAyeSAtIHAxeSkgKiAocDJ5IC0gcDF5KSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBIZXJlIGlzIHNvbWUgdm9vZG9vIG1hZ2ljIGZvciBkZXRlcm1pbmluZyB0aGUgZGlzdGFuY2UgdG8gYSBsaW5lIGZvcm0gYSBnaXZlbiBwb2ludCB7eCwgeX0uXG4gICAgICAgICAgICB2YXIgZG90TGluZUxlbmd0aCA9IGZ1bmN0aW9uICh4LCB5LCB4MCwgeTAsIHgxLCB5MSwgbykge1xuICAgICAgICAgICAgICAgIGlmIChvICYmICEobyA9XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICh4LCB5LCB4MCwgeTAsIHgxLCB5MSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB4MCAhPT0gJ3VuZGVmaW5lZCcpIHJldHVybiB7IHg6IHgwLCB5OiB5IH07XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgeTAgIT09ICd1bmRlZmluZWQnKSByZXR1cm4geyB4OiB4LCB5OiB5MCB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZyA9IC0xIC8gKCh5MSAtIHkwKSAvICh4MSAtIHgwKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogbGVmdCA9ICh4MSAqICh4ICogdGcgLSB5ICsgeTApICsgeDAgKiAoeCAqIC10ZyArIHkgLSB5MSkpIC8gKHRnICogKHgxIC0geDApICsgeTAgLSB5MSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogdGcgKiBsZWZ0IC0gdGcgKiB4ICsgeVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSAoeCwgeSwgeDAsIHkwLCB4MSwgeTEpLFxuICAgICAgICAgICAgICAgICAgICBvLnggPj0gTWF0aC5taW4oeDAsIHgxKSAmJiBvLnggPD0gTWF0aC5tYXgoeDAsIHgxKSAmJiBvLnkgPj0gTWF0aC5taW4oeTAsIHkxKSAmJiBvLnkgPD0gTWF0aC5tYXgoeTAsIHkxKSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGwxID0gbGluZURpc3RhbmNlKHgsIHksIHgwLCB5MCksIGwyID0gbGluZURpc3RhbmNlKHgsIHksIHgxLCB5MSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsMSA+IGwyID8gbDIgOiBsMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IHkwIC0geTEsIGIgPSB4MSAtIHgwLCBjID0geDAgKiB5MSAtIHkwICogeDE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyhhICogeCArIGIgKiB5ICsgYykgLyBNYXRoLnNxcnQoYSAqIGEgKyBiICogYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKGl0ZW0gJiYgIWlzTmFOKGl0ZW0uZGF0YUluZGV4KSkge1xuICAgICAgICAgICAgICAgIHBsb3Quc2hvd1Rvb2x0aXAoaXRlbSwgdGhhdC50b29sdGlwT3B0aW9ucy5zbmFwID8gaXRlbSA6IHBvcyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoYXQucGxvdE9wdGlvbnMuc2VyaWVzLmxpbmVzLnNob3cgJiYgdGhhdC50b29sdGlwT3B0aW9ucy5saW5lcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBtYXhEaXN0YW5jZSA9IHRoYXQucGxvdE9wdGlvbnMuZ3JpZC5tb3VzZUFjdGl2ZVJhZGl1cztcblxuICAgICAgICAgICAgICAgIHZhciBjbG9zZXN0VHJhY2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlOiBtYXhEaXN0YW5jZSArIDFcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdmFyIHR0UG9zID0gcG9zO1xuXG4gICAgICAgICAgICAgICAgJC5lYWNoKHBsb3QuZ2V0RGF0YSgpLCBmdW5jdGlvbiAoaSwgc2VyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4QmVmb3JlSW5kZXggPSAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgeEFmdGVySW5kZXggPSAtMTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBPdXIgc2VhcmNoIGhlcmUgYXNzdW1lcyBvdXIgZGF0YSBpcyBzb3J0ZWQgdmlhIHRoZSB4LWF4aXMuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IEltcHJvdmUgZWZmaWNpZW5jeSBzb21laG93IC0gc2VhcmNoIHNtYWxsZXIgc2V0cyBvZiBkYXRhLlxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IHNlcmllcy5kYXRhLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VyaWVzLmRhdGFbaiAtIDFdWzBdIDw9IHBvcy54ICYmIHNlcmllcy5kYXRhW2pdWzBdID49IHBvcy54KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeEJlZm9yZUluZGV4ID0gaiAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeEFmdGVySW5kZXggPSBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHhBZnRlckluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGxvdC5oaWRlVG9vbHRpcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50UHJldiA9IHsgeDogc2VyaWVzLmRhdGFbeEJlZm9yZUluZGV4XVswXSwgeTogc2VyaWVzLmRhdGFbeEJlZm9yZUluZGV4XVsxXSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnROZXh0ID0geyB4OiBzZXJpZXMuZGF0YVt4QWZ0ZXJJbmRleF1bMF0sIHk6IHNlcmllcy5kYXRhW3hBZnRlckluZGV4XVsxXSB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXN0VG9MaW5lID0gZG90TGluZUxlbmd0aChzZXJpZXMueGF4aXMucDJjKHBvcy54KSwgc2VyaWVzLnlheGlzLnAyYyhwb3MueSksIHNlcmllcy54YXhpcy5wMmMocG9pbnRQcmV2LngpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzLnlheGlzLnAyYyhwb2ludFByZXYueSksIHNlcmllcy54YXhpcy5wMmMocG9pbnROZXh0LngpLCBzZXJpZXMueWF4aXMucDJjKHBvaW50TmV4dC55KSwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXN0VG9MaW5lIDwgY2xvc2VzdFRyYWNlLmRpc3RhbmNlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjbG9zZXN0SW5kZXggPSBsaW5lRGlzdGFuY2UocG9pbnRQcmV2LngsIHBvaW50UHJldi55LCBwb3MueCwgcG9zLnkpIDxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lRGlzdGFuY2UocG9zLngsIHBvcy55LCBwb2ludE5leHQueCwgcG9pbnROZXh0LnkpID8geEJlZm9yZUluZGV4IDogeEFmdGVySW5kZXg7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb2ludFNpemUgPSBzZXJpZXMuZGF0YXBvaW50cy5wb2ludHNpemU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgcG9pbnQgb24gdGhlIGxpbmUgdmVydGljYWxseSBjbG9zZXN0IHRvIG91ciBjdXJzb3IuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnRPbkxpbmUgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zLngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRQcmV2LnkgKyAoKHBvaW50TmV4dC55IC0gcG9pbnRQcmV2LnkpICogKChwb3MueCAtIHBvaW50UHJldi54KSAvIChwb2ludE5leHQueCAtIHBvaW50UHJldi54KSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhcG9pbnQ6IHBvaW50T25MaW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFJbmRleDogY2xvc2VzdEluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllczogc2VyaWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBpXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXN0VHJhY2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2U6IGRpc3RUb0xpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbTogaXRlbVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQudG9vbHRpcE9wdGlvbnMuc25hcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR0UG9zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdlWDogc2VyaWVzLnhheGlzLnAyYyhwb2ludE9uTGluZVswXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VZOiBzZXJpZXMueWF4aXMucDJjKHBvaW50T25MaW5lWzFdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmIChjbG9zZXN0VHJhY2UuZGlzdGFuY2UgPCBtYXhEaXN0YW5jZSArIDEpXG4gICAgICAgICAgICAgICAgICAgIHBsb3Quc2hvd1Rvb2x0aXAoY2xvc2VzdFRyYWNlLml0ZW0sIHR0UG9zKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHBsb3QuaGlkZVRvb2x0aXAoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGxvdC5oaWRlVG9vbHRpcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUXVpY2sgbGl0dGxlIGZ1bmN0aW9uIGZvciBzZXR0aW5nIHRoZSB0b29sdGlwIHBvc2l0aW9uLlxuICAgICAgICBwbG90LnNldFRvb2x0aXBQb3NpdGlvbiA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgICAgIHZhciAkdGlwID0gdGhhdC5nZXREb21FbGVtZW50KCk7XG5cbiAgICAgICAgICAgIHZhciB0b3RhbFRpcFdpZHRoID0gJHRpcC5vdXRlcldpZHRoKCkgKyB0aGF0LnRvb2x0aXBPcHRpb25zLnNoaWZ0cy54O1xuICAgICAgICAgICAgdmFyIHRvdGFsVGlwSGVpZ2h0ID0gJHRpcC5vdXRlckhlaWdodCgpICsgdGhhdC50b29sdGlwT3B0aW9ucy5zaGlmdHMueTtcbiAgICAgICAgICAgIGlmICgocG9zLnggLSAkKHdpbmRvdykuc2Nyb2xsTGVmdCgpKSA+ICgkKHdpbmRvdylbdGhhdC53ZnVuY10oKSAtIHRvdGFsVGlwV2lkdGgpKSB7XG4gICAgICAgICAgICAgICAgcG9zLnggLT0gdG90YWxUaXBXaWR0aDtcbiAgICAgICAgICAgICAgICBwb3MueCA9IE1hdGgubWF4KHBvcy54LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgocG9zLnkgLSAkKHdpbmRvdykuc2Nyb2xsVG9wKCkpID4gKCQod2luZG93KVt0aGF0LmhmdW5jXSgpIC0gdG90YWxUaXBIZWlnaHQpKSB7XG4gICAgICAgICAgICAgICAgcG9zLnkgLT0gdG90YWxUaXBIZWlnaHQ7XG4gICAgICAgICAgICB9XG5cblx0ICAgIC8qXG5cdCAgICAgICBUaGUgc2VjdGlvbiBhcHBsaWVzIHRoZSBuZXcgcG9zaXRpb25pbmcgT05MWSBpZiBwb3MueCBhbmQgcG9zLnlcblx0ICAgICAgIGFyZSBudW1iZXJzLiBJZiB0aGV5IGFyZSB1bmRlZmluZWQgb3Igbm90IGEgbnVtYmVyLCB1c2UgdGhlIGxhc3Rcblx0ICAgICAgIGtub3duIG51bWVyaWNhbCBwb3NpdGlvbi4gVGhpcyBoYWNrIGZpeGVzIGEgYnVnIHRoYXQga2VwdCBwaWVcblx0ICAgICAgIGNoYXJ0cyBmcm9tIGtlZXBpbmcgdGhlaXIgdG9vbHRpcCBwb3NpdGlvbmluZy5cblx0ICAgICAqL1xuXG4gICAgICAgICAgICBpZiAoaXNOYU4ocG9zLngpKSB7XG5cdFx0dGhhdC50aXBQb3NpdGlvbi54ID0gdGhhdC50aXBQb3NpdGlvbi54UHJldjtcblx0ICAgIH1cblx0ICAgIGVsc2Uge1xuXHRcdHRoYXQudGlwUG9zaXRpb24ueCA9IHBvcy54O1xuXHRcdHRoYXQudGlwUG9zaXRpb24ueFByZXYgPSBwb3MueDtcblx0ICAgIH1cblx0ICAgIGlmIChpc05hTihwb3MueSkpIHtcblx0XHR0aGF0LnRpcFBvc2l0aW9uLnkgPSB0aGF0LnRpcFBvc2l0aW9uLnlQcmV2O1xuXHQgICAgfVxuXHQgICAgZWxzZSB7XG5cdFx0dGhhdC50aXBQb3NpdGlvbi55ID0gcG9zLnk7XG5cdFx0dGhhdC50aXBQb3NpdGlvbi55UHJldiA9IHBvcy55O1xuXHQgICAgfVxuXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUXVpY2sgbGl0dGxlIGZ1bmN0aW9uIGZvciBzaG93aW5nIHRoZSB0b29sdGlwLlxuICAgICAgICBwbG90LnNob3dUb29sdGlwID0gZnVuY3Rpb24gKHRhcmdldCwgcG9zaXRpb24sIHRhcmdldFBvc2l0aW9uKSB7XG4gICAgICAgICAgICB2YXIgJHRpcCA9IHRoYXQuZ2V0RG9tRWxlbWVudCgpO1xuXG4gICAgICAgICAgICAvLyBjb252ZXJ0IHRvb2x0aXAgY29udGVudCB0ZW1wbGF0ZSB0byByZWFsIHRpcFRleHRcbiAgICAgICAgICAgIHZhciB0aXBUZXh0ID0gdGhhdC5zdHJpbmdGb3JtYXQodGhhdC50b29sdGlwT3B0aW9ucy5jb250ZW50LCB0YXJnZXQpO1xuICAgICAgICAgICAgaWYgKHRpcFRleHQgPT09ICcnKVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgJHRpcC5odG1sKHRpcFRleHQpO1xuICAgICAgICAgICAgcGxvdC5zZXRUb29sdGlwUG9zaXRpb24oeyB4OiB0aGF0LnRpcFBvc2l0aW9uLngsIHk6IHRoYXQudGlwUG9zaXRpb24ueSB9KTtcbiAgICAgICAgICAgICR0aXAuY3NzKHtcbiAgICAgICAgICAgICAgICBsZWZ0OiB0aGF0LnRpcFBvc2l0aW9uLnggKyB0aGF0LnRvb2x0aXBPcHRpb25zLnNoaWZ0cy54LFxuICAgICAgICAgICAgICAgIHRvcDogdGhhdC50aXBQb3NpdGlvbi55ICsgdGhhdC50b29sdGlwT3B0aW9ucy5zaGlmdHMueVxuICAgICAgICAgICAgfSkuc2hvdygpO1xuXG4gICAgICAgICAgICAvLyBydW4gY2FsbGJhY2tcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhhdC50b29sdGlwT3B0aW9ucy5vbkhvdmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhhdC50b29sdGlwT3B0aW9ucy5vbkhvdmVyKHRhcmdldCwgJHRpcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUXVpY2sgbGl0dGxlIGZ1bmN0aW9uIGZvciBoaWRpbmcgdGhlIHRvb2x0aXAuXG4gICAgICAgIHBsb3QuaGlkZVRvb2x0aXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0LmdldERvbUVsZW1lbnQoKS5oaWRlKCkuaHRtbCgnJyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcGxvdC5yZW1vdmVUb29sdGlwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGF0LmdldERvbUVsZW1lbnQoKS5yZW1vdmUoKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogZ2V0IG9yIGNyZWF0ZSB0b29sdGlwIERPTSBlbGVtZW50XG4gICAgICogQHJldHVybiBqUXVlcnkgb2JqZWN0XG4gICAgICovXG4gICAgRmxvdFRvb2x0aXAucHJvdG90eXBlLmdldERvbUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkdGlwID0gJCgnPGRpdj4nKTtcbiAgICAgICAgaWYgKHRoaXMudG9vbHRpcE9wdGlvbnMgJiYgdGhpcy50b29sdGlwT3B0aW9ucy5jc3NDbGFzcykge1xuICAgICAgICAgICAgJHRpcCA9ICQoJy4nICsgdGhpcy50b29sdGlwT3B0aW9ucy5jc3NDbGFzcyk7XG5cbiAgICAgICAgICAgIGlmKCAkdGlwLmxlbmd0aCA9PT0gMCApe1xuICAgICAgICAgICAgICAgICR0aXAgPSAkKCc8ZGl2IC8+JykuYWRkQ2xhc3ModGhpcy50b29sdGlwT3B0aW9ucy5jc3NDbGFzcyk7XG4gICAgICAgICAgICAgICAgJHRpcC5hcHBlbmRUbygnYm9keScpLmhpZGUoKS5jc3Moe3Bvc2l0aW9uOiAnYWJzb2x1dGUnfSk7XG5cbiAgICAgICAgICAgICAgICBpZih0aGlzLnRvb2x0aXBPcHRpb25zLmRlZmF1bHRUaGVtZSkge1xuICAgICAgICAgICAgICAgICAgICAkdGlwLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAnYmFja2dyb3VuZCc6ICcjZmZmJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd6LWluZGV4JzogJzEwNDAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3BhZGRpbmcnOiAnMC40ZW0gMC42ZW0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2JvcmRlci1yYWRpdXMnOiAnMC41ZW0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZvbnQtc2l6ZSc6ICcwLjhlbScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYm9yZGVyJzogJzFweCBzb2xpZCAjMTExJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkaXNwbGF5JzogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3doaXRlLXNwYWNlJzogJ25vd3JhcCdcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICR0aXA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGNvcmUgZnVuY3Rpb24sIGNyZWF0ZSB0b29sdGlwIGNvbnRlbnRcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGNvbnRlbnQgLSB0ZW1wbGF0ZSB3aXRoIHRvb2x0aXAgY29udGVudFxuICAgICAqIEBwYXJhbSAge29iamVjdH0gaXRlbSAtIEZsb3QgaXRlbVxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gcmVhbCB0b29sdGlwIGNvbnRlbnQgZm9yIGN1cnJlbnQgaXRlbVxuICAgICAqL1xuICAgIEZsb3RUb29sdGlwLnByb3RvdHlwZS5zdHJpbmdGb3JtYXQgPSBmdW5jdGlvbiAoY29udGVudCwgaXRlbSkge1xuICAgICAgICB2YXIgcGVyY2VudFBhdHRlcm4gPSAvJXBcXC57MCwxfShcXGR7MCx9KS87XG4gICAgICAgIHZhciBzZXJpZXNQYXR0ZXJuID0gLyVzLztcbiAgICAgICAgdmFyIGNvbG9yUGF0dGVybiA9IC8lYy87XG4gICAgICAgIHZhciB4TGFiZWxQYXR0ZXJuID0gLyVseC87IC8vIHJlcXVpcmVzIGZsb3QtYXhpc2xhYmVscyBwbHVnaW4gaHR0cHM6Ly9naXRodWIuY29tL21hcmtyY290ZS9mbG90LWF4aXNsYWJlbHMsIHdpbGwgYmUgaWdub3JlZCBpZiBwbHVnaW4gaXNuJ3QgbG9hZGVkXG4gICAgICAgIHZhciB5TGFiZWxQYXR0ZXJuID0gLyVseS87IC8vIHJlcXVpcmVzIGZsb3QtYXhpc2xhYmVscyBwbHVnaW4gaHR0cHM6Ly9naXRodWIuY29tL21hcmtyY290ZS9mbG90LWF4aXNsYWJlbHMsIHdpbGwgYmUgaWdub3JlZCBpZiBwbHVnaW4gaXNuJ3QgbG9hZGVkXG4gICAgICAgIHZhciB4UGF0dGVybiA9IC8leFxcLnswLDF9KFxcZHswLH0pLztcbiAgICAgICAgdmFyIHlQYXR0ZXJuID0gLyV5XFwuezAsMX0oXFxkezAsfSkvO1xuICAgICAgICB2YXIgeFBhdHRlcm5XaXRob3V0UHJlY2lzaW9uID0gXCIleFwiO1xuICAgICAgICB2YXIgeVBhdHRlcm5XaXRob3V0UHJlY2lzaW9uID0gXCIleVwiO1xuICAgICAgICB2YXIgY3VzdG9tVGV4dFBhdHRlcm4gPSBcIiVjdFwiO1xuXHR2YXIgblBpZVBhdHRlcm4gPSBcIiVuXCI7XG5cbiAgICAgICAgdmFyIHgsIHksIGN1c3RvbVRleHQsIHAsIG47XG5cbiAgICAgICAgLy8gZm9yIHRocmVzaG9sZCBwbHVnaW4gd2UgbmVlZCB0byByZWFkIGRhdGEgZnJvbSBkaWZmZXJlbnQgcGxhY2VcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtLnNlcmllcy50aHJlc2hvbGQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHggPSBpdGVtLmRhdGFwb2ludFswXTtcbiAgICAgICAgICAgIHkgPSBpdGVtLmRhdGFwb2ludFsxXTtcbiAgICAgICAgICAgIGN1c3RvbVRleHQgPSBpdGVtLmRhdGFwb2ludFsyXTtcblx0fVxuXG5cdC8vIGZvciBDdXJ2ZWRMaW5lcyBwbHVnaW4gd2UgbmVlZCB0byByZWFkIGRhdGEgZnJvbSBkaWZmZXJlbnQgcGxhY2Vcblx0ICAgIGVsc2UgaWYgKHR5cGVvZiBpdGVtLnNlcmllcy5jdXJ2ZWRMaW5lcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdHggPSBpdGVtLmRhdGFwb2ludFswXTtcblx0XHR5ID0gaXRlbS5kYXRhcG9pbnRbMV07XG5cdCAgICB9XG5cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGl0ZW0uc2VyaWVzLmxpbmVzICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZW0uc2VyaWVzLmxpbmVzLnN0ZXBzKSB7XG4gICAgICAgICAgICB4ID0gaXRlbS5zZXJpZXMuZGF0YXBvaW50cy5wb2ludHNbaXRlbS5kYXRhSW5kZXggKiAyXTtcbiAgICAgICAgICAgIHkgPSBpdGVtLnNlcmllcy5kYXRhcG9pbnRzLnBvaW50c1tpdGVtLmRhdGFJbmRleCAqIDIgKyAxXTtcbiAgICAgICAgICAgIC8vIFRPRE86IHdoZXJlIHRvIGZpbmQgY3VzdG9tIHRleHQgaW4gdGhpcyB2YXJpYW50P1xuICAgICAgICAgICAgY3VzdG9tVGV4dCA9IFwiXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4ID0gaXRlbS5zZXJpZXMuZGF0YVtpdGVtLmRhdGFJbmRleF1bMF07XG4gICAgICAgICAgICB5ID0gaXRlbS5zZXJpZXMuZGF0YVtpdGVtLmRhdGFJbmRleF1bMV07XG4gICAgICAgICAgICBjdXN0b21UZXh0ID0gaXRlbS5zZXJpZXMuZGF0YVtpdGVtLmRhdGFJbmRleF1bMl07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJIHRoaW5rIHRoaXMgaXMgb25seSBpbiBjYXNlIG9mIHRocmVzaG9sZCBwbHVnaW5cbiAgICAgICAgaWYgKGl0ZW0uc2VyaWVzLmxhYmVsID09PSBudWxsICYmIGl0ZW0uc2VyaWVzLm9yaWdpblNlcmllcykge1xuICAgICAgICAgICAgaXRlbS5zZXJpZXMubGFiZWwgPSBpdGVtLnNlcmllcy5vcmlnaW5TZXJpZXMubGFiZWw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBpdCBpcyBhIGZ1bmN0aW9uIGNhbGxiYWNrIGdldCB0aGUgY29udGVudCBzdHJpbmdcbiAgICAgICAgaWYgKHR5cGVvZihjb250ZW50KSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQoaXRlbS5zZXJpZXMubGFiZWwsIHgsIHksIGl0ZW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhlIGNhc2Ugd2hlcmUgdGhlIHBhc3NlZCBjb250ZW50IGlzIGVxdWFsIHRvIGZhbHNlXG4gICAgICAgIGlmICh0eXBlb2YoY29udGVudCkgPT09ICdib29sZWFuJyAmJiAhY29udGVudCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogcmVwbGFjZW1lbnQgb2YgJWN0IGFuZCBvdGhlciBtdWx0aS1jaGFyYWN0ZXIgdGVtcGxhdGVzIG11c3RcbiAgICAgICAgICAgcHJlY2VkZSB0aGUgcmVwbGFjZW1lbnQgb2Ygc2luZ2xlLWNoYXJhY3RlciB0ZW1wbGF0ZXNcbiAgICAgICAgICAgdG8gYXZvaWQgY29uZmxpY3QgYmV0d2VlbiAnJWMnIGFuZCAnJWN0JyAgYW5kIHNpbWlsYXIgc3Vic3RyaW5nc1xuICAgICAgICAqL1xuICAgICAgICBpZiAoY3VzdG9tVGV4dCkge1xuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZShjdXN0b21UZXh0UGF0dGVybiwgY3VzdG9tVGV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwZXJjZW50IG1hdGNoIGZvciBwaWUgY2hhcnRzIGFuZCBzdGFja2VkIHBlcmNlbnRcbiAgICAgICAgaWYgKHR5cGVvZiAoaXRlbS5zZXJpZXMucGVyY2VudCkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwID0gaXRlbS5zZXJpZXMucGVyY2VudDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgKGl0ZW0uc2VyaWVzLnBlcmNlbnRzKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHAgPSBpdGVtLnNlcmllcy5wZXJjZW50c1tpdGVtLmRhdGFJbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgY29udGVudCA9IHRoaXMuYWRqdXN0VmFsUHJlY2lzaW9uKHBlcmNlbnRQYXR0ZXJuLCBjb250ZW50LCBwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlcGxhY2UgJW4gd2l0aCBudW1iZXIgb2YgaXRlbXMgcmVwcmVzZW50ZWQgYnkgc2xpY2UgaW4gcGllIGNoYXJ0c1xuICAgICAgICBpZiAoaXRlbS5zZXJpZXMuaGFzT3duUHJvcGVydHkoJ3BpZScpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0uc2VyaWVzLmRhdGFbMF1bMV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgbiA9IGl0ZW0uc2VyaWVzLmRhdGFbMF1bMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBuID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZShuUGllUGF0dGVybiwgbik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXJpZXMgbWF0Y2hcbiAgICAgICAgaWYgKHR5cGVvZihpdGVtLnNlcmllcy5sYWJlbCkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKHNlcmllc1BhdHRlcm4sIGl0ZW0uc2VyaWVzLmxhYmVsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vcmVtb3ZlICVzIGlmIGxhYmVsIGlzIHVuZGVmaW5lZFxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZShzZXJpZXNQYXR0ZXJuLCBcIlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbG9yIG1hdGNoXG4gICAgICAgIGlmICh0eXBlb2YoaXRlbS5zZXJpZXMuY29sb3IpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZShjb2xvclBhdHRlcm4sIGl0ZW0uc2VyaWVzLmNvbG9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vcmVtb3ZlICVzIGlmIGNvbG9yIGlzIHVuZGVmaW5lZFxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZShjb2xvclBhdHRlcm4sIFwiXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8geCBheGlzIGxhYmVsIG1hdGNoXG4gICAgICAgIGlmICh0aGlzLmhhc0F4aXNMYWJlbCgneGF4aXMnLCBpdGVtKSkge1xuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSh4TGFiZWxQYXR0ZXJuLCBpdGVtLnNlcmllcy54YXhpcy5vcHRpb25zLmF4aXNMYWJlbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL3JlbW92ZSAlbHggaWYgYXhpcyBsYWJlbCBpcyB1bmRlZmluZWQgb3IgYXhpc2xhYmVscyBwbHVnaW4gbm90IHByZXNlbnRcbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoeExhYmVsUGF0dGVybiwgXCJcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB5IGF4aXMgbGFiZWwgbWF0Y2hcbiAgICAgICAgaWYgKHRoaXMuaGFzQXhpc0xhYmVsKCd5YXhpcycsIGl0ZW0pKSB7XG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKHlMYWJlbFBhdHRlcm4sIGl0ZW0uc2VyaWVzLnlheGlzLm9wdGlvbnMuYXhpc0xhYmVsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vcmVtb3ZlICVseSBpZiBheGlzIGxhYmVsIGlzIHVuZGVmaW5lZCBvciBheGlzbGFiZWxzIHBsdWdpbiBub3QgcHJlc2VudFxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSh5TGFiZWxQYXR0ZXJuLCBcIlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRpbWUgbW9kZSBheGVzIHdpdGggY3VzdG9tIGRhdGVGb3JtYXRcbiAgICAgICAgaWYgKHRoaXMuaXNUaW1lTW9kZSgneGF4aXMnLCBpdGVtKSAmJiB0aGlzLmlzWERhdGVGb3JtYXQoaXRlbSkpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoeFBhdHRlcm4sIHRoaXMudGltZXN0YW1wVG9EYXRlKHgsIHRoaXMudG9vbHRpcE9wdGlvbnMueERhdGVGb3JtYXQsIGl0ZW0uc2VyaWVzLnhheGlzLm9wdGlvbnMpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1RpbWVNb2RlKCd5YXhpcycsIGl0ZW0pICYmIHRoaXMuaXNZRGF0ZUZvcm1hdChpdGVtKSkge1xuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSh5UGF0dGVybiwgdGhpcy50aW1lc3RhbXBUb0RhdGUoeSwgdGhpcy50b29sdGlwT3B0aW9ucy55RGF0ZUZvcm1hdCwgaXRlbS5zZXJpZXMueWF4aXMub3B0aW9ucykpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IHByZWNpc2lvbiBpZiBkZWZpbmVkXG4gICAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLmFkanVzdFZhbFByZWNpc2lvbih4UGF0dGVybiwgY29udGVudCwgeCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB5ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgY29udGVudCA9IHRoaXMuYWRqdXN0VmFsUHJlY2lzaW9uKHlQYXR0ZXJuLCBjb250ZW50LCB5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoYW5nZSB4IGZyb20gbnVtYmVyIHRvIGdpdmVuIGxhYmVsLCBpZiBnaXZlblxuICAgICAgICBpZiAodHlwZW9mIGl0ZW0uc2VyaWVzLnhheGlzLnRpY2tzICE9PSAndW5kZWZpbmVkJykge1xuXG4gICAgICAgICAgICB2YXIgdGlja3M7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNSb3RhdGVkWEF4aXNUaWNrcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgIC8vIHhheGlzLnRpY2tzIHdpbGwgYmUgYW4gZW1wdHkgYXJyYXkgaWYgdGlja1JvdG9yIGlzIGJlaW5nIHVzZWQsIGJ1dCB0aGUgdmFsdWVzIGFyZSBhdmFpbGFibGUgaW4gcm90YXRlZFRpY2tzXG4gICAgICAgICAgICAgICAgdGlja3MgPSAncm90YXRlZFRpY2tzJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGlja3MgPSAndGlja3MnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2tyenlzdS9mbG90LnRvb2x0aXAvaXNzdWVzLzY1XG4gICAgICAgICAgICB2YXIgdGlja0luZGV4ID0gaXRlbS5kYXRhSW5kZXggKyBpdGVtLnNlcmllc0luZGV4O1xuXG4gICAgICAgICAgICBmb3IgKHZhciB4SW5kZXggaW4gaXRlbS5zZXJpZXMueGF4aXNbdGlja3NdKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uc2VyaWVzLnhheGlzW3RpY2tzXS5oYXNPd25Qcm9wZXJ0eSh0aWNrSW5kZXgpICYmICF0aGlzLmlzVGltZU1vZGUoJ3hheGlzJywgaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlWCA9ICh0aGlzLmlzQ2F0ZWdvcmllc01vZGUoJ3hheGlzJywgaXRlbSkpID8gaXRlbS5zZXJpZXMueGF4aXNbdGlja3NdW3RpY2tJbmRleF0ubGFiZWwgOiBpdGVtLnNlcmllcy54YXhpc1t0aWNrc11bdGlja0luZGV4XS52O1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVYID09PSB4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKHhQYXR0ZXJuLCBpdGVtLnNlcmllcy54YXhpc1t0aWNrc11bdGlja0luZGV4XS5sYWJlbC5yZXBsYWNlKC9cXCQvZywgJyQkJCQnKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGFuZ2UgeSBmcm9tIG51bWJlciB0byBnaXZlbiBsYWJlbCwgaWYgZ2l2ZW5cbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtLnNlcmllcy55YXhpcy50aWNrcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHlJbmRleCBpbiBpdGVtLnNlcmllcy55YXhpcy50aWNrcykge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLnNlcmllcy55YXhpcy50aWNrcy5oYXNPd25Qcm9wZXJ0eSh5SW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZVkgPSAodGhpcy5pc0NhdGVnb3JpZXNNb2RlKCd5YXhpcycsIGl0ZW0pKSA/IGl0ZW0uc2VyaWVzLnlheGlzLnRpY2tzW3lJbmRleF0ubGFiZWwgOiBpdGVtLnNlcmllcy55YXhpcy50aWNrc1t5SW5kZXhdLnY7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZVkgPT09IHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoeVBhdHRlcm4sIGl0ZW0uc2VyaWVzLnlheGlzLnRpY2tzW3lJbmRleF0ubGFiZWwucmVwbGFjZSgvXFwkL2csICckJCQkJykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgbm8gdmFsdWUgY3VzdG9taXphdGlvbiwgdXNlIHRpY2tGb3JtYXR0ZXIgYnkgZGVmYXVsdFxuICAgICAgICBpZiAodHlwZW9mIGl0ZW0uc2VyaWVzLnhheGlzLnRpY2tGb3JtYXR0ZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvL2VzY2FwZSBkb2xsYXJcbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoeFBhdHRlcm5XaXRob3V0UHJlY2lzaW9uLCBpdGVtLnNlcmllcy54YXhpcy50aWNrRm9ybWF0dGVyKHgsIGl0ZW0uc2VyaWVzLnhheGlzKS5yZXBsYWNlKC9cXCQvZywgJyQkJykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbS5zZXJpZXMueWF4aXMudGlja0Zvcm1hdHRlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vZXNjYXBlIGRvbGxhclxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSh5UGF0dGVybldpdGhvdXRQcmVjaXNpb24sIGl0ZW0uc2VyaWVzLnlheGlzLnRpY2tGb3JtYXR0ZXIoeSwgaXRlbS5zZXJpZXMueWF4aXMpLnJlcGxhY2UoL1xcJC9nLCAnJCQnKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICB9O1xuXG4gICAgLy8gaGVscGVycyBqdXN0IGZvciByZWFkYWJpbGl0eVxuICAgIEZsb3RUb29sdGlwLnByb3RvdHlwZS5pc1RpbWVNb2RlID0gZnVuY3Rpb24gKGF4aXNOYW1lLCBpdGVtKSB7XG4gICAgICAgIHJldHVybiAodHlwZW9mIGl0ZW0uc2VyaWVzW2F4aXNOYW1lXS5vcHRpb25zLm1vZGUgIT09ICd1bmRlZmluZWQnICYmIGl0ZW0uc2VyaWVzW2F4aXNOYW1lXS5vcHRpb25zLm1vZGUgPT09ICd0aW1lJyk7XG4gICAgfTtcblxuICAgIEZsb3RUb29sdGlwLnByb3RvdHlwZS5pc1hEYXRlRm9ybWF0ID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgdGhpcy50b29sdGlwT3B0aW9ucy54RGF0ZUZvcm1hdCAhPT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy50b29sdGlwT3B0aW9ucy54RGF0ZUZvcm1hdCAhPT0gbnVsbCk7XG4gICAgfTtcblxuICAgIEZsb3RUb29sdGlwLnByb3RvdHlwZS5pc1lEYXRlRm9ybWF0ID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgdGhpcy50b29sdGlwT3B0aW9ucy55RGF0ZUZvcm1hdCAhPT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy50b29sdGlwT3B0aW9ucy55RGF0ZUZvcm1hdCAhPT0gbnVsbCk7XG4gICAgfTtcblxuICAgIEZsb3RUb29sdGlwLnByb3RvdHlwZS5pc0NhdGVnb3JpZXNNb2RlID0gZnVuY3Rpb24gKGF4aXNOYW1lLCBpdGVtKSB7XG4gICAgICAgIHJldHVybiAodHlwZW9mIGl0ZW0uc2VyaWVzW2F4aXNOYW1lXS5vcHRpb25zLm1vZGUgIT09ICd1bmRlZmluZWQnICYmIGl0ZW0uc2VyaWVzW2F4aXNOYW1lXS5vcHRpb25zLm1vZGUgPT09ICdjYXRlZ29yaWVzJyk7XG4gICAgfTtcblxuICAgIC8vXG4gICAgRmxvdFRvb2x0aXAucHJvdG90eXBlLnRpbWVzdGFtcFRvRGF0ZSA9IGZ1bmN0aW9uICh0bXN0LCBkYXRlRm9ybWF0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB0aGVEYXRlID0gJC5wbG90LmRhdGVHZW5lcmF0b3IodG1zdCwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiAkLnBsb3QuZm9ybWF0RGF0ZSh0aGVEYXRlLCBkYXRlRm9ybWF0LCB0aGlzLnRvb2x0aXBPcHRpb25zLm1vbnRoTmFtZXMsIHRoaXMudG9vbHRpcE9wdGlvbnMuZGF5TmFtZXMpO1xuICAgIH07XG5cbiAgICAvL1xuICAgIEZsb3RUb29sdGlwLnByb3RvdHlwZS5hZGp1c3RWYWxQcmVjaXNpb24gPSBmdW5jdGlvbiAocGF0dGVybiwgY29udGVudCwgdmFsdWUpIHtcblxuICAgICAgICB2YXIgcHJlY2lzaW9uO1xuICAgICAgICB2YXIgbWF0Y2hSZXN1bHQgPSBjb250ZW50Lm1hdGNoKHBhdHRlcm4pO1xuICAgICAgICBpZiggbWF0Y2hSZXN1bHQgIT09IG51bGwgKSB7XG4gICAgICAgICAgICBpZihSZWdFeHAuJDEgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uID0gUmVnRXhwLiQxO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9GaXhlZChwcmVjaXNpb24pO1xuXG4gICAgICAgICAgICAgICAgLy8gb25seSByZXBsYWNlIGNvbnRlbnQgaWYgcHJlY2lzaW9uIGV4aXN0cywgaW4gb3RoZXIgY2FzZSB1c2UgdGhpY2tmb3JtYXRlclxuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UocGF0dGVybiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH07XG5cbiAgICAvLyBvdGhlciBwbHVnaW5zIGRldGVjdGlvbiBiZWxvd1xuXG4gICAgLy8gY2hlY2sgaWYgZmxvdC1heGlzbGFiZWxzIHBsdWdpbiAoaHR0cHM6Ly9naXRodWIuY29tL21hcmtyY290ZS9mbG90LWF4aXNsYWJlbHMpIGlzIHVzZWQgYW5kIHRoYXQgYW4gYXhpcyBsYWJlbCBpcyBnaXZlblxuICAgIEZsb3RUb29sdGlwLnByb3RvdHlwZS5oYXNBeGlzTGFiZWwgPSBmdW5jdGlvbiAoYXhpc05hbWUsIGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuICgkLmluQXJyYXkoJ2F4aXNMYWJlbHMnLCB0aGlzLnBsb3RQbHVnaW5zKSAhPT0gLTEgJiYgdHlwZW9mIGl0ZW0uc2VyaWVzW2F4aXNOYW1lXS5vcHRpb25zLmF4aXNMYWJlbCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXRlbS5zZXJpZXNbYXhpc05hbWVdLm9wdGlvbnMuYXhpc0xhYmVsLmxlbmd0aCA+IDApO1xuICAgIH07XG5cbiAgICAvLyBjaGVjayB3aGV0aGVyIGZsb3QtdGlja1JvdG9yLCBhIHBsdWdpbiB3aGljaCBhbGxvd3Mgcm90YXRpb24gb2YgWC1heGlzIHRpY2tzLCBpcyBiZWluZyB1c2VkXG4gICAgRmxvdFRvb2x0aXAucHJvdG90eXBlLmhhc1JvdGF0ZWRYQXhpc1RpY2tzID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuICgkLmluQXJyYXkoJ3RpY2tSb3RvcicsdGhpcy5wbG90UGx1Z2lucykgIT09IC0xICYmIHR5cGVvZiBpdGVtLnNlcmllcy54YXhpcy5yb3RhdGVkVGlja3MgIT09ICd1bmRlZmluZWQnKTtcbiAgICB9O1xuXG4gICAgLy9cbiAgICB2YXIgaW5pdCA9IGZ1bmN0aW9uIChwbG90KSB7XG4gICAgICBuZXcgRmxvdFRvb2x0aXAocGxvdCk7XG4gICAgfTtcblxuICAgIC8vIGRlZmluZSBGbG90IHBsdWdpblxuICAgICQucGxvdC5wbHVnaW5zLnB1c2goe1xuICAgICAgICBpbml0OiBpbml0LFxuICAgICAgICBvcHRpb25zOiBkZWZhdWx0T3B0aW9ucyxcbiAgICAgICAgbmFtZTogJ3Rvb2x0aXAnLFxuICAgICAgICB2ZXJzaW9uOiAnMC44LjUnXG4gICAgfSk7XG5cbn0pKGpRdWVyeSk7XG4iLCIvLyBTb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5LW1vdXNld2hlZWwvYmxvYi9hMDZlZjRlMWExMjc3OTU2MDY2NDJjNTVlMjJkNGYyOTQ1ZWRjMDYxL2pxdWVyeS5tb3VzZXdoZWVsLmpzXG5cbi8qISBDb3B5cmlnaHQgKGMpIDIwMTEgQnJhbmRvbiBBYXJvbiAoaHR0cDovL2JyYW5kb25hYXJvbi5uZXQpXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKExJQ0VOU0UudHh0KS5cbiAqXG4gKiBUaGFua3MgdG86IGh0dHA6Ly9hZG9tYXMub3JnL2phdmFzY3JpcHQtbW91c2Utd2hlZWwvIGZvciBzb21lIHBvaW50ZXJzLlxuICogVGhhbmtzIHRvOiBNYXRoaWFzIEJhbmsoaHR0cDovL3d3dy5tYXRoaWFzLWJhbmsuZGUpIGZvciBhIHNjb3BlIGJ1ZyBmaXguXG4gKiBUaGFua3MgdG86IFNlYW11cyBMZWFoeSBmb3IgYWRkaW5nIGRlbHRhWCBhbmQgZGVsdGFZXG4gKlxuICogVmVyc2lvbjogMy4wLjZcbiAqXG4gKiBSZXF1aXJlczogMS4yLjIrXG4gKi9cblxuKGZ1bmN0aW9uKCQpIHtcblxudmFyIHR5cGVzID0gWydET01Nb3VzZVNjcm9sbCcsICdtb3VzZXdoZWVsJ107XG5cbmlmICgkLmV2ZW50LmZpeEhvb2tzKSB7XG4gICAgZm9yICggdmFyIGk9dHlwZXMubGVuZ3RoOyBpOyApIHtcbiAgICAgICAgJC5ldmVudC5maXhIb29rc1sgdHlwZXNbLS1pXSBdID0gJC5ldmVudC5tb3VzZUhvb2tzO1xuICAgIH1cbn1cblxuJC5ldmVudC5zcGVjaWFsLm1vdXNld2hlZWwgPSB7XG4gICAgc2V0dXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciApIHtcbiAgICAgICAgICAgIGZvciAoIHZhciBpPXR5cGVzLmxlbmd0aDsgaTsgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCB0eXBlc1stLWldLCBoYW5kbGVyLCBmYWxzZSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vbm1vdXNld2hlZWwgPSBoYW5kbGVyO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHRlYXJkb3duOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XG4gICAgICAgICAgICBmb3IgKCB2YXIgaT10eXBlcy5sZW5ndGg7IGk7ICkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZXNbLS1pXSwgaGFuZGxlciwgZmFsc2UgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub25tb3VzZXdoZWVsID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbiQuZm4uZXh0ZW5kKHtcbiAgICBtb3VzZXdoZWVsOiBmdW5jdGlvbihmbikge1xuICAgICAgICByZXR1cm4gZm4gPyB0aGlzLmJpbmQoXCJtb3VzZXdoZWVsXCIsIGZuKSA6IHRoaXMudHJpZ2dlcihcIm1vdXNld2hlZWxcIik7XG4gICAgfSxcblxuICAgIHVubW91c2V3aGVlbDogZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5iaW5kKFwibW91c2V3aGVlbFwiLCBmbik7XG4gICAgfVxufSk7XG5cblxuZnVuY3Rpb24gaGFuZGxlcihldmVudCkge1xuICAgIHZhciBvcmdFdmVudCA9IGV2ZW50IHx8IHdpbmRvdy5ldmVudCwgYXJncyA9IFtdLnNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApLCBkZWx0YSA9IDAsIHJldHVyblZhbHVlID0gdHJ1ZSwgZGVsdGFYID0gMCwgZGVsdGFZID0gMDtcbiAgICBldmVudCA9ICQuZXZlbnQuZml4KG9yZ0V2ZW50KTtcbiAgICBldmVudC50eXBlID0gXCJtb3VzZXdoZWVsXCI7XG5cbiAgICAvLyBPbGQgc2Nob29sIHNjcm9sbHdoZWVsIGRlbHRhXG4gICAgaWYgKCBvcmdFdmVudC53aGVlbERlbHRhICkgeyBkZWx0YSA9IG9yZ0V2ZW50LndoZWVsRGVsdGEvMTIwOyB9XG4gICAgaWYgKCBvcmdFdmVudC5kZXRhaWwgICAgICkgeyBkZWx0YSA9IC1vcmdFdmVudC5kZXRhaWwvMzsgfVxuXG4gICAgLy8gTmV3IHNjaG9vbCBtdWx0aWRpbWVuc2lvbmFsIHNjcm9sbCAodG91Y2hwYWRzKSBkZWx0YXNcbiAgICBkZWx0YVkgPSBkZWx0YTtcblxuICAgIC8vIEdlY2tvXG4gICAgaWYgKCBvcmdFdmVudC5heGlzICE9PSB1bmRlZmluZWQgJiYgb3JnRXZlbnQuYXhpcyA9PT0gb3JnRXZlbnQuSE9SSVpPTlRBTF9BWElTICkge1xuICAgICAgICBkZWx0YVkgPSAwO1xuICAgICAgICBkZWx0YVggPSAtMSpkZWx0YTtcbiAgICB9XG5cbiAgICAvLyBXZWJraXRcbiAgICBpZiAoIG9yZ0V2ZW50LndoZWVsRGVsdGFZICE9PSB1bmRlZmluZWQgKSB7IGRlbHRhWSA9IG9yZ0V2ZW50LndoZWVsRGVsdGFZLzEyMDsgfVxuICAgIGlmICggb3JnRXZlbnQud2hlZWxEZWx0YVggIT09IHVuZGVmaW5lZCApIHsgZGVsdGFYID0gLTEqb3JnRXZlbnQud2hlZWxEZWx0YVgvMTIwOyB9XG5cbiAgICAvLyBBZGQgZXZlbnQgYW5kIGRlbHRhIHRvIHRoZSBmcm9udCBvZiB0aGUgYXJndW1lbnRzXG4gICAgYXJncy51bnNoaWZ0KGV2ZW50LCBkZWx0YSwgZGVsdGFYLCBkZWx0YVkpO1xuXG4gICAgcmV0dXJuICgkLmV2ZW50LmRpc3BhdGNoIHx8ICQuZXZlbnQuaGFuZGxlKS5hcHBseSh0aGlzLCBhcmdzKTtcbn1cblxufSkoalF1ZXJ5KTtcbiIsIi8qKiAjIyBqcXVlcnkuZmxvdC5jYW52YXN3cmFwcGVyXG5cblRoaXMgcGx1Z2luIGNvbnRhaW5zIHRoZSBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYW5kIG1hbmlwdWxhdGluZyBib3RoIHRoZSBjYW52YXNcbmxheWVycyBhbmQgc3ZnIGxheWVycy5cblxuVGhlIENhbnZhcyBvYmplY3QgaXMgYSB3cmFwcGVyIGFyb3VuZCBhbiBIVE1MNSBjYW52YXMgdGFnLlxuVGhlIGNvbnN0cnVjdG9yIENhbnZhcyhjbHMsIGNvbnRhaW5lcikgdGFrZXMgYXMgcGFyYW1ldGVycyBjbHMsXG50aGUgbGlzdCBvZiBjbGFzc2VzIHRvIGFwcGx5IHRvIHRoZSBjYW52YXMgYWRuZCB0aGUgY29udGFpbnRlcixcbmVsZW1lbnQgb250byB3aGljaCB0byBhcHBlbmQgdGhlIGNhbnZhcy4gVGhlIGNhbnZhcyBvcGVyYXRpb25zXG5kb24ndCB3b3JrIHVubGVzcyB0aGUgY2FudmFzIGlzIGF0dGFjaGVkIHRvIHRoZSBET00uXG5cbiMjIyBqcXVlcnkuY2FudmFzd3JhcHBlci5qcyBBUEkgZnVuY3Rpb25zXG4qL1xuXG4oZnVuY3Rpb24oJCkge1xuICAgIHZhciBDYW52YXMgPSBmdW5jdGlvbihjbHMsIGNvbnRhaW5lcikge1xuICAgICAgICB2YXIgZWxlbWVudCA9IGNvbnRhaW5lci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGNscylbMF07XG5cbiAgICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGNscztcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuZGlyZWN0aW9uID0gJ2x0cic7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUubGVmdCA9ICcwcHgnO1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS50b3AgPSAnMHB4JztcblxuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAvLyBJZiBIVE1MNSBDYW52YXMgaXNuJ3QgYXZhaWxhYmxlLCB0aHJvd1xuXG4gICAgICAgICAgICBpZiAoIWVsZW1lbnQuZ2V0Q29udGV4dCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FudmFzIGlzIG5vdCBhdmFpbGFibGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuXG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0ID0gZWxlbWVudC5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB0aGlzLnBpeGVsUmF0aW8gPSAkLnBsb3QuYnJvd3Nlci5nZXRQaXhlbFJhdGlvKGNvbnRleHQpO1xuXG4gICAgICAgIC8vIFNpemUgdGhlIGNhbnZhcyB0byBtYXRjaCB0aGUgaW50ZXJuYWwgZGltZW5zaW9ucyBvZiBpdHMgY29udGFpbmVyXG4gICAgICAgIHZhciB3aWR0aCA9ICQoY29udGFpbmVyKS53aWR0aCgpO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gJChjb250YWluZXIpLmhlaWdodCgpO1xuICAgICAgICB0aGlzLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICAvLyBDb2xsZWN0aW9uIG9mIEhUTUwgZGl2IGxheWVycyBmb3IgdGV4dCBvdmVybGFpZCBvbnRvIHRoZSBjYW52YXNcblxuICAgICAgICB0aGlzLlNWR0NvbnRhaW5lciA9IG51bGw7XG4gICAgICAgIHRoaXMuU1ZHID0ge307XG5cbiAgICAgICAgLy8gQ2FjaGUgb2YgdGV4dCBmcmFnbWVudHMgYW5kIG1ldHJpY3MsIHNvIHdlIGNhbiBhdm9pZCBleHBlbnNpdmVseVxuICAgICAgICAvLyByZS1jYWxjdWxhdGluZyB0aGVtIHdoZW4gdGhlIHBsb3QgaXMgcmUtcmVuZGVyZWQgaW4gYSBsb29wLlxuXG4gICAgICAgIHRoaXMuX3RleHRDYWNoZSA9IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgIC0gcmVzaXplKHdpZHRoLCBoZWlnaHQpXG5cbiAgICAgUmVzaXplcyB0aGUgY2FudmFzIHRvIHRoZSBnaXZlbiBkaW1lbnNpb25zLlxuICAgICBUaGUgd2lkdGggcmVwcmVzZW50cyB0aGUgbmV3IHdpZHRoIG9mIHRoZSBjYW52YXMsIG1lYW53aGlsZSB0aGUgaGVpZ2h0XG4gICAgIGlzIHRoZSBuZXcgaGVpZ2h0IG9mIHRoZSBjYW52YXMsIGJvdGggb2YgdGhlbSBpbiBwaXhlbHMuXG4gICAgKi9cblxuICAgIENhbnZhcy5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgbWluU2l6ZSA9IDEwO1xuICAgICAgICB3aWR0aCA9IHdpZHRoIDwgbWluU2l6ZSA/IG1pblNpemUgOiB3aWR0aDtcbiAgICAgICAgaGVpZ2h0ID0gaGVpZ2h0IDwgbWluU2l6ZSA/IG1pblNpemUgOiBoZWlnaHQ7XG5cbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsXG4gICAgICAgICAgICBjb250ZXh0ID0gdGhpcy5jb250ZXh0LFxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IHRoaXMucGl4ZWxSYXRpbztcblxuICAgICAgICAvLyBSZXNpemUgdGhlIGNhbnZhcywgaW5jcmVhc2luZyBpdHMgZGVuc2l0eSBiYXNlZCBvbiB0aGUgZGlzcGxheSdzXG4gICAgICAgIC8vIHBpeGVsIHJhdGlvOyBiYXNpY2FsbHkgZ2l2aW5nIGl0IG1vcmUgcGl4ZWxzIHdpdGhvdXQgaW5jcmVhc2luZyB0aGVcbiAgICAgICAgLy8gc2l6ZSBvZiBpdHMgZWxlbWVudCwgdG8gdGFrZSBhZHZhbnRhZ2Ugb2YgdGhlIGZhY3QgdGhhdCByZXRpbmFcbiAgICAgICAgLy8gZGlzcGxheXMgaGF2ZSB0aGF0IG1hbnkgbW9yZSBwaXhlbHMgaW4gdGhlIHNhbWUgYWR2ZXJ0aXNlZCBzcGFjZS5cblxuICAgICAgICAvLyBSZXNpemluZyBzaG91bGQgcmVzZXQgdGhlIHN0YXRlIChleGNhbnZhcyBzZWVtcyB0byBiZSBidWdneSB0aG91Z2gpXG5cbiAgICAgICAgaWYgKHRoaXMud2lkdGggIT09IHdpZHRoKSB7XG4gICAgICAgICAgICBlbGVtZW50LndpZHRoID0gd2lkdGggKiBwaXhlbFJhdGlvO1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmhlaWdodCAhPT0gaGVpZ2h0KSB7XG4gICAgICAgICAgICBlbGVtZW50LmhlaWdodCA9IGhlaWdodCAqIHBpeGVsUmF0aW87XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNhdmUgdGhlIGNvbnRleHQsIHNvIHdlIGNhbiByZXNldCBpbiBjYXNlIHdlIGdldCByZXBsb3R0ZWQuICBUaGVcbiAgICAgICAgLy8gcmVzdG9yZSBlbnN1cmUgdGhhdCB3ZSdyZSByZWFsbHkgYmFjayBhdCB0aGUgaW5pdGlhbCBzdGF0ZSwgYW5kXG4gICAgICAgIC8vIHNob3VsZCBiZSBzYWZlIGV2ZW4gaWYgd2UgaGF2ZW4ndCBzYXZlZCB0aGUgaW5pdGlhbCBzdGF0ZSB5ZXQuXG5cbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuXG4gICAgICAgIC8vIFNjYWxlIHRoZSBjb29yZGluYXRlIHNwYWNlIHRvIG1hdGNoIHRoZSBkaXNwbGF5IGRlbnNpdHk7IHNvIGV2ZW4gdGhvdWdoIHdlXG4gICAgICAgIC8vIG1heSBoYXZlIHR3aWNlIGFzIG1hbnkgcGl4ZWxzLCB3ZSBzdGlsbCB3YW50IGxpbmVzIGFuZCBvdGhlciBkcmF3aW5nIHRvXG4gICAgICAgIC8vIGFwcGVhciBhdCB0aGUgc2FtZSBzaXplOyB0aGUgZXh0cmEgcGl4ZWxzIHdpbGwganVzdCBtYWtlIHRoZW0gY3Jpc3Blci5cblxuICAgICAgICBjb250ZXh0LnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAtIGNsZWFyKClcblxuICAgICBDbGVhcnMgdGhlIGVudGlyZSBjYW52YXMgYXJlYSwgbm90IGluY2x1ZGluZyBhbnkgb3ZlcmxhaWQgSFRNTCB0ZXh0XG4gICAgKi9cbiAgICBDYW52YXMucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAtIHJlbmRlcigpXG5cbiAgICAgRmluaXNoZXMgcmVuZGVyaW5nIHRoZSBjYW52YXMsIGluY2x1ZGluZyBtYW5hZ2luZyB0aGUgdGV4dCBvdmVybGF5LlxuICAgICovXG4gICAgQ2FudmFzLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gdGhpcy5fdGV4dENhY2hlO1xuXG4gICAgICAgIC8vIEZvciBlYWNoIHRleHQgbGF5ZXIsIGFkZCBlbGVtZW50cyBtYXJrZWQgYXMgYWN0aXZlIHRoYXQgaGF2ZW4ndFxuICAgICAgICAvLyBhbHJlYWR5IGJlZW4gcmVuZGVyZWQsIGFuZCByZW1vdmUgdGhvc2UgdGhhdCBhcmUgbm8gbG9uZ2VyIGFjdGl2ZS5cblxuICAgICAgICBmb3IgKHZhciBsYXllcktleSBpbiBjYWNoZSkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY2FjaGUsIGxheWVyS2V5KSkge1xuICAgICAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXMuZ2V0U1ZHTGF5ZXIobGF5ZXJLZXkpLFxuICAgICAgICAgICAgICAgICAgICBsYXllckNhY2hlID0gY2FjaGVbbGF5ZXJLZXldO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRpc3BsYXkgPSBsYXllci5zdHlsZS5kaXNwbGF5O1xuICAgICAgICAgICAgICAgIGxheWVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBzdHlsZUtleSBpbiBsYXllckNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGxheWVyQ2FjaGUsIHN0eWxlS2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0eWxlQ2FjaGUgPSBsYXllckNhY2hlW3N0eWxlS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBzdHlsZUNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc3R5bGVDYWNoZSwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gc3R5bGVDYWNoZVtrZXldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25zID0gdmFsLnBvc2l0aW9ucztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgcG9zaXRpb247IHBvc2l0aW9uc1tpXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbi5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBvc2l0aW9uLnJlbmRlcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyLmFwcGVuZENoaWxkKHBvc2l0aW9uLmVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbi5yZW5kZXJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbnMuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uLnJlbmRlcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChwb3NpdGlvbi5lbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uLmVsZW1lbnQucmVtb3ZlQ2hpbGQocG9zaXRpb24uZWxlbWVudC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbi5lbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocG9zaXRpb24uZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwubWVhc3VyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwubWVhc3VyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHN0eWxlQ2FjaGVba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxheWVyLnN0eWxlLmRpc3BsYXkgPSBkaXNwbGF5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgIC0gZ2V0U1ZHTGF5ZXIoY2xhc3NlcylcblxuICAgICBDcmVhdGVzIChpZiBuZWNlc3NhcnkpIGFuZCByZXR1cm5zIHRoZSBTVkcgb3ZlcmxheSBjb250YWluZXIuXG4gICAgIFRoZSBjbGFzc2VzIHN0cmluZyByZXByZXNlbnRzIHRoZSBzdHJpbmcgb2Ygc3BhY2Utc2VwYXJhdGVkIENTUyBjbGFzc2VzXG4gICAgIHVzZWQgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhlIHRleHQgbGF5ZXIuIEl0IHJldHVybiB0aGUgc3ZnLWxheWVyIGRpdi5cbiAgICAqL1xuICAgIENhbnZhcy5wcm90b3R5cGUuZ2V0U1ZHTGF5ZXIgPSBmdW5jdGlvbihjbGFzc2VzKSB7XG4gICAgICAgIHZhciBsYXllciA9IHRoaXMuU1ZHW2NsYXNzZXNdO1xuXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgU1ZHIGxheWVyIGlmIGl0IGRvZXNuJ3QgZXhpc3RcblxuICAgICAgICBpZiAoIWxheWVyKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIHN2ZyBsYXllciBjb250YWluZXIsIGlmIGl0IGRvZXNuJ3QgZXhpc3RcblxuICAgICAgICAgICAgdmFyIHN2Z0VsZW1lbnQ7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5TVkdDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLlNWR0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgIHRoaXMuU1ZHQ29udGFpbmVyLmNsYXNzTmFtZSA9ICdmbG90LXN2Zyc7XG4gICAgICAgICAgICAgICAgdGhpcy5TVkdDb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgICAgICAgIHRoaXMuU1ZHQ29udGFpbmVyLnN0eWxlLnRvcCA9ICcwcHgnO1xuICAgICAgICAgICAgICAgIHRoaXMuU1ZHQ29udGFpbmVyLnN0eWxlLmxlZnQgPSAnMHB4JztcbiAgICAgICAgICAgICAgICB0aGlzLlNWR0NvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgICAgICAgICAgICAgdGhpcy5TVkdDb250YWluZXIuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICAgICAgICAgICAgdGhpcy5TVkdDb250YWluZXIuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0aGlzLlNWR0NvbnRhaW5lcik7XG5cbiAgICAgICAgICAgICAgICBzdmdFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdzdmcnKTtcbiAgICAgICAgICAgICAgICBzdmdFbGVtZW50LnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICAgICAgICAgIHN2Z0VsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5TVkdDb250YWluZXIuYXBwZW5kQ2hpbGQoc3ZnRWxlbWVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN2Z0VsZW1lbnQgPSB0aGlzLlNWR0NvbnRhaW5lci5maXJzdENoaWxkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsYXllciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAnZycpO1xuICAgICAgICAgICAgbGF5ZXIuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNsYXNzZXMpO1xuICAgICAgICAgICAgbGF5ZXIuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgICAgbGF5ZXIuc3R5bGUudG9wID0gJzBweCc7XG4gICAgICAgICAgICBsYXllci5zdHlsZS5sZWZ0ID0gJzBweCc7XG4gICAgICAgICAgICBsYXllci5zdHlsZS5ib3R0b20gPSAnMHB4JztcbiAgICAgICAgICAgIGxheWVyLnN0eWxlLnJpZ2h0ID0gJzBweCc7XG4gICAgICAgICAgICBzdmdFbGVtZW50LmFwcGVuZENoaWxkKGxheWVyKTtcbiAgICAgICAgICAgIHRoaXMuU1ZHW2NsYXNzZXNdID0gbGF5ZXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGF5ZXI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgIC0gZ2V0VGV4dEluZm8obGF5ZXIsIHRleHQsIGZvbnQsIGFuZ2xlLCB3aWR0aClcblxuICAgICBDcmVhdGVzIChpZiBuZWNlc3NhcnkpIGFuZCByZXR1cm5zIGEgdGV4dCBpbmZvIG9iamVjdC5cbiAgICAgVGhlIG9iamVjdCBsb29rcyBsaWtlIHRoaXM6XG4gICAgIGBgYGpzXG4gICAgIHtcbiAgICAgICAgIHdpZHRoIC8vV2lkdGggb2YgdGhlIHRleHQncyB3cmFwcGVyIGRpdi5cbiAgICAgICAgIGhlaWdodCAvL0hlaWdodCBvZiB0aGUgdGV4dCdzIHdyYXBwZXIgZGl2LlxuICAgICAgICAgZWxlbWVudCAvL1RoZSBIVE1MIGRpdiBjb250YWluaW5nIHRoZSB0ZXh0LlxuICAgICAgICAgcG9zaXRpb25zIC8vQXJyYXkgb2YgcG9zaXRpb25zIGF0IHdoaWNoIHRoaXMgdGV4dCBpcyBkcmF3bi5cbiAgICAgIH1cbiAgICAgIGBgYFxuICAgICAgVGhlIHBvc2l0aW9ucyBhcnJheSBjb250YWlucyBvYmplY3RzIHRoYXQgbG9vayBsaWtlIHRoaXM6XG4gICAgICBgYGBqc1xuICAgICAge1xuICAgICAgICAgYWN0aXZlIC8vRmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHRleHQgc2hvdWxkIGJlIHZpc2libGUuXG4gICAgICAgICByZW5kZXJlZCAvL0ZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSB0ZXh0IGlzIGN1cnJlbnRseSB2aXNpYmxlLlxuICAgICAgICAgZWxlbWVudCAvL1RoZSBIVE1MIGRpdiBjb250YWluaW5nIHRoZSB0ZXh0LlxuICAgICAgICAgdGV4dCAvL1RoZSBhY3R1YWwgdGV4dCBhbmQgaXMgaWRlbnRpY2FsIHdpdGggZWxlbWVudFswXS50ZXh0Q29udGVudC5cbiAgICAgICAgIHggLy9YIGNvb3JkaW5hdGUgYXQgd2hpY2ggdG8gZHJhdyB0aGUgdGV4dC5cbiAgICAgICAgIHkgLy9ZIGNvb3JkaW5hdGUgYXQgd2hpY2ggdG8gZHJhdyB0aGUgdGV4dC5cbiAgICAgIH1cbiAgICAgIGBgYFxuICAgICAgRWFjaCBwb3NpdGlvbiBhZnRlciB0aGUgZmlyc3QgcmVjZWl2ZXMgYSBjbG9uZSBvZiB0aGUgb3JpZ2luYWwgZWxlbWVudC5cbiAgICAgIFRoZSBpZGVhIGlzIHRoYXQgdGhhdCB0aGUgd2lkdGgsIGhlaWdodCwgYW5kIGdlbmVyYWwgJ2lkZW50aXR5JyBvZiB0aGVcbiAgICAgIHRleHQgaXMgY29uc3RhbnQgbm8gbWF0dGVyIHdoZXJlIGl0IGlzIHBsYWNlZDsgdGhlIHBsYWNlbWVudHMgYXJlIGFcbiAgICAgIHNlY29uZGFyeSBwcm9wZXJ0eS5cblxuICAgICAgQ2FudmFzIG1haW50YWlucyBhIGNhY2hlIG9mIHJlY2VudGx5LXVzZWQgdGV4dCBpbmZvIG9iamVjdHM7IGdldFRleHRJbmZvXG4gICAgICBlaXRoZXIgcmV0dXJucyB0aGUgY2FjaGVkIGVsZW1lbnQgb3IgY3JlYXRlcyBhIG5ldyBlbnRyeS5cblxuICAgICBUaGUgbGF5ZXIgcGFyYW1ldGVyIGlzIHN0cmluZyBvZiBzcGFjZS1zZXBhcmF0ZWQgQ1NTIGNsYXNzZXMgdW5pcXVlbHlcbiAgICAgaWRlbnRpZnlpbmcgdGhlIGxheWVyIGNvbnRhaW5pbmcgdGhpcyB0ZXh0LlxuICAgICBUZXh0IGlzIHRoZSB0ZXh0IHN0cmluZyB0byByZXRyaWV2ZSBpbmZvIGZvci5cbiAgICAgRm9udCBpcyBlaXRoZXIgYSBzdHJpbmcgb2Ygc3BhY2Utc2VwYXJhdGVkIENTUyBjbGFzc2VzIG9yIGEgZm9udC1zcGVjIG9iamVjdCxcbiAgICAgZGVmaW5pbmcgdGhlIHRleHQncyBmb250IGFuZCBzdHlsZS5cbiAgICAgQW5nbGUgaXMgdGhlIGFuZ2xlIGF0IHdoaWNoIHRvIHJvdGF0ZSB0aGUgdGV4dCwgaW4gZGVncmVlcy4gQW5nbGUgaXMgY3VycmVudGx5IHVudXNlZCxcbiAgICAgaXQgd2lsbCBiZSBpbXBsZW1lbnRlZCBpbiB0aGUgZnV0dXJlLlxuICAgICBUaGUgbGFzdCBwYXJhbWV0ZXIgaXMgdGhlIE1heGltdW0gd2lkdGggb2YgdGhlIHRleHQgYmVmb3JlIGl0IHdyYXBzLlxuICAgICBUaGUgbWV0aG9kIHJldHVybnMgYSB0ZXh0IGluZm8gb2JqZWN0LlxuICAgICovXG4gICAgQ2FudmFzLnByb3RvdHlwZS5nZXRUZXh0SW5mbyA9IGZ1bmN0aW9uKGxheWVyLCB0ZXh0LCBmb250LCBhbmdsZSwgd2lkdGgpIHtcbiAgICAgICAgdmFyIHRleHRTdHlsZSwgbGF5ZXJDYWNoZSwgc3R5bGVDYWNoZSwgaW5mbztcblxuICAgICAgICAvLyBDYXN0IHRoZSB2YWx1ZSB0byBhIHN0cmluZywgaW4gY2FzZSB3ZSB3ZXJlIGdpdmVuIGEgbnVtYmVyIG9yIHN1Y2hcblxuICAgICAgICB0ZXh0ID0gJycgKyB0ZXh0O1xuXG4gICAgICAgIC8vIElmIHRoZSBmb250IGlzIGEgZm9udC1zcGVjIG9iamVjdCwgZ2VuZXJhdGUgYSBDU1MgZm9udCBkZWZpbml0aW9uXG5cbiAgICAgICAgaWYgKHR5cGVvZiBmb250ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGV4dFN0eWxlID0gZm9udC5zdHlsZSArICcgJyArIGZvbnQudmFyaWFudCArICcgJyArIGZvbnQud2VpZ2h0ICsgJyAnICsgZm9udC5zaXplICsgJ3B4LycgKyBmb250LmxpbmVIZWlnaHQgKyAncHggJyArIGZvbnQuZmFtaWx5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGV4dFN0eWxlID0gZm9udDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJldHJpZXZlIChvciBjcmVhdGUpIHRoZSBjYWNoZSBmb3IgdGhlIHRleHQncyBsYXllciBhbmQgc3R5bGVzXG5cbiAgICAgICAgbGF5ZXJDYWNoZSA9IHRoaXMuX3RleHRDYWNoZVtsYXllcl07XG5cbiAgICAgICAgaWYgKGxheWVyQ2FjaGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgbGF5ZXJDYWNoZSA9IHRoaXMuX3RleHRDYWNoZVtsYXllcl0gPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0eWxlQ2FjaGUgPSBsYXllckNhY2hlW3RleHRTdHlsZV07XG5cbiAgICAgICAgaWYgKHN0eWxlQ2FjaGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgc3R5bGVDYWNoZSA9IGxheWVyQ2FjaGVbdGV4dFN0eWxlXSA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGtleSA9IGdlbmVyYXRlS2V5KHRleHQpO1xuICAgICAgICBpbmZvID0gc3R5bGVDYWNoZVtrZXldO1xuXG4gICAgICAgIC8vIElmIHdlIGNhbid0IGZpbmQgYSBtYXRjaGluZyBlbGVtZW50IGluIG91ciBjYWNoZSwgY3JlYXRlIGEgbmV3IG9uZVxuXG4gICAgICAgIGlmICghaW5mbykge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ3RleHQnKTtcbiAgICAgICAgICAgIGlmICh0ZXh0LmluZGV4T2YoJzxicj4nKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBhZGRUc3BhbkVsZW1lbnRzKHRleHQsIGVsZW1lbnQsIC05OTk5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCk7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZCh0ZXh0Tm9kZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5tYXhXaWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneCcsIC05OTk5KTtcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3knLCAtOTk5OSk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZm9udCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLmZvbnQgPSB0ZXh0U3R5bGU7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5maWxsID0gZm9udC5maWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZm9udCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBmb250KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5nZXRTVkdMYXllcihsYXllcikuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgICAgICB2YXIgZWxlbWVudFJlY3QgPSBlbGVtZW50LmdldEJCb3goKTtcblxuICAgICAgICAgICAgaW5mbyA9IHN0eWxlQ2FjaGVba2V5XSA9IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogZWxlbWVudFJlY3Qud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBlbGVtZW50UmVjdC5oZWlnaHQsXG4gICAgICAgICAgICAgICAgbWVhc3VyZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbnM6IFtdXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvL3JlbW92ZSBlbGVtZW50cyBmcm9tIGRvbVxuICAgICAgICAgICAgd2hpbGUgKGVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQ2hpbGQoZWxlbWVudC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZm8ubWVhc3VyZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gaW5mbztcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gdXBkYXRlVHJhbnNmb3JtcyAoZWxlbWVudCwgdHJhbnNmb3Jtcykge1xuICAgICAgICBlbGVtZW50LnRyYW5zZm9ybS5iYXNlVmFsLmNsZWFyKCk7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1zKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1zLmZvckVhY2goZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQudHJhbnNmb3JtLmJhc2VWYWwuYXBwZW5kSXRlbSh0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgLSBhZGRUZXh0IChsYXllciwgeCwgeSwgdGV4dCwgZm9udCwgYW5nbGUsIHdpZHRoLCBoYWxpZ24sIHZhbGlnbiwgdHJhbnNmb3JtcylcblxuICAgICBBZGRzIGEgdGV4dCBzdHJpbmcgdG8gdGhlIGNhbnZhcyB0ZXh0IG92ZXJsYXkuXG4gICAgIFRoZSB0ZXh0IGlzbid0IGRyYXduIGltbWVkaWF0ZWx5OyBpdCBpcyBtYXJrZWQgYXMgcmVuZGVyaW5nLCB3aGljaCB3aWxsXG4gICAgIHJlc3VsdCBpbiBpdHMgYWRkaXRpb24gdG8gdGhlIGNhbnZhcyBvbiB0aGUgbmV4dCByZW5kZXIgcGFzcy5cblxuICAgICBUaGUgbGF5ZXIgaXMgc3RyaW5nIG9mIHNwYWNlLXNlcGFyYXRlZCBDU1MgY2xhc3NlcyB1bmlxdWVseVxuICAgICBpZGVudGlmeWluZyB0aGUgbGF5ZXIgY29udGFpbmluZyB0aGlzIHRleHQuXG4gICAgIFggYW5kIFkgcmVwcmVzZW50cyB0aGUgWCBhbmQgWSBjb29yZGluYXRlIGF0IHdoaWNoIHRvIGRyYXcgdGhlIHRleHQuXG4gICAgIGFuZCB0ZXh0IGlzIHRoZSBzdHJpbmcgdG8gZHJhd1xuICAgICovXG4gICAgQ2FudmFzLnByb3RvdHlwZS5hZGRUZXh0ID0gZnVuY3Rpb24obGF5ZXIsIHgsIHksIHRleHQsIGZvbnQsIGFuZ2xlLCB3aWR0aCwgaGFsaWduLCB2YWxpZ24sIHRyYW5zZm9ybXMpIHtcbiAgICAgICAgdmFyIGluZm8gPSB0aGlzLmdldFRleHRJbmZvKGxheWVyLCB0ZXh0LCBmb250LCBhbmdsZSwgd2lkdGgpLFxuICAgICAgICAgICAgcG9zaXRpb25zID0gaW5mby5wb3NpdGlvbnM7XG5cbiAgICAgICAgLy8gVHdlYWsgdGhlIGRpdidzIHBvc2l0aW9uIHRvIG1hdGNoIHRoZSB0ZXh0J3MgYWxpZ25tZW50XG5cbiAgICAgICAgaWYgKGhhbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIHggLT0gaW5mby53aWR0aCAvIDI7XG4gICAgICAgIH0gZWxzZSBpZiAoaGFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICB4IC09IGluZm8ud2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsaWduID09PSAnbWlkZGxlJykge1xuICAgICAgICAgICAgeSAtPSBpbmZvLmhlaWdodCAvIDI7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsaWduID09PSAnYm90dG9tJykge1xuICAgICAgICAgICAgeSAtPSBpbmZvLmhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIHkgKz0gMC43NSAqIGluZm8uaGVpZ2h0O1xuXG4gICAgICAgIC8vIERldGVybWluZSB3aGV0aGVyIHRoaXMgdGV4dCBhbHJlYWR5IGV4aXN0cyBhdCB0aGlzIHBvc2l0aW9uLlxuICAgICAgICAvLyBJZiBzbywgbWFyayBpdCBmb3IgaW5jbHVzaW9uIGluIHRoZSBuZXh0IHJlbmRlciBwYXNzLlxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwb3NpdGlvbjsgcG9zaXRpb25zW2ldOyBpKyspIHtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gcG9zaXRpb25zW2ldO1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uLnggPT09IHggJiYgcG9zaXRpb24ueSA9PT0geSAmJiBwb3NpdGlvbi50ZXh0ID09PSB0ZXh0KSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24uYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHRyYW5zZm9ybXNcbiAgICAgICAgICAgICAgICB1cGRhdGVUcmFuc2Zvcm1zKHBvc2l0aW9uLmVsZW1lbnQsIHRyYW5zZm9ybXMpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbi5hY3RpdmUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24uYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbi50ZXh0ID0gdGV4dDtcbiAgICAgICAgICAgICAgICBpZiAodGV4dC5pbmRleE9mKCc8YnI+JykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHkgLT0gMC4yNSAqIGluZm8uaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBhZGRUc3BhbkVsZW1lbnRzKHRleHQsIHBvc2l0aW9uLmVsZW1lbnQsIHgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uLmVsZW1lbnQudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3NpdGlvbi5lbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsICd4JywgeCk7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24uZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneScsIHkpO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uLnggPSB4O1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uLnkgPSB5O1xuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgdHJhbnNmb3Jtc1xuICAgICAgICAgICAgICAgIHVwZGF0ZVRyYW5zZm9ybXMocG9zaXRpb24uZWxlbWVudCwgdHJhbnNmb3Jtcyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgdGV4dCBkb2Vzbid0IGV4aXN0IGF0IHRoaXMgcG9zaXRpb24sIGNyZWF0ZSBhIG5ldyBlbnRyeVxuXG4gICAgICAgIC8vIEZvciB0aGUgdmVyeSBmaXJzdCBwb3NpdGlvbiB3ZSdsbCByZS11c2UgdGhlIG9yaWdpbmFsIGVsZW1lbnQsXG4gICAgICAgIC8vIHdoaWxlIGZvciBzdWJzZXF1ZW50IG9uZXMgd2UnbGwgY2xvbmUgaXQuXG5cbiAgICAgICAgcG9zaXRpb24gPSB7XG4gICAgICAgICAgICBhY3RpdmU6IHRydWUsXG4gICAgICAgICAgICByZW5kZXJlZDogZmFsc2UsXG4gICAgICAgICAgICBlbGVtZW50OiBwb3NpdGlvbnMubGVuZ3RoID8gaW5mby5lbGVtZW50LmNsb25lTm9kZSgpIDogaW5mby5lbGVtZW50LFxuICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5XG4gICAgICAgIH07XG5cbiAgICAgICAgcG9zaXRpb25zLnB1c2gocG9zaXRpb24pO1xuXG4gICAgICAgIGlmICh0ZXh0LmluZGV4T2YoJzxicj4nKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHkgLT0gMC4yNSAqIGluZm8uaGVpZ2h0O1xuICAgICAgICAgICAgYWRkVHNwYW5FbGVtZW50cyh0ZXh0LCBwb3NpdGlvbi5lbGVtZW50LCB4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvc2l0aW9uLmVsZW1lbnQudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTW92ZSB0aGUgZWxlbWVudCB0byBpdHMgZmluYWwgcG9zaXRpb24gd2l0aGluIHRoZSBjb250YWluZXJcbiAgICAgICAgcG9zaXRpb24uZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneCcsIHgpO1xuICAgICAgICBwb3NpdGlvbi5lbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsICd5JywgeSk7XG4gICAgICAgIHBvc2l0aW9uLmVsZW1lbnQuc3R5bGUudGV4dEFsaWduID0gaGFsaWduO1xuICAgICAgICAvLyB1cGRhdGUgdGhlIHRyYW5zZm9ybXNcbiAgICAgICAgdXBkYXRlVHJhbnNmb3Jtcyhwb3NpdGlvbi5lbGVtZW50LCB0cmFuc2Zvcm1zKTtcbiAgICB9O1xuXG4gICAgdmFyIGFkZFRzcGFuRWxlbWVudHMgPSBmdW5jdGlvbih0ZXh0LCBlbGVtZW50LCB4KSB7XG4gICAgICAgIHZhciBsaW5lcyA9IHRleHQuc3BsaXQoJzxicj4nKSxcbiAgICAgICAgICAgIHRzcGFuLCBpLCBvZmZzZXQ7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWVsZW1lbnQuY2hpbGROb2Rlc1tpXSkge1xuICAgICAgICAgICAgICAgIHRzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICd0c3BhbicpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQodHNwYW4pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0c3BhbiA9IGVsZW1lbnQuY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRzcGFuLnRleHRDb250ZW50ID0gbGluZXNbaV07XG4gICAgICAgICAgICBvZmZzZXQgPSAoaSA9PT0gMCA/IDAgOiAxKSArICdlbSc7XG4gICAgICAgICAgICB0c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZHknLCBvZmZzZXQpO1xuICAgICAgICAgICAgdHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgJ3gnLCB4KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgIC0gcmVtb3ZlVGV4dCAobGF5ZXIsIHgsIHksIHRleHQsIGZvbnQsIGFuZ2xlKVxuXG4gICAgICBUaGUgZnVuY3Rpb24gcmVtb3ZlcyBvbmUgb3IgbW9yZSB0ZXh0IHN0cmluZ3MgZnJvbSB0aGUgY2FudmFzIHRleHQgb3ZlcmxheS5cbiAgICAgIElmIG5vIHBhcmFtZXRlcnMgYXJlIGdpdmVuLCBhbGwgdGV4dCB3aXRoaW4gdGhlIGxheWVyIGlzIHJlbW92ZWQuXG5cbiAgICAgIE5vdGUgdGhhdCB0aGUgdGV4dCBpcyBub3QgaW1tZWRpYXRlbHkgcmVtb3ZlZDsgaXQgaXMgc2ltcGx5IG1hcmtlZCBhc1xuICAgICAgaW5hY3RpdmUsIHdoaWNoIHdpbGwgcmVzdWx0IGluIGl0cyByZW1vdmFsIG9uIHRoZSBuZXh0IHJlbmRlciBwYXNzLlxuICAgICAgVGhpcyBhdm9pZHMgdGhlIHBlcmZvcm1hbmNlIHBlbmFsdHkgZm9yICdjbGVhciBhbmQgcmVkcmF3JyBiZWhhdmlvcixcbiAgICAgIHdoZXJlIHdlIHBvdGVudGlhbGx5IGdldCByaWQgb2YgYWxsIHRleHQgb24gYSBsYXllciwgYnV0IHdpbGwgbGlrZWx5XG4gICAgICBhZGQgYmFjayBtb3N0IG9yIGFsbCBvZiBpdCBsYXRlciwgYXMgd2hlbiByZWRyYXdpbmcgYXhlcywgZm9yIGV4YW1wbGUuXG5cbiAgICAgIFRoZSBsYXllciBpcyBhIHN0cmluZyBvZiBzcGFjZS1zZXBhcmF0ZWQgQ1NTIGNsYXNzZXMgdW5pcXVlbHlcbiAgICAgIGlkZW50aWZ5aW5nIHRoZSBsYXllciBjb250YWluaW5nIHRoaXMgdGV4dC4gVGhlIGZvbGxvd2luZyBwYXJhbWV0ZXIgYXJlXG4gICAgICBYIGFuZCBZIGNvb3JkaW5hdGUgb2YgdGhlIHRleHQuXG4gICAgICBUZXh0IGlzIHRoZSBzdHJpbmcgdG8gcmVtb3ZlLCB3aGlsZSB0aGUgZm9udCBpcyBlaXRoZXIgYSBzdHJpbmcgb2Ygc3BhY2Utc2VwYXJhdGVkIENTU1xuICAgICAgY2xhc3NlcyBvciBhIGZvbnQtc3BlYyBvYmplY3QsIGRlZmluaW5nIHRoZSB0ZXh0J3MgZm9udCBhbmQgc3R5bGUuXG4gICAgICovXG4gICAgQ2FudmFzLnByb3RvdHlwZS5yZW1vdmVUZXh0ID0gZnVuY3Rpb24obGF5ZXIsIHgsIHksIHRleHQsIGZvbnQsIGFuZ2xlKSB7XG4gICAgICAgIHZhciBpbmZvLCBodG1sWUNvb3JkO1xuICAgICAgICBpZiAodGV4dCA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXJDYWNoZSA9IHRoaXMuX3RleHRDYWNoZVtsYXllcl07XG4gICAgICAgICAgICBpZiAobGF5ZXJDYWNoZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgc3R5bGVLZXkgaW4gbGF5ZXJDYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChsYXllckNhY2hlLCBzdHlsZUtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHlsZUNhY2hlID0gbGF5ZXJDYWNoZVtzdHlsZUtleV07XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc3R5bGVDYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHN0eWxlQ2FjaGUsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9ucyA9IHN0eWxlQ2FjaGVba2V5XS5wb3NpdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbi5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5mbyA9IHRoaXMuZ2V0VGV4dEluZm8obGF5ZXIsIHRleHQsIGZvbnQsIGFuZ2xlKTtcbiAgICAgICAgICAgIHBvc2l0aW9ucyA9IGluZm8ucG9zaXRpb25zO1xuICAgICAgICAgICAgcG9zaXRpb25zLmZvckVhY2goZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBodG1sWUNvb3JkID0geSArIDAuNzUgKiBpbmZvLmhlaWdodDtcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24ueCA9PT0geCAmJiBwb3NpdGlvbi55ID09PSBodG1sWUNvb3JkICYmIHBvc2l0aW9uLnRleHQgPT09IHRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24uYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgLSBjbGVhckNhY2hlKClcblxuICAgICBDbGVhcnMgdGhlIGNhY2hlIHVzZWQgdG8gc3BlZWQgdXAgdGhlIHRleHQgc2l6ZSBtZWFzdXJlbWVudHMuXG4gICAgIEFzIGFuICh1bmZvcnR1bmF0ZSkgc2lkZSBlZmZlY3QgYWxsIHRleHQgd2l0aGluIHRoZSB0ZXh0IExheWVyIGlzIHJlbW92ZWQuXG4gICAgIFVzZSB0aGlzIGZ1bmN0aW9uIGJlZm9yZSBwbG90LnNldHVwR3JpZCgpIGFuZCBwbG90LmRyYXcoKSBpZiB0aGUgcGxvdCBqdXN0XG4gICAgIGJlY2FtZSB2aXNpYmxlIG9yIHRoZSBzdHlsZXMgY2hhbmdlZC5cbiAgICAqL1xuICAgIENhbnZhcy5wcm90b3R5cGUuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2FjaGUgPSB0aGlzLl90ZXh0Q2FjaGU7XG4gICAgICAgIGZvciAodmFyIGxheWVyS2V5IGluIGNhY2hlKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjYWNoZSwgbGF5ZXJLZXkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRTVkdMYXllcihsYXllcktleSk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGxheWVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIucmVtb3ZlQ2hpbGQobGF5ZXIuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX3RleHRDYWNoZSA9IHt9O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUtleSh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoLzB8MXwyfDN8NHw1fDZ8N3w4fDkvZywgJzAnKTtcbiAgICB9XG5cbiAgICBpZiAoIXdpbmRvdy5GbG90KSB7XG4gICAgICAgIHdpbmRvdy5GbG90ID0ge307XG4gICAgfVxuXG4gICAgd2luZG93LkZsb3QuQ2FudmFzID0gQ2FudmFzO1xufSkoalF1ZXJ5KTtcbiIsIi8qIFBsdWdpbiBmb3IgalF1ZXJ5IGZvciB3b3JraW5nIHdpdGggY29sb3JzLlxuICpcbiAqIFZlcnNpb24gMS4xLlxuICpcbiAqIEluc3BpcmF0aW9uIGZyb20galF1ZXJ5IGNvbG9yIGFuaW1hdGlvbiBwbHVnaW4gYnkgSm9obiBSZXNpZy5cbiAqXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgYnkgT2xlIExhdXJzZW4sIE9jdG9iZXIgMjAwOS5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICQuY29sb3IucGFyc2UoXCIjZmZmXCIpLnNjYWxlKCdyZ2InLCAwLjI1KS5hZGQoJ2EnLCAtMC41KS50b1N0cmluZygpXG4gKiAgIHZhciBjID0gJC5jb2xvci5leHRyYWN0KCQoXCIjbXlkaXZcIiksICdiYWNrZ3JvdW5kLWNvbG9yJyk7XG4gKiAgIGNvbnNvbGUubG9nKGMuciwgYy5nLCBjLmIsIGMuYSk7XG4gKiAgICQuY29sb3IubWFrZSgxMDAsIDUwLCAyNSwgMC40KS50b1N0cmluZygpIC8vIHJldHVybnMgXCJyZ2JhKDEwMCw1MCwyNSwwLjQpXCJcbiAqXG4gKiBOb3RlIHRoYXQgLnNjYWxlKCkgYW5kIC5hZGQoKSByZXR1cm4gdGhlIHNhbWUgbW9kaWZpZWQgb2JqZWN0XG4gKiBpbnN0ZWFkIG9mIG1ha2luZyBhIG5ldyBvbmUuXG4gKlxuICogVi4gMS4xOiBGaXggZXJyb3IgaGFuZGxpbmcgc28gZS5nLiBwYXJzaW5nIGFuIGVtcHR5IHN0cmluZyBkb2VzXG4gKiBwcm9kdWNlIGEgY29sb3IgcmF0aGVyIHRoYW4ganVzdCBjcmFzaGluZy5cbiAqL1xuXG4oZnVuY3Rpb24oJCkge1xuICAgICQuY29sb3IgPSB7fTtcblxuICAgIC8vIGNvbnN0cnVjdCBjb2xvciBvYmplY3Qgd2l0aCBzb21lIGNvbnZlbmllbnQgY2hhaW5hYmxlIGhlbHBlcnNcbiAgICAkLmNvbG9yLm1ha2UgPSBmdW5jdGlvbiAociwgZywgYiwgYSkge1xuICAgICAgICB2YXIgbyA9IHt9O1xuICAgICAgICBvLnIgPSByIHx8IDA7XG4gICAgICAgIG8uZyA9IGcgfHwgMDtcbiAgICAgICAgby5iID0gYiB8fCAwO1xuICAgICAgICBvLmEgPSBhICE9IG51bGwgPyBhIDogMTtcblxuICAgICAgICBvLmFkZCA9IGZ1bmN0aW9uIChjLCBkKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBvW2MuY2hhckF0KGkpXSArPSBkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gby5ub3JtYWxpemUoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBvLnNjYWxlID0gZnVuY3Rpb24gKGMsIGYpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIG9bYy5jaGFyQXQoaSldICo9IGY7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvLm5vcm1hbGl6ZSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIG8udG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoby5hID49IDEuMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcInJnYihcIiArIFtvLnIsIG8uZywgby5iXS5qb2luKFwiLFwiKSArIFwiKVwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJyZ2JhKFwiICsgW28uciwgby5nLCBvLmIsIG8uYV0uam9pbihcIixcIikgKyBcIilcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBvLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNsYW1wKG1pbiwgdmFsdWUsIG1heCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA8IG1pbiA/IG1pbiA6ICh2YWx1ZSA+IG1heCA/IG1heCA6IHZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgby5yID0gY2xhbXAoMCwgcGFyc2VJbnQoby5yKSwgMjU1KTtcbiAgICAgICAgICAgIG8uZyA9IGNsYW1wKDAsIHBhcnNlSW50KG8uZyksIDI1NSk7XG4gICAgICAgICAgICBvLmIgPSBjbGFtcCgwLCBwYXJzZUludChvLmIpLCAyNTUpO1xuICAgICAgICAgICAgby5hID0gY2xhbXAoMCwgby5hLCAxKTtcbiAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICB9O1xuXG4gICAgICAgIG8uY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJC5jb2xvci5tYWtlKG8uciwgby5iLCBvLmcsIG8uYSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG8ubm9ybWFsaXplKCk7XG4gICAgfVxuXG4gICAgLy8gZXh0cmFjdCBDU1MgY29sb3IgcHJvcGVydHkgZnJvbSBlbGVtZW50LCBnb2luZyB1cCBpbiB0aGUgRE9NXG4gICAgLy8gaWYgaXQncyBcInRyYW5zcGFyZW50XCJcbiAgICAkLmNvbG9yLmV4dHJhY3QgPSBmdW5jdGlvbiAoZWxlbSwgY3NzKSB7XG4gICAgICAgIHZhciBjO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGMgPSBlbGVtLmNzcyhjc3MpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAvLyBrZWVwIGdvaW5nIHVudGlsIHdlIGZpbmQgYW4gZWxlbWVudCB0aGF0IGhhcyBjb2xvciwgb3JcbiAgICAgICAgICAgIC8vIHdlIGhpdCB0aGUgYm9keSBvciByb290IChoYXZlIG5vIHBhcmVudClcbiAgICAgICAgICAgIGlmIChjICE9PSAnJyAmJiBjICE9PSAndHJhbnNwYXJlbnQnKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsZW0gPSBlbGVtLnBhcmVudCgpO1xuICAgICAgICB9IHdoaWxlIChlbGVtLmxlbmd0aCAmJiAhJC5ub2RlTmFtZShlbGVtLmdldCgwKSwgXCJib2R5XCIpKTtcblxuICAgICAgICAvLyBjYXRjaCBTYWZhcmkncyB3YXkgb2Ygc2lnbmFsbGluZyB0cmFuc3BhcmVudFxuICAgICAgICBpZiAoYyA9PT0gXCJyZ2JhKDAsIDAsIDAsIDApXCIpIHtcbiAgICAgICAgICAgIGMgPSBcInRyYW5zcGFyZW50XCI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJC5jb2xvci5wYXJzZShjKTtcbiAgICB9XG5cbiAgICAvLyBwYXJzZSBDU1MgY29sb3Igc3RyaW5nIChsaWtlIFwicmdiKDEwLCAzMiwgNDMpXCIgb3IgXCIjZmZmXCIpLFxuICAgIC8vIHJldHVybnMgY29sb3Igb2JqZWN0LCBpZiBwYXJzaW5nIGZhaWxlZCwgeW91IGdldCBibGFjayAoMCwgMCxcbiAgICAvLyAwKSBvdXRcbiAgICAkLmNvbG9yLnBhcnNlID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICB2YXIgcmVzLCBtID0gJC5jb2xvci5tYWtlO1xuXG4gICAgICAgIC8vIExvb2sgZm9yIHJnYihudW0sbnVtLG51bSlcbiAgICAgICAgcmVzID0gL3JnYlxcKFxccyooWzAtOV17MSwzfSlcXHMqLFxccyooWzAtOV17MSwzfSlcXHMqLFxccyooWzAtOV17MSwzfSlcXHMqXFwpLy5leGVjKHN0cik7XG4gICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBtKHBhcnNlSW50KHJlc1sxXSwgMTApLCBwYXJzZUludChyZXNbMl0sIDEwKSwgcGFyc2VJbnQocmVzWzNdLCAxMCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTG9vayBmb3IgcmdiYShudW0sbnVtLG51bSxudW0pXG4gICAgICAgIHJlcyA9IC9yZ2JhXFwoXFxzKihbMC05XXsxLDN9KVxccyosXFxzKihbMC05XXsxLDN9KVxccyosXFxzKihbMC05XXsxLDN9KVxccyosXFxzKihbMC05XSsoPzpcXC5bMC05XSspPylcXHMqXFwpLy5leGVjKHN0cilcbiAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgcmV0dXJuIG0ocGFyc2VJbnQocmVzWzFdLCAxMCksIHBhcnNlSW50KHJlc1syXSwgMTApLCBwYXJzZUludChyZXNbM10sIDEwKSwgcGFyc2VGbG9hdChyZXNbNF0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExvb2sgZm9yIHJnYihudW0lLG51bSUsbnVtJSlcbiAgICAgICAgcmVzID0gL3JnYlxcKFxccyooWzAtOV0rKD86XFwuWzAtOV0rKT8pJVxccyosXFxzKihbMC05XSsoPzpcXC5bMC05XSspPyklXFxzKixcXHMqKFswLTldKyg/OlxcLlswLTldKyk/KSVcXHMqXFwpLy5leGVjKHN0cik7XG4gICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBtKHBhcnNlRmxvYXQocmVzWzFdKSAqIDIuNTUsIHBhcnNlRmxvYXQocmVzWzJdKSAqIDIuNTUsIHBhcnNlRmxvYXQocmVzWzNdKSAqIDIuNTUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTG9vayBmb3IgcmdiYShudW0lLG51bSUsbnVtJSxudW0pXG4gICAgICAgIHJlcyA9IC9yZ2JhXFwoXFxzKihbMC05XSsoPzpcXC5bMC05XSspPyklXFxzKixcXHMqKFswLTldKyg/OlxcLlswLTldKyk/KSVcXHMqLFxccyooWzAtOV0rKD86XFwuWzAtOV0rKT8pJVxccyosXFxzKihbMC05XSsoPzpcXC5bMC05XSspPylcXHMqXFwpLy5leGVjKHN0cik7XG4gICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBtKHBhcnNlRmxvYXQocmVzWzFdKSAqIDIuNTUsIHBhcnNlRmxvYXQocmVzWzJdKSAqIDIuNTUsIHBhcnNlRmxvYXQocmVzWzNdKSAqIDIuNTUsIHBhcnNlRmxvYXQocmVzWzRdKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMb29rIGZvciAjYTBiMWMyXG4gICAgICAgIHJlcyA9IC8jKFthLWZBLUYwLTldezJ9KShbYS1mQS1GMC05XXsyfSkoW2EtZkEtRjAtOV17Mn0pLy5leGVjKHN0cik7XG4gICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBtKHBhcnNlSW50KHJlc1sxXSwgMTYpLCBwYXJzZUludChyZXNbMl0sIDE2KSwgcGFyc2VJbnQocmVzWzNdLCAxNikpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTG9vayBmb3IgI2ZmZlxuICAgICAgICByZXMgPSAvIyhbYS1mQS1GMC05XSkoW2EtZkEtRjAtOV0pKFthLWZBLUYwLTldKS8uZXhlYyhzdHIpO1xuICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbShwYXJzZUludChyZXNbMV0gKyByZXNbMV0sIDE2KSwgcGFyc2VJbnQocmVzWzJdICsgcmVzWzJdLCAxNiksIHBhcnNlSW50KHJlc1szXSArIHJlc1szXSwgMTYpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgd2UncmUgbW9zdCBsaWtlbHkgZGVhbGluZyB3aXRoIGEgbmFtZWQgY29sb3JcbiAgICAgICAgdmFyIG5hbWUgPSAkLnRyaW0oc3RyKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAobmFtZSA9PT0gXCJ0cmFuc3BhcmVudFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbSgyNTUsIDI1NSwgMjU1LCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gYmxhY2tcbiAgICAgICAgICAgIHJlcyA9IGxvb2t1cENvbG9yc1tuYW1lXSB8fCBbMCwgMCwgMF07XG4gICAgICAgICAgICByZXR1cm4gbShyZXNbMF0sIHJlc1sxXSwgcmVzWzJdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsb29rdXBDb2xvcnMgPSB7XG4gICAgICAgIGFxdWE6IFswLCAyNTUsIDI1NV0sXG4gICAgICAgIGF6dXJlOiBbMjQwLCAyNTUsIDI1NV0sXG4gICAgICAgIGJlaWdlOiBbMjQ1LCAyNDUsIDIyMF0sXG4gICAgICAgIGJsYWNrOiBbMCwgMCwgMF0sXG4gICAgICAgIGJsdWU6IFswLCAwLCAyNTVdLFxuICAgICAgICBicm93bjogWzE2NSwgNDIsIDQyXSxcbiAgICAgICAgY3lhbjogWzAsIDI1NSwgMjU1XSxcbiAgICAgICAgZGFya2JsdWU6IFswLCAwLCAxMzldLFxuICAgICAgICBkYXJrY3lhbjogWzAsIDEzOSwgMTM5XSxcbiAgICAgICAgZGFya2dyZXk6IFsxNjksIDE2OSwgMTY5XSxcbiAgICAgICAgZGFya2dyZWVuOiBbMCwgMTAwLCAwXSxcbiAgICAgICAgZGFya2toYWtpOiBbMTg5LCAxODMsIDEwN10sXG4gICAgICAgIGRhcmttYWdlbnRhOiBbMTM5LCAwLCAxMzldLFxuICAgICAgICBkYXJrb2xpdmVncmVlbjogWzg1LCAxMDcsIDQ3XSxcbiAgICAgICAgZGFya29yYW5nZTogWzI1NSwgMTQwLCAwXSxcbiAgICAgICAgZGFya29yY2hpZDogWzE1MywgNTAsIDIwNF0sXG4gICAgICAgIGRhcmtyZWQ6IFsxMzksIDAsIDBdLFxuICAgICAgICBkYXJrc2FsbW9uOiBbMjMzLCAxNTAsIDEyMl0sXG4gICAgICAgIGRhcmt2aW9sZXQ6IFsxNDgsIDAsIDIxMV0sXG4gICAgICAgIGZ1Y2hzaWE6IFsyNTUsIDAsIDI1NV0sXG4gICAgICAgIGdvbGQ6IFsyNTUsIDIxNSwgMF0sXG4gICAgICAgIGdyZWVuOiBbMCwgMTI4LCAwXSxcbiAgICAgICAgaW5kaWdvOiBbNzUsIDAsIDEzMF0sXG4gICAgICAgIGtoYWtpOiBbMjQwLCAyMzAsIDE0MF0sXG4gICAgICAgIGxpZ2h0Ymx1ZTogWzE3MywgMjE2LCAyMzBdLFxuICAgICAgICBsaWdodGN5YW46IFsyMjQsIDI1NSwgMjU1XSxcbiAgICAgICAgbGlnaHRncmVlbjogWzE0NCwgMjM4LCAxNDRdLFxuICAgICAgICBsaWdodGdyZXk6IFsyMTEsIDIxMSwgMjExXSxcbiAgICAgICAgbGlnaHRwaW5rOiBbMjU1LCAxODIsIDE5M10sXG4gICAgICAgIGxpZ2h0eWVsbG93OiBbMjU1LCAyNTUsIDIyNF0sXG4gICAgICAgIGxpbWU6IFswLCAyNTUsIDBdLFxuICAgICAgICBtYWdlbnRhOiBbMjU1LCAwLCAyNTVdLFxuICAgICAgICBtYXJvb246IFsxMjgsIDAsIDBdLFxuICAgICAgICBuYXZ5OiBbMCwgMCwgMTI4XSxcbiAgICAgICAgb2xpdmU6IFsxMjgsIDEyOCwgMF0sXG4gICAgICAgIG9yYW5nZTogWzI1NSwgMTY1LCAwXSxcbiAgICAgICAgcGluazogWzI1NSwgMTkyLCAyMDNdLFxuICAgICAgICBwdXJwbGU6IFsxMjgsIDAsIDEyOF0sXG4gICAgICAgIHZpb2xldDogWzEyOCwgMCwgMTI4XSxcbiAgICAgICAgcmVkOiBbMjU1LCAwLCAwXSxcbiAgICAgICAgc2lsdmVyOiBbMTkyLCAxOTIsIDE5Ml0sXG4gICAgICAgIHdoaXRlOiBbMjU1LCAyNTUsIDI1NV0sXG4gICAgICAgIHllbGxvdzogWzI1NSwgMjU1LCAwXVxuICAgIH07XG59KShqUXVlcnkpO1xuIiwiLypcbkF4aXMgbGFiZWwgcGx1Z2luIGZvciBmbG90XG5cbkRlcml2ZWQgZnJvbTpcbkF4aXMgTGFiZWxzIFBsdWdpbiBmb3IgZmxvdC5cbmh0dHA6Ly9naXRodWIuY29tL21hcmtyY290ZS9mbG90LWF4aXNsYWJlbHNcblxuT3JpZ2luYWwgY29kZSBpcyBDb3B5cmlnaHQgKGMpIDIwMTAgWHVhbiBMdW8uXG5PcmlnaW5hbCBjb2RlIHdhcyByZWxlYXNlZCB1bmRlciB0aGUgR1BMdjMgbGljZW5zZSBieSBYdWFuIEx1bywgU2VwdGVtYmVyIDIwMTAuXG5PcmlnaW5hbCBjb2RlIHdhcyByZXJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBieSBYdWFuIEx1bywgQXByaWwgMjAxMi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXG5hIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcblwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xud2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG5wZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbnRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbmluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG5NRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRVxuTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTlxuT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG5XSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiovXG5cbihmdW5jdGlvbigkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgYXhpc0xhYmVsczoge1xuICAgICAgICAgICAgc2hvdzogdHJ1ZVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIEF4aXNMYWJlbChheGlzTmFtZSwgcG9zaXRpb24sIHBhZGRpbmcsIHBsYWNlaG9sZGVyLCBheGlzTGFiZWwsIHN1cmZhY2UpIHtcbiAgICAgICAgdGhpcy5heGlzTmFtZSA9IGF4aXNOYW1lO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgIHRoaXMucGFkZGluZyA9IHBhZGRpbmc7XG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlcjtcbiAgICAgICAgdGhpcy5heGlzTGFiZWwgPSBheGlzTGFiZWw7XG4gICAgICAgIHRoaXMuc3VyZmFjZSA9IHN1cmZhY2U7XG4gICAgICAgIHRoaXMud2lkdGggPSAwO1xuICAgICAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgICAgIHRoaXMuZWxlbSA9IG51bGw7XG4gICAgfVxuXG4gICAgQXhpc0xhYmVsLnByb3RvdHlwZS5jYWxjdWxhdGVTaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBheGlzSWQgPSB0aGlzLmF4aXNOYW1lICsgJ0xhYmVsJyxcbiAgICAgICAgICAgIGxheWVySWQgPSBheGlzSWQgKyAnTGF5ZXInLFxuICAgICAgICAgICAgY2xhc3NOYW1lID0gYXhpc0lkICsgJyBheGlzTGFiZWxzJztcblxuICAgICAgICB2YXIgaW5mbyA9IHRoaXMuc3VyZmFjZS5nZXRUZXh0SW5mbyhsYXllcklkLCB0aGlzLmF4aXNMYWJlbCwgY2xhc3NOYW1lKTtcbiAgICAgICAgdGhpcy5sYWJlbFdpZHRoID0gaW5mby53aWR0aDtcbiAgICAgICAgdGhpcy5sYWJlbEhlaWdodCA9IGluZm8uaGVpZ2h0O1xuXG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9uID09PSAnbGVmdCcgfHwgdGhpcy5wb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMubGFiZWxIZWlnaHQgKyB0aGlzLnBhZGRpbmc7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gMDtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5sYWJlbEhlaWdodCArIHRoaXMucGFkZGluZztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBBeGlzTGFiZWwucHJvdG90eXBlLnRyYW5zZm9ybXMgPSBmdW5jdGlvbihkZWdyZWVzLCB4LCB5LCBzdmdMYXllcikge1xuICAgICAgICB2YXIgdHJhbnNmb3JtcyA9IFtdLCB0cmFuc2xhdGUsIHJvdGF0ZTtcbiAgICAgICAgaWYgKHggIT09IDAgfHwgeSAhPT0gMCkge1xuICAgICAgICAgICAgdHJhbnNsYXRlID0gc3ZnTGF5ZXIuY3JlYXRlU1ZHVHJhbnNmb3JtKCk7XG4gICAgICAgICAgICB0cmFuc2xhdGUuc2V0VHJhbnNsYXRlKHgsIHkpO1xuICAgICAgICAgICAgdHJhbnNmb3Jtcy5wdXNoKHRyYW5zbGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZ3JlZXMgIT09IDApIHtcbiAgICAgICAgICAgIHJvdGF0ZSA9IHN2Z0xheWVyLmNyZWF0ZVNWR1RyYW5zZm9ybSgpO1xuICAgICAgICAgICAgdmFyIGNlbnRlclggPSBNYXRoLnJvdW5kKHRoaXMubGFiZWxXaWR0aCAvIDIpLFxuICAgICAgICAgICAgICAgIGNlbnRlclkgPSAwO1xuICAgICAgICAgICAgcm90YXRlLnNldFJvdGF0ZShkZWdyZWVzLCBjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICAgICAgICAgIHRyYW5zZm9ybXMucHVzaChyb3RhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybXM7XG4gICAgfTtcblxuICAgIEF4aXNMYWJlbC5wcm90b3R5cGUuY2FsY3VsYXRlT2Zmc2V0cyA9IGZ1bmN0aW9uKGJveCkge1xuICAgICAgICB2YXIgb2Zmc2V0cyA9IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgZGVncmVlczogMFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5wb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgIG9mZnNldHMueCA9IGJveC5sZWZ0ICsgYm94LndpZHRoIC8gMiAtIHRoaXMubGFiZWxXaWR0aCAvIDI7XG4gICAgICAgICAgICBvZmZzZXRzLnkgPSBib3gudG9wICsgYm94LmhlaWdodCAtIHRoaXMubGFiZWxIZWlnaHQ7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5wb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICAgIG9mZnNldHMueCA9IGJveC5sZWZ0ICsgYm94LndpZHRoIC8gMiAtIHRoaXMubGFiZWxXaWR0aCAvIDI7XG4gICAgICAgICAgICBvZmZzZXRzLnkgPSBib3gudG9wO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgb2Zmc2V0cy5kZWdyZWVzID0gLTkwO1xuICAgICAgICAgICAgb2Zmc2V0cy54ID0gYm94LmxlZnQgLSB0aGlzLmxhYmVsV2lkdGggLyAyO1xuICAgICAgICAgICAgb2Zmc2V0cy55ID0gYm94LmhlaWdodCAvIDIgKyBib3gudG9wO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIG9mZnNldHMuZGVncmVlcyA9IDkwO1xuICAgICAgICAgICAgb2Zmc2V0cy54ID0gYm94LmxlZnQgKyBib3gud2lkdGggLSB0aGlzLmxhYmVsV2lkdGggLyAyO1xuICAgICAgICAgICAgb2Zmc2V0cy55ID0gYm94LmhlaWdodCAvIDIgKyBib3gudG9wO1xuICAgICAgICB9XG4gICAgICAgIG9mZnNldHMueCA9IE1hdGgucm91bmQob2Zmc2V0cy54KTtcbiAgICAgICAgb2Zmc2V0cy55ID0gTWF0aC5yb3VuZChvZmZzZXRzLnkpO1xuXG4gICAgICAgIHJldHVybiBvZmZzZXRzO1xuICAgIH07XG5cbiAgICBBeGlzTGFiZWwucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGF4aXNJZCA9IHRoaXMuYXhpc05hbWUgKyAnTGFiZWwnLFxuICAgICAgICAgICAgbGF5ZXJJZCA9IGF4aXNJZCArICdMYXllcicsXG4gICAgICAgICAgICBjbGFzc05hbWUgPSBheGlzSWQgKyAnIGF4aXNMYWJlbHMnO1xuICAgICAgICB0aGlzLnN1cmZhY2UucmVtb3ZlVGV4dChsYXllcklkLCAwLCAwLCB0aGlzLmF4aXNMYWJlbCwgY2xhc3NOYW1lKTtcbiAgICB9O1xuXG4gICAgQXhpc0xhYmVsLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oYm94KSB7XG4gICAgICAgIHZhciBheGlzSWQgPSB0aGlzLmF4aXNOYW1lICsgJ0xhYmVsJyxcbiAgICAgICAgICAgIGxheWVySWQgPSBheGlzSWQgKyAnTGF5ZXInLFxuICAgICAgICAgICAgY2xhc3NOYW1lID0gYXhpc0lkICsgJyBheGlzTGFiZWxzJyxcbiAgICAgICAgICAgIG9mZnNldHMgPSB0aGlzLmNhbGN1bGF0ZU9mZnNldHMoYm94KSxcbiAgICAgICAgICAgIHN0eWxlID0ge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgIGJvdHRvbTogJycsXG4gICAgICAgICAgICAgICAgcmlnaHQ6ICcnLFxuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgICAgICAgICAgICd3aGl0ZS1zcGFjZSc6ICdub3dyYXAnXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHZhciBsYXllciA9IHRoaXMuc3VyZmFjZS5nZXRTVkdMYXllcihsYXllcklkKTtcbiAgICAgICAgdmFyIHRyYW5zZm9ybXMgPSB0aGlzLnRyYW5zZm9ybXMob2Zmc2V0cy5kZWdyZWVzLCBvZmZzZXRzLngsIG9mZnNldHMueSwgbGF5ZXIucGFyZW50Tm9kZSk7XG5cbiAgICAgICAgdGhpcy5zdXJmYWNlLmFkZFRleHQobGF5ZXJJZCwgMCwgMCwgdGhpcy5heGlzTGFiZWwsIGNsYXNzTmFtZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0cmFuc2Zvcm1zKTtcbiAgICAgICAgdGhpcy5zdXJmYWNlLnJlbmRlcigpO1xuICAgICAgICBPYmplY3Qua2V5cyhzdHlsZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIGxheWVyLnN0eWxlW2tleV0gPSBzdHlsZVtrZXldO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaW5pdChwbG90KSB7XG4gICAgICAgIHBsb3QuaG9va3MucHJvY2Vzc09wdGlvbnMucHVzaChmdW5jdGlvbihwbG90LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuYXhpc0xhYmVscy5zaG93KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYXhpc0xhYmVscyA9IHt9O1xuICAgICAgICAgICAgdmFyIGRlZmF1bHRQYWRkaW5nID0gMjsgLy8gcGFkZGluZyBiZXR3ZWVuIGF4aXMgYW5kIHRpY2sgbGFiZWxzXG5cbiAgICAgICAgICAgIHBsb3QuaG9va3MuYXhpc1Jlc2VydmVTcGFjZS5wdXNoKGZ1bmN0aW9uKHBsb3QsIGF4aXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0cyA9IGF4aXMub3B0aW9ucztcbiAgICAgICAgICAgICAgICB2YXIgYXhpc05hbWUgPSBheGlzLmRpcmVjdGlvbiArIGF4aXMubjtcblxuICAgICAgICAgICAgICAgIGF4aXMubGFiZWxIZWlnaHQgKz0gYXhpcy5ib3hQb3NpdGlvbi5jZW50ZXJZO1xuICAgICAgICAgICAgICAgIGF4aXMubGFiZWxXaWR0aCArPSBheGlzLmJveFBvc2l0aW9uLmNlbnRlclg7XG5cbiAgICAgICAgICAgICAgICBpZiAoIW9wdHMgfHwgIW9wdHMuYXhpc0xhYmVsIHx8ICFheGlzLnNob3cpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBwYWRkaW5nID0gb3B0cy5heGlzTGFiZWxQYWRkaW5nID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgPyBkZWZhdWx0UGFkZGluZ1xuICAgICAgICAgICAgICAgICAgICA6IG9wdHMuYXhpc0xhYmVsUGFkZGluZztcblxuICAgICAgICAgICAgICAgIHZhciBheGlzTGFiZWwgPSBheGlzTGFiZWxzW2F4aXNOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoIWF4aXNMYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBheGlzTGFiZWwgPSBuZXcgQXhpc0xhYmVsKGF4aXNOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0cy5wb3NpdGlvbiwgcGFkZGluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsb3QuZ2V0UGxhY2Vob2xkZXIoKVswXSwgb3B0cy5heGlzTGFiZWwsIHBsb3QuZ2V0U3VyZmFjZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgYXhpc0xhYmVsc1theGlzTmFtZV0gPSBheGlzTGFiZWw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYXhpc0xhYmVsLmNhbGN1bGF0ZVNpemUoKTtcblxuICAgICAgICAgICAgICAgIC8vIEluY3JlbWVudGluZyB0aGUgc2l6ZXMgb2YgdGhlIHRpY2sgbGFiZWxzLlxuICAgICAgICAgICAgICAgIGF4aXMubGFiZWxIZWlnaHQgKz0gYXhpc0xhYmVsLmhlaWdodDtcbiAgICAgICAgICAgICAgICBheGlzLmxhYmVsV2lkdGggKz0gYXhpc0xhYmVsLndpZHRoO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFRPRE8gLSB1c2UgdGhlIGRyYXdBeGlzIGhvb2tcbiAgICAgICAgICAgIHBsb3QuaG9va3MuZHJhdy5wdXNoKGZ1bmN0aW9uKHBsb3QsIGN0eCkge1xuICAgICAgICAgICAgICAgICQuZWFjaChwbG90LmdldEF4ZXMoKSwgZnVuY3Rpb24oZmxvdEF4aXNOYW1lLCBheGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRzID0gYXhpcy5vcHRpb25zO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdHMgfHwgIW9wdHMuYXhpc0xhYmVsIHx8ICFheGlzLnNob3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBheGlzTmFtZSA9IGF4aXMuZGlyZWN0aW9uICsgYXhpcy5uO1xuICAgICAgICAgICAgICAgICAgICBheGlzTGFiZWxzW2F4aXNOYW1lXS5kcmF3KGF4aXMuYm94KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBwbG90Lmhvb2tzLnNodXRkb3duLnB1c2goZnVuY3Rpb24ocGxvdCwgZXZlbnRIb2xkZXIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBheGlzTmFtZSBpbiBheGlzTGFiZWxzKSB7XG4gICAgICAgICAgICAgICAgICAgIGF4aXNMYWJlbHNbYXhpc05hbWVdLmNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgICQucGxvdC5wbHVnaW5zLnB1c2goe1xuICAgICAgICBpbml0OiBpbml0LFxuICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICBuYW1lOiAnYXhpc0xhYmVscycsXG4gICAgICAgIHZlcnNpb246ICczLjAnXG4gICAgfSk7XG59KShqUXVlcnkpO1xuIiwiLyoqICMjIGpxdWVyeS5mbG90LmJyb3dzZXIuanNcblxuVGhpcyBwbHVnaW4gaXMgdXNlZCB0byBtYWtlIGF2YWlsYWJsZSBzb21lIGJyb3dzZXItcmVsYXRlZCB1dGlsaXR5IGZ1bmN0aW9ucy5cblxuIyMjIE1ldGhvZHNcbiovXG5cbihmdW5jdGlvbiAoJCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBicm93c2VyID0ge1xuICAgICAgICAvKipcbiAgICAgICAgLSBnZXRQYWdlWFkoZSlcblxuICAgICAgICAgQ2FsY3VsYXRlcyB0aGUgcGFnZVggYW5kIHBhZ2VZIHVzaW5nIHRoZSBzY3JlZW5YLCBzY3JlZW5ZIHByb3BlcnRpZXMgb2YgdGhlIGV2ZW50XG4gICAgICAgICBhbmQgdGhlIHNjcm9sbGluZyBvZiB0aGUgcGFnZS4gVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgcGFnZVggYW5kIHBhZ2VZXG4gICAgICAgICBwcm9wZXJ0aWVzIG9mIHRoZSBldmVudCBhcmUgbm90IGNvcnJlY3Qgd2hpbGUgcnVubmluZyB0ZXN0cyBpbiBFZGdlLiAqL1xuICAgICAgICBnZXRQYWdlWFk6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGNvZGUgaXMgaW5zcGlyZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzQ2NDg5MFxuICAgICAgICAgICAgdmFyIGRvYyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgICAgICAgICAgICAgICBwYWdlWCA9IGUuY2xpZW50WCArICh3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jLnNjcm9sbExlZnQpIC0gKGRvYy5jbGllbnRMZWZ0IHx8IDApLFxuICAgICAgICAgICAgICAgIHBhZ2VZID0gZS5jbGllbnRZICsgKHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2Muc2Nyb2xsVG9wKSAtIChkb2MuY2xpZW50VG9wIHx8IDApO1xuICAgICAgICAgICAgcmV0dXJuIHsgWDogcGFnZVgsIFk6IHBhZ2VZIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgIC0gZ2V0UGl4ZWxSYXRpbyhjb250ZXh0KVxuXG4gICAgICAgICBUaGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGN1cnJlbnQgcGl4ZWwgcmF0aW8gZGVmaW5lZCBieSB0aGUgcHJvZHVjdCBvZiBkZXNrdG9wXG4gICAgICAgICB6b29tIGFuZCBwYWdlIHpvb20uXG4gICAgICAgICBBZGRpdGlvbmFsIGluZm86IGh0dHBzOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9jYW52YXMvaGlkcGkvXG4gICAgICAgICovXG4gICAgICAgIGdldFBpeGVsUmF0aW86IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBkZXZpY2VQaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSxcbiAgICAgICAgICAgICAgICBiYWNraW5nU3RvcmVSYXRpbyA9XG4gICAgICAgICAgICAgICAgY29udGV4dC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgY29udGV4dC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgY29udGV4dC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgY29udGV4dC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDE7XG4gICAgICAgICAgICByZXR1cm4gZGV2aWNlUGl4ZWxSYXRpbyAvIGJhY2tpbmdTdG9yZVJhdGlvO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAtIGlzU2FmYXJpLCBpc01vYmlsZVNhZmFyaSwgaXNPcGVyYSwgaXNGaXJlZm94LCBpc0lFLCBpc0VkZ2UsIGlzQ2hyb21lLCBpc0JsaW5rXG5cbiAgICAgICAgIFRoaXMgaXMgYSBjb2xsZWN0aW9uIG9mIGZ1bmN0aW9ucywgdXNlZCB0byBjaGVjayBpZiB0aGUgY29kZSBpcyBydW5uaW5nIGluIGFcbiAgICAgICAgIHBhcnRpY3VsYXIgYnJvd3NlciBvciBKYXZhc2NyaXB0IGVuZ2luZS5cbiAgICAgICAgKi9cbiAgICAgICAgaXNTYWZhcmk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gKioqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzk4NDc1ODAvaG93LXRvLWRldGVjdC1zYWZhcmktY2hyb21lLWllLWZpcmVmb3gtYW5kLW9wZXJhLWJyb3dzZXJcbiAgICAgICAgICAgIC8vIFNhZmFyaSAzLjArIFwiW29iamVjdCBIVE1MRWxlbWVudENvbnN0cnVjdG9yXVwiXG4gICAgICAgICAgICByZXR1cm4gL2NvbnN0cnVjdG9yL2kudGVzdCh3aW5kb3cudG9wLkhUTUxFbGVtZW50KSB8fCAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAudG9TdHJpbmcoKSA9PT0gXCJbb2JqZWN0IFNhZmFyaVJlbW90ZU5vdGlmaWNhdGlvbl1cIjsgfSkoIXdpbmRvdy50b3BbJ3NhZmFyaSddIHx8ICh0eXBlb2Ygd2luZG93LnRvcC5zYWZhcmkgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b3Auc2FmYXJpLnB1c2hOb3RpZmljYXRpb24pKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpc01vYmlsZVNhZmFyaTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvL2lzTW9iaWxlU2FmYXJpIGFkYXB0ZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zMDA3NDgwL2RldGVybWluZS1pZi11c2VyLW5hdmlnYXRlZC1mcm9tLW1vYmlsZS1zYWZhcmlcbiAgICAgICAgICAgIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC8oaVBvZHxpUGhvbmV8aVBhZCkvKSAmJiBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9BcHBsZVdlYktpdC8pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzT3BlcmE6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gKioqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzk4NDc1ODAvaG93LXRvLWRldGVjdC1zYWZhcmktY2hyb21lLWllLWZpcmVmb3gtYW5kLW9wZXJhLWJyb3dzZXJcbiAgICAgICAgICAgIC8vT3BlcmEgOC4wK1xuICAgICAgICAgICAgcmV0dXJuICghIXdpbmRvdy5vcHIgJiYgISFvcHIuYWRkb25zKSB8fCAhIXdpbmRvdy5vcGVyYSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJyBPUFIvJykgPj0gMDtcbiAgICAgICAgfSxcblxuICAgICAgICBpc0ZpcmVmb3g6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gKioqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzk4NDc1ODAvaG93LXRvLWRldGVjdC1zYWZhcmktY2hyb21lLWllLWZpcmVmb3gtYW5kLW9wZXJhLWJyb3dzZXJcbiAgICAgICAgICAgIC8vIEZpcmVmb3ggMS4wK1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBJbnN0YWxsVHJpZ2dlciAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNJRTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyAqKiogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTg0NzU4MC9ob3ctdG8tZGV0ZWN0LXNhZmFyaS1jaHJvbWUtaWUtZmlyZWZveC1hbmQtb3BlcmEtYnJvd3NlclxuICAgICAgICAgICAgLy8gSW50ZXJuZXQgRXhwbG9yZXIgNi0xMVxuICAgICAgICAgICAgcmV0dXJuIC8qQGNjX29uIUAqL2ZhbHNlIHx8ICEhZG9jdW1lbnQuZG9jdW1lbnRNb2RlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzRWRnZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyAqKiogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTg0NzU4MC9ob3ctdG8tZGV0ZWN0LXNhZmFyaS1jaHJvbWUtaWUtZmlyZWZveC1hbmQtb3BlcmEtYnJvd3NlclxuICAgICAgICAgICAgLy8gRWRnZSAyMCtcbiAgICAgICAgICAgIHJldHVybiAhYnJvd3Nlci5pc0lFKCkgJiYgISF3aW5kb3cuU3R5bGVNZWRpYTtcbiAgICAgICAgfSxcblxuICAgICAgICBpc0Nocm9tZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyAqKiogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTg0NzU4MC9ob3ctdG8tZGV0ZWN0LXNhZmFyaS1jaHJvbWUtaWUtZmlyZWZveC1hbmQtb3BlcmEtYnJvd3NlclxuICAgICAgICAgICAgLy8gQ2hyb21lIDErXG4gICAgICAgICAgICByZXR1cm4gISF3aW5kb3cuY2hyb21lICYmICEhd2luZG93LmNocm9tZS53ZWJzdG9yZTtcbiAgICAgICAgfSxcblxuICAgICAgICBpc0JsaW5rOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vICoqKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy85ODQ3NTgwL2hvdy10by1kZXRlY3Qtc2FmYXJpLWNocm9tZS1pZS1maXJlZm94LWFuZC1vcGVyYS1icm93c2VyXG4gICAgICAgICAgICByZXR1cm4gKGJyb3dzZXIuaXNDaHJvbWUoKSB8fCBicm93c2VyLmlzT3BlcmEoKSkgJiYgISF3aW5kb3cuQ1NTO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgICQucGxvdC5icm93c2VyID0gYnJvd3Nlcjtcbn0pKGpRdWVyeSk7XG4iLCIvKiBGbG90IHBsdWdpbiBmb3IgcGxvdHRpbmcgdGV4dHVhbCBkYXRhIG9yIGNhdGVnb3JpZXMuXG5cbkNvcHlyaWdodCAoYykgMjAwNy0yMDE0IElPTEEgYW5kIE9sZSBMYXVyc2VuLlxuTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXG5Db25zaWRlciBhIGRhdGFzZXQgbGlrZSBbW1wiRmVicnVhcnlcIiwgMzRdLCBbXCJNYXJjaFwiLCAyMF0sIC4uLl0uIFRoaXMgcGx1Z2luXG5hbGxvd3MgeW91IHRvIHBsb3Qgc3VjaCBhIGRhdGFzZXQgZGlyZWN0bHkuXG5cblRvIGVuYWJsZSBpdCwgeW91IG11c3Qgc3BlY2lmeSBtb2RlOiBcImNhdGVnb3JpZXNcIiBvbiB0aGUgYXhpcyB3aXRoIHRoZSB0ZXh0dWFsXG5sYWJlbHMsIGUuZy5cblxuICAgICQucGxvdChcIiNwbGFjZWhvbGRlclwiLCBkYXRhLCB7IHhheGlzOiB7IG1vZGU6IFwiY2F0ZWdvcmllc1wiIH0gfSk7XG5cbkJ5IGRlZmF1bHQsIHRoZSBsYWJlbHMgYXJlIG9yZGVyZWQgYXMgdGhleSBhcmUgbWV0IGluIHRoZSBkYXRhIHNlcmllcy4gSWYgeW91XG5uZWVkIGEgZGlmZmVyZW50IG9yZGVyaW5nLCB5b3UgY2FuIHNwZWNpZnkgXCJjYXRlZ29yaWVzXCIgb24gdGhlIGF4aXMgb3B0aW9uc1xuYW5kIGxpc3QgdGhlIGNhdGVnb3JpZXMgdGhlcmU6XG5cbiAgICB4YXhpczoge1xuICAgICAgICBtb2RlOiBcImNhdGVnb3JpZXNcIixcbiAgICAgICAgY2F0ZWdvcmllczogW1wiRmVicnVhcnlcIiwgXCJNYXJjaFwiLCBcIkFwcmlsXCJdXG4gICAgfVxuXG5JZiB5b3UgbmVlZCB0byBjdXN0b21pemUgdGhlIGRpc3RhbmNlcyBiZXR3ZWVuIHRoZSBjYXRlZ29yaWVzLCB5b3UgY2FuIHNwZWNpZnlcblwiY2F0ZWdvcmllc1wiIGFzIGFuIG9iamVjdCBtYXBwaW5nIGxhYmVscyB0byB2YWx1ZXNcblxuICAgIHhheGlzOiB7XG4gICAgICAgIG1vZGU6IFwiY2F0ZWdvcmllc1wiLFxuICAgICAgICBjYXRlZ29yaWVzOiB7IFwiRmVicnVhcnlcIjogMSwgXCJNYXJjaFwiOiAzLCBcIkFwcmlsXCI6IDQgfVxuICAgIH1cblxuSWYgeW91IGRvbid0IHNwZWNpZnkgYWxsIGNhdGVnb3JpZXMsIHRoZSByZW1haW5pbmcgY2F0ZWdvcmllcyB3aWxsIGJlIG51bWJlcmVkXG5mcm9tIHRoZSBtYXggdmFsdWUgcGx1cyAxICh3aXRoIGEgc3BhY2luZyBvZiAxIGJldHdlZW4gZWFjaCkuXG5cbkludGVybmFsbHksIHRoZSBwbHVnaW4gd29ya3MgYnkgdHJhbnNmb3JtaW5nIHRoZSBpbnB1dCBkYXRhIHRocm91Z2ggYW4gYXV0by1cbmdlbmVyYXRlZCBtYXBwaW5nIHdoZXJlIHRoZSBmaXJzdCBjYXRlZ29yeSBiZWNvbWVzIDAsIHRoZSBzZWNvbmQgMSwgZXRjLlxuSGVuY2UsIGEgcG9pbnQgbGlrZSBbXCJGZWJydWFyeVwiLCAzNF0gYmVjb21lcyBbMCwgMzRdIGludGVybmFsbHkgaW4gRmxvdCAodGhpc1xuaXMgdmlzaWJsZSBpbiBob3ZlciBhbmQgY2xpY2sgZXZlbnRzIHRoYXQgcmV0dXJuIG51bWJlcnMgcmF0aGVyIHRoYW4gdGhlXG5jYXRlZ29yeSBsYWJlbHMpLiBUaGUgcGx1Z2luIGFsc28gb3ZlcnJpZGVzIHRoZSB0aWNrIGdlbmVyYXRvciB0byBzcGl0IG91dCB0aGVcbmNhdGVnb3JpZXMgYXMgdGlja3MgaW5zdGVhZCBvZiB0aGUgdmFsdWVzLlxuXG5JZiB5b3UgbmVlZCB0byBtYXAgYSB2YWx1ZSBiYWNrIHRvIGl0cyBsYWJlbCwgdGhlIG1hcHBpbmcgaXMgYWx3YXlzIGFjY2Vzc2libGVcbmFzIFwiY2F0ZWdvcmllc1wiIG9uIHRoZSBheGlzIG9iamVjdCwgZS5nLiBwbG90LmdldEF4ZXMoKS54YXhpcy5jYXRlZ29yaWVzLlxuXG4qL1xuXG4oZnVuY3Rpb24gKCQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgeGF4aXM6IHtcbiAgICAgICAgICAgIGNhdGVnb3JpZXM6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgeWF4aXM6IHtcbiAgICAgICAgICAgIGNhdGVnb3JpZXM6IG51bGxcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzUmF3RGF0YShwbG90LCBzZXJpZXMsIGRhdGEsIGRhdGFwb2ludHMpIHtcbiAgICAgICAgLy8gaWYgY2F0ZWdvcmllcyBhcmUgZW5hYmxlZCwgd2UgbmVlZCB0byBkaXNhYmxlXG4gICAgICAgIC8vIGF1dG8tdHJhbnNmb3JtYXRpb24gdG8gbnVtYmVycyBzbyB0aGUgc3RyaW5ncyBhcmUgaW50YWN0XG4gICAgICAgIC8vIGZvciBsYXRlciBwcm9jZXNzaW5nXG5cbiAgICAgICAgdmFyIHhDYXRlZ29yaWVzID0gc2VyaWVzLnhheGlzLm9wdGlvbnMubW9kZSA9PT0gXCJjYXRlZ29yaWVzXCIsXG4gICAgICAgICAgICB5Q2F0ZWdvcmllcyA9IHNlcmllcy55YXhpcy5vcHRpb25zLm1vZGUgPT09IFwiY2F0ZWdvcmllc1wiO1xuXG4gICAgICAgIGlmICghKHhDYXRlZ29yaWVzIHx8IHlDYXRlZ29yaWVzKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZvcm1hdCA9IGRhdGFwb2ludHMuZm9ybWF0O1xuXG4gICAgICAgIGlmICghZm9ybWF0KSB7XG4gICAgICAgICAgICAvLyBGSVhNRTogYXV0by1kZXRlY3Rpb24gc2hvdWxkIHJlYWxseSBub3QgYmUgZGVmaW5lZCBoZXJlXG4gICAgICAgICAgICB2YXIgcyA9IHNlcmllcztcbiAgICAgICAgICAgIGZvcm1hdCA9IFtdO1xuICAgICAgICAgICAgZm9ybWF0LnB1c2goeyB4OiB0cnVlLCBudW1iZXI6IHRydWUsIHJlcXVpcmVkOiB0cnVlLCBjb21wdXRlUmFuZ2U6IHRydWV9KTtcbiAgICAgICAgICAgIGZvcm1hdC5wdXNoKHsgeTogdHJ1ZSwgbnVtYmVyOiB0cnVlLCByZXF1aXJlZDogdHJ1ZSwgY29tcHV0ZVJhbmdlOiB0cnVlIH0pO1xuXG4gICAgICAgICAgICBpZiAocy5iYXJzLnNob3cgfHwgKHMubGluZXMuc2hvdyAmJiBzLmxpbmVzLmZpbGwpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF1dG9TY2FsZSA9ICEhKChzLmJhcnMuc2hvdyAmJiBzLmJhcnMuemVybykgfHwgKHMubGluZXMuc2hvdyAmJiBzLmxpbmVzLnplcm8pKTtcbiAgICAgICAgICAgICAgICBmb3JtYXQucHVzaCh7IHk6IHRydWUsIG51bWJlcjogdHJ1ZSwgcmVxdWlyZWQ6IGZhbHNlLCBkZWZhdWx0VmFsdWU6IDAsIGNvbXB1dGVSYW5nZTogYXV0b1NjYWxlIH0pO1xuICAgICAgICAgICAgICAgIGlmIChzLmJhcnMuaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZm9ybWF0W2Zvcm1hdC5sZW5ndGggLSAxXS55O1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXRbZm9ybWF0Lmxlbmd0aCAtIDFdLnggPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGF0YXBvaW50cy5mb3JtYXQgPSBmb3JtYXQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBtID0gMDsgbSA8IGZvcm1hdC5sZW5ndGg7ICsrbSkge1xuICAgICAgICAgICAgaWYgKGZvcm1hdFttXS54ICYmIHhDYXRlZ29yaWVzKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0W21dLm51bWJlciA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZm9ybWF0W21dLnkgJiYgeUNhdGVnb3JpZXMpIHtcbiAgICAgICAgICAgICAgICBmb3JtYXRbbV0ubnVtYmVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9ybWF0W21dLmNvbXB1dGVSYW5nZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0TmV4dEluZGV4KGNhdGVnb3JpZXMpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTE7XG5cbiAgICAgICAgZm9yICh2YXIgdiBpbiBjYXRlZ29yaWVzKSB7XG4gICAgICAgICAgICBpZiAoY2F0ZWdvcmllc1t2XSA+IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBjYXRlZ29yaWVzW3ZdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluZGV4ICsgMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYXRlZ29yaWVzVGlja0dlbmVyYXRvcihheGlzKSB7XG4gICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgbGFiZWwgaW4gYXhpcy5jYXRlZ29yaWVzKSB7XG4gICAgICAgICAgICB2YXIgdiA9IGF4aXMuY2F0ZWdvcmllc1tsYWJlbF07XG4gICAgICAgICAgICBpZiAodiA+PSBheGlzLm1pbiAmJiB2IDw9IGF4aXMubWF4KSB7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2goW3YsIGxhYmVsXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXMuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYVswXSAtIGJbMF07IH0pO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0dXBDYXRlZ29yaWVzRm9yQXhpcyhzZXJpZXMsIGF4aXMsIGRhdGFwb2ludHMpIHtcbiAgICAgICAgaWYgKHNlcmllc1theGlzXS5vcHRpb25zLm1vZGUgIT09IFwiY2F0ZWdvcmllc1wiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNlcmllc1theGlzXS5jYXRlZ29yaWVzKSB7XG4gICAgICAgICAgICAvLyBwYXJzZSBvcHRpb25zXG4gICAgICAgICAgICB2YXIgYyA9IHt9LCBvID0gc2VyaWVzW2F4aXNdLm9wdGlvbnMuY2F0ZWdvcmllcyB8fCB7fTtcbiAgICAgICAgICAgIGlmICgkLmlzQXJyYXkobykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG8ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY1tvW2ldXSA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB2IGluIG8pIHtcbiAgICAgICAgICAgICAgICAgICAgY1t2XSA9IG9bdl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZXJpZXNbYXhpc10uY2F0ZWdvcmllcyA9IGM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaXggdGlja3NcbiAgICAgICAgaWYgKCFzZXJpZXNbYXhpc10ub3B0aW9ucy50aWNrcykge1xuICAgICAgICAgICAgc2VyaWVzW2F4aXNdLm9wdGlvbnMudGlja3MgPSBjYXRlZ29yaWVzVGlja0dlbmVyYXRvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyYW5zZm9ybVBvaW50c09uQXhpcyhkYXRhcG9pbnRzLCBheGlzLCBzZXJpZXNbYXhpc10uY2F0ZWdvcmllcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtUG9pbnRzT25BeGlzKGRhdGFwb2ludHMsIGF4aXMsIGNhdGVnb3JpZXMpIHtcbiAgICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgcG9pbnRzLCB0cmFuc2Zvcm1pbmcgdGhlbVxuICAgICAgICB2YXIgcG9pbnRzID0gZGF0YXBvaW50cy5wb2ludHMsXG4gICAgICAgICAgICBwcyA9IGRhdGFwb2ludHMucG9pbnRzaXplLFxuICAgICAgICAgICAgZm9ybWF0ID0gZGF0YXBvaW50cy5mb3JtYXQsXG4gICAgICAgICAgICBmb3JtYXRDb2x1bW4gPSBheGlzLmNoYXJBdCgwKSxcbiAgICAgICAgICAgIGluZGV4ID0gZ2V0TmV4dEluZGV4KGNhdGVnb3JpZXMpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSArPSBwcykge1xuICAgICAgICAgICAgaWYgKHBvaW50c1tpXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIG0gPSAwOyBtIDwgcHM7ICsrbSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSBwb2ludHNbaSArIG1dO1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbCA9PSBudWxsIHx8ICFmb3JtYXRbbV1bZm9ybWF0Q29sdW1uXSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoISh2YWwgaW4gY2F0ZWdvcmllcykpIHtcbiAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcmllc1t2YWxdID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcG9pbnRzW2kgKyBtXSA9IGNhdGVnb3JpZXNbdmFsXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NEYXRhcG9pbnRzKHBsb3QsIHNlcmllcywgZGF0YXBvaW50cykge1xuICAgICAgICBzZXR1cENhdGVnb3JpZXNGb3JBeGlzKHNlcmllcywgXCJ4YXhpc1wiLCBkYXRhcG9pbnRzKTtcbiAgICAgICAgc2V0dXBDYXRlZ29yaWVzRm9yQXhpcyhzZXJpZXMsIFwieWF4aXNcIiwgZGF0YXBvaW50cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5pdChwbG90KSB7XG4gICAgICAgIHBsb3QuaG9va3MucHJvY2Vzc1Jhd0RhdGEucHVzaChwcm9jZXNzUmF3RGF0YSk7XG4gICAgICAgIHBsb3QuaG9va3MucHJvY2Vzc0RhdGFwb2ludHMucHVzaChwcm9jZXNzRGF0YXBvaW50cyk7XG4gICAgfVxuXG4gICAgJC5wbG90LnBsdWdpbnMucHVzaCh7XG4gICAgICAgIGluaXQ6IGluaXQsXG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgIG5hbWU6ICdjYXRlZ29yaWVzJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMCdcbiAgICB9KTtcbn0pKGpRdWVyeSk7XG4iLCIvKiogIyMganF1ZXJ5LmZsb3QuY29tcG9zZUltYWdlcy5qc1xuXG5UaGlzIHBsdWdpbiBpcyB1c2VkIHRvIGV4cG9zZSBhIGZ1bmN0aW9uIHVzZWQgdG8gb3ZlcmxhcCBzZXZlcmFsIGNhbnZhc2VzIGFuZFxuU1ZHcywgZm9yIHRoZSBwdXJwb3NlIG9mIGNyZWF0aW5nIGEgc25hcGhvdCBvdXQgb2YgdGhlbS5cblxuIyMjIFdoZW4gY29tcG9zZUltYWdlcyBpcyB1c2VkOlxuV2hlbiBtdWx0aXBsZSBjYW52YXNlcyBhbmQgU1ZHcyBoYXZlIHRvIGJlIG92ZXJsYXBwZWQgaW50byBhIHNpbmdsZSBpbWFnZVxuYW5kIHRoZWlyIG9mZnNldCBvbiB0aGUgcGFnZSwgbXVzdCBiZSBwcmVzZXJ2ZWQuXG5cbiMjIyBXaGVyZSBjYW4gYmUgdXNlZDpcbkluIGNyZWF0aW5nIGEgZG93bmxvYWRhYmxlIHNuYXBzaG90IG9mIHRoZSBwbG90cywgYXhlcywgY3Vyc29ycyBldGMgb2YgYSBncmFwaC5cblxuIyMjIEhvdyBpdCB3b3JrczpcblRoZSBlbnRyeSBwb2ludCBpcyBjb21wb3NlSW1hZ2VzIGZ1bmN0aW9uLiBJdCBleHBlY3RzIGFuIGFycmF5IG9mIG9iamVjdHMsXG53aGljaCBzaG91bGQgYmUgZWl0aGVyIGNhbnZhc2VzIG9yIFNWR3MgKG9yIGEgbWl4KS4gSXQgZG9lcyBhIHByZXZhbGlkYXRpb25cbm9mIHRoZW0sIGJ5IHZlcmlmeWluZyBpZiB0aGV5IHdpbGwgYmUgdXNhYmxlIG9yIG5vdCwgbGF0ZXIgaW4gdGhlIGZsb3cuXG5BZnRlciBzZWxlY3Rpbmcgb25seSB1c2FibGUgc291cmNlcywgaXQgcGFzc2VzIHRoZW0gdG8gZ2V0R2VuZXJhdGVUZW1wSW1nXG5mdW5jdGlvbiwgd2hpY2ggZ2VuZXJhdGVzIHRlbXBvcmFyeSBpbWFnZXMgb3V0IG9mIHRoZW0uIFRoaXMgZnVuY3Rpb25cbmV4cGVjdHMgdGhhdCBzb21lIG9mIHRoZSBwYXNzZWQgc291cmNlcyAoY2FudmFzIG9yIFNWRykgbWF5IHN0aWxsIGhhdmVcbnByb2JsZW1zIGJlaW5nIGNvbnZlcnRlZCB0byBhbiBpbWFnZSBhbmQgbWFrZXMgc3VyZSB0aGUgcHJvbWlzZXMgc3lzdGVtLFxudXNlZCBieSBjb21wb3NlSW1hZ2VzIGZ1bmN0aW9uLCBtb3ZlcyBmb3J3YXJkLiBBcyBhbiBleGFtcGxlLCBTVkdzIHdpdGhcbm1pc3NpbmcgaW5mb3JtYXRpb24gZnJvbSBoZWFkZXIgb3Igd2l0aCB1bnN1cHBvcnRlZCBjb250ZW50LCBtYXkgbGVhZCB0b1xuZmFpbHVyZSBpbiBnZW5lcmF0aW5nIHRoZSB0ZW1wb3JhcnkgaW1hZ2UuIFRlbXBvcmFyeSBpbWFnZXMgYXJlIHJlcXVpcmVkXG5tb3N0bHkgb24gZXh0cmFjdGluZyBjb250ZW50IGZyb20gU1ZHcywgYnV0IHRoaXMgaXMgYWxzbyB3aGVyZSB0aGUgeC95XG5vZmZzZXRzIGFyZSBleHRyYWN0ZWQgZm9yIGVhY2ggaW1hZ2Ugd2hpY2ggd2lsbCBiZSBhZGRlZC4gRm9yIFNWR3MgaW5cbnBhcnRpY3VsYXIsIHRoZWlyIENTUyBydWxlcyBoYXZlIHRvIGJlIGFwcGxpZWQuXG5BZnRlciBhbGwgdGVtcG9yYXJ5IGltYWdlcyBhcmUgZ2VuZXJhdGVkLCB0aGV5IGFyZSBvdmVybGFwcGVkIHVzaW5nXG5nZXRFeGVjdXRlSW1nQ29tcG9zaXRpb24gZnVuY3Rpb24uIFRoaXMgaXMgd2hlcmUgdGhlIGRlc3RpbmF0aW9uIGNhbnZhc1xuaXMgc2V0IHRvIHRoZSBwcm9wZXIgZGltZW5zaW9ucy4gSXQgaXMgdGhlbiBvdXRwdXQgYnkgY29tcG9zZUltYWdlcy5cblRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIHByb21pc2UsIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHdhaXQgZm9yIHRoZSB3aG9sZVxuY29tcG9zaXRpb24gcHJvY2Vzcy4gSXQgcmVxdWlyZXMgdG8gYmUgYXN5bmNocm9ub3VzLCBiZWNhdXNlIHRoaXMgaXMgaG93XG50ZW1wb3JhcnkgaW1hZ2VzIGxvYWQgdGhlaXIgZGF0YS5cbiovXG5cbihmdW5jdGlvbigkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgY29uc3QgR0VORVJBTEZBSUxVUkVDQUxMQkFDS0VSUk9SID0gLTEwMDsgLy9zaW1wbHkgYSBuZWdhdGl2ZSBudW1iZXJcbiAgICBjb25zdCBTVUNDRVNTRlVMSU1BR0VQUkVQQVJBVElPTiA9IDA7XG4gICAgY29uc3QgRU1QVFlBUlJBWU9GSU1BR0VTT1VSQ0VTID0gLTE7XG4gICAgY29uc3QgTkVHQVRJVkVJTUFHRVNJWkUgPSAtMjtcbiAgICB2YXIgcGl4ZWxSYXRpbyA9IDE7XG4gICAgdmFyIGJyb3dzZXIgPSAkLnBsb3QuYnJvd3NlcjtcbiAgICB2YXIgZ2V0UGl4ZWxSYXRpbyA9IGJyb3dzZXIuZ2V0UGl4ZWxSYXRpbztcblxuICAgIGZ1bmN0aW9uIGNvbXBvc2VJbWFnZXMoY2FudmFzT3JTdmdTb3VyY2VzLCBkZXN0aW5hdGlvbkNhbnZhcykge1xuICAgICAgICB2YXIgdmFsaWRDYW52YXNPclN2Z1NvdXJjZXMgPSBjYW52YXNPclN2Z1NvdXJjZXMuZmlsdGVyKGlzVmFsaWRTb3VyY2UpO1xuICAgICAgICBwaXhlbFJhdGlvID0gZ2V0UGl4ZWxSYXRpbyhkZXN0aW5hdGlvbkNhbnZhcy5nZXRDb250ZXh0KCcyZCcpKTtcblxuICAgICAgICB2YXIgYWxsSW1nQ29tcG9zaXRpb25Qcm9taXNlcyA9IHZhbGlkQ2FudmFzT3JTdmdTb3VyY2VzLm1hcChmdW5jdGlvbih2YWxpZENhbnZhc09yU3ZnU291cmNlKSB7XG4gICAgICAgICAgICB2YXIgdGVtcEltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRQcm9taXNlID0gbmV3IFByb21pc2UoZ2V0R2VuZXJhdGVUZW1wSW1nKHRlbXBJbWcsIHZhbGlkQ2FudmFzT3JTdmdTb3VyY2UpKTtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50UHJvbWlzZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGxhc3RQcm9taXNlID0gUHJvbWlzZS5hbGwoYWxsSW1nQ29tcG9zaXRpb25Qcm9taXNlcykudGhlbihnZXRFeGVjdXRlSW1nQ29tcG9zaXRpb24oZGVzdGluYXRpb25DYW52YXMpLCBmYWlsdXJlQ2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gbGFzdFByb21pc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNWYWxpZFNvdXJjZShjYW52YXNPclN2Z1NvdXJjZSkge1xuICAgICAgICB2YXIgaXNWYWxpZEZyb21DYW52YXMgPSB0cnVlO1xuICAgICAgICB2YXIgaXNWYWxpZEZyb21Db250ZW50ID0gdHJ1ZTtcbiAgICAgICAgaWYgKChjYW52YXNPclN2Z1NvdXJjZSA9PT0gbnVsbCkgfHwgKGNhbnZhc09yU3ZnU291cmNlID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICBpc1ZhbGlkRnJvbUNvbnRlbnQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjYW52YXNPclN2Z1NvdXJjZS50YWdOYW1lID09PSAnQ0FOVkFTJykge1xuICAgICAgICAgICAgICAgIGlmICgoY2FudmFzT3JTdmdTb3VyY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkucmlnaHQgPT09IGNhbnZhc09yU3ZnU291cmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQpIHx8XG4gICAgICAgICAgICAgICAgICAgIChjYW52YXNPclN2Z1NvdXJjZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5ib3R0b20gPT09IGNhbnZhc09yU3ZnU291cmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNWYWxpZEZyb21DYW52YXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzVmFsaWRGcm9tQ29udGVudCAmJiBpc1ZhbGlkRnJvbUNhbnZhcyAmJiAod2luZG93LmdldENvbXB1dGVkU3R5bGUoY2FudmFzT3JTdmdTb3VyY2UpLnZpc2liaWxpdHkgPT09ICd2aXNpYmxlJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0R2VuZXJhdGVUZW1wSW1nKHRlbXBJbWcsIGNhbnZhc09yU3ZnU291cmNlKSB7XG4gICAgICAgIHRlbXBJbWcuc291cmNlRGVzY3JpcHRpb24gPSAnPGluZm8gY2xhc3NOYW1lPVwiJyArIGNhbnZhc09yU3ZnU291cmNlLmNsYXNzTmFtZSArICdcIiB0YWdOYW1lPVwiJyArIGNhbnZhc09yU3ZnU291cmNlLnRhZ05hbWUgKyAnXCIgaWQ9XCInICsgY2FudmFzT3JTdmdTb3VyY2UuaWQgKyAnXCI+JztcbiAgICAgICAgdGVtcEltZy5zb3VyY2VDb21wb25lbnQgPSBjYW52YXNPclN2Z1NvdXJjZTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gZG9HZW5lcmF0ZVRlbXBJbWcoc3VjY2Vzc0NhbGxiYWNrRnVuYywgZmFpbHVyZUNhbGxiYWNrRnVuYykge1xuICAgICAgICAgICAgdGVtcEltZy5vbmxvYWQgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgICAgICB0ZW1wSW1nLnN1Y2Nlc3NmdWxseUxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3VjY2Vzc0NhbGxiYWNrRnVuYyh0ZW1wSW1nKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRlbXBJbWcub25hYm9ydCA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgICAgIHRlbXBJbWcuc3VjY2Vzc2Z1bGx5TG9hZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0NhblxcJ3QgZ2VuZXJhdGUgdGVtcCBpbWFnZSBmcm9tICcgKyB0ZW1wSW1nLnNvdXJjZURlc2NyaXB0aW9uICsgJy4gSXQgaXMgcG9zc2libGUgdGhhdCBpdCBpcyBtaXNzaW5nIHNvbWUgcHJvcGVydGllcyBvciBpdHMgY29udGVudCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgYnJvd3Nlci4gU291cmNlIGNvbXBvbmVudDonLCB0ZW1wSW1nLnNvdXJjZUNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgc3VjY2Vzc0NhbGxiYWNrRnVuYyh0ZW1wSW1nKTsgLy9jYWxsIHN1Y2Nlc3NDYWxsYmFjaywgdG8gYWxsb3cgc25hcHNob3Qgb2YgYWxsIHdvcmtpbmcgaW1hZ2VzXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0ZW1wSW1nLm9uZXJyb3IgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgICAgICB0ZW1wSW1nLnN1Y2Nlc3NmdWxseUxvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDYW5cXCd0IGdlbmVyYXRlIHRlbXAgaW1hZ2UgZnJvbSAnICsgdGVtcEltZy5zb3VyY2VEZXNjcmlwdGlvbiArICcuIEl0IGlzIHBvc3NpYmxlIHRoYXQgaXQgaXMgbWlzc2luZyBzb21lIHByb3BlcnRpZXMgb3IgaXRzIGNvbnRlbnQgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIGJyb3dzZXIuIFNvdXJjZSBjb21wb25lbnQ6JywgdGVtcEltZy5zb3VyY2VDb21wb25lbnQpO1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3NDYWxsYmFja0Z1bmModGVtcEltZyk7IC8vY2FsbCBzdWNjZXNzQ2FsbGJhY2ssIHRvIGFsbG93IHNuYXBzaG90IG9mIGFsbCB3b3JraW5nIGltYWdlc1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZ2VuZXJhdGVUZW1wSW1hZ2VGcm9tQ2FudmFzT3JTdmcoY2FudmFzT3JTdmdTb3VyY2UsIHRlbXBJbWcpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEV4ZWN1dGVJbWdDb21wb3NpdGlvbihkZXN0aW5hdGlvbkNhbnZhcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gZXhlY3V0ZUltZ0NvbXBvc2l0aW9uKHRlbXBJbWdzKSB7XG4gICAgICAgICAgICB2YXIgY29tcG9zaXRpb25SZXN1bHQgPSBjb3B5SW1nc1RvQ2FudmFzKHRlbXBJbWdzLCBkZXN0aW5hdGlvbkNhbnZhcyk7XG4gICAgICAgICAgICByZXR1cm4gY29tcG9zaXRpb25SZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29weUNhbnZhc1RvSW1nKGNhbnZhcywgaW1nKSB7XG4gICAgICAgIGltZy5zcmMgPSBjYW52YXMudG9EYXRhVVJMKCdpbWFnZS9wbmcnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRDU1NSdWxlcyhkb2N1bWVudCkge1xuICAgICAgICB2YXIgc3R5bGVTaGVldHMgPSBkb2N1bWVudC5zdHlsZVNoZWV0cyxcbiAgICAgICAgICAgIHJ1bGVzTGlzdCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlU2hlZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBDT1JTIHJlcXVlc3RzIGZvciBzdHlsZSBzaGVldHMgdGhyb3cgYW5kIGFuIGV4Y2VwdGlvbiBvbiBDaHJvbWUgPiA2NFxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBpbiBDaHJvbWUsIHRoZSBleHRlcm5hbCBDU1MgZmlsZXMgYXJlIGVtcHR5IHdoZW4gdGhlIHBhZ2UgaXMgZGlyZWN0bHkgbG9hZGVkIGZyb20gZGlza1xuICAgICAgICAgICAgICAgIHZhciBydWxlcyA9IHN0eWxlU2hlZXRzW2ldLmNzc1J1bGVzIHx8IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcnVsZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJ1bGUgPSBydWxlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgcnVsZXNMaXN0LnB1c2gocnVsZS5jc3NUZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZhaWxlZCB0byBnZXQgc29tZSBjc3MgcnVsZXMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVsZXNMaXN0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVtYmVkQ1NTUnVsZXNJblNWRyhydWxlcywgc3ZnKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gW1xuICAgICAgICAgICAgJzxzdmcgY2xhc3M9XCJzbmFwc2hvdCAnICsgc3ZnLmNsYXNzTGlzdCArICdcIiB3aWR0aD1cIicgKyBzdmcud2lkdGguYmFzZVZhbC52YWx1ZSAqIHBpeGVsUmF0aW8gKyAnXCIgaGVpZ2h0PVwiJyArIHN2Zy5oZWlnaHQuYmFzZVZhbC52YWx1ZSAqIHBpeGVsUmF0aW8gKyAnXCIgdmlld0JveD1cIjAgMCAnICsgc3ZnLndpZHRoLmJhc2VWYWwudmFsdWUgKyAnICcgKyBzdmcuaGVpZ2h0LmJhc2VWYWwudmFsdWUgKyAnXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPicsXG4gICAgICAgICAgICAnPHN0eWxlPicsXG4gICAgICAgICAgICAnLyogPCFbQ0RBVEFbICovJyxcbiAgICAgICAgICAgIHJ1bGVzLmpvaW4oJ1xcbicpLFxuICAgICAgICAgICAgJy8qIF1dPiAqLycsXG4gICAgICAgICAgICAnPC9zdHlsZT4nLFxuICAgICAgICAgICAgc3ZnLmlubmVySFRNTCxcbiAgICAgICAgICAgICc8L3N2Zz4nXG4gICAgICAgIF0uam9pbignXFxuJyk7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvcHlTVkdUb0ltZ01vc3RCcm93c2VycyhzdmcsIGltZykge1xuICAgICAgICB2YXIgcnVsZXMgPSBnZXRDU1NSdWxlcyhkb2N1bWVudCksXG4gICAgICAgICAgICBzb3VyY2UgPSBlbWJlZENTU1J1bGVzSW5TVkcocnVsZXMsIHN2Zyk7XG5cbiAgICAgICAgc291cmNlID0gcGF0Y2hTVkdTb3VyY2Uoc291cmNlKTtcblxuICAgICAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtzb3VyY2VdLCB7dHlwZTogXCJpbWFnZS9zdmcreG1sO2NoYXJzZXQ9dXRmLThcIn0pLFxuICAgICAgICAgICAgZG9tVVJMID0gc2VsZi5VUkwgfHwgc2VsZi53ZWJraXRVUkwgfHwgc2VsZixcbiAgICAgICAgICAgIHVybCA9IGRvbVVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgIGltZy5zcmMgPSB1cmw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29weVNWR1RvSW1nU2FmYXJpKHN2ZywgaW1nKSB7XG4gICAgICAgIC8vIFVzZSB0aGlzIG1ldGhvZCB0byBjb252ZXJ0IGEgc3RyaW5nIGJ1ZmZlciBhcnJheSB0byBhIGJpbmFyeSBzdHJpbmcuXG4gICAgICAgIC8vIERvIHNvIGJ5IGJyZWFraW5nIHVwIGxhcmdlIHN0cmluZ3MgaW50byBzbWFsbGVyIHN1YnN0cmluZ3M7IHRoaXMgaXMgbmVjZXNzYXJ5IHRvIGF2b2lkIHRoZVxuICAgICAgICAvLyBcIm1heGltdW0gY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIgZXhjZXB0aW9uIHRoYXQgY2FuIGhhcHBlbiB3aGVuIGNhbGxpbmcgJ1N0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHknXG4gICAgICAgIC8vIHdpdGggYSB2ZXJ5IGxvbmcgYXJyYXkuXG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkQmluYXJ5U3RyaW5nIChhcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgdmFyIGJpbmFyeVN0cmluZyA9IFwiXCI7XG4gICAgICAgICAgICBjb25zdCB1dGY4QXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcik7XG4gICAgICAgICAgICBjb25zdCBibG9ja1NpemUgPSAxNjM4NDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXRmOEFycmF5Lmxlbmd0aDsgaSA9IGkgKyBibG9ja1NpemUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiaW5hcnlTdWJTdHJpbmcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIHV0ZjhBcnJheS5zdWJhcnJheShpLCBpICsgYmxvY2tTaXplKSk7XG4gICAgICAgICAgICAgICAgYmluYXJ5U3RyaW5nID0gYmluYXJ5U3RyaW5nICsgYmluYXJ5U3ViU3RyaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJpbmFyeVN0cmluZztcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcnVsZXMgPSBnZXRDU1NSdWxlcyhkb2N1bWVudCksXG4gICAgICAgICAgICBzb3VyY2UgPSBlbWJlZENTU1J1bGVzSW5TVkcocnVsZXMsIHN2ZyksXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgdXRmOEJpbmFyeVN0cmluZztcblxuICAgICAgICBzb3VyY2UgPSBwYXRjaFNWR1NvdXJjZShzb3VyY2UpO1xuXG4gICAgICAgIC8vIEVuY29kZSB0aGUgc3RyaW5nIGFzIFVURi04IGFuZCBjb252ZXJ0IGl0IHRvIGEgYmluYXJ5IHN0cmluZy4gVGhlIFVURi04IGVuY29kaW5nIGlzIHJlcXVpcmVkIHRvXG4gICAgICAgIC8vIGNhcHR1cmUgdW5pY29kZSBjaGFyYWN0ZXJzIGNvcnJlY3RseS5cbiAgICAgICAgdXRmOEJpbmFyeVN0cmluZyA9IGJ1aWxkQmluYXJ5U3RyaW5nKG5ldyAoVGV4dEVuY29kZXIgfHwgVGV4dEVuY29kZXJMaXRlKSgndXRmLTgnKS5lbmNvZGUoc291cmNlKSk7XG5cbiAgICAgICAgZGF0YSA9IFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxcIiArIGJ0b2EodXRmOEJpbmFyeVN0cmluZyk7XG4gICAgICAgIGltZy5zcmMgPSBkYXRhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhdGNoU1ZHU291cmNlKHN2Z1NvdXJjZSkge1xuICAgICAgICB2YXIgc291cmNlID0gJyc7XG4gICAgICAgIC8vYWRkIG5hbWUgc3BhY2VzLlxuICAgICAgICBpZiAoIXN2Z1NvdXJjZS5tYXRjaCgvXjxzdmdbXj5dK3htbG5zPVwiaHR0cDpcXC9cXC93d3dcXC53M1xcLm9yZ1xcLzIwMDBcXC9zdmdcIi8pKSB7XG4gICAgICAgICAgICBzb3VyY2UgPSBzdmdTb3VyY2UucmVwbGFjZSgvXjxzdmcvLCAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN2Z1NvdXJjZS5tYXRjaCgvXjxzdmdbXj5dK1wiaHR0cDpcXC9cXC93d3dcXC53M1xcLm9yZ1xcLzE5OTlcXC94bGlua1wiLykpIHtcbiAgICAgICAgICAgIHNvdXJjZSA9IHN2Z1NvdXJjZS5yZXBsYWNlKC9ePHN2Zy8sICc8c3ZnIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2FkZCB4bWwgZGVjbGFyYXRpb25cbiAgICAgICAgcmV0dXJuICc8P3htbCB2ZXJzaW9uPVwiMS4wXCIgc3RhbmRhbG9uZT1cIm5vXCI/PlxcclxcbicgKyBzb3VyY2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29weVNWR1RvSW1nKHN2ZywgaW1nKSB7XG4gICAgICAgIGlmIChicm93c2VyLmlzU2FmYXJpKCkgfHwgYnJvd3Nlci5pc01vYmlsZVNhZmFyaSgpKSB7XG4gICAgICAgICAgICBjb3B5U1ZHVG9JbWdTYWZhcmkoc3ZnLCBpbWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29weVNWR1RvSW1nTW9zdEJyb3dzZXJzKHN2ZywgaW1nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkYXB0RGVzdFNpemVUb1pvb20oZGVzdGluYXRpb25DYW52YXMsIHNvdXJjZXMpIHtcbiAgICAgICAgZnVuY3Rpb24gY29udGFpbnNTVkdzKHNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5zcmNJbWdUYWdOYW1lID09PSAnc3ZnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzb3VyY2VzLmZpbmQoY29udGFpbnNTVkdzKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAocGl4ZWxSYXRpbyA8IDEpIHtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbkNhbnZhcy53aWR0aCA9IGRlc3RpbmF0aW9uQ2FudmFzLndpZHRoICogcGl4ZWxSYXRpbztcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbkNhbnZhcy5oZWlnaHQgPSBkZXN0aW5hdGlvbkNhbnZhcy5oZWlnaHQgKiBwaXhlbFJhdGlvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlcGFyZUltYWdlc1RvQmVDb21wb3NlZChzb3VyY2VzLCBkZXN0aW5hdGlvbikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gU1VDQ0VTU0ZVTElNQUdFUFJFUEFSQVRJT047XG4gICAgICAgIGlmIChzb3VyY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gRU1QVFlBUlJBWU9GSU1BR0VTT1VSQ0VTOyAvL25vdGhpbmcgdG8gZG8gaWYgY2FsbGVkIHdpdGhvdXQgc291cmNlc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG1pblggPSBzb3VyY2VzWzBdLmdlbkxlZnQ7XG4gICAgICAgICAgICB2YXIgbWluWSA9IHNvdXJjZXNbMF0uZ2VuVG9wO1xuICAgICAgICAgICAgdmFyIG1heFggPSBzb3VyY2VzWzBdLmdlblJpZ2h0O1xuICAgICAgICAgICAgdmFyIG1heFkgPSBzb3VyY2VzWzBdLmdlbkJvdHRvbTtcbiAgICAgICAgICAgIHZhciBpID0gMDtcblxuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IHNvdXJjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobWluWCA+IHNvdXJjZXNbaV0uZ2VuTGVmdCkge1xuICAgICAgICAgICAgICAgICAgICBtaW5YID0gc291cmNlc1tpXS5nZW5MZWZ0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChtaW5ZID4gc291cmNlc1tpXS5nZW5Ub3ApIHtcbiAgICAgICAgICAgICAgICAgICAgbWluWSA9IHNvdXJjZXNbaV0uZ2VuVG9wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IHNvdXJjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4WCA8IHNvdXJjZXNbaV0uZ2VuUmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4WCA9IHNvdXJjZXNbaV0uZ2VuUmlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG1heFkgPCBzb3VyY2VzW2ldLmdlbkJvdHRvbSkge1xuICAgICAgICAgICAgICAgICAgICBtYXhZID0gc291cmNlc1tpXS5nZW5Cb3R0b207XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoKG1heFggLSBtaW5YIDw9IDApIHx8IChtYXhZIC0gbWluWSA8PSAwKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IE5FR0FUSVZFSU1BR0VTSVpFOyAvL3RoaXMgbWlnaHQgb2NjdXIgb24gaGlkZGVuIGltYWdlc1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi53aWR0aCA9IE1hdGgucm91bmQobWF4WCAtIG1pblgpO1xuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLmhlaWdodCA9IE1hdGgucm91bmQobWF4WSAtIG1pblkpO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlc1tpXS54Q29tcE9mZnNldCA9IHNvdXJjZXNbaV0uZ2VuTGVmdCAtIG1pblg7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZXNbaV0ueUNvbXBPZmZzZXQgPSBzb3VyY2VzW2ldLmdlblRvcCAtIG1pblk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYWRhcHREZXN0U2l6ZVRvWm9vbShkZXN0aW5hdGlvbiwgc291cmNlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb3B5SW1nc1RvQ2FudmFzKHNvdXJjZXMsIGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIHZhciBwcmVwYXJlSW1hZ2VzUmVzdWx0ID0gcHJlcGFyZUltYWdlc1RvQmVDb21wb3NlZChzb3VyY2VzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIGlmIChwcmVwYXJlSW1hZ2VzUmVzdWx0ID09PSBTVUNDRVNTRlVMSU1BR0VQUkVQQVJBVElPTikge1xuICAgICAgICAgICAgdmFyIGRlc3RpbmF0aW9uQ3R4ID0gZGVzdGluYXRpb24uZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZXNbaV0uc3VjY2Vzc2Z1bGx5TG9hZGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uQ3R4LmRyYXdJbWFnZShzb3VyY2VzW2ldLCBzb3VyY2VzW2ldLnhDb21wT2Zmc2V0ICogcGl4ZWxSYXRpbywgc291cmNlc1tpXS55Q29tcE9mZnNldCAqIHBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJlcGFyZUltYWdlc1Jlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZG5vdGF0ZURlc3RJbWdXaXRoQm91bmRpbmdDbGllbnRSZWN0KHNyY0NhbnZhc09yU3ZnLCBkZXN0SW1nKSB7XG4gICAgICAgIGRlc3RJbWcuZ2VuTGVmdCA9IHNyY0NhbnZhc09yU3ZnLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG4gICAgICAgIGRlc3RJbWcuZ2VuVG9wID0gc3JjQ2FudmFzT3JTdmcuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuXG4gICAgICAgIGlmIChzcmNDYW52YXNPclN2Zy50YWdOYW1lID09PSAnQ0FOVkFTJykge1xuICAgICAgICAgICAgZGVzdEltZy5nZW5SaWdodCA9IGRlc3RJbWcuZ2VuTGVmdCArIHNyY0NhbnZhc09yU3ZnLndpZHRoO1xuICAgICAgICAgICAgZGVzdEltZy5nZW5Cb3R0b20gPSBkZXN0SW1nLmdlblRvcCArIHNyY0NhbnZhc09yU3ZnLmhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzcmNDYW52YXNPclN2Zy50YWdOYW1lID09PSAnc3ZnJykge1xuICAgICAgICAgICAgZGVzdEltZy5nZW5SaWdodCA9IHNyY0NhbnZhc09yU3ZnLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnJpZ2h0O1xuICAgICAgICAgICAgZGVzdEltZy5nZW5Cb3R0b20gPSBzcmNDYW52YXNPclN2Zy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5ib3R0b207XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZVRlbXBJbWFnZUZyb21DYW52YXNPclN2ZyhzcmNDYW52YXNPclN2ZywgZGVzdEltZykge1xuICAgICAgICBpZiAoc3JjQ2FudmFzT3JTdmcudGFnTmFtZSA9PT0gJ0NBTlZBUycpIHtcbiAgICAgICAgICAgIGNvcHlDYW52YXNUb0ltZyhzcmNDYW52YXNPclN2ZywgZGVzdEltZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3JjQ2FudmFzT3JTdmcudGFnTmFtZSA9PT0gJ3N2ZycpIHtcbiAgICAgICAgICAgIGNvcHlTVkdUb0ltZyhzcmNDYW52YXNPclN2ZywgZGVzdEltZyk7XG4gICAgICAgIH1cblxuICAgICAgICBkZXN0SW1nLnNyY0ltZ1RhZ05hbWUgPSBzcmNDYW52YXNPclN2Zy50YWdOYW1lO1xuICAgICAgICBhZG5vdGF0ZURlc3RJbWdXaXRoQm91bmRpbmdDbGllbnRSZWN0KHNyY0NhbnZhc09yU3ZnLCBkZXN0SW1nKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmYWlsdXJlQ2FsbGJhY2soKSB7XG4gICAgICAgIHJldHVybiBHRU5FUkFMRkFJTFVSRUNBTExCQUNLRVJST1I7XG4gICAgfVxuXG4gICAgLy8gdXNlZCBmb3IgdGVzdGluZ1xuICAgICQucGxvdC5jb21wb3NlSW1hZ2VzID0gY29tcG9zZUltYWdlcztcblxuICAgIGZ1bmN0aW9uIGluaXQocGxvdCkge1xuICAgICAgICAvLyB1c2VkIHRvIGV4dGVuZCB0aGUgcHVibGljIEFQSSBvZiB0aGUgcGxvdFxuICAgICAgICBwbG90LmNvbXBvc2VJbWFnZXMgPSBjb21wb3NlSW1hZ2VzO1xuICAgIH1cblxuICAgICQucGxvdC5wbHVnaW5zLnB1c2goe1xuICAgICAgICBpbml0OiBpbml0LFxuICAgICAgICBuYW1lOiAnY29tcG9zZUltYWdlcycsXG4gICAgICAgIHZlcnNpb246ICcxLjAnXG4gICAgfSk7XG59KShqUXVlcnkpO1xuIiwiLyogRmxvdCBwbHVnaW4gZm9yIHNob3dpbmcgY3Jvc3NoYWlycyB3aGVuIHRoZSBtb3VzZSBob3ZlcnMgb3ZlciB0aGUgcGxvdC5cblxuQ29weXJpZ2h0IChjKSAyMDA3LTIwMTQgSU9MQSBhbmQgT2xlIExhdXJzZW4uXG5MaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cblRoZSBwbHVnaW4gc3VwcG9ydHMgdGhlc2Ugb3B0aW9uczpcblxuICAgIGNyb3NzaGFpcjoge1xuICAgICAgICBtb2RlOiBudWxsIG9yIFwieFwiIG9yIFwieVwiIG9yIFwieHlcIlxuICAgICAgICBjb2xvcjogY29sb3JcbiAgICAgICAgbGluZVdpZHRoOiBudW1iZXJcbiAgICB9XG5cblNldCB0aGUgbW9kZSB0byBvbmUgb2YgXCJ4XCIsIFwieVwiIG9yIFwieHlcIi4gVGhlIFwieFwiIG1vZGUgZW5hYmxlcyBhIHZlcnRpY2FsXG5jcm9zc2hhaXIgdGhhdCBsZXRzIHlvdSB0cmFjZSB0aGUgdmFsdWVzIG9uIHRoZSB4IGF4aXMsIFwieVwiIGVuYWJsZXMgYVxuaG9yaXpvbnRhbCBjcm9zc2hhaXIgYW5kIFwieHlcIiBlbmFibGVzIHRoZW0gYm90aC4gXCJjb2xvclwiIGlzIHRoZSBjb2xvciBvZiB0aGVcbmNyb3NzaGFpciAoZGVmYXVsdCBpcyBcInJnYmEoMTcwLCAwLCAwLCAwLjgwKVwiKSwgXCJsaW5lV2lkdGhcIiBpcyB0aGUgd2lkdGggb2ZcbnRoZSBkcmF3biBsaW5lcyAoZGVmYXVsdCBpcyAxKS5cblxuVGhlIHBsdWdpbiBhbHNvIGFkZHMgZm91ciBwdWJsaWMgbWV0aG9kczpcblxuICAtIHNldENyb3NzaGFpciggcG9zIClcblxuICAgIFNldCB0aGUgcG9zaXRpb24gb2YgdGhlIGNyb3NzaGFpci4gTm90ZSB0aGF0IHRoaXMgaXMgY2xlYXJlZCBpZiB0aGUgdXNlclxuICAgIG1vdmVzIHRoZSBtb3VzZS4gXCJwb3NcIiBpcyBpbiBjb29yZGluYXRlcyBvZiB0aGUgcGxvdCBhbmQgc2hvdWxkIGJlIG9uIHRoZVxuICAgIGZvcm0geyB4OiB4cG9zLCB5OiB5cG9zIH0gKHlvdSBjYW4gdXNlIHgyL3gzLy4uLiBpZiB5b3UncmUgdXNpbmcgbXVsdGlwbGVcbiAgICBheGVzKSwgd2hpY2ggaXMgY29pbmNpZGVudGFsbHkgdGhlIHNhbWUgZm9ybWF0IGFzIHdoYXQgeW91IGdldCBmcm9tIGFcbiAgICBcInBsb3Rob3ZlclwiIGV2ZW50LiBJZiBcInBvc1wiIGlzIG51bGwsIHRoZSBjcm9zc2hhaXIgaXMgY2xlYXJlZC5cblxuICAtIGNsZWFyQ3Jvc3NoYWlyKClcblxuICAgIENsZWFyIHRoZSBjcm9zc2hhaXIuXG5cbiAgLSBsb2NrQ3Jvc3NoYWlyKHBvcylcblxuICAgIENhdXNlIHRoZSBjcm9zc2hhaXIgdG8gbG9jayB0byB0aGUgY3VycmVudCBsb2NhdGlvbiwgbm8gbG9uZ2VyIHVwZGF0aW5nIGlmXG4gICAgdGhlIHVzZXIgbW92ZXMgdGhlIG1vdXNlLiBPcHRpb25hbGx5IHN1cHBseSBhIHBvc2l0aW9uIChwYXNzZWQgb24gdG9cbiAgICBzZXRDcm9zc2hhaXIoKSkgdG8gbW92ZSBpdCB0by5cblxuICAgIEV4YW1wbGUgdXNhZ2U6XG5cbiAgICB2YXIgbXlGbG90ID0gJC5wbG90KCAkKFwiI2dyYXBoXCIpLCAuLi4sIHsgY3Jvc3NoYWlyOiB7IG1vZGU6IFwieFwiIH0gfSB9O1xuICAgICQoXCIjZ3JhcGhcIikuYmluZCggXCJwbG90aG92ZXJcIiwgZnVuY3Rpb24gKCBldnQsIHBvc2l0aW9uLCBpdGVtICkge1xuICAgICAgICBpZiAoIGl0ZW0gKSB7XG4gICAgICAgICAgICAvLyBMb2NrIHRoZSBjcm9zc2hhaXIgdG8gdGhlIGRhdGEgcG9pbnQgYmVpbmcgaG92ZXJlZFxuICAgICAgICAgICAgbXlGbG90LmxvY2tDcm9zc2hhaXIoe1xuICAgICAgICAgICAgICAgIHg6IGl0ZW0uZGF0YXBvaW50WyAwIF0sXG4gICAgICAgICAgICAgICAgeTogaXRlbS5kYXRhcG9pbnRbIDEgXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBSZXR1cm4gbm9ybWFsIGNyb3NzaGFpciBvcGVyYXRpb25cbiAgICAgICAgICAgIG15RmxvdC51bmxvY2tDcm9zc2hhaXIoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gIC0gdW5sb2NrQ3Jvc3NoYWlyKClcblxuICAgIEZyZWUgdGhlIGNyb3NzaGFpciB0byBtb3ZlIGFnYWluIGFmdGVyIGxvY2tpbmcgaXQuXG4qL1xuXG4oZnVuY3Rpb24gKCQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgY3Jvc3NoYWlyOiB7XG4gICAgICAgICAgICBtb2RlOiBudWxsLCAvLyBvbmUgb2YgbnVsbCwgXCJ4XCIsIFwieVwiIG9yIFwieHlcIixcbiAgICAgICAgICAgIGNvbG9yOiBcInJnYmEoMTcwLCAwLCAwLCAwLjgwKVwiLFxuICAgICAgICAgICAgbGluZVdpZHRoOiAxXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaW5pdChwbG90KSB7XG4gICAgICAgIC8vIHBvc2l0aW9uIG9mIGNyb3NzaGFpciBpbiBwaXhlbHNcbiAgICAgICAgdmFyIGNyb3NzaGFpciA9IHt4OiAtMSwgeTogLTEsIGxvY2tlZDogZmFsc2UsIGhpZ2hsaWdodGVkOiBmYWxzZX07XG5cbiAgICAgICAgcGxvdC5zZXRDcm9zc2hhaXIgPSBmdW5jdGlvbiBzZXRDcm9zc2hhaXIocG9zKSB7XG4gICAgICAgICAgICBpZiAoIXBvcykge1xuICAgICAgICAgICAgICAgIGNyb3NzaGFpci54ID0gLTE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBvID0gcGxvdC5wMmMocG9zKTtcbiAgICAgICAgICAgICAgICBjcm9zc2hhaXIueCA9IE1hdGgubWF4KDAsIE1hdGgubWluKG8ubGVmdCwgcGxvdC53aWR0aCgpKSk7XG4gICAgICAgICAgICAgICAgY3Jvc3NoYWlyLnkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihvLnRvcCwgcGxvdC5oZWlnaHQoKSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwbG90LnRyaWdnZXJSZWRyYXdPdmVybGF5KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcGxvdC5jbGVhckNyb3NzaGFpciA9IHBsb3Quc2V0Q3Jvc3NoYWlyOyAvLyBwYXNzZXMgbnVsbCBmb3IgcG9zXG5cbiAgICAgICAgcGxvdC5sb2NrQ3Jvc3NoYWlyID0gZnVuY3Rpb24gbG9ja0Nyb3NzaGFpcihwb3MpIHtcbiAgICAgICAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgICAgICAgICBwbG90LnNldENyb3NzaGFpcihwb3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjcm9zc2hhaXIubG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICBwbG90LnVubG9ja0Nyb3NzaGFpciA9IGZ1bmN0aW9uIHVubG9ja0Nyb3NzaGFpcigpIHtcbiAgICAgICAgICAgIGNyb3NzaGFpci5sb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNyb3NzaGFpci5yZWN0ID0gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBvbk1vdXNlT3V0KGUpIHtcbiAgICAgICAgICAgIGlmIChjcm9zc2hhaXIubG9ja2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3Jvc3NoYWlyLnggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY3Jvc3NoYWlyLnggPSAtMTtcbiAgICAgICAgICAgICAgICBwbG90LnRyaWdnZXJSZWRyYXdPdmVybGF5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBvbk1vdXNlTW92ZShlKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gcGxvdC5vZmZzZXQoKTtcbiAgICAgICAgICAgIGlmIChjcm9zc2hhaXIubG9ja2VkKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1vdXNlWCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGUucGFnZVggLSBvZmZzZXQubGVmdCwgcGxvdC53aWR0aCgpKSk7XG4gICAgICAgICAgICAgICAgdmFyIG1vdXNlWSA9IE1hdGgubWF4KDAsIE1hdGgubWluKGUucGFnZVkgLSBvZmZzZXQudG9wLCBwbG90LmhlaWdodCgpKSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoKG1vdXNlWCA+IGNyb3NzaGFpci54IC0gNCkgJiYgKG1vdXNlWCA8IGNyb3NzaGFpci54ICsgNCkgJiYgKG1vdXNlWSA+IGNyb3NzaGFpci55IC0gNCkgJiYgKG1vdXNlWSA8IGNyb3NzaGFpci55ICsgNCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjcm9zc2hhaXIuaGlnaGxpZ2h0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyb3NzaGFpci5oaWdobGlnaHRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBwbG90LnRyaWdnZXJSZWRyYXdPdmVybGF5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3Jvc3NoYWlyLmhpZ2hsaWdodGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcm9zc2hhaXIuaGlnaGxpZ2h0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsb3QudHJpZ2dlclJlZHJhd092ZXJsYXkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwbG90LmdldFNlbGVjdGlvbiAmJiBwbG90LmdldFNlbGVjdGlvbigpKSB7XG4gICAgICAgICAgICAgICAgY3Jvc3NoYWlyLnggPSAtMTsgLy8gaGlkZSB0aGUgY3Jvc3NoYWlyIHdoaWxlIHNlbGVjdGluZ1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3Jvc3NoYWlyLnggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihlLnBhZ2VYIC0gb2Zmc2V0LmxlZnQsIHBsb3Qud2lkdGgoKSkpO1xuICAgICAgICAgICAgY3Jvc3NoYWlyLnkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihlLnBhZ2VZIC0gb2Zmc2V0LnRvcCwgcGxvdC5oZWlnaHQoKSkpO1xuICAgICAgICAgICAgcGxvdC50cmlnZ2VyUmVkcmF3T3ZlcmxheSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGxvdC5ob29rcy5iaW5kRXZlbnRzLnB1c2goZnVuY3Rpb24gKHBsb3QsIGV2ZW50SG9sZGVyKSB7XG4gICAgICAgICAgICBpZiAoIXBsb3QuZ2V0T3B0aW9ucygpLmNyb3NzaGFpci5tb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBldmVudEhvbGRlci5tb3VzZW91dChvbk1vdXNlT3V0KTtcbiAgICAgICAgICAgIGV2ZW50SG9sZGVyLm1vdXNlbW92ZShvbk1vdXNlTW92ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHBsb3QuaG9va3MuZHJhd092ZXJsYXkucHVzaChmdW5jdGlvbiAocGxvdCwgY3R4KSB7XG4gICAgICAgICAgICB2YXIgYyA9IHBsb3QuZ2V0T3B0aW9ucygpLmNyb3NzaGFpcjtcbiAgICAgICAgICAgIGlmICghYy5tb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcGxvdE9mZnNldCA9IHBsb3QuZ2V0UGxvdE9mZnNldCgpO1xuXG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShwbG90T2Zmc2V0LmxlZnQsIHBsb3RPZmZzZXQudG9wKTtcblxuICAgICAgICAgICAgaWYgKGNyb3NzaGFpci54ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHZhciBhZGogPSBwbG90LmdldE9wdGlvbnMoKS5jcm9zc2hhaXIubGluZVdpZHRoICUgMiA/IDAuNSA6IDA7XG5cbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjLmNvbG9yO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBjLmxpbmVXaWR0aDtcbiAgICAgICAgICAgICAgICBjdHgubGluZUpvaW4gPSBcInJvdW5kXCI7XG5cbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgaWYgKGMubW9kZS5pbmRleE9mKFwieFwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRyYXdYID0gTWF0aC5mbG9vcihjcm9zc2hhaXIueCkgKyBhZGo7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oZHJhd1gsIDApO1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKGRyYXdYLCBwbG90LmhlaWdodCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGMubW9kZS5pbmRleE9mKFwieVwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRyYXdZID0gTWF0aC5mbG9vcihjcm9zc2hhaXIueSkgKyBhZGo7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oMCwgZHJhd1kpO1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHBsb3Qud2lkdGgoKSwgZHJhd1kpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3Jvc3NoYWlyLmxvY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3Jvc3NoYWlyLmhpZ2hsaWdodGVkKSBjdHguZmlsbFN0eWxlID0gJ29yYW5nZSc7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgY3R4LmZpbGxTdHlsZSA9IGMuY29sb3I7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChNYXRoLmZsb29yKGNyb3NzaGFpci54KSArIGFkaiAtIDQsIE1hdGguZmxvb3IoY3Jvc3NoYWlyLnkpICsgYWRqIC0gNCwgOCwgOCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHBsb3QuaG9va3Muc2h1dGRvd24ucHVzaChmdW5jdGlvbiAocGxvdCwgZXZlbnRIb2xkZXIpIHtcbiAgICAgICAgICAgIGV2ZW50SG9sZGVyLnVuYmluZChcIm1vdXNlb3V0XCIsIG9uTW91c2VPdXQpO1xuICAgICAgICAgICAgZXZlbnRIb2xkZXIudW5iaW5kKFwibW91c2Vtb3ZlXCIsIG9uTW91c2VNb3ZlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgJC5wbG90LnBsdWdpbnMucHVzaCh7XG4gICAgICAgIGluaXQ6IGluaXQsXG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgIG5hbWU6ICdjcm9zc2hhaXInLFxuICAgICAgICB2ZXJzaW9uOiAnMS4wJ1xuICAgIH0pO1xufSkoalF1ZXJ5KTtcbiIsIi8qKlxuIyMganF1ZXJ5LmZsb3QuZHJhd1Nlcmllcy5qc1xuXG5UaGlzIHBsdWdpbiBpcyB1c2VkIGJ5IGZsb3QgZm9yIGRyYXdpbmcgbGluZXMsIHBsb3RzLCBiYXJzIG9yIGFyZWEuXG5cbiMjIyBQdWJsaWMgbWV0aG9kc1xuKi9cblxuKGZ1bmN0aW9uKCQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGZ1bmN0aW9uIERyYXdTZXJpZXMoKSB7XG4gICAgICAgIGZ1bmN0aW9uIHBsb3RMaW5lKGRhdGFwb2ludHMsIHhvZmZzZXQsIHlvZmZzZXQsIGF4aXN4LCBheGlzeSwgY3R4LCBzdGVwcykge1xuICAgICAgICAgICAgdmFyIHBvaW50cyA9IGRhdGFwb2ludHMucG9pbnRzLFxuICAgICAgICAgICAgICAgIHBzID0gZGF0YXBvaW50cy5wb2ludHNpemUsXG4gICAgICAgICAgICAgICAgcHJldnggPSBudWxsLFxuICAgICAgICAgICAgICAgIHByZXZ5ID0gbnVsbDtcbiAgICAgICAgICAgIHZhciB4MSA9IDAuMCxcbiAgICAgICAgICAgICAgICB5MSA9IDAuMCxcbiAgICAgICAgICAgICAgICB4MiA9IDAuMCxcbiAgICAgICAgICAgICAgICB5MiA9IDAuMCxcbiAgICAgICAgICAgICAgICBteCA9IG51bGwsXG4gICAgICAgICAgICAgICAgbXkgPSBudWxsLFxuICAgICAgICAgICAgICAgIGkgPSAwO1xuXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBmb3IgKGkgPSBwczsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gcHMpIHtcbiAgICAgICAgICAgICAgICB4MSA9IHBvaW50c1tpIC0gcHNdO1xuICAgICAgICAgICAgICAgIHkxID0gcG9pbnRzW2kgLSBwcyArIDFdO1xuICAgICAgICAgICAgICAgIHgyID0gcG9pbnRzW2ldO1xuICAgICAgICAgICAgICAgIHkyID0gcG9pbnRzW2kgKyAxXTtcblxuICAgICAgICAgICAgICAgIGlmICh4MSA9PT0gbnVsbCB8fCB4MiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBteCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIG15ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKHgxKSB8fCBpc05hTih4MikgfHwgaXNOYU4oeTEpIHx8IGlzTmFOKHkyKSkge1xuICAgICAgICAgICAgICAgICAgICBwcmV2eCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHByZXZ5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHN0ZXBzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChteCAhPT0gbnVsbCAmJiBteSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgbWlkZGxlIHBvaW50IGV4aXN0cywgdHJhbnNmZXIgcDIgLT4gcDEgYW5kIHAxIC0+IG1wXG4gICAgICAgICAgICAgICAgICAgICAgICB4MiA9IHgxO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTIgPSB5MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHgxID0gbXg7XG4gICAgICAgICAgICAgICAgICAgICAgICB5MSA9IG15O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAncmVtb3ZlJyBtaWRkbGUgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIG14ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG15ID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3VidHJhY3QgcG9pbnRzaXplIGZyb20gaSB0byBoYXZlIGN1cnJlbnQgcG9pbnQgcDEgaGFuZGxlZCBhZ2FpblxuICAgICAgICAgICAgICAgICAgICAgICAgaSAtPSBwcztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh5MSAhPT0geTIgJiYgeDEgIT09IHgyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYSBtaWRkbGUgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHkyID0geTE7XG4gICAgICAgICAgICAgICAgICAgICAgICBteCA9IHgyO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXkgPSB5MTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGNsaXAgd2l0aCB5bWluXG4gICAgICAgICAgICAgICAgaWYgKHkxIDw9IHkyICYmIHkxIDwgYXhpc3kubWluKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh5MiA8IGF4aXN5Lm1pbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGluZSBzZWdtZW50IGlzIG91dHNpZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbXB1dGUgbmV3IGludGVyc2VjdGlvbiBwb2ludFxuICAgICAgICAgICAgICAgICAgICB4MSA9IChheGlzeS5taW4gLSB5MSkgLyAoeTIgLSB5MSkgKiAoeDIgLSB4MSkgKyB4MTtcbiAgICAgICAgICAgICAgICAgICAgeTEgPSBheGlzeS5taW47XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh5MiA8PSB5MSAmJiB5MiA8IGF4aXN5Lm1pbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoeTEgPCBheGlzeS5taW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgeDIgPSAoYXhpc3kubWluIC0geTEpIC8gKHkyIC0geTEpICogKHgyIC0geDEpICsgeDE7XG4gICAgICAgICAgICAgICAgICAgIHkyID0gYXhpc3kubWluO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGNsaXAgd2l0aCB5bWF4XG4gICAgICAgICAgICAgICAgaWYgKHkxID49IHkyICYmIHkxID4gYXhpc3kubWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh5MiA+IGF4aXN5Lm1heCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB4MSA9IChheGlzeS5tYXggLSB5MSkgLyAoeTIgLSB5MSkgKiAoeDIgLSB4MSkgKyB4MTtcbiAgICAgICAgICAgICAgICAgICAgeTEgPSBheGlzeS5tYXg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh5MiA+PSB5MSAmJiB5MiA+IGF4aXN5Lm1heCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoeTEgPiBheGlzeS5tYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgeDIgPSAoYXhpc3kubWF4IC0geTEpIC8gKHkyIC0geTEpICogKHgyIC0geDEpICsgeDE7XG4gICAgICAgICAgICAgICAgICAgIHkyID0gYXhpc3kubWF4O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGNsaXAgd2l0aCB4bWluXG4gICAgICAgICAgICAgICAgaWYgKHgxIDw9IHgyICYmIHgxIDwgYXhpc3gubWluKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh4MiA8IGF4aXN4Lm1pbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB5MSA9IChheGlzeC5taW4gLSB4MSkgLyAoeDIgLSB4MSkgKiAoeTIgLSB5MSkgKyB5MTtcbiAgICAgICAgICAgICAgICAgICAgeDEgPSBheGlzeC5taW47XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh4MiA8PSB4MSAmJiB4MiA8IGF4aXN4Lm1pbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoeDEgPCBheGlzeC5taW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgeTIgPSAoYXhpc3gubWluIC0geDEpIC8gKHgyIC0geDEpICogKHkyIC0geTEpICsgeTE7XG4gICAgICAgICAgICAgICAgICAgIHgyID0gYXhpc3gubWluO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGNsaXAgd2l0aCB4bWF4XG4gICAgICAgICAgICAgICAgaWYgKHgxID49IHgyICYmIHgxID4gYXhpc3gubWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh4MiA+IGF4aXN4Lm1heCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB5MSA9IChheGlzeC5tYXggLSB4MSkgLyAoeDIgLSB4MSkgKiAoeTIgLSB5MSkgKyB5MTtcbiAgICAgICAgICAgICAgICAgICAgeDEgPSBheGlzeC5tYXg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh4MiA+PSB4MSAmJiB4MiA+IGF4aXN4Lm1heCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoeDEgPiBheGlzeC5tYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgeTIgPSAoYXhpc3gubWF4IC0geDEpIC8gKHgyIC0geDEpICogKHkyIC0geTEpICsgeTE7XG4gICAgICAgICAgICAgICAgICAgIHgyID0gYXhpc3gubWF4O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh4MSAhPT0gcHJldnggfHwgeTEgIT09IHByZXZ5KSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oYXhpc3gucDJjKHgxKSArIHhvZmZzZXQsIGF4aXN5LnAyYyh5MSkgKyB5b2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwcmV2eCA9IHgyO1xuICAgICAgICAgICAgICAgIHByZXZ5ID0geTI7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhheGlzeC5wMmMoeDIpICsgeG9mZnNldCwgYXhpc3kucDJjKHkyKSArIHlvZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcGxvdExpbmVBcmVhKGRhdGFwb2ludHMsIGF4aXN4LCBheGlzeSwgZmlsbFRvd2FyZHMsIGN0eCwgc3RlcHMpIHtcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSBkYXRhcG9pbnRzLnBvaW50cyxcbiAgICAgICAgICAgICAgICBwcyA9IGRhdGFwb2ludHMucG9pbnRzaXplLFxuICAgICAgICAgICAgICAgIGJvdHRvbSA9IGZpbGxUb3dhcmRzID4gYXhpc3kubWluID8gTWF0aC5taW4oYXhpc3kubWF4LCBmaWxsVG93YXJkcykgOiBheGlzeS5taW4sXG4gICAgICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICAgICAgeXBvcyA9IDEsXG4gICAgICAgICAgICAgICAgYXJlYU9wZW4gPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBzZWdtZW50U3RhcnQgPSAwLFxuICAgICAgICAgICAgICAgIHNlZ21lbnRFbmQgPSAwLFxuICAgICAgICAgICAgICAgIG14ID0gbnVsbCxcbiAgICAgICAgICAgICAgICBteSA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIHdlIHByb2Nlc3MgZWFjaCBzZWdtZW50IGluIHR3byB0dXJucywgZmlyc3QgZm9yd2FyZFxuICAgICAgICAgICAgLy8gZGlyZWN0aW9uIHRvIHNrZXRjaCBvdXQgdG9wLCB0aGVuIG9uY2Ugd2UgaGl0IHRoZVxuICAgICAgICAgICAgLy8gZW5kIHdlIGdvIGJhY2t3YXJkcyB0byBza2V0Y2ggdGhlIGJvdHRvbVxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBpZiAocHMgPiAwICYmIGkgPiBwb2ludHMubGVuZ3RoICsgcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaSArPSBwczsgLy8gcHMgaXMgbmVnYXRpdmUgaWYgZ29pbmcgYmFja3dhcmRzXG5cbiAgICAgICAgICAgICAgICB2YXIgeDEgPSBwb2ludHNbaSAtIHBzXSxcbiAgICAgICAgICAgICAgICAgICAgeTEgPSBwb2ludHNbaSAtIHBzICsgeXBvc10sXG4gICAgICAgICAgICAgICAgICAgIHgyID0gcG9pbnRzW2ldLFxuICAgICAgICAgICAgICAgICAgICB5MiA9IHBvaW50c1tpICsgeXBvc107XG5cbiAgICAgICAgICAgICAgICBpZiAocHMgPT09IC0yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIGdvaW5nIGJhY2t3YXJkcyBhbmQgbm8gdmFsdWUgZm9yIHRoZSBib3R0b20gcHJvdmlkZWQgaW4gdGhlIHNlcmllcyovXG4gICAgICAgICAgICAgICAgICAgIHkxID0geTIgPSBib3R0b207XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGFyZWFPcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcyA+IDAgJiYgeDEgIT0gbnVsbCAmJiB4MiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhdCB0dXJuaW5nIHBvaW50XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50RW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBzID0gLXBzO1xuICAgICAgICAgICAgICAgICAgICAgICAgeXBvcyA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcyA8IDAgJiYgaSA9PT0gc2VnbWVudFN0YXJ0ICsgcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvbmUgd2l0aCB0aGUgcmV2ZXJzZSBzd2VlcFxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZWFPcGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcyA9IC1wcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHlwb3MgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IHNlZ21lbnRTdGFydCA9IHNlZ21lbnRFbmQgKyBwcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHgxID09IG51bGwgfHwgeDIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBteCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIG15ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHN0ZXBzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChteCAhPT0gbnVsbCAmJiBteSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgbWlkZGxlIHBvaW50IGV4aXN0cywgdHJhbnNmZXIgcDIgLT4gcDEgYW5kIHAxIC0+IG1wXG4gICAgICAgICAgICAgICAgICAgICAgICB4MiA9IHgxO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTIgPSB5MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHgxID0gbXg7XG4gICAgICAgICAgICAgICAgICAgICAgICB5MSA9IG15O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAncmVtb3ZlJyBtaWRkbGUgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIG14ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG15ID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3VidHJhY3QgcG9pbnRzaXplIGZyb20gaSB0byBoYXZlIGN1cnJlbnQgcG9pbnQgcDEgaGFuZGxlZCBhZ2FpblxuICAgICAgICAgICAgICAgICAgICAgICAgaSAtPSBwcztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh5MSAhPT0geTIgJiYgeDEgIT09IHgyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYSBtaWRkbGUgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHkyID0geTE7XG4gICAgICAgICAgICAgICAgICAgICAgICBteCA9IHgyO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXkgPSB5MTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGNsaXAgeCB2YWx1ZXNcblxuICAgICAgICAgICAgICAgIC8vIGNsaXAgd2l0aCB4bWluXG4gICAgICAgICAgICAgICAgaWYgKHgxIDw9IHgyICYmIHgxIDwgYXhpc3gubWluKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh4MiA8IGF4aXN4Lm1pbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB5MSA9IChheGlzeC5taW4gLSB4MSkgLyAoeDIgLSB4MSkgKiAoeTIgLSB5MSkgKyB5MTtcbiAgICAgICAgICAgICAgICAgICAgeDEgPSBheGlzeC5taW47XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh4MiA8PSB4MSAmJiB4MiA8IGF4aXN4Lm1pbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoeDEgPCBheGlzeC5taW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgeTIgPSAoYXhpc3gubWluIC0geDEpIC8gKHgyIC0geDEpICogKHkyIC0geTEpICsgeTE7XG4gICAgICAgICAgICAgICAgICAgIHgyID0gYXhpc3gubWluO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGNsaXAgd2l0aCB4bWF4XG4gICAgICAgICAgICAgICAgaWYgKHgxID49IHgyICYmIHgxID4gYXhpc3gubWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh4MiA+IGF4aXN4Lm1heCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB5MSA9IChheGlzeC5tYXggLSB4MSkgLyAoeDIgLSB4MSkgKiAoeTIgLSB5MSkgKyB5MTtcbiAgICAgICAgICAgICAgICAgICAgeDEgPSBheGlzeC5tYXg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh4MiA+PSB4MSAmJiB4MiA+IGF4aXN4Lm1heCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoeDEgPiBheGlzeC5tYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgeTIgPSAoYXhpc3gubWF4IC0geDEpIC8gKHgyIC0geDEpICogKHkyIC0geTEpICsgeTE7XG4gICAgICAgICAgICAgICAgICAgIHgyID0gYXhpc3gubWF4O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghYXJlYU9wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb3BlbiBhcmVhXG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhheGlzeC5wMmMoeDEpLCBheGlzeS5wMmMoYm90dG9tKSk7XG4gICAgICAgICAgICAgICAgICAgIGFyZWFPcGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBub3cgZmlyc3QgY2hlY2sgdGhlIGNhc2Ugd2hlcmUgYm90aCBpcyBvdXRzaWRlXG4gICAgICAgICAgICAgICAgaWYgKHkxID49IGF4aXN5Lm1heCAmJiB5MiA+PSBheGlzeS5tYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhheGlzeC5wMmMoeDEpLCBheGlzeS5wMmMoYXhpc3kubWF4KSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oYXhpc3gucDJjKHgyKSwgYXhpc3kucDJjKGF4aXN5Lm1heCkpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHkxIDw9IGF4aXN5Lm1pbiAmJiB5MiA8PSBheGlzeS5taW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhheGlzeC5wMmMoeDEpLCBheGlzeS5wMmMoYXhpc3kubWluKSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oYXhpc3gucDJjKHgyKSwgYXhpc3kucDJjKGF4aXN5Lm1pbikpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBlbHNlIGl0J3MgYSBiaXQgbW9yZSBjb21wbGljYXRlZCwgdGhlcmUgbWlnaHRcbiAgICAgICAgICAgICAgICAvLyBiZSBhIGZsYXQgbWF4ZWQgb3V0IHJlY3RhbmdsZSBmaXJzdCwgdGhlbiBhXG4gICAgICAgICAgICAgICAgLy8gdHJpYW5ndWxhciBjdXRvdXQgb3IgcmV2ZXJzZTsgdG8gZmluZCB0aGVzZVxuICAgICAgICAgICAgICAgIC8vIGtlZXAgdHJhY2sgb2YgdGhlIGN1cnJlbnQgeCB2YWx1ZXNcbiAgICAgICAgICAgICAgICB2YXIgeDFvbGQgPSB4MSxcbiAgICAgICAgICAgICAgICAgICAgeDJvbGQgPSB4MjtcblxuICAgICAgICAgICAgICAgIC8vIGNsaXAgdGhlIHkgdmFsdWVzLCB3aXRob3V0IHNob3J0Y3V0dGluZywgd2VcbiAgICAgICAgICAgICAgICAvLyBnbyB0aHJvdWdoIGFsbCBjYXNlcyBpbiB0dXJuXG5cbiAgICAgICAgICAgICAgICAvLyBjbGlwIHdpdGggeW1pblxuICAgICAgICAgICAgICAgIGlmICh5MSA8PSB5MiAmJiB5MSA8IGF4aXN5Lm1pbiAmJiB5MiA+PSBheGlzeS5taW4pIHtcbiAgICAgICAgICAgICAgICAgICAgeDEgPSAoYXhpc3kubWluIC0geTEpIC8gKHkyIC0geTEpICogKHgyIC0geDEpICsgeDE7XG4gICAgICAgICAgICAgICAgICAgIHkxID0gYXhpc3kubWluO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoeTIgPD0geTEgJiYgeTIgPCBheGlzeS5taW4gJiYgeTEgPj0gYXhpc3kubWluKSB7XG4gICAgICAgICAgICAgICAgICAgIHgyID0gKGF4aXN5Lm1pbiAtIHkxKSAvICh5MiAtIHkxKSAqICh4MiAtIHgxKSArIHgxO1xuICAgICAgICAgICAgICAgICAgICB5MiA9IGF4aXN5Lm1pbjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBjbGlwIHdpdGggeW1heFxuICAgICAgICAgICAgICAgIGlmICh5MSA+PSB5MiAmJiB5MSA+IGF4aXN5Lm1heCAmJiB5MiA8PSBheGlzeS5tYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgeDEgPSAoYXhpc3kubWF4IC0geTEpIC8gKHkyIC0geTEpICogKHgyIC0geDEpICsgeDE7XG4gICAgICAgICAgICAgICAgICAgIHkxID0gYXhpc3kubWF4O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoeTIgPj0geTEgJiYgeTIgPiBheGlzeS5tYXggJiYgeTEgPD0gYXhpc3kubWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIHgyID0gKGF4aXN5Lm1heCAtIHkxKSAvICh5MiAtIHkxKSAqICh4MiAtIHgxKSArIHgxO1xuICAgICAgICAgICAgICAgICAgICB5MiA9IGF4aXN5Lm1heDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgeCB2YWx1ZSB3YXMgY2hhbmdlZCB3ZSBnb3QgYSByZWN0YW5nbGVcbiAgICAgICAgICAgICAgICAvLyB0byBmaWxsXG4gICAgICAgICAgICAgICAgaWYgKHgxICE9PSB4MW9sZCkge1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKGF4aXN4LnAyYyh4MW9sZCksIGF4aXN5LnAyYyh5MSkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBpdCBnb2VzIHRvICh4MSwgeTEpLCBidXQgd2UgZmlsbCB0aGF0IGJlbG93XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gZmlsbCB0cmlhbmd1bGFyIHNlY3Rpb24sIHRoaXMgc29tZXRpbWVzIHJlc3VsdFxuICAgICAgICAgICAgICAgIC8vIGluIHJlZHVuZGFudCBwb2ludHMgaWYgKHgxLCB5MSkgaGFzbid0IGNoYW5nZWRcbiAgICAgICAgICAgICAgICAvLyBmcm9tIHByZXZpb3VzIGxpbmUgdG8sIGJ1dCB3ZSBqdXN0IGlnbm9yZSB0aGF0XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhheGlzeC5wMmMoeDEpLCBheGlzeS5wMmMoeTEpKTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKGF4aXN4LnAyYyh4MiksIGF4aXN5LnAyYyh5MikpO1xuXG4gICAgICAgICAgICAgICAgLy8gZmlsbCB0aGUgb3RoZXIgcmVjdGFuZ2xlIGlmIGl0J3MgdGhlcmVcbiAgICAgICAgICAgICAgICBpZiAoeDIgIT09IHgyb2xkKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oYXhpc3gucDJjKHgyKSwgYXhpc3kucDJjKHkyKSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oYXhpc3gucDJjKHgyb2xkKSwgYXhpc3kucDJjKHkyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgIC0gZHJhd1Nlcmllc0xpbmVzKHNlcmllcywgY3R4LCBwbG90T2Zmc2V0LCBwbG90V2lkdGgsIHBsb3RIZWlnaHQsIGRyYXdTeW1ib2wsIGdldENvbG9yT3JHcmFkaWVudClcblxuICAgICAgICAgVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGZvciBkcmF3aW5nIGxpbmVzIG9yIGFyZWEgZmlsbC4gIEluIGNhc2UgdGhlIHNlcmllcyBoYXMgbGluZSBkZWNpbWF0aW9uIGZ1bmN0aW9uXG4gICAgICAgICBhdHRhY2hlZCwgYmVmb3JlIHN0YXJ0aW5nIHRvIGRyYXcsIGFzIGFuIG9wdGltaXphdGlvbiB0aGUgcG9pbnRzIHdpbGwgZmlyc3QgYmUgZGVjaW1hdGVkLlxuXG4gICAgICAgICBUaGUgc2VyaWVzIHBhcmFtZXRlciBjb250YWlucyB0aGUgc2VyaWVzIHRvIGJlIGRyYXduIG9uIGN0eCBjb250ZXh0LiBUaGUgcGxvdE9mZnNldCwgcGxvdFdpZHRoIGFuZFxuICAgICAgICAgcGxvdEhlaWdodCBhcmUgdGhlIGNvcnJlc3BvbmRpbmcgcGFyYW1ldGVycyBvZiBmbG90IHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBkcmF3aW5nIHN1cmZhY2UuXG4gICAgICAgICBUaGUgZnVuY3Rpb24gZ2V0Q29sb3JPckdyYWRpZW50IGlzIHVzZWQgdG8gY29tcHV0ZSB0aGUgZmlsbCBzdHlsZSBvZiBsaW5lcyBhbmQgYXJlYS5cbiAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZHJhd1Nlcmllc0xpbmVzKHNlcmllcywgY3R4LCBwbG90T2Zmc2V0LCBwbG90V2lkdGgsIHBsb3RIZWlnaHQsIGRyYXdTeW1ib2wsIGdldENvbG9yT3JHcmFkaWVudCkge1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUocGxvdE9mZnNldC5sZWZ0LCBwbG90T2Zmc2V0LnRvcCk7XG4gICAgICAgICAgICBjdHgubGluZUpvaW4gPSBcInJvdW5kXCI7XG5cbiAgICAgICAgICAgIGlmIChzZXJpZXMubGluZXMuZGFzaGVzICYmIGN0eC5zZXRMaW5lRGFzaCkge1xuICAgICAgICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChzZXJpZXMubGluZXMuZGFzaGVzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRhdGFwb2ludHMgPSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiBzZXJpZXMuZGF0YXBvaW50cy5mb3JtYXQsXG4gICAgICAgICAgICAgICAgcG9pbnRzOiBzZXJpZXMuZGF0YXBvaW50cy5wb2ludHMsXG4gICAgICAgICAgICAgICAgcG9pbnRzaXplOiBzZXJpZXMuZGF0YXBvaW50cy5wb2ludHNpemVcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChzZXJpZXMuZGVjaW1hdGUpIHtcbiAgICAgICAgICAgICAgICBkYXRhcG9pbnRzLnBvaW50cyA9IHNlcmllcy5kZWNpbWF0ZShzZXJpZXMsIHNlcmllcy54YXhpcy5taW4sIHNlcmllcy54YXhpcy5tYXgsIHBsb3RXaWR0aCwgc2VyaWVzLnlheGlzLm1pbiwgc2VyaWVzLnlheGlzLm1heCwgcGxvdEhlaWdodCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBsdyA9IHNlcmllcy5saW5lcy5saW5lV2lkdGg7XG5cbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBsdztcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHNlcmllcy5jb2xvcjtcbiAgICAgICAgICAgIHZhciBmaWxsU3R5bGUgPSBnZXRGaWxsU3R5bGUoc2VyaWVzLmxpbmVzLCBzZXJpZXMuY29sb3IsIDAsIHBsb3RIZWlnaHQsIGdldENvbG9yT3JHcmFkaWVudCk7XG4gICAgICAgICAgICBpZiAoZmlsbFN0eWxlKSB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcbiAgICAgICAgICAgICAgICBwbG90TGluZUFyZWEoZGF0YXBvaW50cywgc2VyaWVzLnhheGlzLCBzZXJpZXMueWF4aXMsIHNlcmllcy5saW5lcy5maWxsVG93YXJkcyB8fCAwLCBjdHgsIHNlcmllcy5saW5lcy5zdGVwcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsdyA+IDApIHtcbiAgICAgICAgICAgICAgICBwbG90TGluZShkYXRhcG9pbnRzLCAwLCAwLCBzZXJpZXMueGF4aXMsIHNlcmllcy55YXhpcywgY3R4LCBzZXJpZXMubGluZXMuc3RlcHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgIC0gZHJhd1Nlcmllc1BvaW50cyhzZXJpZXMsIGN0eCwgcGxvdE9mZnNldCwgcGxvdFdpZHRoLCBwbG90SGVpZ2h0LCBkcmF3U3ltYm9sLCBnZXRDb2xvck9yR3JhZGllbnQpXG5cbiAgICAgICAgIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBmb3IgZHJhd2luZyBwb2ludHMgdXNpbmcgYSBnaXZlbiBzeW1ib2wuIEluIGNhc2UgdGhlIHNlcmllcyBoYXMgcG9pbnRzIGRlY2ltYXRpb25cbiAgICAgICAgIGZ1bmN0aW9uIGF0dGFjaGVkLCBiZWZvcmUgc3RhcnRpbmcgdG8gZHJhdywgYXMgYW4gb3B0aW1pemF0aW9uIHRoZSBwb2ludHMgd2lsbCBmaXJzdCBiZSBkZWNpbWF0ZWQuXG5cbiAgICAgICAgIFRoZSBzZXJpZXMgcGFyYW1ldGVyIGNvbnRhaW5zIHRoZSBzZXJpZXMgdG8gYmUgZHJhd24gb24gY3R4IGNvbnRleHQuIFRoZSBwbG90T2Zmc2V0LCBwbG90V2lkdGggYW5kXG4gICAgICAgICBwbG90SGVpZ2h0IGFyZSB0aGUgY29ycmVzcG9uZGluZyBwYXJhbWV0ZXJzIG9mIGZsb3QgdXNlZCB0byBkZXRlcm1pbmUgdGhlIGRyYXdpbmcgc3VyZmFjZS5cbiAgICAgICAgIFRoZSBmdW5jdGlvbiBkcmF3U3ltYm9sIGlzIHVzZWQgdG8gY29tcHV0ZSBhbmQgZHJhdyB0aGUgc3ltYm9sIGNob3NlbiBmb3IgdGhlIHBvaW50cy5cbiAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZHJhd1Nlcmllc1BvaW50cyhzZXJpZXMsIGN0eCwgcGxvdE9mZnNldCwgcGxvdFdpZHRoLCBwbG90SGVpZ2h0LCBkcmF3U3ltYm9sLCBnZXRDb2xvck9yR3JhZGllbnQpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGRyYXdDaXJjbGUoY3R4LCB4LCB5LCByYWRpdXMsIHNoYWRvdywgZmlsbCkge1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCArIHJhZGl1cywgeSk7XG4gICAgICAgICAgICAgICAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIDAsIHNoYWRvdyA/IE1hdGguUEkgOiBNYXRoLlBJICogMiwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZHJhd0NpcmNsZS5maWxsID0gdHJ1ZTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHBsb3RQb2ludHMoZGF0YXBvaW50cywgcmFkaXVzLCBmaWxsLCBvZmZzZXQsIHNoYWRvdywgYXhpc3gsIGF4aXN5LCBkcmF3U3ltYm9sRm4pIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRzID0gZGF0YXBvaW50cy5wb2ludHMsXG4gICAgICAgICAgICAgICAgICAgIHBzID0gZGF0YXBvaW50cy5wb2ludHNpemU7XG5cbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpICs9IHBzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4ID0gcG9pbnRzW2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IHBvaW50c1tpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh4ID09IG51bGwgfHwgeCA8IGF4aXN4Lm1pbiB8fCB4ID4gYXhpc3gubWF4IHx8IHkgPCBheGlzeS5taW4gfHwgeSA+IGF4aXN5Lm1heCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB4ID0gYXhpc3gucDJjKHgpO1xuICAgICAgICAgICAgICAgICAgICB5ID0gYXhpc3kucDJjKHkpICsgb2Zmc2V0O1xuXG4gICAgICAgICAgICAgICAgICAgIGRyYXdTeW1ib2xGbihjdHgsIHgsIHksIHJhZGl1cywgc2hhZG93LCBmaWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRyYXdTeW1ib2xGbi5maWxsICYmICFzaGFkb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShwbG90T2Zmc2V0LmxlZnQsIHBsb3RPZmZzZXQudG9wKTtcblxuICAgICAgICAgICAgdmFyIGRhdGFwb2ludHMgPSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiBzZXJpZXMuZGF0YXBvaW50cy5mb3JtYXQsXG4gICAgICAgICAgICAgICAgcG9pbnRzOiBzZXJpZXMuZGF0YXBvaW50cy5wb2ludHMsXG4gICAgICAgICAgICAgICAgcG9pbnRzaXplOiBzZXJpZXMuZGF0YXBvaW50cy5wb2ludHNpemVcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChzZXJpZXMuZGVjaW1hdGVQb2ludHMpIHtcbiAgICAgICAgICAgICAgICBkYXRhcG9pbnRzLnBvaW50cyA9IHNlcmllcy5kZWNpbWF0ZVBvaW50cyhzZXJpZXMsIHNlcmllcy54YXhpcy5taW4sIHNlcmllcy54YXhpcy5tYXgsIHBsb3RXaWR0aCwgc2VyaWVzLnlheGlzLm1pbiwgc2VyaWVzLnlheGlzLm1heCwgcGxvdEhlaWdodCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBsdyA9IHNlcmllcy5wb2ludHMubGluZVdpZHRoLFxuICAgICAgICAgICAgICAgIHJhZGl1cyA9IHNlcmllcy5wb2ludHMucmFkaXVzLFxuICAgICAgICAgICAgICAgIHN5bWJvbCA9IHNlcmllcy5wb2ludHMuc3ltYm9sLFxuICAgICAgICAgICAgICAgIGRyYXdTeW1ib2xGbjtcblxuICAgICAgICAgICAgaWYgKHN5bWJvbCA9PT0gJ2NpcmNsZScpIHtcbiAgICAgICAgICAgICAgICBkcmF3U3ltYm9sRm4gPSBkcmF3Q2lyY2xlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3ltYm9sID09PSAnc3RyaW5nJyAmJiBkcmF3U3ltYm9sICYmIGRyYXdTeW1ib2xbc3ltYm9sXSkge1xuICAgICAgICAgICAgICAgIGRyYXdTeW1ib2xGbiA9IGRyYXdTeW1ib2xbc3ltYm9sXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRyYXdTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBkcmF3U3ltYm9sRm4gPSBkcmF3U3ltYm9sO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB0aGUgdXNlciBzZXRzIHRoZSBsaW5lIHdpZHRoIHRvIDAsIHdlIGNoYW5nZSBpdCB0byBhIHZlcnlcbiAgICAgICAgICAgIC8vIHNtYWxsIHZhbHVlLiBBIGxpbmUgd2lkdGggb2YgMCBzZWVtcyB0byBmb3JjZSB0aGUgZGVmYXVsdCBvZiAxLlxuXG4gICAgICAgICAgICBpZiAobHcgPT09IDApIHtcbiAgICAgICAgICAgICAgICBsdyA9IDAuMDAwMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGx3O1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGdldEZpbGxTdHlsZShzZXJpZXMucG9pbnRzLCBzZXJpZXMuY29sb3IsIG51bGwsIG51bGwsIGdldENvbG9yT3JHcmFkaWVudCk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzZXJpZXMuY29sb3I7XG4gICAgICAgICAgICBwbG90UG9pbnRzKGRhdGFwb2ludHMsIHJhZGl1cyxcbiAgICAgICAgICAgICAgICB0cnVlLCAwLCBmYWxzZSxcbiAgICAgICAgICAgICAgICBzZXJpZXMueGF4aXMsIHNlcmllcy55YXhpcywgZHJhd1N5bWJvbEZuKTtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBkcmF3QmFyKHgsIHksIGIsIGJhckxlZnQsIGJhclJpZ2h0LCBmaWxsU3R5bGVDYWxsYmFjaywgYXhpc3gsIGF4aXN5LCBjLCBob3Jpem9udGFsLCBsaW5lV2lkdGgpIHtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0geCArIGJhckxlZnQsXG4gICAgICAgICAgICAgICAgcmlnaHQgPSB4ICsgYmFyUmlnaHQsXG4gICAgICAgICAgICAgICAgYm90dG9tID0gYiwgdG9wID0geSxcbiAgICAgICAgICAgICAgICBkcmF3TGVmdCwgZHJhd1JpZ2h0LCBkcmF3VG9wLCBkcmF3Qm90dG9tID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgdG1wO1xuXG4gICAgICAgICAgICBkcmF3TGVmdCA9IGRyYXdSaWdodCA9IGRyYXdUb3AgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBpbiBob3Jpem9udGFsIG1vZGUsIHdlIHN0YXJ0IHRoZSBiYXIgZnJvbSB0aGUgbGVmdFxuICAgICAgICAgICAgLy8gaW5zdGVhZCBvZiBmcm9tIHRoZSBib3R0b20gc28gaXQgYXBwZWFycyB0byBiZVxuICAgICAgICAgICAgLy8gaG9yaXpvbnRhbCByYXRoZXIgdGhhbiB2ZXJ0aWNhbFxuICAgICAgICAgICAgaWYgKGhvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgICBkcmF3Qm90dG9tID0gZHJhd1JpZ2h0ID0gZHJhd1RvcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZHJhd0xlZnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gYjtcbiAgICAgICAgICAgICAgICByaWdodCA9IHg7XG4gICAgICAgICAgICAgICAgdG9wID0geSArIGJhckxlZnQ7XG4gICAgICAgICAgICAgICAgYm90dG9tID0geSArIGJhclJpZ2h0O1xuXG4gICAgICAgICAgICAgICAgLy8gYWNjb3VudCBmb3IgbmVnYXRpdmUgYmFyc1xuICAgICAgICAgICAgICAgIGlmIChyaWdodCA8IGxlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdG1wID0gcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gbGVmdDtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHRtcDtcbiAgICAgICAgICAgICAgICAgICAgZHJhd0xlZnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBkcmF3UmlnaHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRyYXdMZWZ0ID0gZHJhd1JpZ2h0ID0gZHJhd1RvcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZHJhd0JvdHRvbSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxlZnQgPSB4ICsgYmFyTGVmdDtcbiAgICAgICAgICAgICAgICByaWdodCA9IHggKyBiYXJSaWdodDtcbiAgICAgICAgICAgICAgICBib3R0b20gPSBiO1xuICAgICAgICAgICAgICAgIHRvcCA9IHk7XG5cbiAgICAgICAgICAgICAgICAvLyBhY2NvdW50IGZvciBuZWdhdGl2ZSBiYXJzXG4gICAgICAgICAgICAgICAgaWYgKHRvcCA8IGJvdHRvbSkge1xuICAgICAgICAgICAgICAgICAgICB0bXAgPSB0b3A7XG4gICAgICAgICAgICAgICAgICAgIHRvcCA9IGJvdHRvbTtcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tID0gdG1wO1xuICAgICAgICAgICAgICAgICAgICBkcmF3Qm90dG9tID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZHJhd1RvcCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2xpcFxuICAgICAgICAgICAgaWYgKHJpZ2h0IDwgYXhpc3gubWluIHx8IGxlZnQgPiBheGlzeC5tYXggfHxcbiAgICAgICAgICAgICAgICB0b3AgPCBheGlzeS5taW4gfHwgYm90dG9tID4gYXhpc3kubWF4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGVmdCA8IGF4aXN4Lm1pbikge1xuICAgICAgICAgICAgICAgIGxlZnQgPSBheGlzeC5taW47XG4gICAgICAgICAgICAgICAgZHJhd0xlZnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJpZ2h0ID4gYXhpc3gubWF4KSB7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSBheGlzeC5tYXg7XG4gICAgICAgICAgICAgICAgZHJhd1JpZ2h0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChib3R0b20gPCBheGlzeS5taW4pIHtcbiAgICAgICAgICAgICAgICBib3R0b20gPSBheGlzeS5taW47XG4gICAgICAgICAgICAgICAgZHJhd0JvdHRvbSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodG9wID4gYXhpc3kubWF4KSB7XG4gICAgICAgICAgICAgICAgdG9wID0gYXhpc3kubWF4O1xuICAgICAgICAgICAgICAgIGRyYXdUb3AgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGVmdCA9IGF4aXN4LnAyYyhsZWZ0KTtcbiAgICAgICAgICAgIGJvdHRvbSA9IGF4aXN5LnAyYyhib3R0b20pO1xuICAgICAgICAgICAgcmlnaHQgPSBheGlzeC5wMmMocmlnaHQpO1xuICAgICAgICAgICAgdG9wID0gYXhpc3kucDJjKHRvcCk7XG5cbiAgICAgICAgICAgIC8vIGZpbGwgdGhlIGJhclxuICAgICAgICAgICAgaWYgKGZpbGxTdHlsZUNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgYy5maWxsU3R5bGUgPSBmaWxsU3R5bGVDYWxsYmFjayhib3R0b20sIHRvcCk7XG4gICAgICAgICAgICAgICAgYy5maWxsUmVjdChsZWZ0LCB0b3AsIHJpZ2h0IC0gbGVmdCwgYm90dG9tIC0gdG9wKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBkcmF3IG91dGxpbmVcbiAgICAgICAgICAgIGlmIChsaW5lV2lkdGggPiAwICYmIChkcmF3TGVmdCB8fCBkcmF3UmlnaHQgfHwgZHJhd1RvcCB8fCBkcmF3Qm90dG9tKSkge1xuICAgICAgICAgICAgICAgIGMuYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBGSVhNRTogaW5saW5lIG1vdmVUbyBpcyBidWdneSB3aXRoIGV4Y2FudmFzXG4gICAgICAgICAgICAgICAgYy5tb3ZlVG8obGVmdCwgYm90dG9tKTtcbiAgICAgICAgICAgICAgICBpZiAoZHJhd0xlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgYy5saW5lVG8obGVmdCwgdG9wKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjLm1vdmVUbyhsZWZ0LCB0b3ApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChkcmF3VG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIGMubGluZVRvKHJpZ2h0LCB0b3ApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGMubW92ZVRvKHJpZ2h0LCB0b3ApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChkcmF3UmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgYy5saW5lVG8ocmlnaHQsIGJvdHRvbSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYy5tb3ZlVG8ocmlnaHQsIGJvdHRvbSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGRyYXdCb3R0b20pIHtcbiAgICAgICAgICAgICAgICAgICAgYy5saW5lVG8obGVmdCwgYm90dG9tKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjLm1vdmVUbyhsZWZ0LCBib3R0b20pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGMuc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgLSBkcmF3U2VyaWVzQmFycyhzZXJpZXMsIGN0eCwgcGxvdE9mZnNldCwgcGxvdFdpZHRoLCBwbG90SGVpZ2h0LCBkcmF3U3ltYm9sLCBnZXRDb2xvck9yR3JhZGllbnQpXG5cbiAgICAgICAgIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBmb3IgZHJhd2luZyBzZXJpZXMgcmVwcmVzZW50ZWQgYXMgYmFycy4gSW4gY2FzZSB0aGUgc2VyaWVzIGhhcyBkZWNpbWF0aW9uXG4gICAgICAgICBmdW5jdGlvbiBhdHRhY2hlZCwgYmVmb3JlIHN0YXJ0aW5nIHRvIGRyYXcsIGFzIGFuIG9wdGltaXphdGlvbiB0aGUgcG9pbnRzIHdpbGwgZmlyc3QgYmUgZGVjaW1hdGVkLlxuXG4gICAgICAgICBUaGUgc2VyaWVzIHBhcmFtZXRlciBjb250YWlucyB0aGUgc2VyaWVzIHRvIGJlIGRyYXduIG9uIGN0eCBjb250ZXh0LiBUaGUgcGxvdE9mZnNldCwgcGxvdFdpZHRoIGFuZFxuICAgICAgICAgcGxvdEhlaWdodCBhcmUgdGhlIGNvcnJlc3BvbmRpbmcgcGFyYW1ldGVycyBvZiBmbG90IHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBkcmF3aW5nIHN1cmZhY2UuXG4gICAgICAgICBUaGUgZnVuY3Rpb24gZ2V0Q29sb3JPckdyYWRpZW50IGlzIHVzZWQgdG8gY29tcHV0ZSB0aGUgZmlsbCBzdHlsZSBvZiBiYXJzLlxuICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBkcmF3U2VyaWVzQmFycyhzZXJpZXMsIGN0eCwgcGxvdE9mZnNldCwgcGxvdFdpZHRoLCBwbG90SGVpZ2h0LCBkcmF3U3ltYm9sLCBnZXRDb2xvck9yR3JhZGllbnQpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHBsb3RCYXJzKGRhdGFwb2ludHMsIGJhckxlZnQsIGJhclJpZ2h0LCBmaWxsU3R5bGVDYWxsYmFjaywgYXhpc3gsIGF4aXN5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IGRhdGFwb2ludHMucG9pbnRzLFxuICAgICAgICAgICAgICAgICAgICBwcyA9IGRhdGFwb2ludHMucG9pbnRzaXplLFxuICAgICAgICAgICAgICAgICAgICBmaWxsVG93YXJkcyA9IHNlcmllcy5iYXJzLmZpbGxUb3dhcmRzIHx8IDAsXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRCb3R0b20gPSBmaWxsVG93YXJkcyA+IGF4aXN5Lm1pbiA/IE1hdGgubWluKGF4aXN5Lm1heCwgZmlsbFRvd2FyZHMpIDogYXhpc3kubWluO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpICs9IHBzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb2ludHNbaV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhpcmQgcG9pbnQgYXMgYm90dG9tIGlmIHBvaW50c2l6ZSBpcyAzXG4gICAgICAgICAgICAgICAgICAgIHZhciBib3R0b20gPSBwcyA9PT0gMyA/IHBvaW50c1tpICsgMl0gOiBkZWZhdWx0Qm90dG9tO1xuICAgICAgICAgICAgICAgICAgICBkcmF3QmFyKHBvaW50c1tpXSwgcG9pbnRzW2kgKyAxXSwgYm90dG9tLCBiYXJMZWZ0LCBiYXJSaWdodCwgZmlsbFN0eWxlQ2FsbGJhY2ssIGF4aXN4LCBheGlzeSwgY3R4LCBzZXJpZXMuYmFycy5ob3Jpem9udGFsLCBzZXJpZXMuYmFycy5saW5lV2lkdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUocGxvdE9mZnNldC5sZWZ0LCBwbG90T2Zmc2V0LnRvcCk7XG5cbiAgICAgICAgICAgIHZhciBkYXRhcG9pbnRzID0ge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogc2VyaWVzLmRhdGFwb2ludHMuZm9ybWF0LFxuICAgICAgICAgICAgICAgIHBvaW50czogc2VyaWVzLmRhdGFwb2ludHMucG9pbnRzLFxuICAgICAgICAgICAgICAgIHBvaW50c2l6ZTogc2VyaWVzLmRhdGFwb2ludHMucG9pbnRzaXplXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoc2VyaWVzLmRlY2ltYXRlKSB7XG4gICAgICAgICAgICAgICAgZGF0YXBvaW50cy5wb2ludHMgPSBzZXJpZXMuZGVjaW1hdGUoc2VyaWVzLCBzZXJpZXMueGF4aXMubWluLCBzZXJpZXMueGF4aXMubWF4LCBwbG90V2lkdGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gc2VyaWVzLmJhcnMubGluZVdpZHRoO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc2VyaWVzLmNvbG9yO1xuXG4gICAgICAgICAgICB2YXIgYmFyTGVmdDtcbiAgICAgICAgICAgIHZhciBiYXJXaWR0aCA9IHNlcmllcy5iYXJzLmJhcldpZHRoWzBdIHx8IHNlcmllcy5iYXJzLmJhcldpZHRoO1xuICAgICAgICAgICAgc3dpdGNoIChzZXJpZXMuYmFycy5hbGlnbikge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICAgICAgICAgICAgICAgIGJhckxlZnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgICAgICAgICAgICAgYmFyTGVmdCA9IC1iYXJXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgYmFyTGVmdCA9IC1iYXJXaWR0aCAvIDI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBmaWxsU3R5bGVDYWxsYmFjayA9IHNlcmllcy5iYXJzLmZpbGwgPyBmdW5jdGlvbihib3R0b20sIHRvcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRGaWxsU3R5bGUoc2VyaWVzLmJhcnMsIHNlcmllcy5jb2xvciwgYm90dG9tLCB0b3AsIGdldENvbG9yT3JHcmFkaWVudCk7XG4gICAgICAgICAgICB9IDogbnVsbDtcblxuICAgICAgICAgICAgcGxvdEJhcnMoZGF0YXBvaW50cywgYmFyTGVmdCwgYmFyTGVmdCArIGJhcldpZHRoLCBmaWxsU3R5bGVDYWxsYmFjaywgc2VyaWVzLnhheGlzLCBzZXJpZXMueWF4aXMpO1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldEZpbGxTdHlsZShmaWxsb3B0aW9ucywgc2VyaWVzQ29sb3IsIGJvdHRvbSwgdG9wLCBnZXRDb2xvck9yR3JhZGllbnQpIHtcbiAgICAgICAgICAgIHZhciBmaWxsID0gZmlsbG9wdGlvbnMuZmlsbDtcbiAgICAgICAgICAgIGlmICghZmlsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZmlsbG9wdGlvbnMuZmlsbENvbG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldENvbG9yT3JHcmFkaWVudChmaWxsb3B0aW9ucy5maWxsQ29sb3IsIGJvdHRvbSwgdG9wLCBzZXJpZXNDb2xvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjID0gJC5jb2xvci5wYXJzZShzZXJpZXNDb2xvcik7XG4gICAgICAgICAgICBjLmEgPSB0eXBlb2YgZmlsbCA9PT0gXCJudW1iZXJcIiA/IGZpbGwgOiAwLjQ7XG4gICAgICAgICAgICBjLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGMudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZHJhd1Nlcmllc0xpbmVzID0gZHJhd1Nlcmllc0xpbmVzO1xuICAgICAgICB0aGlzLmRyYXdTZXJpZXNQb2ludHMgPSBkcmF3U2VyaWVzUG9pbnRzO1xuICAgICAgICB0aGlzLmRyYXdTZXJpZXNCYXJzID0gZHJhd1Nlcmllc0JhcnM7XG4gICAgICAgIHRoaXMuZHJhd0JhciA9IGRyYXdCYXI7XG4gICAgfTtcblxuICAgICQucGxvdC5kcmF3U2VyaWVzID0gbmV3IERyYXdTZXJpZXMoKTtcbn0pKGpRdWVyeSk7XG4iLCIvKiBGbG90IHBsdWdpbiBmb3IgcGxvdHRpbmcgZXJyb3IgYmFycy5cblxuQ29weXJpZ2h0IChjKSAyMDA3LTIwMTQgSU9MQSBhbmQgT2xlIExhdXJzZW4uXG5MaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cbkVycm9yIGJhcnMgYXJlIHVzZWQgdG8gc2hvdyBzdGFuZGFyZCBkZXZpYXRpb24gYW5kIG90aGVyIHN0YXRpc3RpY2FsXG5wcm9wZXJ0aWVzIGluIGEgcGxvdC5cblxuKiBDcmVhdGVkIGJ5IFJ1aSBQZXJlaXJhICAtICBydWkgKGRvdCkgcGVyZWlyYSAoYXQpIGdtYWlsIChkb3QpIGNvbVxuXG5UaGlzIHBsdWdpbiBhbGxvd3MgeW91IHRvIHBsb3QgZXJyb3ItYmFycyBvdmVyIHBvaW50cy4gU2V0IFwiZXJyb3JiYXJzXCIgaW5zaWRlXG50aGUgcG9pbnRzIHNlcmllcyB0byB0aGUgYXhpcyBuYW1lIG92ZXIgd2hpY2ggdGhlcmUgd2lsbCBiZSBlcnJvciB2YWx1ZXMgaW5cbnlvdXIgZGF0YSBhcnJheSAoKmV2ZW4qIGlmIHlvdSBkbyBub3QgaW50ZW5kIHRvIHBsb3QgdGhlbSBsYXRlciwgYnkgc2V0dGluZ1xuXCJzaG93OiBudWxsXCIgb24geGVyci95ZXJyKS5cblxuVGhlIHBsdWdpbiBzdXBwb3J0cyB0aGVzZSBvcHRpb25zOlxuXG4gICAgc2VyaWVzOiB7XG4gICAgICAgIHBvaW50czoge1xuICAgICAgICAgICAgZXJyb3JiYXJzOiBcInhcIiBvciBcInlcIiBvciBcInh5XCIsXG4gICAgICAgICAgICB4ZXJyOiB7XG4gICAgICAgICAgICAgICAgc2hvdzogbnVsbC9mYWxzZSBvciB0cnVlLFxuICAgICAgICAgICAgICAgIGFzeW1tZXRyaWM6IG51bGwvZmFsc2Ugb3IgdHJ1ZSxcbiAgICAgICAgICAgICAgICB1cHBlckNhcDogbnVsbCBvciBcIi1cIiBvciBmdW5jdGlvbixcbiAgICAgICAgICAgICAgICBsb3dlckNhcDogbnVsbCBvciBcIi1cIiBvciBmdW5jdGlvbixcbiAgICAgICAgICAgICAgICBjb2xvcjogbnVsbCBvciBjb2xvcixcbiAgICAgICAgICAgICAgICByYWRpdXM6IG51bGwgb3IgbnVtYmVyXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeWVycjogeyBzYW1lIG9wdGlvbnMgYXMgeGVyciB9XG4gICAgICAgIH1cbiAgICB9XG5cbkVhY2ggZGF0YSBwb2ludCBhcnJheSBpcyBleHBlY3RlZCB0byBiZSBvZiB0aGUgdHlwZTpcblxuICAgIFwieFwiICBbIHgsIHksIHhlcnIgXVxuICAgIFwieVwiICBbIHgsIHksIHllcnIgXVxuICAgIFwieHlcIiBbIHgsIHksIHhlcnIsIHllcnIgXVxuXG5XaGVyZSB4ZXJyIGJlY29tZXMgeGVycl9sb3dlcix4ZXJyX3VwcGVyIGZvciB0aGUgYXN5bW1ldHJpYyBlcnJvciBjYXNlLCBhbmRcbmVxdWl2YWxlbnRseSBmb3IgeWVyci4gRWcuLCBhIGRhdGFwb2ludCBmb3IgdGhlIFwieHlcIiBjYXNlIHdpdGggc3ltbWV0cmljXG5lcnJvci1iYXJzIG9uIFggYW5kIGFzeW1tZXRyaWMgb24gWSB3b3VsZCBiZTpcblxuICAgIFsgeCwgeSwgeGVyciwgeWVycl9sb3dlciwgeWVycl91cHBlciBdXG5cbkJ5IGRlZmF1bHQgbm8gZW5kIGNhcHMgYXJlIGRyYXduLiBTZXR0aW5nIHVwcGVyQ2FwIGFuZC9vciBsb3dlckNhcCB0byBcIi1cIiB3aWxsXG5kcmF3IGEgc21hbGwgY2FwIHBlcnBlbmRpY3VsYXIgdG8gdGhlIGVycm9yIGJhci4gVGhleSBjYW4gYWxzbyBiZSBzZXQgdG8gYVxudXNlci1kZWZpbmVkIGRyYXdpbmcgZnVuY3Rpb24sIHdpdGggKGN0eCwgeCwgeSwgcmFkaXVzKSBhcyBwYXJhbWV0ZXJzLCBhcyBlZy5cblxuICAgIGZ1bmN0aW9uIGRyYXdTZW1pQ2lyY2xlKCBjdHgsIHgsIHksIHJhZGl1cyApIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHguYXJjKCB4LCB5LCByYWRpdXMsIDAsIE1hdGguUEksIGZhbHNlICk7XG4gICAgICAgIGN0eC5tb3ZlVG8oIHggLSByYWRpdXMsIHkgKTtcbiAgICAgICAgY3R4LmxpbmVUbyggeCArIHJhZGl1cywgeSApO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxuXG5Db2xvciBhbmQgcmFkaXVzIGJvdGggZGVmYXVsdCB0byB0aGUgc2FtZSBvbmVzIG9mIHRoZSBwb2ludHMgc2VyaWVzIGlmIG5vdFxuc2V0LiBUaGUgaW5kZXBlbmRlbnQgcmFkaXVzIHBhcmFtZXRlciBvbiB4ZXJyL3llcnIgaXMgdXNlZnVsIGZvciB0aGUgY2FzZSB3aGVuXG53ZSBtYXkgd2FudCB0byBhZGQgZXJyb3ItYmFycyB0byBhIGxpbmUsIHdpdGhvdXQgc2hvd2luZyB0aGUgaW50ZXJjb25uZWN0aW5nXG5wb2ludHMgKHdpdGggcmFkaXVzOiAwKSwgYW5kIHN0aWxsIHNob3dpbmcgZW5kIGNhcHMgb24gdGhlIGVycm9yLWJhcnMuXG5zaGFkb3dTaXplIGFuZCBsaW5lV2lkdGggYXJlIGRlcml2ZWQgYXMgd2VsbCBmcm9tIHRoZSBwb2ludHMgc2VyaWVzLlxuXG4qL1xuXG4oZnVuY3Rpb24gKCQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgc2VyaWVzOiB7XG4gICAgICAgICAgICBwb2ludHM6IHtcbiAgICAgICAgICAgICAgICBlcnJvcmJhcnM6IG51bGwsIC8vc2hvdWxkIGJlICd4JywgJ3knIG9yICd4eSdcbiAgICAgICAgICAgICAgICB4ZXJyOiB7ZXJyOiAneCcsIHNob3c6IG51bGwsIGFzeW1tZXRyaWM6IG51bGwsIHVwcGVyQ2FwOiBudWxsLCBsb3dlckNhcDogbnVsbCwgY29sb3I6IG51bGwsIHJhZGl1czogbnVsbH0sXG4gICAgICAgICAgICAgICAgeWVycjoge2VycjogJ3knLCBzaG93OiBudWxsLCBhc3ltbWV0cmljOiBudWxsLCB1cHBlckNhcDogbnVsbCwgbG93ZXJDYXA6IG51bGwsIGNvbG9yOiBudWxsLCByYWRpdXM6IG51bGx9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1Jhd0RhdGEocGxvdCwgc2VyaWVzLCBkYXRhLCBkYXRhcG9pbnRzKSB7XG4gICAgICAgIGlmICghc2VyaWVzLnBvaW50cy5lcnJvcmJhcnMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHgseSB2YWx1ZXNcbiAgICAgICAgdmFyIGZvcm1hdCA9IFtcbiAgICAgICAgICAgIHsgeDogdHJ1ZSwgbnVtYmVyOiB0cnVlLCByZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyB5OiB0cnVlLCBudW1iZXI6IHRydWUsIHJlcXVpcmVkOiB0cnVlIH1cbiAgICAgICAgXTtcblxuICAgICAgICB2YXIgZXJyb3JzID0gc2VyaWVzLnBvaW50cy5lcnJvcmJhcnM7XG4gICAgICAgIC8vIGVycm9yIGJhcnMgLSBmaXJzdCBYIHRoZW4gWVxuICAgICAgICBpZiAoZXJyb3JzID09PSAneCcgfHwgZXJyb3JzID09PSAneHknKSB7XG4gICAgICAgICAgICAvLyBsb3dlciAvIHVwcGVyIGVycm9yXG4gICAgICAgICAgICBpZiAoc2VyaWVzLnBvaW50cy54ZXJyLmFzeW1tZXRyaWMpIHtcbiAgICAgICAgICAgICAgICBmb3JtYXQucHVzaCh7IHg6IHRydWUsIG51bWJlcjogdHJ1ZSwgcmVxdWlyZWQ6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgZm9ybWF0LnB1c2goeyB4OiB0cnVlLCBudW1iZXI6IHRydWUsIHJlcXVpcmVkOiB0cnVlIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3JtYXQucHVzaCh7IHg6IHRydWUsIG51bWJlcjogdHJ1ZSwgcmVxdWlyZWQ6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9ycyA9PT0gJ3knIHx8IGVycm9ycyA9PT0gJ3h5Jykge1xuICAgICAgICAgICAgLy8gbG93ZXIgLyB1cHBlciBlcnJvclxuICAgICAgICAgICAgaWYgKHNlcmllcy5wb2ludHMueWVyci5hc3ltbWV0cmljKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0LnB1c2goeyB5OiB0cnVlLCBudW1iZXI6IHRydWUsIHJlcXVpcmVkOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIGZvcm1hdC5wdXNoKHsgeTogdHJ1ZSwgbnVtYmVyOiB0cnVlLCByZXF1aXJlZDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0LnB1c2goeyB5OiB0cnVlLCBudW1iZXI6IHRydWUsIHJlcXVpcmVkOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRhdGFwb2ludHMuZm9ybWF0ID0gZm9ybWF0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRXJyb3JzKHNlcmllcywgaSkge1xuICAgICAgICB2YXIgcG9pbnRzID0gc2VyaWVzLmRhdGFwb2ludHMucG9pbnRzO1xuXG4gICAgICAgIC8vIHJlYWQgZXJyb3JzIGZyb20gcG9pbnRzIGFycmF5XG4gICAgICAgIHZhciBleGwgPSBudWxsLFxuICAgICAgICAgICAgZXh1ID0gbnVsbCxcbiAgICAgICAgICAgIGV5bCA9IG51bGwsXG4gICAgICAgICAgICBleXUgPSBudWxsO1xuICAgICAgICB2YXIgeGVyciA9IHNlcmllcy5wb2ludHMueGVycixcbiAgICAgICAgICAgIHllcnIgPSBzZXJpZXMucG9pbnRzLnllcnI7XG5cbiAgICAgICAgdmFyIGViID0gc2VyaWVzLnBvaW50cy5lcnJvcmJhcnM7XG4gICAgICAgIC8vIGVycm9yIGJhcnMgLSBmaXJzdCBYXG4gICAgICAgIGlmIChlYiA9PT0gJ3gnIHx8IGViID09PSAneHknKSB7XG4gICAgICAgICAgICBpZiAoeGVyci5hc3ltbWV0cmljKSB7XG4gICAgICAgICAgICAgICAgZXhsID0gcG9pbnRzW2kgKyAyXTtcbiAgICAgICAgICAgICAgICBleHUgPSBwb2ludHNbaSArIDNdO1xuICAgICAgICAgICAgICAgIGlmIChlYiA9PT0gJ3h5Jykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoeWVyci5hc3ltbWV0cmljKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleWwgPSBwb2ludHNbaSArIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXl1ID0gcG9pbnRzW2kgKyA1XTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV5bCA9IHBvaW50c1tpICsgNF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4bCA9IHBvaW50c1tpICsgMl07XG4gICAgICAgICAgICAgICAgaWYgKGViID09PSAneHknKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh5ZXJyLmFzeW1tZXRyaWMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV5bCA9IHBvaW50c1tpICsgM107XG4gICAgICAgICAgICAgICAgICAgICAgICBleXUgPSBwb2ludHNbaSArIDRdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXlsID0gcG9pbnRzW2kgKyAzXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgLy8gb25seSBZXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZWIgPT09ICd5Jykge1xuICAgICAgICAgICAgICAgIGlmICh5ZXJyLmFzeW1tZXRyaWMpIHtcbiAgICAgICAgICAgICAgICAgICAgZXlsID0gcG9pbnRzW2kgKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgZXl1ID0gcG9pbnRzW2kgKyAzXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBleWwgPSBwb2ludHNbaSArIDJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHN5bW1ldHJpYyBlcnJvcnM/XG4gICAgICAgIGlmIChleHUgPT0gbnVsbCkgZXh1ID0gZXhsO1xuICAgICAgICBpZiAoZXl1ID09IG51bGwpIGV5dSA9IGV5bDtcblxuICAgICAgICB2YXIgZXJyUmFuZ2VzID0gW2V4bCwgZXh1LCBleWwsIGV5dV07XG4gICAgICAgIC8vIG51bGxpZnkgaWYgbm90IHNob3dpbmdcbiAgICAgICAgaWYgKCF4ZXJyLnNob3cpIHtcbiAgICAgICAgICAgIGVyclJhbmdlc1swXSA9IG51bGw7XG4gICAgICAgICAgICBlcnJSYW5nZXNbMV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICgheWVyci5zaG93KSB7XG4gICAgICAgICAgICBlcnJSYW5nZXNbMl0gPSBudWxsO1xuICAgICAgICAgICAgZXJyUmFuZ2VzWzNdID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyUmFuZ2VzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRyYXdTZXJpZXNFcnJvcnMocGxvdCwgY3R4LCBzKSB7XG4gICAgICAgIHZhciBwb2ludHMgPSBzLmRhdGFwb2ludHMucG9pbnRzLFxuICAgICAgICAgICAgcHMgPSBzLmRhdGFwb2ludHMucG9pbnRzaXplLFxuICAgICAgICAgICAgYXggPSBbcy54YXhpcywgcy55YXhpc10sXG4gICAgICAgICAgICByYWRpdXMgPSBzLnBvaW50cy5yYWRpdXMsXG4gICAgICAgICAgICBlcnIgPSBbcy5wb2ludHMueGVyciwgcy5wb2ludHMueWVycl0sXG4gICAgICAgICAgICB0bXA7XG5cbiAgICAgICAgLy9zYW5pdHkgY2hlY2ssIGluIGNhc2Ugc29tZSBpbnZlcnRlZCBheGlzIGhhY2sgaXMgYXBwbGllZCB0byBmbG90XG4gICAgICAgIHZhciBpbnZlcnRYID0gZmFsc2U7XG4gICAgICAgIGlmIChheFswXS5wMmMoYXhbMF0ubWF4KSA8IGF4WzBdLnAyYyhheFswXS5taW4pKSB7XG4gICAgICAgICAgICBpbnZlcnRYID0gdHJ1ZTtcbiAgICAgICAgICAgIHRtcCA9IGVyclswXS5sb3dlckNhcDtcbiAgICAgICAgICAgIGVyclswXS5sb3dlckNhcCA9IGVyclswXS51cHBlckNhcDtcbiAgICAgICAgICAgIGVyclswXS51cHBlckNhcCA9IHRtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbnZlcnRZID0gZmFsc2U7XG4gICAgICAgIGlmIChheFsxXS5wMmMoYXhbMV0ubWluKSA8IGF4WzFdLnAyYyhheFsxXS5tYXgpKSB7XG4gICAgICAgICAgICBpbnZlcnRZID0gdHJ1ZTtcbiAgICAgICAgICAgIHRtcCA9IGVyclsxXS5sb3dlckNhcDtcbiAgICAgICAgICAgIGVyclsxXS5sb3dlckNhcCA9IGVyclsxXS51cHBlckNhcDtcbiAgICAgICAgICAgIGVyclsxXS51cHBlckNhcCA9IHRtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5kYXRhcG9pbnRzLnBvaW50cy5sZW5ndGg7IGkgKz0gcHMpIHtcbiAgICAgICAgICAgIC8vcGFyc2VcbiAgICAgICAgICAgIHZhciBlcnJSYW5nZXMgPSBwYXJzZUVycm9ycyhzLCBpKTtcblxuICAgICAgICAgICAgLy9jeWNsZSB4ZXJyICYgeWVyclxuICAgICAgICAgICAgZm9yICh2YXIgZSA9IDA7IGUgPCBlcnIubGVuZ3RoOyBlKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbWlubWF4ID0gW2F4W2VdLm1pbiwgYXhbZV0ubWF4XTtcblxuICAgICAgICAgICAgICAgIC8vZHJhdyB0aGlzIGVycm9yP1xuICAgICAgICAgICAgICAgIGlmIChlcnJSYW5nZXNbZSAqIGVyci5sZW5ndGhdKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vZGF0YSBjb29yZGluYXRlc1xuICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IHBvaW50c1tpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBwb2ludHNbaSArIDFdO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vZXJyb3JiYXIgcmFuZ2VzXG4gICAgICAgICAgICAgICAgICAgIHZhciB1cHBlciA9IFt4LCB5XVtlXSArIGVyclJhbmdlc1tlICogZXJyLmxlbmd0aCArIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXIgPSBbeCwgeV1bZV0gLSBlcnJSYW5nZXNbZSAqIGVyci5sZW5ndGhdO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vcG9pbnRzIG91dHNpZGUgb2YgdGhlIGNhbnZhc1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyW2VdLmVyciA9PT0gJ3gnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeSA+IGF4WzFdLm1heCB8fCB5IDwgYXhbMV0ubWluIHx8IHVwcGVyIDwgYXhbMF0ubWluIHx8IGxvd2VyID4gYXhbMF0ubWF4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyW2VdLmVyciA9PT0gJ3knKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeCA+IGF4WzBdLm1heCB8fCB4IDwgYXhbMF0ubWluIHx8IHVwcGVyIDwgYXhbMV0ubWluIHx8IGxvd2VyID4gYXhbMV0ubWF4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBwcmV2ZW50IGVycm9yYmFycyBnZXR0aW5nIG91dCBvZiB0aGUgY2FudmFzXG4gICAgICAgICAgICAgICAgICAgIHZhciBkcmF3VXBwZXIgPSB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhd0xvd2VyID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodXBwZXIgPiBtaW5tYXhbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdVcHBlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXIgPSBtaW5tYXhbMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvd2VyIDwgbWlubWF4WzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3TG93ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VyID0gbWlubWF4WzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy9zYW5pdHkgY2hlY2ssIGluIGNhc2Ugc29tZSBpbnZlcnRlZCBheGlzIGhhY2sgaXMgYXBwbGllZCB0byBmbG90XG4gICAgICAgICAgICAgICAgICAgIGlmICgoZXJyW2VdLmVyciA9PT0gJ3gnICYmIGludmVydFgpIHx8IChlcnJbZV0uZXJyID09PSAneScgJiYgaW52ZXJ0WSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc3dhcCBjb29yZGluYXRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgdG1wID0gbG93ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlciA9IHVwcGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXIgPSB0bXA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0bXAgPSBkcmF3TG93ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3TG93ZXIgPSBkcmF3VXBwZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3VXBwZXIgPSB0bXA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0bXAgPSBtaW5tYXhbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5tYXhbMF0gPSBtaW5tYXhbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5tYXhbMV0gPSB0bXA7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IHRvIHBpeGVsc1xuICAgICAgICAgICAgICAgICAgICB4ID0gYXhbMF0ucDJjKHgpO1xuICAgICAgICAgICAgICAgICAgICB5ID0gYXhbMV0ucDJjKHkpO1xuICAgICAgICAgICAgICAgICAgICB1cHBlciA9IGF4W2VdLnAyYyh1cHBlcik7XG4gICAgICAgICAgICAgICAgICAgIGxvd2VyID0gYXhbZV0ucDJjKGxvd2VyKTtcbiAgICAgICAgICAgICAgICAgICAgbWlubWF4WzBdID0gYXhbZV0ucDJjKG1pbm1heFswXSk7XG4gICAgICAgICAgICAgICAgICAgIG1pbm1heFsxXSA9IGF4W2VdLnAyYyhtaW5tYXhbMV0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vc2FtZSBzdHlsZSBhcyBwb2ludHMgYnkgZGVmYXVsdFxuICAgICAgICAgICAgICAgICAgICB2YXIgbHcgPSBlcnJbZV0ubGluZVdpZHRoID8gZXJyW2VdLmxpbmVXaWR0aCA6IHMucG9pbnRzLmxpbmVXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3ID0gcy5wb2ludHMuc2hhZG93U2l6ZSAhPSBudWxsID8gcy5wb2ludHMuc2hhZG93U2l6ZSA6IHMuc2hhZG93U2l6ZTtcblxuICAgICAgICAgICAgICAgICAgICAvL3NoYWRvdyBhcyBmb3IgcG9pbnRzXG4gICAgICAgICAgICAgICAgICAgIGlmIChsdyA+IDAgJiYgc3cgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdyA9IHN3IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSB3O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gXCJyZ2JhKDAsMCwwLDAuMSlcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdFcnJvcihjdHgsIGVycltlXSwgeCwgeSwgdXBwZXIsIGxvd2VyLCBkcmF3VXBwZXIsIGRyYXdMb3dlciwgcmFkaXVzLCB3ICsgdyAvIDIsIG1pbm1heCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IFwicmdiYSgwLDAsMCwwLjIpXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3RXJyb3IoY3R4LCBlcnJbZV0sIHgsIHksIHVwcGVyLCBsb3dlciwgZHJhd1VwcGVyLCBkcmF3TG93ZXIsIHJhZGl1cywgdyAvIDIsIG1pbm1heCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBlcnJbZV0uY29sb3JcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZXJyW2VdLmNvbG9yXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHMuY29sb3I7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBsdztcbiAgICAgICAgICAgICAgICAgICAgLy9kcmF3IGl0XG4gICAgICAgICAgICAgICAgICAgIGRyYXdFcnJvcihjdHgsIGVycltlXSwgeCwgeSwgdXBwZXIsIGxvd2VyLCBkcmF3VXBwZXIsIGRyYXdMb3dlciwgcmFkaXVzLCAwLCBtaW5tYXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRyYXdFcnJvcihjdHgsIGVyciwgeCwgeSwgdXBwZXIsIGxvd2VyLCBkcmF3VXBwZXIsIGRyYXdMb3dlciwgcmFkaXVzLCBvZmZzZXQsIG1pbm1heCkge1xuICAgICAgICAvL3NoYWRvdyBvZmZzZXRcbiAgICAgICAgeSArPSBvZmZzZXQ7XG4gICAgICAgIHVwcGVyICs9IG9mZnNldDtcbiAgICAgICAgbG93ZXIgKz0gb2Zmc2V0O1xuXG4gICAgICAgIC8vIGVycm9yIGJhciAtIGF2b2lkIHBsb3R0aW5nIG92ZXIgY2lyY2xlc1xuICAgICAgICBpZiAoZXJyLmVyciA9PT0gJ3gnKSB7XG4gICAgICAgICAgICBpZiAodXBwZXIgPiB4ICsgcmFkaXVzKSBkcmF3UGF0aChjdHgsIFtbdXBwZXIsIHldLCBbTWF0aC5tYXgoeCArIHJhZGl1cywgbWlubWF4WzBdKSwgeV1dKTtcbiAgICAgICAgICAgIGVsc2UgZHJhd1VwcGVyID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChsb3dlciA8IHggLSByYWRpdXMpIGRyYXdQYXRoKGN0eCwgW1tNYXRoLm1pbih4IC0gcmFkaXVzLCBtaW5tYXhbMV0pLCB5XSwgW2xvd2VyLCB5XV0pO1xuICAgICAgICAgICAgZWxzZSBkcmF3TG93ZXIgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh1cHBlciA8IHkgLSByYWRpdXMpIGRyYXdQYXRoKGN0eCwgW1t4LCB1cHBlcl0sIFt4LCBNYXRoLm1pbih5IC0gcmFkaXVzLCBtaW5tYXhbMF0pXV0pO1xuICAgICAgICAgICAgZWxzZSBkcmF3VXBwZXIgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGxvd2VyID4geSArIHJhZGl1cykgZHJhd1BhdGgoY3R4LCBbW3gsIE1hdGgubWF4KHkgKyByYWRpdXMsIG1pbm1heFsxXSldLCBbeCwgbG93ZXJdXSk7XG4gICAgICAgICAgICBlbHNlIGRyYXdMb3dlciA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9pbnRlcm5hbCByYWRpdXMgdmFsdWUgaW4gZXJyb3JiYXIsIGFsbG93cyB0byBwbG90IHJhZGl1cyAwIHBvaW50cyBhbmQgc3RpbGwga2VlcCBwcm9wZXIgc2l6ZWQgY2Fwc1xuICAgICAgICAvL3RoaXMgaXMgYSB3YXkgdG8gZ2V0IGVycm9yYmFycyBvbiBsaW5lcyB3aXRob3V0IHZpc2libGUgY29ubmVjdGluZyBkb3RzXG4gICAgICAgIHJhZGl1cyA9IGVyci5yYWRpdXMgIT0gbnVsbFxuICAgICAgICAgICAgPyBlcnIucmFkaXVzXG4gICAgICAgICAgICA6IHJhZGl1cztcblxuICAgICAgICAvLyB1cHBlciBjYXBcbiAgICAgICAgaWYgKGRyYXdVcHBlcikge1xuICAgICAgICAgICAgaWYgKGVyci51cHBlckNhcCA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVyci5lcnIgPT09ICd4JykgZHJhd1BhdGgoY3R4LCBbW3VwcGVyLCB5IC0gcmFkaXVzXSwgW3VwcGVyLCB5ICsgcmFkaXVzXV0pO1xuICAgICAgICAgICAgICAgIGVsc2UgZHJhd1BhdGgoY3R4LCBbW3ggLSByYWRpdXMsIHVwcGVyXSwgW3ggKyByYWRpdXMsIHVwcGVyXV0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgkLmlzRnVuY3Rpb24oZXJyLnVwcGVyQ2FwKSkge1xuICAgICAgICAgICAgICAgIGlmIChlcnIuZXJyID09PSAneCcpIGVyci51cHBlckNhcChjdHgsIHVwcGVyLCB5LCByYWRpdXMpO1xuICAgICAgICAgICAgICAgIGVsc2UgZXJyLnVwcGVyQ2FwKGN0eCwgeCwgdXBwZXIsIHJhZGl1cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG93ZXIgY2FwXG4gICAgICAgIGlmIChkcmF3TG93ZXIpIHtcbiAgICAgICAgICAgIGlmIChlcnIubG93ZXJDYXAgPT09ICctJykge1xuICAgICAgICAgICAgICAgIGlmIChlcnIuZXJyID09PSAneCcpIGRyYXdQYXRoKGN0eCwgW1tsb3dlciwgeSAtIHJhZGl1c10sIFtsb3dlciwgeSArIHJhZGl1c11dKTtcbiAgICAgICAgICAgICAgICBlbHNlIGRyYXdQYXRoKGN0eCwgW1t4IC0gcmFkaXVzLCBsb3dlcl0sIFt4ICsgcmFkaXVzLCBsb3dlcl1dKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJC5pc0Z1bmN0aW9uKGVyci5sb3dlckNhcCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyLmVyciA9PT0gJ3gnKSBlcnIubG93ZXJDYXAoY3R4LCBsb3dlciwgeSwgcmFkaXVzKTtcbiAgICAgICAgICAgICAgICBlbHNlIGVyci5sb3dlckNhcChjdHgsIHgsIGxvd2VyLCByYWRpdXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHJhd1BhdGgoY3R4LCBwdHMpIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKHB0c1swXVswXSwgcHRzWzBdWzFdKTtcbiAgICAgICAgZm9yICh2YXIgcCA9IDE7IHAgPCBwdHMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8ocHRzW3BdWzBdLCBwdHNbcF1bMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRyYXcocGxvdCwgY3R4KSB7XG4gICAgICAgIHZhciBwbG90T2Zmc2V0ID0gcGxvdC5nZXRQbG90T2Zmc2V0KCk7XG5cbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZShwbG90T2Zmc2V0LmxlZnQsIHBsb3RPZmZzZXQudG9wKTtcbiAgICAgICAgJC5lYWNoKHBsb3QuZ2V0RGF0YSgpLCBmdW5jdGlvbiAoaSwgcykge1xuICAgICAgICAgICAgaWYgKHMucG9pbnRzLmVycm9yYmFycyAmJiAocy5wb2ludHMueGVyci5zaG93IHx8IHMucG9pbnRzLnllcnIuc2hvdykpIHtcbiAgICAgICAgICAgICAgICBkcmF3U2VyaWVzRXJyb3JzKHBsb3QsIGN0eCwgcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluaXQocGxvdCkge1xuICAgICAgICBwbG90Lmhvb2tzLnByb2Nlc3NSYXdEYXRhLnB1c2gocHJvY2Vzc1Jhd0RhdGEpO1xuICAgICAgICBwbG90Lmhvb2tzLmRyYXcucHVzaChkcmF3KTtcbiAgICB9XG5cbiAgICAkLnBsb3QucGx1Z2lucy5wdXNoKHtcbiAgICAgICAgaW5pdDogaW5pdCxcbiAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgbmFtZTogJ2Vycm9yYmFycycsXG4gICAgICAgIHZlcnNpb246ICcxLjAnXG4gICAgfSk7XG59KShqUXVlcnkpO1xuIiwiLyogRmxvdCBwbHVnaW4gZm9yIGNvbXB1dGluZyBib3R0b21zIGZvciBmaWxsZWQgbGluZSBhbmQgYmFyIGNoYXJ0cy5cblxuQ29weXJpZ2h0IChjKSAyMDA3LTIwMTQgSU9MQSBhbmQgT2xlIExhdXJzZW4uXG5MaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cblRoZSBjYXNlOiB5b3UndmUgZ290IHR3byBzZXJpZXMgdGhhdCB5b3Ugd2FudCB0byBmaWxsIHRoZSBhcmVhIGJldHdlZW4uIEluIEZsb3RcbnRlcm1zLCB5b3UgbmVlZCB0byB1c2Ugb25lIGFzIHRoZSBmaWxsIGJvdHRvbSBvZiB0aGUgb3RoZXIuIFlvdSBjYW4gc3BlY2lmeSB0aGVcbmJvdHRvbSBvZiBlYWNoIGRhdGEgcG9pbnQgYXMgdGhlIHRoaXJkIGNvb3JkaW5hdGUgbWFudWFsbHksIG9yIHlvdSBjYW4gdXNlIHRoaXNcbnBsdWdpbiB0byBjb21wdXRlIGl0IGZvciB5b3UuXG5cbkluIG9yZGVyIHRvIG5hbWUgdGhlIG90aGVyIHNlcmllcywgeW91IG5lZWQgdG8gZ2l2ZSBpdCBhbiBpZCwgbGlrZSB0aGlzOlxuXG4gICAgdmFyIGRhdGFzZXQgPSBbXG4gICAgICAgIHsgZGF0YTogWyAuLi4gXSwgaWQ6IFwiZm9vXCIgfSAsICAgICAgICAgLy8gdXNlIGRlZmF1bHQgYm90dG9tXG4gICAgICAgIHsgZGF0YTogWyAuLi4gXSwgZmlsbEJldHdlZW46IFwiZm9vXCIgfSwgLy8gdXNlIGZpcnN0IGRhdGFzZXQgYXMgYm90dG9tXG4gICAgXTtcblxuICAgICQucGxvdCgkKFwiI3BsYWNlaG9sZGVyXCIpLCBkYXRhc2V0LCB7IGxpbmVzOiB7IHNob3c6IHRydWUsIGZpbGw6IHRydWUgfX0pO1xuXG5BcyBhIGNvbnZlbmllbmNlLCBpZiB0aGUgaWQgZ2l2ZW4gaXMgYSBudW1iZXIgdGhhdCBkb2Vzbid0IGFwcGVhciBhcyBhbiBpZCBpblxudGhlIHNlcmllcywgaXQgaXMgaW50ZXJwcmV0ZWQgYXMgdGhlIGluZGV4IGluIHRoZSBhcnJheSBpbnN0ZWFkIChzbyBmaWxsQmV0d2VlbjpcbjAgY2FuIGFsc28gbWVhbiB0aGUgZmlyc3Qgc2VyaWVzKS5cblxuSW50ZXJuYWxseSwgdGhlIHBsdWdpbiBtb2RpZmllcyB0aGUgZGF0YXBvaW50cyBpbiBlYWNoIHNlcmllcy4gRm9yIGxpbmUgc2VyaWVzLFxuZXh0cmEgZGF0YSBwb2ludHMgbWlnaHQgYmUgaW5zZXJ0ZWQgdGhyb3VnaCBpbnRlcnBvbGF0aW9uLiBOb3RlIHRoYXQgYXQgcG9pbnRzXG53aGVyZSB0aGUgYm90dG9tIGxpbmUgaXMgbm90IGRlZmluZWQgKGR1ZSB0byBhIG51bGwgcG9pbnQgb3Igc3RhcnQvZW5kIG9mIGxpbmUpLFxudGhlIGN1cnJlbnQgbGluZSB3aWxsIHNob3cgYSBnYXAgdG9vLiBUaGUgYWxnb3JpdGhtIGNvbWVzIGZyb20gdGhlXG5qcXVlcnkuZmxvdC5zdGFjay5qcyBwbHVnaW4sIHBvc3NpYmx5IHNvbWUgY29kZSBjb3VsZCBiZSBzaGFyZWQuXG5cbiovXG5cbihmdW5jdGlvbiAoJCkge1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBzZXJpZXM6IHtcbiAgICAgICAgICAgIGZpbGxCZXR3ZWVuOiBudWxsIC8vIG9yIG51bWJlclxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGluaXQocGxvdCkge1xuICAgICAgICBmdW5jdGlvbiBmaW5kQm90dG9tU2VyaWVzKHMsIGFsbHNlcmllcykge1xuICAgICAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhbGxzZXJpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWxsc2VyaWVzWyBpIF0uaWQgPT09IHMuZmlsbEJldHdlZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFsbHNlcmllc1sgaSBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzLmZpbGxCZXR3ZWVuID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHMuZmlsbEJldHdlZW4gPCAwIHx8IHMuZmlsbEJldHdlZW4gPj0gYWxsc2VyaWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFsbHNlcmllc1sgcy5maWxsQmV0d2VlbiBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVGb3JtYXQocGxvdCwgcywgZGF0YSwgZGF0YXBvaW50cykge1xuICAgICAgICAgICAgaWYgKHMuZmlsbEJldHdlZW4gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGZvcm1hdCA9IGRhdGFwb2ludHMuZm9ybWF0O1xuICAgICAgICAgICAgdmFyIHBsb3RIYXNJZCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBsb3REYXRhID0gcGxvdC5nZXREYXRhKCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbG90RGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGxvdERhdGFbaV0uaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBbXTtcblxuICAgICAgICAgICAgICAgIGZvcm1hdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgeDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb21wdXRlUmFuZ2U6IHMueGF4aXMub3B0aW9ucy5hdXRvU2NhbGUgIT09ICdub25lJyxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBmb3JtYXQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29tcHV0ZVJhbmdlOiBzLnlheGlzLm9wdGlvbnMuYXV0b1NjYWxlICE9PSAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocy5maWxsQmV0d2VlbiAhPT0gdW5kZWZpbmVkICYmIHMuZmlsbEJldHdlZW4gIT09ICcnICYmIHBsb3RIYXNJZChzLmZpbGxCZXR3ZWVuKSAmJiBzLmZpbGxCZXR3ZWVuICE9PSBzLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVSYW5nZTogcy55YXhpcy5vcHRpb25zLmF1dG9TY2FsZSAhPT0gJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiAwXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRhdGFwb2ludHMuZm9ybWF0ID0gZm9ybWF0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY29tcHV0ZUZpbGxCb3R0b21zKHBsb3QsIHMsIGRhdGFwb2ludHMpIHtcbiAgICAgICAgICAgIGlmIChzLmZpbGxCZXR3ZWVuID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvdGhlciA9IGZpbmRCb3R0b21TZXJpZXMocywgcGxvdC5nZXREYXRhKCkpO1xuXG4gICAgICAgICAgICBpZiAoIW90aGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcHMgPSBkYXRhcG9pbnRzLnBvaW50c2l6ZSxcbiAgICAgICAgICAgICAgICBwb2ludHMgPSBkYXRhcG9pbnRzLnBvaW50cyxcbiAgICAgICAgICAgICAgICBvdGhlcnBzID0gb3RoZXIuZGF0YXBvaW50cy5wb2ludHNpemUsXG4gICAgICAgICAgICAgICAgb3RoZXJwb2ludHMgPSBvdGhlci5kYXRhcG9pbnRzLnBvaW50cyxcbiAgICAgICAgICAgICAgICBuZXdwb2ludHMgPSBbXSxcbiAgICAgICAgICAgICAgICBweCwgcHksIGludGVyeSwgcXgsIHF5LCBib3R0b20sXG4gICAgICAgICAgICAgICAgd2l0aGxpbmVzID0gcy5saW5lcy5zaG93LFxuICAgICAgICAgICAgICAgIHdpdGhib3R0b20gPSBwcyA+IDIgJiYgZGF0YXBvaW50cy5mb3JtYXRbMl0ueSxcbiAgICAgICAgICAgICAgICB3aXRoc3RlcHMgPSB3aXRobGluZXMgJiYgcy5saW5lcy5zdGVwcyxcbiAgICAgICAgICAgICAgICBmcm9tZ2FwID0gdHJ1ZSxcbiAgICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgICBqID0gMCxcbiAgICAgICAgICAgICAgICBsLCBtO1xuXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChpID49IHBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbCA9IG5ld3BvaW50cy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBpZiAocG9pbnRzWyBpIF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb3B5IGdhcHNcbiAgICAgICAgICAgICAgICAgICAgZm9yIChtID0gMDsgbSA8IHBzOyArK20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld3BvaW50cy5wdXNoKHBvaW50c1sgaSArIG0gXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpICs9IHBzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaiA+PSBvdGhlcnBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIGxpbmVzLCB3ZSBjYW4ndCB1c2UgdGhlIHJlc3Qgb2YgdGhlIHBvaW50c1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXdpdGhsaW5lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChtID0gMDsgbSA8IHBzOyArK20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdwb2ludHMucHVzaChwb2ludHNbIGkgKyBtIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaSArPSBwcztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG90aGVycG9pbnRzWyBqIF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBvb3BzLCBnb3QgYSBnYXBcbiAgICAgICAgICAgICAgICAgICAgZm9yIChtID0gMDsgbSA8IHBzOyArK20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld3BvaW50cy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZnJvbWdhcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGogKz0gb3RoZXJwcztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBjYXNlcyB3aGVyZSB3ZSBhY3R1YWxseSBnb3QgdHdvIHBvaW50c1xuICAgICAgICAgICAgICAgICAgICBweCA9IHBvaW50c1sgaSBdO1xuICAgICAgICAgICAgICAgICAgICBweSA9IHBvaW50c1sgaSArIDEgXTtcbiAgICAgICAgICAgICAgICAgICAgcXggPSBvdGhlcnBvaW50c1sgaiBdO1xuICAgICAgICAgICAgICAgICAgICBxeSA9IG90aGVycG9pbnRzWyBqICsgMSBdO1xuICAgICAgICAgICAgICAgICAgICBib3R0b20gPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChweCA9PT0gcXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobSA9IDA7IG0gPCBwczsgKyttKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3cG9pbnRzLnB1c2gocG9pbnRzWyBpICsgbSBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9uZXdwb2ludHNbIGwgKyAxIF0gKz0gcXk7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b20gPSBxeTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSBwcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGogKz0gb3RoZXJwcztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChweCA+IHF4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBnb3QgcGFzdCBwb2ludCBiZWxvdywgbWlnaHQgbmVlZCB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zZXJ0IGludGVycG9sYXRlZCBleHRyYSBwb2ludFxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod2l0aGxpbmVzICYmIGkgPiAwICYmIHBvaW50c1sgaSAtIHBzIF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVyeSA9IHB5ICsgKHBvaW50c1sgaSAtIHBzICsgMSBdIC0gcHkpICogKHF4IC0gcHgpIC8gKHBvaW50c1sgaSAtIHBzIF0gLSBweCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3cG9pbnRzLnB1c2gocXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld3BvaW50cy5wdXNoKGludGVyeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChtID0gMjsgbSA8IHBzOyArK20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3cG9pbnRzLnB1c2gocG9pbnRzWyBpICsgbSBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tID0gcXk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGogKz0gb3RoZXJwcztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHB4IDwgcXhcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGNvbWUgZnJvbSBhIGdhcCwgd2UganVzdCBza2lwIHRoaXMgcG9pbnRcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyb21nYXAgJiYgd2l0aGxpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSArPSBwcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChtID0gMDsgbSA8IHBzOyArK20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdwb2ludHMucHVzaChwb2ludHNbIGkgKyBtIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBtaWdodCBiZSBhYmxlIHRvIGludGVycG9sYXRlIGEgcG9pbnQgYmVsb3csXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGNhbiBnaXZlIHVzIGEgYmV0dGVyIHlcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpdGhsaW5lcyAmJiBqID4gMCAmJiBvdGhlcnBvaW50c1sgaiAtIG90aGVycHMgXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tID0gcXkgKyAob3RoZXJwb2ludHNbIGogLSBvdGhlcnBzICsgMSBdIC0gcXkpICogKHB4IC0gcXgpIC8gKG90aGVycG9pbnRzWyBqIC0gb3RoZXJwcyBdIC0gcXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL25ld3BvaW50c1tsICsgMV0gKz0gYm90dG9tO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IHBzO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZnJvbWdhcCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChsICE9PSBuZXdwb2ludHMubGVuZ3RoICYmIHdpdGhib3R0b20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld3BvaW50c1sgbCArIDIgXSA9IGJvdHRvbTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG1haW50YWluIHRoZSBsaW5lIHN0ZXBzIGludmFyaWFudFxuXG4gICAgICAgICAgICAgICAgaWYgKHdpdGhzdGVwcyAmJiBsICE9PSBuZXdwb2ludHMubGVuZ3RoICYmIGwgPiAwICYmXG4gICAgICAgICAgICAgICAgICAgIG5ld3BvaW50c1sgbCBdICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgIG5ld3BvaW50c1sgbCBdICE9PSBuZXdwb2ludHNbIGwgLSBwcyBdICYmXG4gICAgICAgICAgICAgICAgICAgIG5ld3BvaW50c1sgbCArIDEgXSAhPT0gbmV3cG9pbnRzWyBsIC0gcHMgKyAxIF0pIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChtID0gMDsgbSA8IHBzOyArK20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld3BvaW50c1sgbCArIHBzICsgbSBdID0gbmV3cG9pbnRzWyBsICsgbSBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5ld3BvaW50c1sgbCArIDEgXSA9IG5ld3BvaW50c1sgbCAtIHBzICsgMSBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGF0YXBvaW50cy5wb2ludHMgPSBuZXdwb2ludHM7XG4gICAgICAgIH1cblxuICAgICAgICBwbG90Lmhvb2tzLnByb2Nlc3NSYXdEYXRhLnB1c2goY29tcHV0ZUZvcm1hdCk7XG4gICAgICAgIHBsb3QuaG9va3MucHJvY2Vzc0RhdGFwb2ludHMucHVzaChjb21wdXRlRmlsbEJvdHRvbXMpO1xuICAgIH1cblxuICAgICQucGxvdC5wbHVnaW5zLnB1c2goe1xuICAgICAgICBpbml0OiBpbml0LFxuICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICBuYW1lOiBcImZpbGxiZXR3ZWVuXCIsXG4gICAgICAgIHZlcnNpb246IFwiMS4wXCJcbiAgICB9KTtcbn0pKGpRdWVyeSk7XG4iLCIvKiBTdXBwb3J0IGZvciBmbGF0IDFEIGRhdGEgc2VyaWVzLlxuXG5BIDFEIGZsYXQgZGF0YSBzZXJpZXMgaXMgYSBkYXRhIHNlcmllcyBpbiB0aGUgZm9ybSBvZiBhIHJlZ3VsYXIgMUQgYXJyYXkuIFRoZVxubWFpbiByZWFzb24gZm9yIHVzaW5nIGEgZmxhdCBkYXRhIHNlcmllcyBpcyB0aGF0IGl0IHBlcmZvcm1zIGJldHRlciwgY29uc3VtZXNcbmxlc3MgbWVtb3J5IGFuZCBnZW5lcmF0ZXMgbGVzcyBnYXJiYWdlIGNvbGxlY3Rpb24gdGhhbiB0aGUgcmVndWxhciBmbG90IGZvcm1hdC5cblxuRXhhbXBsZTpcblxuICAgIHBsb3Quc2V0RGF0YShbW1swLDBdLCBbMSwxXSwgWzIsMl0sIFszLDNdXV0pOyAvLyByZWd1bGFyIGZsb3QgZm9ybWF0XG4gICAgcGxvdC5zZXREYXRhKFt7ZmxhdGRhdGE6IHRydWUsIGRhdGE6IFswLCAxLCAyLCAzXX1dKTsgLy8gZmxhdGRhdGEgZm9ybWF0XG5cblNldCBzZXJpZXMuZmxhdGRhdGEgdG8gdHJ1ZSB0byBlbmFibGUgdGhpcyBwbHVnaW4uXG5cbllvdSBjYW4gdXNlIHNlcmllcy5zdGFydCB0byBzcGVjaWZ5IHRoZSBzdGFydGluZyBpbmRleCBvZiB0aGUgc2VyaWVzIChkZWZhdWx0IGlzIDApXG5Zb3UgY2FuIHVzZSBzZXJpZXMuc3RlcCB0byBzcGVjaWZ5IHRoZSBpbnRlcnZhbCBiZXR3ZWVuIGNvbnNlY3V0aXZlIGluZGV4ZXMgb2YgdGhlIHNlcmllcyAoZGVmYXVsdCBpcyAxKVxuKi9cblxuLyogZ2xvYmFsIGpRdWVyeSovXG5cbihmdW5jdGlvbiAoJCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGZ1bmN0aW9uIHByb2Nlc3MxRFJhd0RhdGEocGxvdCwgc2VyaWVzLCBkYXRhLCBkYXRhcG9pbnRzKSB7XG4gICAgICAgIGlmIChzZXJpZXMuZmxhdGRhdGEgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHNlcmllcy5zdGFydCB8fCAwO1xuICAgICAgICAgICAgdmFyIHN0ZXAgPSB0eXBlb2Ygc2VyaWVzLnN0ZXAgPT09ICdudW1iZXInID8gc2VyaWVzLnN0ZXAgOiAxO1xuICAgICAgICAgICAgZGF0YXBvaW50cy5wb2ludHNpemUgPSAyO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKywgaiArPSAyKSB7XG4gICAgICAgICAgICAgICAgZGF0YXBvaW50cy5wb2ludHNbal0gPSBzdGFydCArIChpICogc3RlcCk7XG4gICAgICAgICAgICAgICAgZGF0YXBvaW50cy5wb2ludHNbaiArIDFdID0gZGF0YVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhcG9pbnRzLnBvaW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZGF0YXBvaW50cy5wb2ludHMubGVuZ3RoID0gZGF0YS5sZW5ndGggKiAyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhcG9pbnRzLnBvaW50cyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgJC5wbG90LnBsdWdpbnMucHVzaCh7XG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uKHBsb3QpIHtcbiAgICAgICAgICAgIHBsb3QuaG9va3MucHJvY2Vzc1Jhd0RhdGEucHVzaChwcm9jZXNzMURSYXdEYXRhKTtcbiAgICAgICAgfSxcbiAgICAgICAgbmFtZTogJ2ZsYXRkYXRhJyxcbiAgICAgICAgdmVyc2lvbjogJzAuMC4yJ1xuICAgIH0pO1xufSkoalF1ZXJ5KTtcbiIsIi8qIGdsb2JhbCBqUXVlcnkgKi9cblxuLyoqXG4jIyBqcXVlcnkuZmxvdC5ob3Zlci5qc1xuXG5UaGlzIHBsdWdpbiBpcyB1c2VkIGZvciBtb3VzZSBob3ZlciBhbmQgdGFwIG9uIGEgcG9pbnQgb2YgcGxvdCBzZXJpZXMuXG5JdCBzdXBwb3J0cyB0aGUgZm9sbG93aW5nIG9wdGlvbnM6XG5gYGBqc1xuZ3JpZDoge1xuICAgIGhvdmVyYWJsZTogZmFsc2UsIC8vdG8gdHJpZ2dlciBwbG90aG92ZXIgZXZlbnQgb24gbW91c2UgaG92ZXIgb3IgdGFwIG9uIGEgcG9pbnRcbiAgICBjbGlja2FibGU6IGZhbHNlIC8vdG8gdHJpZ2dlciBwbG90Y2xpY2sgZXZlbnQgb24gbW91c2UgaG92ZXJcbn1cbmBgYFxuXG5JdCBsaXN0ZW5zIHRvIG5hdGl2ZSBtb3VzZSBtb3ZlIGV2ZW50IG9yIGNsaWNrLCBhcyB3ZWxsIGFzIGFydGlmaWNpYWwgZ2VuZXJhdGVkXG50YXAgYW5kIHRvdWNoZXZlbnQuXG5cbldoZW4gdGhlIG1vdXNlIGlzIG92ZXIgYSBwb2ludCBvciBhIHRhcCBvbiBhIHBvaW50IGlzIHBlcmZvcm1lZCwgdGhhdCBwb2ludCBvclxudGhlIGNvcnJlc2Nwb25kaW5nIGJhciB3aWxsIGJlIGhpZ2hsaWdodGVkIGFuZCBhIFwicGxvdGhvdmVyXCIgZXZlbnQgd2lsbCBiZSBnZW5lcmF0ZWQuXG5cbkN1c3RvbSBcInRvdWNoZXZlbnRcIiBpcyB0cmlnZ2VyZWQgd2hlbiBhbnkgdG91Y2ggaW50ZXJhY3Rpb24gaXMgbWFkZS4gSG92ZXIgcGx1Z2luXG5oYW5kbGVzIHRoaXMgZXZlbnRzIGJ5IHVuaGlnaGxpZ2h0aW5nIGFsbCBvZiB0aGUgcHJldmlvdXNseSBoaWdobGlnaHRlZCBwb2ludHMgYW5kIGdlbmVyYXRlc1xuXCJwbG90aG92ZXJjbGVhbnVwXCIgZXZlbnQgdG8gbm90aWZ5IGFueSBwYXJ0IHRoYXQgaXMgaGFuZGxpbmcgcGxvdGhvdmVyIChmb3IgZXhlbXBsZSB0byBjbGVhbnVwXG50aGUgdG9vbHRpcCBmcm9tIHdlYmNoYXJ0cykuXG4qL1xuXG4oZnVuY3Rpb24oJCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBncmlkOiB7XG4gICAgICAgICAgICBob3ZlcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY2xpY2thYmxlOiBmYWxzZVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBicm93c2VyID0gJC5wbG90LmJyb3dzZXI7XG5cbiAgICB2YXIgZXZlbnRUeXBlID0ge1xuICAgICAgICBjbGljazogJ2NsaWNrJyxcbiAgICAgICAgaG92ZXI6ICdob3ZlcidcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0KHBsb3QpIHtcbiAgICAgICAgdmFyIGxhc3RNb3VzZU1vdmVFdmVudDtcbiAgICAgICAgdmFyIGhpZ2hsaWdodHMgPSBbXTtcblxuICAgICAgICBmdW5jdGlvbiBiaW5kRXZlbnRzKHBsb3QsIGV2ZW50SG9sZGVyKSB7XG4gICAgICAgICAgICB2YXIgbyA9IHBsb3QuZ2V0T3B0aW9ucygpO1xuXG4gICAgICAgICAgICBpZiAoby5ncmlkLmhvdmVyYWJsZSB8fCBvLmdyaWQuY2xpY2thYmxlKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRIb2xkZXJbMF0uYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hldmVudCcsIHRyaWdnZXJDbGVhbnVwRXZlbnQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBldmVudEhvbGRlclswXS5hZGRFdmVudExpc3RlbmVyKCd0YXAnLCBnZW5lcmF0ZVBsb3Rob3ZlckV2ZW50LCBmYWxzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvLmdyaWQuY2xpY2thYmxlKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRIb2xkZXIuYmluZChcImNsaWNrXCIsIG9uQ2xpY2spO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoby5ncmlkLmhvdmVyYWJsZSkge1xuICAgICAgICAgICAgICAgIGV2ZW50SG9sZGVyLmJpbmQoXCJtb3VzZW1vdmVcIiwgb25Nb3VzZU1vdmUpO1xuXG4gICAgICAgICAgICAgICAgLy8gVXNlIGJpbmQsIHJhdGhlciB0aGFuIC5tb3VzZWxlYXZlLCBiZWNhdXNlIHdlIG9mZmljaWFsbHlcbiAgICAgICAgICAgICAgICAvLyBzdGlsbCBzdXBwb3J0IGpRdWVyeSAxLjIuNiwgd2hpY2ggZG9lc24ndCBkZWZpbmUgYSBzaG9ydGN1dFxuICAgICAgICAgICAgICAgIC8vIGZvciBtb3VzZWVudGVyIG9yIG1vdXNlbGVhdmUuICBUaGlzIHdhcyBhIGJ1Zy9vdmVyc2lnaHQgdGhhdFxuICAgICAgICAgICAgICAgIC8vIHdhcyBmaXhlZCBzb21ld2hlcmUgYXJvdW5kIDEuMy54LiAgV2UgY2FuIHJldHVybiB0byB1c2luZ1xuICAgICAgICAgICAgICAgIC8vIC5tb3VzZWxlYXZlIHdoZW4gd2UgZHJvcCBzdXBwb3J0IGZvciAxLjIuNi5cblxuICAgICAgICAgICAgICAgIGV2ZW50SG9sZGVyLmJpbmQoXCJtb3VzZWxlYXZlXCIsIG9uTW91c2VMZWF2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzaHV0ZG93bihwbG90LCBldmVudEhvbGRlcikge1xuICAgICAgICAgICAgZXZlbnRIb2xkZXJbMF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGFwJywgZ2VuZXJhdGVQbG90aG92ZXJFdmVudCk7XG4gICAgICAgICAgICBldmVudEhvbGRlclswXS5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGV2ZW50JywgdHJpZ2dlckNsZWFudXBFdmVudCk7XG4gICAgICAgICAgICBldmVudEhvbGRlci51bmJpbmQoXCJtb3VzZW1vdmVcIiwgb25Nb3VzZU1vdmUpO1xuICAgICAgICAgICAgZXZlbnRIb2xkZXIudW5iaW5kKFwibW91c2VsZWF2ZVwiLCBvbk1vdXNlTGVhdmUpO1xuICAgICAgICAgICAgZXZlbnRIb2xkZXIudW5iaW5kKFwiY2xpY2tcIiwgb25DbGljayk7XG4gICAgICAgICAgICBoaWdobGlnaHRzID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZW5lcmF0ZVBsb3Rob3ZlckV2ZW50KGUpIHtcbiAgICAgICAgICAgIHZhciBvID0gcGxvdC5nZXRPcHRpb25zKCksXG4gICAgICAgICAgICAgICAgbmV3RXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ21vdXNlZXZlbnQnKTtcblxuICAgICAgICAgICAgLy90cmFuc2Zvcm0gZnJvbSB0b3VjaCBldmVudCB0byBtb3VzZSBldmVudCBmb3JtYXRcbiAgICAgICAgICAgIG5ld0V2ZW50LnBhZ2VYID0gZS5kZXRhaWwuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVg7XG4gICAgICAgICAgICBuZXdFdmVudC5wYWdlWSA9IGUuZGV0YWlsLmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZO1xuICAgICAgICAgICAgbmV3RXZlbnQuY2xpZW50WCA9IGUuZGV0YWlsLmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFg7XG4gICAgICAgICAgICBuZXdFdmVudC5jbGllbnRZID0gZS5kZXRhaWwuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WTtcblxuICAgICAgICAgICAgaWYgKG8uZ3JpZC5ob3ZlcmFibGUpIHtcbiAgICAgICAgICAgICAgICBkb1RyaWdnZXJDbGlja0hvdmVyRXZlbnQobmV3RXZlbnQsIGV2ZW50VHlwZS5ob3ZlciwgMzApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZG9UcmlnZ2VyQ2xpY2tIb3ZlckV2ZW50KGV2ZW50LCBldmVudFR5cGUsIHNlYXJjaERpc3RhbmNlKSB7XG4gICAgICAgICAgICB2YXIgc2VyaWVzID0gcGxvdC5nZXREYXRhKCk7XG4gICAgICAgICAgICBpZiAoZXZlbnQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHNlcmllcy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgc2VyaWVzWzBdLnhheGlzLmMycCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgc2VyaWVzWzBdLnlheGlzLmMycCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50VG9UcmlnZ2VyID0gXCJwbG90XCIgKyBldmVudFR5cGU7XG4gICAgICAgICAgICAgICAgdmFyIHNlcmllc0ZsYWcgPSBldmVudFR5cGUgKyBcImFibGVcIjtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyQ2xpY2tIb3ZlckV2ZW50KGV2ZW50VG9UcmlnZ2VyLCBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlcmllc1tpXVtzZXJpZXNGbGFnXSAhPT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0sIHNlYXJjaERpc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG9uTW91c2VNb3ZlKGUpIHtcbiAgICAgICAgICAgIGxhc3RNb3VzZU1vdmVFdmVudCA9IGU7XG4gICAgICAgICAgICBwbG90LmdldFBsYWNlaG9sZGVyKClbMF0ubGFzdE1vdXNlTW92ZUV2ZW50ID0gZTtcbiAgICAgICAgICAgIGRvVHJpZ2dlckNsaWNrSG92ZXJFdmVudChlLCBldmVudFR5cGUuaG92ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gb25Nb3VzZUxlYXZlKGUpIHtcbiAgICAgICAgICAgIGxhc3RNb3VzZU1vdmVFdmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHBsb3QuZ2V0UGxhY2Vob2xkZXIoKVswXS5sYXN0TW91c2VNb3ZlRXZlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0cmlnZ2VyQ2xpY2tIb3ZlckV2ZW50KFwicGxvdGhvdmVyXCIsIGUsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBvbkNsaWNrKGUpIHtcbiAgICAgICAgICAgIGRvVHJpZ2dlckNsaWNrSG92ZXJFdmVudChlLCBldmVudFR5cGUuY2xpY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdHJpZ2dlckNsZWFudXBFdmVudCgpIHtcbiAgICAgICAgICAgIHBsb3QudW5oaWdobGlnaHQoKTtcbiAgICAgICAgICAgIHBsb3QuZ2V0UGxhY2Vob2xkZXIoKS50cmlnZ2VyKCdwbG90aG92ZXJjbGVhbnVwJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0cmlnZ2VyIGNsaWNrIG9yIGhvdmVyIGV2ZW50ICh0aGV5IHNlbmQgdGhlIHNhbWUgcGFyYW1ldGVyc1xuICAgICAgICAvLyBzbyB3ZSBzaGFyZSB0aGVpciBjb2RlKVxuICAgICAgICBmdW5jdGlvbiB0cmlnZ2VyQ2xpY2tIb3ZlckV2ZW50KGV2ZW50bmFtZSwgZXZlbnQsIHNlcmllc0ZpbHRlciwgc2VhcmNoRGlzdGFuY2UpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gcGxvdC5nZXRPcHRpb25zKCksXG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gcGxvdC5vZmZzZXQoKSxcbiAgICAgICAgICAgICAgICBwYWdlID0gYnJvd3Nlci5nZXRQYWdlWFkoZXZlbnQpLFxuICAgICAgICAgICAgICAgIGNhbnZhc1ggPSBwYWdlLlggLSBvZmZzZXQubGVmdCxcbiAgICAgICAgICAgICAgICBjYW52YXNZID0gcGFnZS5ZIC0gb2Zmc2V0LnRvcCxcbiAgICAgICAgICAgICAgICBwb3MgPSBwbG90LmMycCh7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IGNhbnZhc1gsXG4gICAgICAgICAgICAgICAgICAgIHRvcDogY2FudmFzWVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gc2VhcmNoRGlzdGFuY2UgIT09IHVuZGVmaW5lZCA/IHNlYXJjaERpc3RhbmNlIDogb3B0aW9ucy5ncmlkLm1vdXNlQWN0aXZlUmFkaXVzO1xuXG4gICAgICAgICAgICBwb3MucGFnZVggPSBwYWdlLlg7XG4gICAgICAgICAgICBwb3MucGFnZVkgPSBwYWdlLlk7XG5cbiAgICAgICAgICAgIHZhciBpdGVtcyA9IHBsb3QuZmluZE5lYXJieUl0ZW1zKGNhbnZhc1gsIGNhbnZhc1ksIHNlcmllc0ZpbHRlciwgZGlzdGFuY2UpO1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBpdGVtc1swXTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBpdGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmRpc3RhbmNlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgaXRlbXNbaV0uZGlzdGFuY2UgPCBpdGVtLmRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgLy8gZmlsbCBpbiBtb3VzZSBwb3MgZm9yIGFueSBsaXN0ZW5lcnMgb3V0IHRoZXJlXG4gICAgICAgICAgICAgICAgaXRlbS5wYWdlWCA9IHBhcnNlSW50KGl0ZW0uc2VyaWVzLnhheGlzLnAyYyhpdGVtLmRhdGFwb2ludFswXSkgKyBvZmZzZXQubGVmdCwgMTApO1xuICAgICAgICAgICAgICAgIGl0ZW0ucGFnZVkgPSBwYXJzZUludChpdGVtLnNlcmllcy55YXhpcy5wMmMoaXRlbS5kYXRhcG9pbnRbMV0pICsgb2Zmc2V0LnRvcCwgMTApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVtID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZ3JpZC5hdXRvSGlnaGxpZ2h0KSB7XG4gICAgICAgICAgICAgICAgLy8gY2xlYXIgYXV0by1oaWdobGlnaHRzXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoaWdobGlnaHRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoID0gaGlnaGxpZ2h0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChoLmF1dG8gPT09IGV2ZW50bmFtZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIShpdGVtICYmIGguc2VyaWVzID09PSBpdGVtLnNlcmllcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGgucG9pbnRbMF0gPT09IGl0ZW0uZGF0YXBvaW50WzBdICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaC5wb2ludFsxXSA9PT0gaXRlbS5kYXRhcG9pbnRbMV0pKSB8fCAhaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5oaWdobGlnaHQoaC5zZXJpZXMsIGgucG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0KGl0ZW0uc2VyaWVzLCBpdGVtLmRhdGFwb2ludCwgZXZlbnRuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBsb3QuZ2V0UGxhY2Vob2xkZXIoKS50cmlnZ2VyKGV2ZW50bmFtZSwgW3BvcywgaXRlbSwgaXRlbXNdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGhpZ2hsaWdodChzLCBwb2ludCwgYXV0bykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgcyA9IHBsb3QuZ2V0RGF0YSgpW3NdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHBvaW50ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBzID0gcy5kYXRhcG9pbnRzLnBvaW50c2l6ZTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IHMuZGF0YXBvaW50cy5wb2ludHMuc2xpY2UocHMgKiBwb2ludCwgcHMgKiAocG9pbnQgKyAxKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpID0gaW5kZXhPZkhpZ2hsaWdodChzLCBwb2ludCk7XG4gICAgICAgICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBoaWdobGlnaHRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IHMsXG4gICAgICAgICAgICAgICAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgICAgICAgICAgICAgICAgYXV0bzogYXV0b1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcGxvdC50cmlnZ2VyUmVkcmF3T3ZlcmxheSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghYXV0bykge1xuICAgICAgICAgICAgICAgIGhpZ2hsaWdodHNbaV0uYXV0byA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdW5oaWdobGlnaHQocywgcG9pbnQpIHtcbiAgICAgICAgICAgIGlmIChzID09IG51bGwgJiYgcG9pbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGhpZ2hsaWdodHMgPSBbXTtcbiAgICAgICAgICAgICAgICBwbG90LnRyaWdnZXJSZWRyYXdPdmVybGF5KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBzID0gcGxvdC5nZXREYXRhKClbc107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcG9pbnQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHMgPSBzLmRhdGFwb2ludHMucG9pbnRzaXplO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gcy5kYXRhcG9pbnRzLnBvaW50cy5zbGljZShwcyAqIHBvaW50LCBwcyAqIChwb2ludCArIDEpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGkgPSBpbmRleE9mSGlnaGxpZ2h0KHMsIHBvaW50KTtcbiAgICAgICAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGhpZ2hsaWdodHMuc3BsaWNlKGksIDEpO1xuXG4gICAgICAgICAgICAgICAgcGxvdC50cmlnZ2VyUmVkcmF3T3ZlcmxheSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaW5kZXhPZkhpZ2hsaWdodChzLCBwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhpZ2hsaWdodHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgaCA9IGhpZ2hsaWdodHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGguc2VyaWVzID09PSBzICYmXG4gICAgICAgICAgICAgICAgICAgIGgucG9pbnRbMF0gPT09IHBbMF0gJiZcbiAgICAgICAgICAgICAgICAgICAgaC5wb2ludFsxXSA9PT0gcFsxXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHByb2Nlc3NEYXRhcG9pbnRzKCkge1xuICAgICAgICAgICAgdHJpZ2dlckNsZWFudXBFdmVudCgpO1xuICAgICAgICAgICAgZG9UcmlnZ2VyQ2xpY2tIb3ZlckV2ZW50KGxhc3RNb3VzZU1vdmVFdmVudCwgZXZlbnRUeXBlLmhvdmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNldHVwR3JpZCgpIHtcbiAgICAgICAgICAgIGRvVHJpZ2dlckNsaWNrSG92ZXJFdmVudChsYXN0TW91c2VNb3ZlRXZlbnQsIGV2ZW50VHlwZS5ob3Zlcik7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBkcmF3T3ZlcmxheShwbG90LCBvY3R4LCBvdmVybGF5KSB7XG4gICAgICAgICAgICB2YXIgcGxvdE9mZnNldCA9IHBsb3QuZ2V0UGxvdE9mZnNldCgpLFxuICAgICAgICAgICAgICAgIGksIGhpO1xuXG4gICAgICAgICAgICBvY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIG9jdHgudHJhbnNsYXRlKHBsb3RPZmZzZXQubGVmdCwgcGxvdE9mZnNldC50b3ApO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGhpZ2hsaWdodHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBoaSA9IGhpZ2hsaWdodHNbaV07XG5cbiAgICAgICAgICAgICAgICBpZiAoaGkuc2VyaWVzLmJhcnMuc2hvdykgZHJhd0JhckhpZ2hsaWdodChoaS5zZXJpZXMsIGhpLnBvaW50LCBvY3R4KTtcbiAgICAgICAgICAgICAgICBlbHNlIGRyYXdQb2ludEhpZ2hsaWdodChoaS5zZXJpZXMsIGhpLnBvaW50LCBvY3R4LCBwbG90KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9jdHgucmVzdG9yZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZHJhd1BvaW50SGlnaGxpZ2h0KHNlcmllcywgcG9pbnQsIG9jdHgsIHBsb3QpIHtcbiAgICAgICAgICAgIHZhciB4ID0gcG9pbnRbMF0sXG4gICAgICAgICAgICAgICAgeSA9IHBvaW50WzFdLFxuICAgICAgICAgICAgICAgIGF4aXN4ID0gc2VyaWVzLnhheGlzLFxuICAgICAgICAgICAgICAgIGF4aXN5ID0gc2VyaWVzLnlheGlzLFxuICAgICAgICAgICAgICAgIGhpZ2hsaWdodENvbG9yID0gKHR5cGVvZiBzZXJpZXMuaGlnaGxpZ2h0Q29sb3IgPT09IFwic3RyaW5nXCIpID8gc2VyaWVzLmhpZ2hsaWdodENvbG9yIDogJC5jb2xvci5wYXJzZShzZXJpZXMuY29sb3IpLnNjYWxlKCdhJywgMC41KS50b1N0cmluZygpO1xuXG4gICAgICAgICAgICBpZiAoeCA8IGF4aXN4Lm1pbiB8fCB4ID4gYXhpc3gubWF4IHx8IHkgPCBheGlzeS5taW4gfHwgeSA+IGF4aXN5Lm1heCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBvaW50UmFkaXVzID0gc2VyaWVzLnBvaW50cy5yYWRpdXMgKyBzZXJpZXMucG9pbnRzLmxpbmVXaWR0aCAvIDI7XG4gICAgICAgICAgICBvY3R4LmxpbmVXaWR0aCA9IHBvaW50UmFkaXVzO1xuICAgICAgICAgICAgb2N0eC5zdHJva2VTdHlsZSA9IGhpZ2hsaWdodENvbG9yO1xuICAgICAgICAgICAgdmFyIHJhZGl1cyA9IDEuNSAqIHBvaW50UmFkaXVzO1xuICAgICAgICAgICAgeCA9IGF4aXN4LnAyYyh4KTtcbiAgICAgICAgICAgIHkgPSBheGlzeS5wMmMoeSk7XG5cbiAgICAgICAgICAgIG9jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICB2YXIgc3ltYm9sID0gc2VyaWVzLnBvaW50cy5zeW1ib2w7XG4gICAgICAgICAgICBpZiAoc3ltYm9sID09PSAnY2lyY2xlJykge1xuICAgICAgICAgICAgICAgIG9jdHguYXJjKHgsIHksIHJhZGl1cywgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHN5bWJvbCA9PT0gJ3N0cmluZycgJiYgcGxvdC5kcmF3U3ltYm9sICYmIHBsb3QuZHJhd1N5bWJvbFtzeW1ib2xdKSB7XG4gICAgICAgICAgICAgICAgcGxvdC5kcmF3U3ltYm9sW3N5bWJvbF0ob2N0eCwgeCwgeSwgcmFkaXVzLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9jdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBvY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZHJhd0JhckhpZ2hsaWdodChzZXJpZXMsIHBvaW50LCBvY3R4KSB7XG4gICAgICAgICAgICB2YXIgaGlnaGxpZ2h0Q29sb3IgPSAodHlwZW9mIHNlcmllcy5oaWdobGlnaHRDb2xvciA9PT0gXCJzdHJpbmdcIikgPyBzZXJpZXMuaGlnaGxpZ2h0Q29sb3IgOiAkLmNvbG9yLnBhcnNlKHNlcmllcy5jb2xvcikuc2NhbGUoJ2EnLCAwLjUpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgZmlsbFN0eWxlID0gaGlnaGxpZ2h0Q29sb3IsXG4gICAgICAgICAgICAgICAgYmFyTGVmdDtcblxuICAgICAgICAgICAgdmFyIGJhcldpZHRoID0gc2VyaWVzLmJhcnMuYmFyV2lkdGhbMF0gfHwgc2VyaWVzLmJhcnMuYmFyV2lkdGg7XG4gICAgICAgICAgICBzd2l0Y2ggKHNlcmllcy5iYXJzLmFsaWduKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgICAgICAgICAgICAgYmFyTGVmdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICAgICAgICAgICAgICBiYXJMZWZ0ID0gLWJhcldpZHRoO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBiYXJMZWZ0ID0gLWJhcldpZHRoIC8gMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2N0eC5saW5lV2lkdGggPSBzZXJpZXMuYmFycy5saW5lV2lkdGg7XG4gICAgICAgICAgICBvY3R4LnN0cm9rZVN0eWxlID0gaGlnaGxpZ2h0Q29sb3I7XG5cbiAgICAgICAgICAgIHZhciBmaWxsVG93YXJkcyA9IHNlcmllcy5iYXJzLmZpbGxUb3dhcmRzIHx8IDAsXG4gICAgICAgICAgICAgICAgYm90dG9tID0gZmlsbFRvd2FyZHMgPiBzZXJpZXMueWF4aXMubWluID8gTWF0aC5taW4oc2VyaWVzLnlheGlzLm1heCwgZmlsbFRvd2FyZHMpIDogc2VyaWVzLnlheGlzLm1pbjtcblxuICAgICAgICAgICAgJC5wbG90LmRyYXdTZXJpZXMuZHJhd0Jhcihwb2ludFswXSwgcG9pbnRbMV0sIHBvaW50WzJdIHx8IGJvdHRvbSwgYmFyTGVmdCwgYmFyTGVmdCArIGJhcldpZHRoLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlsbFN0eWxlO1xuICAgICAgICAgICAgICAgIH0sIHNlcmllcy54YXhpcywgc2VyaWVzLnlheGlzLCBvY3R4LCBzZXJpZXMuYmFycy5ob3Jpem9udGFsLCBzZXJpZXMuYmFycy5saW5lV2lkdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaW5pdEhvdmVyKHBsb3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHBsb3QuaGlnaGxpZ2h0ID0gaGlnaGxpZ2h0O1xuICAgICAgICAgICAgcGxvdC51bmhpZ2hsaWdodCA9IHVuaGlnaGxpZ2h0O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZ3JpZC5ob3ZlcmFibGUgfHwgb3B0aW9ucy5ncmlkLmNsaWNrYWJsZSkge1xuICAgICAgICAgICAgICAgIHBsb3QuaG9va3MuZHJhd092ZXJsYXkucHVzaChkcmF3T3ZlcmxheSk7XG4gICAgICAgICAgICAgICAgcGxvdC5ob29rcy5wcm9jZXNzRGF0YXBvaW50cy5wdXNoKHByb2Nlc3NEYXRhcG9pbnRzKTtcbiAgICAgICAgICAgICAgICBwbG90Lmhvb2tzLnNldHVwR3JpZC5wdXNoKHNldHVwR3JpZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxhc3RNb3VzZU1vdmVFdmVudCA9IHBsb3QuZ2V0UGxhY2Vob2xkZXIoKVswXS5sYXN0TW91c2VNb3ZlRXZlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBwbG90Lmhvb2tzLmJpbmRFdmVudHMucHVzaChiaW5kRXZlbnRzKTtcbiAgICAgICAgcGxvdC5ob29rcy5zaHV0ZG93bi5wdXNoKHNodXRkb3duKTtcbiAgICAgICAgcGxvdC5ob29rcy5wcm9jZXNzT3B0aW9ucy5wdXNoKGluaXRIb3Zlcik7XG4gICAgfVxuXG4gICAgJC5wbG90LnBsdWdpbnMucHVzaCh7XG4gICAgICAgIGluaXQ6IGluaXQsXG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgIG5hbWU6ICdob3ZlcicsXG4gICAgICAgIHZlcnNpb246ICcwLjEnXG4gICAgfSk7XG59KShqUXVlcnkpO1xuIiwiLyogRmxvdCBwbHVnaW4gZm9yIHBsb3R0aW5nIGltYWdlcy5cblxuQ29weXJpZ2h0IChjKSAyMDA3LTIwMTQgSU9MQSBhbmQgT2xlIExhdXJzZW4uXG5MaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cblRoZSBkYXRhIHN5bnRheCBpcyBbIFsgaW1hZ2UsIHgxLCB5MSwgeDIsIHkyIF0sIC4uLiBdIHdoZXJlICh4MSwgeTEpIGFuZFxuKHgyLCB5MikgYXJlIHdoZXJlIHlvdSBpbnRlbmQgdGhlIHR3byBvcHBvc2l0ZSBjb3JuZXJzIG9mIHRoZSBpbWFnZSB0byBlbmQgdXBcbmluIHRoZSBwbG90LiBJbWFnZSBtdXN0IGJlIGEgZnVsbHkgbG9hZGVkIEphdmFzY3JpcHQgaW1hZ2UgKHlvdSBjYW4gbWFrZSBvbmVcbndpdGggbmV3IEltYWdlKCkpLiBJZiB0aGUgaW1hZ2UgaXMgbm90IGNvbXBsZXRlLCBpdCdzIHNraXBwZWQgd2hlbiBwbG90dGluZy5cblxuVGhlcmUgYXJlIHR3byBoZWxwZXJzIGluY2x1ZGVkIGZvciByZXRyaWV2aW5nIGltYWdlcy4gVGhlIGVhc2llc3Qgd29yayB0aGUgd2F5XG50aGF0IHlvdSBwdXQgaW4gVVJMcyBpbnN0ZWFkIG9mIGltYWdlcyBpbiB0aGUgZGF0YSwgbGlrZSB0aGlzOlxuXG4gICAgWyBcIm15aW1hZ2UucG5nXCIsIDAsIDAsIDEwLCAxMCBdXG5cblRoZW4gY2FsbCAkLnBsb3QuaW1hZ2UubG9hZERhdGEoIGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrICkgd2hlcmUgZGF0YSBhbmRcbm9wdGlvbnMgYXJlIHRoZSBzYW1lIGFzIHlvdSBwYXNzIGluIHRvICQucGxvdC4gVGhpcyBsb2FkcyB0aGUgaW1hZ2VzLCByZXBsYWNlc1xudGhlIFVSTHMgaW4gdGhlIGRhdGEgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBpbWFnZXMgYW5kIGNhbGxzIFwiY2FsbGJhY2tcIiB3aGVuXG5hbGwgaW1hZ2VzIGFyZSBsb2FkZWQgKG9yIGZhaWxlZCBsb2FkaW5nKS4gSW4gdGhlIGNhbGxiYWNrLCB5b3UgY2FuIHRoZW4gY2FsbFxuJC5wbG90IHdpdGggdGhlIGRhdGEgc2V0LiBTZWUgdGhlIGluY2x1ZGVkIGV4YW1wbGUuXG5cbkEgbW9yZSBsb3ctbGV2ZWwgaGVscGVyLCAkLnBsb3QuaW1hZ2UubG9hZCh1cmxzLCBjYWxsYmFjaykgaXMgYWxzbyBpbmNsdWRlZC5cbkdpdmVuIGEgbGlzdCBvZiBVUkxzLCBpdCBjYWxscyBjYWxsYmFjayB3aXRoIGFuIG9iamVjdCBtYXBwaW5nIGZyb20gVVJMIHRvXG5JbWFnZSBvYmplY3Qgd2hlbiBhbGwgaW1hZ2VzIGFyZSBsb2FkZWQgb3IgaGF2ZSBmYWlsZWQgbG9hZGluZy5cblxuVGhlIHBsdWdpbiBzdXBwb3J0cyB0aGVzZSBvcHRpb25zOlxuXG4gICAgc2VyaWVzOiB7XG4gICAgICAgIGltYWdlczoge1xuICAgICAgICAgICAgc2hvdzogYm9vbGVhblxuICAgICAgICAgICAgYW5jaG9yOiBcImNvcm5lclwiIG9yIFwiY2VudGVyXCJcbiAgICAgICAgICAgIGFscGhhOiBbIDAsIDEgXVxuICAgICAgICB9XG4gICAgfVxuXG5UaGV5IGNhbiBiZSBzcGVjaWZpZWQgZm9yIGEgc3BlY2lmaWMgc2VyaWVzOlxuXG4gICAgJC5wbG90KCAkKFwiI3BsYWNlaG9sZGVyXCIpLCBbe1xuICAgICAgICBkYXRhOiBbIC4uLiBdLFxuICAgICAgICBpbWFnZXM6IHsgLi4uIH1cbiAgICBdKVxuXG5Ob3RlIHRoYXQgYmVjYXVzZSB0aGUgZGF0YSBmb3JtYXQgaXMgZGlmZmVyZW50IGZyb20gdXN1YWwgZGF0YSBwb2ludHMsIHlvdVxuY2FuJ3QgdXNlIGltYWdlcyB3aXRoIGFueXRoaW5nIGVsc2UgaW4gYSBzcGVjaWZpYyBkYXRhIHNlcmllcy5cblxuU2V0dGluZyBcImFuY2hvclwiIHRvIFwiY2VudGVyXCIgY2F1c2VzIHRoZSBwaXhlbHMgaW4gdGhlIGltYWdlIHRvIGJlIGFuY2hvcmVkIGF0XG50aGUgY29ybmVyIHBpeGVsIGNlbnRlcnMgaW5zaWRlIG9mIGF0IHRoZSBwaXhlbCBjb3JuZXJzLCBlZmZlY3RpdmVseSBsZXR0aW5nXG5oYWxmIGEgcGl4ZWwgc3RpY2sgb3V0IHRvIGVhY2ggc2lkZSBpbiB0aGUgcGxvdC5cblxuQSBwb3NzaWJsZSBmdXR1cmUgZGlyZWN0aW9uIGNvdWxkIGJlIHN1cHBvcnQgZm9yIHRpbGluZyBmb3IgbGFyZ2UgaW1hZ2VzIChsaWtlXG5Hb29nbGUgTWFwcykuXG5cbiovXG5cbihmdW5jdGlvbiAoJCkge1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBzZXJpZXM6IHtcbiAgICAgICAgICAgIGltYWdlczoge1xuICAgICAgICAgICAgICAgIHNob3c6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFscGhhOiAxLFxuICAgICAgICAgICAgICAgIGFuY2hvcjogXCJjb3JuZXJcIiAvLyBvciBcImNlbnRlclwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgJC5wbG90LmltYWdlID0ge307XG5cbiAgICAkLnBsb3QuaW1hZ2UubG9hZERhdGFJbWFnZXMgPSBmdW5jdGlvbiAoc2VyaWVzLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgdXJscyA9IFtdLCBwb2ludHMgPSBbXTtcblxuICAgICAgICB2YXIgZGVmYXVsdFNob3cgPSBvcHRpb25zLnNlcmllcy5pbWFnZXMuc2hvdztcblxuICAgICAgICAkLmVhY2goc2VyaWVzLCBmdW5jdGlvbiAoaSwgcykge1xuICAgICAgICAgICAgaWYgKCEoZGVmYXVsdFNob3cgfHwgcy5pbWFnZXMuc2hvdykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzLmRhdGEpIHtcbiAgICAgICAgICAgICAgICBzID0gcy5kYXRhO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAkLmVhY2gocywgZnVuY3Rpb24gKGksIHApIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBbMF0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdXJscy5wdXNoKHBbMF0pO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgJC5wbG90LmltYWdlLmxvYWQodXJscywgZnVuY3Rpb24gKGxvYWRlZEltYWdlcykge1xuICAgICAgICAgICAgJC5lYWNoKHBvaW50cywgZnVuY3Rpb24gKGksIHApIHtcbiAgICAgICAgICAgICAgICB2YXIgdXJsID0gcFswXTtcbiAgICAgICAgICAgICAgICBpZiAobG9hZGVkSW1hZ2VzW3VybF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcFswXSA9IGxvYWRlZEltYWdlc1t1cmxdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAkLnBsb3QuaW1hZ2UubG9hZCA9IGZ1bmN0aW9uICh1cmxzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgbWlzc2luZyA9IHVybHMubGVuZ3RoLCBsb2FkZWQgPSB7fTtcbiAgICAgICAgaWYgKG1pc3NpbmcgPT09IDApIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHt9KTtcbiAgICAgICAgfVxuXG4gICAgICAgICQuZWFjaCh1cmxzLCBmdW5jdGlvbiAoaSwgdXJsKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAtLW1pc3Npbmc7XG4gICAgICAgICAgICAgICAgbG9hZGVkW3VybF0gPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1pc3NpbmcgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobG9hZGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAkKCc8aW1nIC8+JykubG9hZChoYW5kbGVyKS5lcnJvcihoYW5kbGVyKS5hdHRyKCdzcmMnLCB1cmwpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZHJhd1NlcmllcyhwbG90LCBjdHgsIHNlcmllcykge1xuICAgICAgICB2YXIgcGxvdE9mZnNldCA9IHBsb3QuZ2V0UGxvdE9mZnNldCgpO1xuXG4gICAgICAgIGlmICghc2VyaWVzLmltYWdlcyB8fCAhc2VyaWVzLmltYWdlcy5zaG93KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcG9pbnRzID0gc2VyaWVzLmRhdGFwb2ludHMucG9pbnRzLFxuICAgICAgICAgICAgcHMgPSBzZXJpZXMuZGF0YXBvaW50cy5wb2ludHNpemU7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpICs9IHBzKSB7XG4gICAgICAgICAgICB2YXIgaW1nID0gcG9pbnRzW2ldLFxuICAgICAgICAgICAgICAgIHgxID0gcG9pbnRzW2kgKyAxXSwgeTEgPSBwb2ludHNbaSArIDJdLFxuICAgICAgICAgICAgICAgIHgyID0gcG9pbnRzW2kgKyAzXSwgeTIgPSBwb2ludHNbaSArIDRdLFxuICAgICAgICAgICAgICAgIHhheGlzID0gc2VyaWVzLnhheGlzLCB5YXhpcyA9IHNlcmllcy55YXhpcyxcbiAgICAgICAgICAgICAgICB0bXA7XG5cbiAgICAgICAgICAgIC8vIGFjdHVhbGx5IHdlIHNob3VsZCBjaGVjayBpbWcuY29tcGxldGUsIGJ1dCBpdFxuICAgICAgICAgICAgLy8gYXBwZWFycyB0byBiZSBhIHNvbWV3aGF0IHVucmVsaWFibGUgaW5kaWNhdG9yIGluXG4gICAgICAgICAgICAvLyBJRTYgKGZhbHNlIGV2ZW4gYWZ0ZXIgbG9hZCBldmVudClcbiAgICAgICAgICAgIGlmICghaW1nIHx8IGltZy53aWR0aCA8PSAwIHx8IGltZy5oZWlnaHQgPD0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoeDEgPiB4Mikge1xuICAgICAgICAgICAgICAgIHRtcCA9IHgyO1xuICAgICAgICAgICAgICAgIHgyID0geDE7XG4gICAgICAgICAgICAgICAgeDEgPSB0bXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeTEgPiB5Mikge1xuICAgICAgICAgICAgICAgIHRtcCA9IHkyO1xuICAgICAgICAgICAgICAgIHkyID0geTE7XG4gICAgICAgICAgICAgICAgeTEgPSB0bXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSBhbmNob3IgaXMgYXQgdGhlIGNlbnRlciBvZiB0aGUgcGl4ZWwsIGV4cGFuZCB0aGVcbiAgICAgICAgICAgIC8vIGltYWdlIGJ5IDEvMiBwaXhlbCBpbiBlYWNoIGRpcmVjdGlvblxuICAgICAgICAgICAgaWYgKHNlcmllcy5pbWFnZXMuYW5jaG9yID09PSBcImNlbnRlclwiKSB7XG4gICAgICAgICAgICAgICAgdG1wID0gMC41ICogKHgyIC0geDEpIC8gKGltZy53aWR0aCAtIDEpO1xuICAgICAgICAgICAgICAgIHgxIC09IHRtcDtcbiAgICAgICAgICAgICAgICB4MiArPSB0bXA7XG4gICAgICAgICAgICAgICAgdG1wID0gMC41ICogKHkyIC0geTEpIC8gKGltZy5oZWlnaHQgLSAxKTtcbiAgICAgICAgICAgICAgICB5MSAtPSB0bXA7XG4gICAgICAgICAgICAgICAgeTIgKz0gdG1wO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjbGlwXG4gICAgICAgICAgICBpZiAoeDEgPT09IHgyIHx8IHkxID09PSB5MiB8fFxuICAgICAgICAgICAgICAgIHgxID49IHhheGlzLm1heCB8fCB4MiA8PSB4YXhpcy5taW4gfHxcbiAgICAgICAgICAgICAgICB5MSA+PSB5YXhpcy5tYXggfHwgeTIgPD0geWF4aXMubWluKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzeDEgPSAwLCBzeTEgPSAwLCBzeDIgPSBpbWcud2lkdGgsIHN5MiA9IGltZy5oZWlnaHQ7XG4gICAgICAgICAgICBpZiAoeDEgPCB4YXhpcy5taW4pIHtcbiAgICAgICAgICAgICAgICBzeDEgKz0gKHN4MiAtIHN4MSkgKiAoeGF4aXMubWluIC0geDEpIC8gKHgyIC0geDEpO1xuICAgICAgICAgICAgICAgIHgxID0geGF4aXMubWluO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoeDIgPiB4YXhpcy5tYXgpIHtcbiAgICAgICAgICAgICAgICBzeDIgKz0gKHN4MiAtIHN4MSkgKiAoeGF4aXMubWF4IC0geDIpIC8gKHgyIC0geDEpO1xuICAgICAgICAgICAgICAgIHgyID0geGF4aXMubWF4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoeTEgPCB5YXhpcy5taW4pIHtcbiAgICAgICAgICAgICAgICBzeTIgKz0gKHN5MSAtIHN5MikgKiAoeWF4aXMubWluIC0geTEpIC8gKHkyIC0geTEpO1xuICAgICAgICAgICAgICAgIHkxID0geWF4aXMubWluO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoeTIgPiB5YXhpcy5tYXgpIHtcbiAgICAgICAgICAgICAgICBzeTEgKz0gKHN5MSAtIHN5MikgKiAoeWF4aXMubWF4IC0geTIpIC8gKHkyIC0geTEpO1xuICAgICAgICAgICAgICAgIHkyID0geWF4aXMubWF4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB4MSA9IHhheGlzLnAyYyh4MSk7XG4gICAgICAgICAgICB4MiA9IHhheGlzLnAyYyh4Mik7XG4gICAgICAgICAgICB5MSA9IHlheGlzLnAyYyh5MSk7XG4gICAgICAgICAgICB5MiA9IHlheGlzLnAyYyh5Mik7XG5cbiAgICAgICAgICAgIC8vIHRoZSB0cmFuc2Zvcm1hdGlvbiBtYXkgaGF2ZSBzd2FwcGVkIHVzXG4gICAgICAgICAgICBpZiAoeDEgPiB4Mikge1xuICAgICAgICAgICAgICAgIHRtcCA9IHgyO1xuICAgICAgICAgICAgICAgIHgyID0geDE7XG4gICAgICAgICAgICAgICAgeDEgPSB0bXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeTEgPiB5Mikge1xuICAgICAgICAgICAgICAgIHRtcCA9IHkyO1xuICAgICAgICAgICAgICAgIHkyID0geTE7XG4gICAgICAgICAgICAgICAgeTEgPSB0bXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRtcCA9IGN0eC5nbG9iYWxBbHBoYTtcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSAqPSBzZXJpZXMuaW1hZ2VzLmFscGhhO1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN4MSwgc3kxLCBzeDIgLSBzeDEsIHN5MiAtIHN5MSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgeDEgKyBwbG90T2Zmc2V0LmxlZnQsIHkxICsgcGxvdE9mZnNldC50b3AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHgyIC0geDEsIHkyIC0geTEpO1xuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdG1wO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1Jhd0RhdGEocGxvdCwgc2VyaWVzLCBkYXRhLCBkYXRhcG9pbnRzKSB7XG4gICAgICAgIGlmICghc2VyaWVzLmltYWdlcy5zaG93KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmb3JtYXQgaXMgSW1hZ2UsIHgxLCB5MSwgeDIsIHkyIChvcHBvc2l0ZSBjb3JuZXJzKVxuICAgICAgICBkYXRhcG9pbnRzLmZvcm1hdCA9IFtcbiAgICAgICAgICAgIHsgcmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgeDogdHJ1ZSwgbnVtYmVyOiB0cnVlLCByZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyB5OiB0cnVlLCBudW1iZXI6IHRydWUsIHJlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHg6IHRydWUsIG51bWJlcjogdHJ1ZSwgcmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgeTogdHJ1ZSwgbnVtYmVyOiB0cnVlLCByZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5pdChwbG90KSB7XG4gICAgICAgIHBsb3QuaG9va3MucHJvY2Vzc1Jhd0RhdGEucHVzaChwcm9jZXNzUmF3RGF0YSk7XG4gICAgICAgIHBsb3QuaG9va3MuZHJhd1Nlcmllcy5wdXNoKGRyYXdTZXJpZXMpO1xuICAgIH1cblxuICAgICQucGxvdC5wbHVnaW5zLnB1c2goe1xuICAgICAgICBpbml0OiBpbml0LFxuICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICBuYW1lOiAnaW1hZ2UnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4xJ1xuICAgIH0pO1xufSkoalF1ZXJ5KTtcbiIsIi8qIEphdmFzY3JpcHQgcGxvdHRpbmcgbGlicmFyeSBmb3IgalF1ZXJ5LCB2ZXJzaW9uIDMuMC4wLlxuXG5Db3B5cmlnaHQgKGMpIDIwMDctMjAxNCBJT0xBIGFuZCBPbGUgTGF1cnNlbi5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuKi9cblxuLy8gdGhlIGFjdHVhbCBGbG90IGNvZGVcbihmdW5jdGlvbigkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgQ2FudmFzID0gd2luZG93LkZsb3QuQ2FudmFzO1xuXG4gICAgZnVuY3Rpb24gZGVmYXVsdFRpY2tHZW5lcmF0b3IoYXhpcykge1xuICAgICAgICB2YXIgdGlja3MgPSBbXSxcbiAgICAgICAgICAgIHN0YXJ0ID0gJC5wbG90LnNhdHVyYXRlZC5zYXR1cmF0ZSgkLnBsb3Quc2F0dXJhdGVkLmZsb29ySW5CYXNlKGF4aXMubWluLCBheGlzLnRpY2tTaXplKSksXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIHYgPSBOdW1iZXIuTmFOLFxuICAgICAgICAgICAgcHJldjtcblxuICAgICAgICBpZiAoc3RhcnQgPT09IC1OdW1iZXIuTUFYX1ZBTFVFKSB7XG4gICAgICAgICAgICB0aWNrcy5wdXNoKHN0YXJ0KTtcbiAgICAgICAgICAgIHN0YXJ0ID0gJC5wbG90LnNhdHVyYXRlZC5mbG9vckluQmFzZShheGlzLm1pbiArIGF4aXMudGlja1NpemUsIGF4aXMudGlja1NpemUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgcHJldiA9IHY7XG4gICAgICAgICAgICAvL3YgPSBzdGFydCArIGkgKiBheGlzLnRpY2tTaXplO1xuICAgICAgICAgICAgdiA9ICQucGxvdC5zYXR1cmF0ZWQubXVsdGlwbHlBZGQoYXhpcy50aWNrU2l6ZSwgaSwgc3RhcnQpO1xuICAgICAgICAgICAgdGlja3MucHVzaCh2KTtcbiAgICAgICAgICAgICsraTtcbiAgICAgICAgfSB3aGlsZSAodiA8IGF4aXMubWF4ICYmIHYgIT09IHByZXYpO1xuXG4gICAgICAgIHJldHVybiB0aWNrcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZhdWx0VGlja0Zvcm1hdHRlcih2YWx1ZSwgYXhpcywgcHJlY2lzaW9uKSB7XG4gICAgICAgIHZhciBvbGRUaWNrRGVjaW1hbHMgPSBheGlzLnRpY2tEZWNpbWFscyxcbiAgICAgICAgICAgIGV4cFBvc2l0aW9uID0gKFwiXCIgKyB2YWx1ZSkuaW5kZXhPZihcImVcIik7XG5cbiAgICAgICAgaWYgKGV4cFBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGV4cFJlcFRpY2tGb3JtYXR0ZXIodmFsdWUsIGF4aXMsIHByZWNpc2lvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJlY2lzaW9uID4gMCkge1xuICAgICAgICAgICAgYXhpcy50aWNrRGVjaW1hbHMgPSBwcmVjaXNpb247XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmFjdG9yID0gYXhpcy50aWNrRGVjaW1hbHMgPyBwYXJzZUZsb2F0KCcxZScgKyBheGlzLnRpY2tEZWNpbWFscykgOiAxLFxuICAgICAgICAgICAgZm9ybWF0dGVkID0gXCJcIiArIE1hdGgucm91bmQodmFsdWUgKiBmYWN0b3IpIC8gZmFjdG9yO1xuXG4gICAgICAgIC8vIElmIHRpY2tEZWNpbWFscyB3YXMgc3BlY2lmaWVkLCBlbnN1cmUgdGhhdCB3ZSBoYXZlIGV4YWN0bHkgdGhhdFxuICAgICAgICAvLyBtdWNoIHByZWNpc2lvbjsgb3RoZXJ3aXNlIGRlZmF1bHQgdG8gdGhlIHZhbHVlJ3Mgb3duIHByZWNpc2lvbi5cbiAgICAgICAgaWYgKGF4aXMudGlja0RlY2ltYWxzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBkZWNpbWFsID0gZm9ybWF0dGVkLmluZGV4T2YoXCIuXCIpLFxuICAgICAgICAgICAgICAgIGRlY2ltYWxQcmVjaXNpb24gPSBkZWNpbWFsID09PSAtMSA/IDAgOiBmb3JtYXR0ZWQubGVuZ3RoIC0gZGVjaW1hbCAtIDE7XG4gICAgICAgICAgICBpZiAoZGVjaW1hbFByZWNpc2lvbiA8IGF4aXMudGlja0RlY2ltYWxzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlY2ltYWxzID0gKFwiXCIgKyBmYWN0b3IpLnN1YnN0cigxLCBheGlzLnRpY2tEZWNpbWFscyAtIGRlY2ltYWxQcmVjaXNpb24pO1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlZCA9IChkZWNpbWFsUHJlY2lzaW9uID8gZm9ybWF0dGVkIDogZm9ybWF0dGVkICsgXCIuXCIpICsgZGVjaW1hbHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBheGlzLnRpY2tEZWNpbWFscyA9IG9sZFRpY2tEZWNpbWFscztcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlZDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZXhwUmVwVGlja0Zvcm1hdHRlcih2YWx1ZSwgYXhpcywgcHJlY2lzaW9uKSB7XG4gICAgICAgIHZhciBleHBQb3NpdGlvbiA9IChcIlwiICsgdmFsdWUpLmluZGV4T2YoXCJlXCIpLFxuICAgICAgICAgICAgZXhwb25lbnRWYWx1ZSA9IHBhcnNlSW50KChcIlwiICsgdmFsdWUpLnN1YnN0cihleHBQb3NpdGlvbiArIDEpKSxcbiAgICAgICAgICAgIHRlbkV4cG9uZW50ID0gZXhwUG9zaXRpb24gIT09IC0xID8gZXhwb25lbnRWYWx1ZSA6ICh2YWx1ZSA+IDAgPyBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4xMCkgOiAwKSxcbiAgICAgICAgICAgIHJvdW5kV2l0aCA9IHBhcnNlRmxvYXQoJzFlJyArIHRlbkV4cG9uZW50KSxcbiAgICAgICAgICAgIHggPSB2YWx1ZSAvIHJvdW5kV2l0aDtcblxuICAgICAgICBpZiAocHJlY2lzaW9uKSB7XG4gICAgICAgICAgICB2YXIgdXBkYXRlZFByZWNpc2lvbiA9IHJlY29tcHV0ZVByZWNpc2lvbih2YWx1ZSwgcHJlY2lzaW9uKTtcbiAgICAgICAgICAgIHJldHVybiAodmFsdWUgLyByb3VuZFdpdGgpLnRvRml4ZWQodXBkYXRlZFByZWNpc2lvbikgKyAnZScgKyB0ZW5FeHBvbmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChheGlzLnRpY2tEZWNpbWFscyA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB4LnRvRml4ZWQocmVjb21wdXRlUHJlY2lzaW9uKHZhbHVlLCBheGlzLnRpY2tEZWNpbWFscykpICsgJ2UnICsgdGVuRXhwb25lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHgudG9GaXhlZCgpICsgJ2UnICsgdGVuRXhwb25lbnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVjb21wdXRlUHJlY2lzaW9uKG51bSwgcHJlY2lzaW9uKSB7XG4gICAgICAgIC8vZm9yIG51bWJlcnMgY2xvc2UgdG8gemVybywgdGhlIHByZWNpc2lvbiBmcm9tIGZsb3Qgd2lsbCBiZSBhIGJpZyBudW1iZXJcbiAgICAgICAgLy93aGlsZSBmb3IgYmlnIG51bWJlcnMsIHRoZSBwcmVjaXNpb24gd2lsbCBiZSBuZWdhdGl2ZVxuICAgICAgICB2YXIgbG9nMTBWYWx1ZSA9IE1hdGgubG9nKE1hdGguYWJzKG51bSkpICogTWF0aC5MT0cxMEUsXG4gICAgICAgICAgICBuZXdQcmVjaXNpb24gPSBNYXRoLmFicyhsb2cxMFZhbHVlICsgcHJlY2lzaW9uKTtcblxuICAgICAgICByZXR1cm4gbmV3UHJlY2lzaW9uIDw9IDIwID8gTWF0aC5mbG9vcihuZXdQcmVjaXNpb24pIDogMjA7XG4gICAgfVxuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gVGhlIHRvcC1sZXZlbCBjb250YWluZXIgZm9yIHRoZSBlbnRpcmUgcGxvdC5cbiAgICBmdW5jdGlvbiBQbG90KHBsYWNlaG9sZGVyLCBkYXRhXywgb3B0aW9uc18sIHBsdWdpbnMpIHtcbiAgICAgICAgLy8gZGF0YSBpcyBvbiB0aGUgZm9ybTpcbiAgICAgICAgLy8gICBbIHNlcmllczEsIHNlcmllczIgLi4uIF1cbiAgICAgICAgLy8gd2hlcmUgc2VyaWVzIGlzIGVpdGhlciBqdXN0IHRoZSBkYXRhIGFzIFsgW3gxLCB5MV0sIFt4MiwgeTJdLCAuLi4gXVxuICAgICAgICAvLyBvciB7IGRhdGE6IFsgW3gxLCB5MV0sIFt4MiwgeTJdLCAuLi4gXSwgbGFiZWw6IFwic29tZSBsYWJlbFwiLCAuLi4gfVxuXG4gICAgICAgIHZhciBzZXJpZXMgPSBbXSxcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIGNvbG9yIHRoZW1lIHVzZWQgZm9yIGdyYXBoc1xuICAgICAgICAgICAgICAgIGNvbG9yczogW1wiI2VkYzI0MFwiLCBcIiNhZmQ4ZjhcIiwgXCIjY2I0YjRiXCIsIFwiIzRkYTc0ZFwiLCBcIiM5NDQwZWRcIl0sXG4gICAgICAgICAgICAgICAgeGF4aXM6IHtcbiAgICAgICAgICAgICAgICAgICAgc2hvdzogbnVsbCwgLy8gbnVsbCA9IGF1dG8tZGV0ZWN0LCB0cnVlID0gYWx3YXlzLCBmYWxzZSA9IG5ldmVyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcImJvdHRvbVwiLCAvLyBvciBcInRvcFwiXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IG51bGwsIC8vIG51bGwgb3IgXCJ0aW1lXCJcbiAgICAgICAgICAgICAgICAgICAgZm9udDogbnVsbCwgLy8gbnVsbCAoZGVyaXZlZCBmcm9tIENTUyBpbiBwbGFjZWhvbGRlcikgb3Igb2JqZWN0IGxpa2UgeyBzaXplOiAxMSwgbGluZUhlaWdodDogMTMsIHN0eWxlOiBcIml0YWxpY1wiLCB3ZWlnaHQ6IFwiYm9sZFwiLCBmYW1pbHk6IFwic2Fucy1zZXJpZlwiLCB2YXJpYW50OiBcInNtYWxsLWNhcHNcIiB9XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBudWxsLCAvLyBiYXNlIGNvbG9yLCBsYWJlbHMsIHRpY2tzXG4gICAgICAgICAgICAgICAgICAgIHRpY2tDb2xvcjogbnVsbCwgLy8gcG9zc2libHkgZGlmZmVyZW50IGNvbG9yIG9mIHRpY2tzLCBlLmcuIFwicmdiYSgwLDAsMCwwLjE1KVwiXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogbnVsbCwgLy8gbnVsbCBvciBmOiBudW1iZXIgLT4gbnVtYmVyIHRvIHRyYW5zZm9ybSBheGlzXG4gICAgICAgICAgICAgICAgICAgIGludmVyc2VUcmFuc2Zvcm06IG51bGwsIC8vIGlmIHRyYW5zZm9ybSBpcyBzZXQsIHRoaXMgc2hvdWxkIGJlIHRoZSBpbnZlcnNlIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgIG1pbjogbnVsbCwgLy8gbWluLiB2YWx1ZSB0byBzaG93LCBudWxsIG1lYW5zIHNldCBhdXRvbWF0aWNhbGx5XG4gICAgICAgICAgICAgICAgICAgIG1heDogbnVsbCwgLy8gbWF4LiB2YWx1ZSB0byBzaG93LCBudWxsIG1lYW5zIHNldCBhdXRvbWF0aWNhbGx5XG4gICAgICAgICAgICAgICAgICAgIGF1dG9TY2FsZU1hcmdpbjogbnVsbCwgLy8gbWFyZ2luIGluICUgdG8gYWRkIGlmIGF1dG9TY2FsZSBvcHRpb24gaXMgb24gXCJsb29zZVwiIG1vZGUsXG4gICAgICAgICAgICAgICAgICAgIGF1dG9TY2FsZTogXCJleGFjdFwiLCAvLyBBdmFpbGFibGUgbW9kZXM6IFwibm9uZVwiLCBcImxvb3NlXCIsIFwiZXhhY3RcIiwgXCJzbGlkaW5nLXdpbmRvd1wiXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd1NpemU6IG51bGwsIC8vIG51bGwgb3IgbnVtYmVyLiBUaGlzIGlzIHRoZSBzaXplIG9mIHNsaWRpbmctd2luZG93LlxuICAgICAgICAgICAgICAgICAgICBncm93T25seTogbnVsbCwgLy8gZ3JvdyBvbmx5LCB1c2VmdWwgZm9yIHNtb290aGVyIGF1dG8tc2NhbGUsIHRoZSBzY2FsZXMgd2lsbCBncm93IHRvIGFjY29tb2RhdGUgZGF0YSBidXQgd29uJ3Qgc2hyaW5rIGJhY2suXG4gICAgICAgICAgICAgICAgICAgIHRpY2tzOiBudWxsLCAvLyBlaXRoZXIgWzEsIDNdIG9yIFtbMSwgXCJhXCJdLCAzXSBvciAoZm46IGF4aXMgaW5mbyAtPiB0aWNrcykgb3IgYXBwLiBudW1iZXIgb2YgdGlja3MgZm9yIGF1dG8tdGlja3NcbiAgICAgICAgICAgICAgICAgICAgdGlja0Zvcm1hdHRlcjogbnVsbCwgLy8gZm46IG51bWJlciAtPiBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgc2hvd1RpY2tMYWJlbHM6IFwibWFqb3JcIiwgLy8gXCJub25lXCIsIFwiZW5kcG9pbnRzXCIsIFwibWFqb3JcIiwgXCJhbGxcIlxuICAgICAgICAgICAgICAgICAgICBsYWJlbFdpZHRoOiBudWxsLCAvLyBzaXplIG9mIHRpY2sgbGFiZWxzIGluIHBpeGVsc1xuICAgICAgICAgICAgICAgICAgICBsYWJlbEhlaWdodDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcmVzZXJ2ZVNwYWNlOiBudWxsLCAvLyB3aGV0aGVyIHRvIHJlc2VydmUgc3BhY2UgZXZlbiBpZiBheGlzIGlzbid0IHNob3duXG4gICAgICAgICAgICAgICAgICAgIHRpY2tMZW5ndGg6IG51bGwsIC8vIHNpemUgaW4gcGl4ZWxzIG9mIG1ham9yIHRpY2sgbWFya3NcbiAgICAgICAgICAgICAgICAgICAgc2hvd01pbm9yVGlja3M6IG51bGwsIC8vIHRydWUgPSBzaG93IG1pbm9yIHRpY2sgbWFya3MsIGZhbHNlID0gaGlkZSBtaW5vciB0aWNrIG1hcmtzXG4gICAgICAgICAgICAgICAgICAgIHNob3dUaWNrczogbnVsbCwgLy8gdHJ1ZSA9IHNob3cgdGljayBtYXJrcywgZmFsc2UgPSBoaWRlIGFsbCB0aWNrIG1hcmtzXG4gICAgICAgICAgICAgICAgICAgIGdyaWRMaW5lczogbnVsbCwgLy8gdHJ1ZSA9IHNob3cgZ3JpZCBsaW5lcywgZmFsc2UgPSBoaWRlIGdyaWQgbGluZXNcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25UaWNrc1dpdGhBeGlzOiBudWxsLCAvLyBheGlzIG51bWJlciBvciBudWxsIGZvciBubyBzeW5jXG4gICAgICAgICAgICAgICAgICAgIHRpY2tEZWNpbWFsczogbnVsbCwgLy8gbm8uIG9mIGRlY2ltYWxzLCBudWxsIG1lYW5zIGF1dG9cbiAgICAgICAgICAgICAgICAgICAgdGlja1NpemU6IG51bGwsIC8vIG51bWJlciBvciBbbnVtYmVyLCBcInVuaXRcIl1cbiAgICAgICAgICAgICAgICAgICAgbWluVGlja1NpemU6IG51bGwsIC8vIG51bWJlciBvciBbbnVtYmVyLCBcInVuaXRcIl1cbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB7IGJlbG93OiAwLCBhYm92ZTogMCB9LCAvLyB0aGUgcGxvdCBkcmF3aW5nIG9mZnNldC4gdGhpcyBpcyBjYWxjdWxhdGVkIGJ5IHRoZSBmbG90Lm5hdmlnYXRlIGZvciBlYWNoIGF4aXNcbiAgICAgICAgICAgICAgICAgICAgYm94UG9zaXRpb246IHsgY2VudGVyWDogMCwgY2VudGVyWTogMCB9IC8vcG9zaXRpb24gb2YgdGhlIGF4aXMgb24gdGhlIGNvcnJlc3BvbmRpbmcgYXhpcyBib3hcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHlheGlzOiB7XG4gICAgICAgICAgICAgICAgICAgIGF1dG9TY2FsZU1hcmdpbjogMC4wMiwgLy8gbWFyZ2luIGluICUgdG8gYWRkIGlmIGF1dG9TY2FsZSBvcHRpb24gaXMgb24gXCJsb29zZVwiIG1vZGVcbiAgICAgICAgICAgICAgICAgICAgYXV0b1NjYWxlOiBcImxvb3NlXCIsIC8vIEF2YWlsYWJsZSBtb2RlczogXCJub25lXCIsIFwibG9vc2VcIiwgXCJleGFjdFwiXG4gICAgICAgICAgICAgICAgICAgIGdyb3dPbmx5OiBudWxsLCAvLyBncm93IG9ubHksIHVzZWZ1bCBmb3Igc21vb3RoZXIgYXV0by1zY2FsZSwgdGhlIHNjYWxlcyB3aWxsIGdyb3cgdG8gYWNjb21vZGF0ZSBkYXRhIGJ1dCB3b24ndCBzaHJpbmsgYmFjay5cbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFwibGVmdFwiLCAvLyBvciBcInJpZ2h0XCJcbiAgICAgICAgICAgICAgICAgICAgc2hvd1RpY2tMYWJlbHM6IFwibWFqb3JcIiwgLy8gXCJub25lXCIsIFwiZW5kcG9pbnRzXCIsIFwibWFqb3JcIiwgXCJhbGxcIlxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHsgYmVsb3c6IDAsIGFib3ZlOiAwIH0sIC8vIHRoZSBwbG90IGRyYXdpbmcgb2Zmc2V0LiB0aGlzIGlzIGNhbGN1bGF0ZWQgYnkgdGhlIGZsb3QubmF2aWdhdGUgZm9yIGVhY2ggYXhpc1xuICAgICAgICAgICAgICAgICAgICBib3hQb3NpdGlvbjogeyBjZW50ZXJYOiAwLCBjZW50ZXJZOiAwIH0gLy9wb3NpdGlvbiBvZiB0aGUgYXhpcyBvbiB0aGUgY29ycmVzcG9uZGluZyBheGlzIGJveFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgeGF4ZXM6IFtdLFxuICAgICAgICAgICAgICAgIHlheGVzOiBbXSxcbiAgICAgICAgICAgICAgICBzZXJpZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhZGl1czogMyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogMiwgLy8gaW4gcGl4ZWxzXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbENvbG9yOiBcIiNmZmZmZmZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbDogJ2NpcmNsZScgLy8gb3IgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbGluZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IHB1dCBpbiBzaG93OiBmYWxzZSBzbyB3ZSBjYW4gc2VlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGV0aGVyIGxpbmVzIHdlcmUgYWN0aXZlbHkgZGlzYWJsZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogMSwgLy8gaW4gcGl4ZWxzXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXBzOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT21pdCAnemVybycsIHNvIHdlIGNhbiBsYXRlciBkZWZhdWx0IGl0cyB2YWx1ZSB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2ggdGhhdCBvZiB0aGUgJ2ZpbGwnIG9wdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYmFyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IDIsIC8vIGluIHBpeGVsc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmFyV2lkdGg6IG51bWJlciBvciBbbnVtYmVyLCBhYnNvbHV0ZV1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gJ2Fic29sdXRlJyBpcyBmYWxzZSwgJ251bWJlcicgaXMgcmVsYXRpdmUgdG8gdGhlIG1pbmltdW0gZGlzdGFuY2UgYmV0d2VlbiBwb2ludHMgZm9yIHRoZSBzZXJpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gJ2Fic29sdXRlJyBpcyB0cnVlLCAnbnVtYmVyJyBpcyBjb25zaWRlcmVkIHRvIGJlIGluIHVuaXRzIG9mIHRoZSB4LWF4aXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvcml6b250YWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmFyV2lkdGg6IDAuOCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsQ29sb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbjogXCJsZWZ0XCIsIC8vIFwibGVmdFwiLCBcInJpZ2h0XCIsIG9yIFwiY2VudGVyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHplcm86IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2hhZG93U2l6ZTogMyxcbiAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0Q29sb3I6IG51bGxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYWJvdmVEYXRhOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IFwiIzU0NTQ1NFwiLCAvLyBwcmltYXJ5IGNvbG9yIHVzZWQgZm9yIG91dGxpbmUgYW5kIGxhYmVsc1xuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IG51bGwsIC8vIG51bGwgZm9yIHRyYW5zcGFyZW50LCBlbHNlIGNvbG9yXG4gICAgICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBudWxsLCAvLyBzZXQgaWYgZGlmZmVyZW50IGZyb20gdGhlIGdyaWQgY29sb3JcbiAgICAgICAgICAgICAgICAgICAgdGlja0NvbG9yOiBudWxsLCAvLyBjb2xvciBmb3IgdGhlIHRpY2tzLCBlLmcuIFwicmdiYSgwLDAsMCwwLjE1KVwiXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbjogMCwgLy8gZGlzdGFuY2UgZnJvbSB0aGUgY2FudmFzIGVkZ2UgdG8gdGhlIGdyaWRcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxNYXJnaW46IDUsIC8vIGluIHBpeGVsc1xuICAgICAgICAgICAgICAgICAgICBheGlzTWFyZ2luOiA4LCAvLyBpbiBwaXhlbHNcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDEsIC8vIGluIHBpeGVsc1xuICAgICAgICAgICAgICAgICAgICBtaW5Cb3JkZXJNYXJnaW46IG51bGwsIC8vIGluIHBpeGVscywgbnVsbCBtZWFucyB0YWtlbiBmcm9tIHBvaW50cyByYWRpdXNcbiAgICAgICAgICAgICAgICAgICAgbWFya2luZ3M6IG51bGwsIC8vIGFycmF5IG9mIHJhbmdlcyBvciBmbjogYXhlcyAtPiBhcnJheSBvZiByYW5nZXNcbiAgICAgICAgICAgICAgICAgICAgbWFya2luZ3NDb2xvcjogXCIjZjRmNGY0XCIsXG4gICAgICAgICAgICAgICAgICAgIG1hcmtpbmdzTGluZVdpZHRoOiAyLFxuICAgICAgICAgICAgICAgICAgICAvLyBpbnRlcmFjdGl2ZSBzdHVmZlxuICAgICAgICAgICAgICAgICAgICBjbGlja2FibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBob3ZlcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBhdXRvSGlnaGxpZ2h0OiB0cnVlLCAvLyBoaWdobGlnaHQgaW4gY2FzZSBtb3VzZSBpcyBuZWFyXG4gICAgICAgICAgICAgICAgICAgIG1vdXNlQWN0aXZlUmFkaXVzOiAxNSAvLyBob3cgZmFyIHRoZSBtb3VzZSBjYW4gYmUgYXdheSB0byBhY3RpdmF0ZSBhbiBpdGVtXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICByZWRyYXdPdmVybGF5SW50ZXJ2YWw6IDEwMDAgLyA2MCAvLyB0aW1lIGJldHdlZW4gdXBkYXRlcywgLTEgbWVhbnMgaW4gc2FtZSBmbG93XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBob29rczoge31cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdXJmYWNlID0gbnVsbCwgLy8gdGhlIGNhbnZhcyBmb3IgdGhlIHBsb3QgaXRzZWxmXG4gICAgICAgICAgICBvdmVybGF5ID0gbnVsbCwgLy8gY2FudmFzIGZvciBpbnRlcmFjdGl2ZSBzdHVmZiBvbiB0b3Agb2YgcGxvdFxuICAgICAgICAgICAgZXZlbnRIb2xkZXIgPSBudWxsLCAvLyBqUXVlcnkgb2JqZWN0IHRoYXQgZXZlbnRzIHNob3VsZCBiZSBib3VuZCB0b1xuICAgICAgICAgICAgY3R4ID0gbnVsbCxcbiAgICAgICAgICAgIG9jdHggPSBudWxsLFxuICAgICAgICAgICAgeGF4ZXMgPSBbXSxcbiAgICAgICAgICAgIHlheGVzID0gW10sXG4gICAgICAgICAgICBwbG90T2Zmc2V0ID0ge1xuICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgIGJvdHRvbTogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBsb3RXaWR0aCA9IDAsXG4gICAgICAgICAgICBwbG90SGVpZ2h0ID0gMCxcbiAgICAgICAgICAgIGhvb2tzID0ge1xuICAgICAgICAgICAgICAgIHByb2Nlc3NPcHRpb25zOiBbXSxcbiAgICAgICAgICAgICAgICBwcm9jZXNzUmF3RGF0YTogW10sXG4gICAgICAgICAgICAgICAgcHJvY2Vzc0RhdGFwb2ludHM6IFtdLFxuICAgICAgICAgICAgICAgIHByb2Nlc3NPZmZzZXQ6IFtdLFxuICAgICAgICAgICAgICAgIHNldHVwR3JpZDogW10sXG4gICAgICAgICAgICAgICAgYWRqdXN0U2VyaWVzRGF0YVJhbmdlOiBbXSxcbiAgICAgICAgICAgICAgICBzZXRSYW5nZTogW10sXG4gICAgICAgICAgICAgICAgZHJhd0JhY2tncm91bmQ6IFtdLFxuICAgICAgICAgICAgICAgIGRyYXdTZXJpZXM6IFtdLFxuICAgICAgICAgICAgICAgIGRyYXdBeGlzOiBbXSxcbiAgICAgICAgICAgICAgICBkcmF3OiBbXSxcbiAgICAgICAgICAgICAgICBmaW5kTmVhcmJ5SXRlbXM6IFtdLFxuICAgICAgICAgICAgICAgIGF4aXNSZXNlcnZlU3BhY2U6IFtdLFxuICAgICAgICAgICAgICAgIGJpbmRFdmVudHM6IFtdLFxuICAgICAgICAgICAgICAgIGRyYXdPdmVybGF5OiBbXSxcbiAgICAgICAgICAgICAgICByZXNpemU6IFtdLFxuICAgICAgICAgICAgICAgIHNodXRkb3duOiBbXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBsb3QgPSB0aGlzO1xuXG4gICAgICAgIHZhciBldmVudE1hbmFnZXIgPSB7fTtcblxuICAgICAgICAvLyBpbnRlcmFjdGl2ZSBmZWF0dXJlc1xuXG4gICAgICAgIHZhciByZWRyYXdUaW1lb3V0ID0gbnVsbDtcblxuICAgICAgICAvLyBwdWJsaWMgZnVuY3Rpb25zXG4gICAgICAgIHBsb3Quc2V0RGF0YSA9IHNldERhdGE7XG4gICAgICAgIHBsb3Quc2V0dXBHcmlkID0gc2V0dXBHcmlkO1xuICAgICAgICBwbG90LmRyYXcgPSBkcmF3O1xuICAgICAgICBwbG90LmdldFBsYWNlaG9sZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXI7XG4gICAgICAgIH07XG4gICAgICAgIHBsb3QuZ2V0Q2FudmFzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VyZmFjZS5lbGVtZW50O1xuICAgICAgICB9O1xuICAgICAgICBwbG90LmdldFN1cmZhY2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBzdXJmYWNlO1xuICAgICAgICB9O1xuICAgICAgICBwbG90LmdldEV2ZW50SG9sZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRIb2xkZXJbMF07XG4gICAgICAgIH07XG4gICAgICAgIHBsb3QuZ2V0UGxvdE9mZnNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHBsb3RPZmZzZXQ7XG4gICAgICAgIH07XG4gICAgICAgIHBsb3Qud2lkdGggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBwbG90V2lkdGg7XG4gICAgICAgIH07XG4gICAgICAgIHBsb3QuaGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gcGxvdEhlaWdodDtcbiAgICAgICAgfTtcbiAgICAgICAgcGxvdC5vZmZzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBvID0gZXZlbnRIb2xkZXIub2Zmc2V0KCk7XG4gICAgICAgICAgICBvLmxlZnQgKz0gcGxvdE9mZnNldC5sZWZ0O1xuICAgICAgICAgICAgby50b3AgKz0gcGxvdE9mZnNldC50b3A7XG4gICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgfTtcbiAgICAgICAgcGxvdC5nZXREYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VyaWVzO1xuICAgICAgICB9O1xuICAgICAgICBwbG90LmdldEF4ZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciByZXMgPSB7fTtcbiAgICAgICAgICAgICQuZWFjaCh4YXhlcy5jb25jYXQoeWF4ZXMpLCBmdW5jdGlvbihfLCBheGlzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF4aXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW2F4aXMuZGlyZWN0aW9uICsgKGF4aXMubiAhPT0gMSA/IGF4aXMubiA6IFwiXCIpICsgXCJheGlzXCJdID0gYXhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgICAgIHBsb3QuZ2V0WEF4ZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB4YXhlcztcbiAgICAgICAgfTtcbiAgICAgICAgcGxvdC5nZXRZQXhlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHlheGVzO1xuICAgICAgICB9O1xuICAgICAgICBwbG90LmMycCA9IGNhbnZhc1RvQ2FydGVzaWFuQXhpc0Nvb3JkcztcbiAgICAgICAgcGxvdC5wMmMgPSBjYXJ0ZXNpYW5BeGlzVG9DYW52YXNDb29yZHM7XG4gICAgICAgIHBsb3QuZ2V0T3B0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICAgIH07XG4gICAgICAgIHBsb3QudHJpZ2dlclJlZHJhd092ZXJsYXkgPSB0cmlnZ2VyUmVkcmF3T3ZlcmxheTtcbiAgICAgICAgcGxvdC5wb2ludE9mZnNldCA9IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGxlZnQ6IHBhcnNlSW50KHhheGVzW2F4aXNOdW1iZXIocG9pbnQsIFwieFwiKSAtIDFdLnAyYygrcG9pbnQueCkgKyBwbG90T2Zmc2V0LmxlZnQsIDEwKSxcbiAgICAgICAgICAgICAgICB0b3A6IHBhcnNlSW50KHlheGVzW2F4aXNOdW1iZXIocG9pbnQsIFwieVwiKSAtIDFdLnAyYygrcG9pbnQueSkgKyBwbG90T2Zmc2V0LnRvcCwgMTApXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBwbG90LnNodXRkb3duID0gc2h1dGRvd247XG4gICAgICAgIHBsb3QuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2h1dGRvd24oKTtcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyLnJlbW92ZURhdGEoXCJwbG90XCIpLmVtcHR5KCk7XG5cbiAgICAgICAgICAgIHNlcmllcyA9IFtdO1xuICAgICAgICAgICAgb3B0aW9ucyA9IG51bGw7XG4gICAgICAgICAgICBzdXJmYWNlID0gbnVsbDtcbiAgICAgICAgICAgIG92ZXJsYXkgPSBudWxsO1xuICAgICAgICAgICAgZXZlbnRIb2xkZXIgPSBudWxsO1xuICAgICAgICAgICAgY3R4ID0gbnVsbDtcbiAgICAgICAgICAgIG9jdHggPSBudWxsO1xuICAgICAgICAgICAgeGF4ZXMgPSBbXTtcbiAgICAgICAgICAgIHlheGVzID0gW107XG4gICAgICAgICAgICBob29rcyA9IG51bGw7XG4gICAgICAgICAgICBwbG90ID0gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICBwbG90LnJlc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gcGxhY2Vob2xkZXIud2lkdGgoKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBwbGFjZWhvbGRlci5oZWlnaHQoKTtcbiAgICAgICAgICAgIHN1cmZhY2UucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgb3ZlcmxheS5yZXNpemUod2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgICAgIGV4ZWN1dGVIb29rcyhob29rcy5yZXNpemUsIFt3aWR0aCwgaGVpZ2h0XSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcGxvdC5jbGVhclRleHRDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHN1cmZhY2UuY2xlYXJDYWNoZSgpO1xuICAgICAgICAgICAgb3ZlcmxheS5jbGVhckNhY2hlKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcGxvdC5hdXRvU2NhbGVBeGlzID0gYXV0b1NjYWxlQXhpcztcbiAgICAgICAgcGxvdC5jb21wdXRlUmFuZ2VGb3JEYXRhU2VyaWVzID0gY29tcHV0ZVJhbmdlRm9yRGF0YVNlcmllcztcbiAgICAgICAgcGxvdC5hZGp1c3RTZXJpZXNEYXRhUmFuZ2UgPSBhZGp1c3RTZXJpZXNEYXRhUmFuZ2U7XG4gICAgICAgIHBsb3QuZmluZE5lYXJieUl0ZW0gPSBmaW5kTmVhcmJ5SXRlbTtcbiAgICAgICAgcGxvdC5maW5kTmVhcmJ5SXRlbXMgPSBmaW5kTmVhcmJ5SXRlbXM7XG4gICAgICAgIHBsb3QuZmluZE5lYXJieUludGVycG9sYXRpb25Qb2ludCA9IGZpbmROZWFyYnlJbnRlcnBvbGF0aW9uUG9pbnQ7XG4gICAgICAgIHBsb3QuY29tcHV0ZVZhbHVlUHJlY2lzaW9uID0gY29tcHV0ZVZhbHVlUHJlY2lzaW9uO1xuICAgICAgICBwbG90LmNvbXB1dGVUaWNrU2l6ZSA9IGNvbXB1dGVUaWNrU2l6ZTtcbiAgICAgICAgcGxvdC5hZGRFdmVudEhhbmRsZXIgPSBhZGRFdmVudEhhbmRsZXI7XG5cbiAgICAgICAgLy8gcHVibGljIGF0dHJpYnV0ZXNcbiAgICAgICAgcGxvdC5ob29rcyA9IGhvb2tzO1xuXG4gICAgICAgIC8vIGluaXRpYWxpemVcbiAgICAgICAgdmFyIE1JTk9SX1RJQ0tTX0NPVU5UX0NPTlNUQU5UID0gJC5wbG90LnVpQ29uc3RhbnRzLk1JTk9SX1RJQ0tTX0NPVU5UX0NPTlNUQU5UO1xuICAgICAgICB2YXIgVElDS19MRU5HVEhfQ09OU1RBTlQgPSAkLnBsb3QudWlDb25zdGFudHMuVElDS19MRU5HVEhfQ09OU1RBTlQ7XG4gICAgICAgIGluaXRQbHVnaW5zKHBsb3QpO1xuICAgICAgICBzZXR1cENhbnZhc2VzKCk7XG4gICAgICAgIHBhcnNlT3B0aW9ucyhvcHRpb25zXyk7XG4gICAgICAgIHNldERhdGEoZGF0YV8pO1xuICAgICAgICBzZXR1cEdyaWQodHJ1ZSk7XG4gICAgICAgIGRyYXcoKTtcbiAgICAgICAgYmluZEV2ZW50cygpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGV4ZWN1dGVIb29rcyhob29rLCBhcmdzKSB7XG4gICAgICAgICAgICBhcmdzID0gW3Bsb3RdLmNvbmNhdChhcmdzKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9vay5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGhvb2tbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpbml0UGx1Z2lucygpIHtcbiAgICAgICAgICAgIC8vIFJlZmVyZW5jZXMgdG8ga2V5IGNsYXNzZXMsIGFsbG93aW5nIHBsdWdpbnMgdG8gbW9kaWZ5IHRoZW1cblxuICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSB7XG4gICAgICAgICAgICAgICAgQ2FudmFzOiBDYW52YXNcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBwID0gcGx1Z2luc1tpXTtcbiAgICAgICAgICAgICAgICBwLmluaXQocGxvdCwgY2xhc3Nlcyk7XG4gICAgICAgICAgICAgICAgaWYgKHAub3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAkLmV4dGVuZCh0cnVlLCBvcHRpb25zLCBwLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlT3B0aW9ucyhvcHRzKSB7XG4gICAgICAgICAgICAkLmV4dGVuZCh0cnVlLCBvcHRpb25zLCBvcHRzKTtcblxuICAgICAgICAgICAgLy8gJC5leHRlbmQgbWVyZ2VzIGFycmF5cywgcmF0aGVyIHRoYW4gcmVwbGFjaW5nIHRoZW0uICBXaGVuIGxlc3NcbiAgICAgICAgICAgIC8vIGNvbG9ycyBhcmUgcHJvdmlkZWQgdGhhbiB0aGUgc2l6ZSBvZiB0aGUgZGVmYXVsdCBwYWxldHRlLCB3ZVxuICAgICAgICAgICAgLy8gZW5kIHVwIHdpdGggdGhvc2UgY29sb3JzIHBsdXMgdGhlIHJlbWFpbmluZyBkZWZhdWx0cywgd2hpY2ggaXNcbiAgICAgICAgICAgIC8vIG5vdCBleHBlY3RlZCBiZWhhdmlvcjsgYXZvaWQgaXQgYnkgcmVwbGFjaW5nIHRoZW0gaGVyZS5cblxuICAgICAgICAgICAgaWYgKG9wdHMgJiYgb3B0cy5jb2xvcnMpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNvbG9ycyA9IG9wdHMuY29sb3JzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy54YXhpcy5jb2xvciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy54YXhpcy5jb2xvciA9ICQuY29sb3IucGFyc2Uob3B0aW9ucy5ncmlkLmNvbG9yKS5zY2FsZSgnYScsIDAuMjIpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnlheGlzLmNvbG9yID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnlheGlzLmNvbG9yID0gJC5jb2xvci5wYXJzZShvcHRpb25zLmdyaWQuY29sb3IpLnNjYWxlKCdhJywgMC4yMikudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMueGF4aXMudGlja0NvbG9yID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBncmlkLnRpY2tDb2xvciBmb3IgYmFjay1jb21wYXRpYmlsaXR5XG4gICAgICAgICAgICAgICAgb3B0aW9ucy54YXhpcy50aWNrQ29sb3IgPSBvcHRpb25zLmdyaWQudGlja0NvbG9yIHx8IG9wdGlvbnMueGF4aXMuY29sb3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnlheGlzLnRpY2tDb2xvciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gZ3JpZC50aWNrQ29sb3IgZm9yIGJhY2stY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgICAgIG9wdGlvbnMueWF4aXMudGlja0NvbG9yID0gb3B0aW9ucy5ncmlkLnRpY2tDb2xvciB8fCBvcHRpb25zLnlheGlzLmNvbG9yO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5ncmlkLmJvcmRlckNvbG9yID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmdyaWQuYm9yZGVyQ29sb3IgPSBvcHRpb25zLmdyaWQuY29sb3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmdyaWQudGlja0NvbG9yID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmdyaWQudGlja0NvbG9yID0gJC5jb2xvci5wYXJzZShvcHRpb25zLmdyaWQuY29sb3IpLnNjYWxlKCdhJywgMC4yMikudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRmlsbCBpbiBkZWZhdWx0cyBmb3IgYXhpcyBvcHRpb25zLCBpbmNsdWRpbmcgYW55IHVuc3BlY2lmaWVkXG4gICAgICAgICAgICAvLyBmb250LXNwZWMgZmllbGRzLCBpZiBhIGZvbnQtc3BlYyB3YXMgcHJvdmlkZWQuXG5cbiAgICAgICAgICAgIC8vIElmIG5vIHgveSBheGlzIG9wdGlvbnMgd2VyZSBwcm92aWRlZCwgY3JlYXRlIG9uZSBvZiBlYWNoIGFueXdheSxcbiAgICAgICAgICAgIC8vIHNpbmNlIHRoZSByZXN0IG9mIHRoZSBjb2RlIGFzc3VtZXMgdGhhdCB0aGV5IGV4aXN0LlxuXG4gICAgICAgICAgICB2YXIgaSwgYXhpc09wdGlvbnMsIGF4aXNDb3VudCxcbiAgICAgICAgICAgICAgICBmb250U2l6ZSA9IHBsYWNlaG9sZGVyLmNzcyhcImZvbnQtc2l6ZVwiKSxcbiAgICAgICAgICAgICAgICBmb250U2l6ZURlZmF1bHQgPSBmb250U2l6ZSA/ICtmb250U2l6ZS5yZXBsYWNlKFwicHhcIiwgXCJcIikgOiAxMyxcbiAgICAgICAgICAgICAgICBmb250RGVmYXVsdHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBwbGFjZWhvbGRlci5jc3MoXCJmb250LXN0eWxlXCIpLFxuICAgICAgICAgICAgICAgICAgICBzaXplOiBNYXRoLnJvdW5kKDAuOCAqIGZvbnRTaXplRGVmYXVsdCksXG4gICAgICAgICAgICAgICAgICAgIHZhcmlhbnQ6IHBsYWNlaG9sZGVyLmNzcyhcImZvbnQtdmFyaWFudFwiKSxcbiAgICAgICAgICAgICAgICAgICAgd2VpZ2h0OiBwbGFjZWhvbGRlci5jc3MoXCJmb250LXdlaWdodFwiKSxcbiAgICAgICAgICAgICAgICAgICAgZmFtaWx5OiBwbGFjZWhvbGRlci5jc3MoXCJmb250LWZhbWlseVwiKVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGF4aXNDb3VudCA9IG9wdGlvbnMueGF4ZXMubGVuZ3RoIHx8IDE7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXhpc0NvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgICBheGlzT3B0aW9ucyA9IG9wdGlvbnMueGF4ZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGF4aXNPcHRpb25zICYmICFheGlzT3B0aW9ucy50aWNrQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgYXhpc09wdGlvbnMudGlja0NvbG9yID0gYXhpc09wdGlvbnMuY29sb3I7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYXhpc09wdGlvbnMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgb3B0aW9ucy54YXhpcywgYXhpc09wdGlvbnMpO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMueGF4ZXNbaV0gPSBheGlzT3B0aW9ucztcblxuICAgICAgICAgICAgICAgIGlmIChheGlzT3B0aW9ucy5mb250KSB7XG4gICAgICAgICAgICAgICAgICAgIGF4aXNPcHRpb25zLmZvbnQgPSAkLmV4dGVuZCh7fSwgZm9udERlZmF1bHRzLCBheGlzT3B0aW9ucy5mb250KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFheGlzT3B0aW9ucy5mb250LmNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzT3B0aW9ucy5mb250LmNvbG9yID0gYXhpc09wdGlvbnMuY29sb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFheGlzT3B0aW9ucy5mb250LmxpbmVIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNPcHRpb25zLmZvbnQubGluZUhlaWdodCA9IE1hdGgucm91bmQoYXhpc09wdGlvbnMuZm9udC5zaXplICogMS4xNSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGF4aXNDb3VudCA9IG9wdGlvbnMueWF4ZXMubGVuZ3RoIHx8IDE7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXhpc0NvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgICBheGlzT3B0aW9ucyA9IG9wdGlvbnMueWF4ZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGF4aXNPcHRpb25zICYmICFheGlzT3B0aW9ucy50aWNrQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgYXhpc09wdGlvbnMudGlja0NvbG9yID0gYXhpc09wdGlvbnMuY29sb3I7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYXhpc09wdGlvbnMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgb3B0aW9ucy55YXhpcywgYXhpc09wdGlvbnMpO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMueWF4ZXNbaV0gPSBheGlzT3B0aW9ucztcblxuICAgICAgICAgICAgICAgIGlmIChheGlzT3B0aW9ucy5mb250KSB7XG4gICAgICAgICAgICAgICAgICAgIGF4aXNPcHRpb25zLmZvbnQgPSAkLmV4dGVuZCh7fSwgZm9udERlZmF1bHRzLCBheGlzT3B0aW9ucy5mb250KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFheGlzT3B0aW9ucy5mb250LmNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzT3B0aW9ucy5mb250LmNvbG9yID0gYXhpc09wdGlvbnMuY29sb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFheGlzT3B0aW9ucy5mb250LmxpbmVIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNPcHRpb25zLmZvbnQubGluZUhlaWdodCA9IE1hdGgucm91bmQoYXhpc09wdGlvbnMuZm9udC5zaXplICogMS4xNSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNhdmUgb3B0aW9ucyBvbiBheGVzIGZvciBmdXR1cmUgcmVmZXJlbmNlXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb3B0aW9ucy54YXhlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGdldE9yQ3JlYXRlQXhpcyh4YXhlcywgaSArIDEpLm9wdGlvbnMgPSBvcHRpb25zLnhheGVzW2ldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb3B0aW9ucy55YXhlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGdldE9yQ3JlYXRlQXhpcyh5YXhlcywgaSArIDEpLm9wdGlvbnMgPSBvcHRpb25zLnlheGVzW2ldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL3Byb2Nlc3MgYm94UG9zaXRpb24gb3B0aW9ucyB1c2VkIGZvciBheGlzLmJveCBzaXplXG4gICAgICAgICAgICAkLmVhY2goYWxsQXhlcygpLCBmdW5jdGlvbihfLCBheGlzKSB7XG4gICAgICAgICAgICAgICAgYXhpcy5ib3hQb3NpdGlvbiA9IGF4aXMub3B0aW9ucy5ib3hQb3NpdGlvbiB8fCB7Y2VudGVyWDogMCwgY2VudGVyWTogMH07XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gYWRkIGhvb2tzIGZyb20gb3B0aW9uc1xuICAgICAgICAgICAgZm9yICh2YXIgbiBpbiBob29rcykge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmhvb2tzW25dICYmIG9wdGlvbnMuaG9va3Nbbl0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvb2tzW25dID0gaG9va3Nbbl0uY29uY2F0KG9wdGlvbnMuaG9va3Nbbl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhlY3V0ZUhvb2tzKGhvb2tzLnByb2Nlc3NPcHRpb25zLCBbb3B0aW9uc10pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc2V0RGF0YShkKSB7XG4gICAgICAgICAgICB2YXIgb2xkc2VyaWVzID0gc2VyaWVzO1xuICAgICAgICAgICAgc2VyaWVzID0gcGFyc2VEYXRhKGQpO1xuICAgICAgICAgICAgZmlsbEluU2VyaWVzT3B0aW9ucygpO1xuICAgICAgICAgICAgcHJvY2Vzc0RhdGEob2xkc2VyaWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlRGF0YShkKSB7XG4gICAgICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgcyA9ICQuZXh0ZW5kKHRydWUsIHt9LCBvcHRpb25zLnNlcmllcyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZFtpXS5kYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcy5kYXRhID0gZFtpXS5kYXRhOyAvLyBtb3ZlIHRoZSBkYXRhIGluc3RlYWQgb2YgZGVlcC1jb3B5XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBkW2ldLmRhdGE7XG5cbiAgICAgICAgICAgICAgICAgICAgJC5leHRlbmQodHJ1ZSwgcywgZFtpXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZFtpXS5kYXRhID0gcy5kYXRhO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHMuZGF0YSA9IGRbaV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzLnB1c2gocyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBheGlzTnVtYmVyKG9iaiwgY29vcmQpIHtcbiAgICAgICAgICAgIHZhciBhID0gb2JqW2Nvb3JkICsgXCJheGlzXCJdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgZ290IGEgcmVhbCBheGlzLCBleHRyYWN0IG51bWJlclxuICAgICAgICAgICAgICAgIGEgPSBhLm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgYSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGEgPSAxOyAvLyBkZWZhdWx0IHRvIGZpcnN0IGF4aXNcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhbGxBeGVzKCkge1xuICAgICAgICAgICAgLy8gcmV0dXJuIGZsYXQgYXJyYXkgd2l0aG91dCBhbm5veWluZyBudWxsIGVudHJpZXNcbiAgICAgICAgICAgIHJldHVybiB4YXhlcy5jb25jYXQoeWF4ZXMpLmZpbHRlcihmdW5jdGlvbihhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNhbnZhcyB0byBheGlzIGZvciBjYXJ0ZXNpYW4gYXhlc1xuICAgICAgICBmdW5jdGlvbiBjYW52YXNUb0NhcnRlc2lhbkF4aXNDb29yZHMocG9zKSB7XG4gICAgICAgICAgICAvLyByZXR1cm4gYW4gb2JqZWN0IHdpdGggeC95IGNvcnJlc3BvbmRpbmcgdG8gYWxsIHVzZWQgYXhlc1xuICAgICAgICAgICAgdmFyIHJlcyA9IHt9LFxuICAgICAgICAgICAgICAgIGksIGF4aXM7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgeGF4ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBheGlzID0geGF4ZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGF4aXMgJiYgYXhpcy51c2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1tcInhcIiArIGF4aXMubl0gPSBheGlzLmMycChwb3MubGVmdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgeWF4ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBheGlzID0geWF4ZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGF4aXMgJiYgYXhpcy51c2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1tcInlcIiArIGF4aXMubl0gPSBheGlzLmMycChwb3MudG9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZXMueDEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlcy54ID0gcmVzLngxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVzLnkxICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXMueSA9IHJlcy55MTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGF4aXMgdG8gY2FudmFzIGZvciBjYXJ0ZXNpYW4gYXhlc1xuICAgICAgICBmdW5jdGlvbiBjYXJ0ZXNpYW5BeGlzVG9DYW52YXNDb29yZHMocG9zKSB7XG4gICAgICAgICAgICAvLyBnZXQgY2FudmFzIGNvb3JkcyBmcm9tIHRoZSBmaXJzdCBwYWlyIG9mIHgveSBmb3VuZCBpbiBwb3NcbiAgICAgICAgICAgIHZhciByZXMgPSB7fSxcbiAgICAgICAgICAgICAgICBpLCBheGlzLCBrZXk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB4YXhlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGF4aXMgPSB4YXhlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoYXhpcyAmJiBheGlzLnVzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gXCJ4XCIgKyBheGlzLm47XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3Nba2V5XSA9PSBudWxsICYmIGF4aXMubiA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gXCJ4XCI7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAocG9zW2tleV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLmxlZnQgPSBheGlzLnAyYyhwb3Nba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHlheGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgYXhpcyA9IHlheGVzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChheGlzICYmIGF4aXMudXNlZCkge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBcInlcIiArIGF4aXMubjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc1trZXldID09IG51bGwgJiYgYXhpcy5uID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBcInlcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3Nba2V5XSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMudG9wID0gYXhpcy5wMmMocG9zW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRPckNyZWF0ZUF4aXMoYXhlcywgbnVtYmVyKSB7XG4gICAgICAgICAgICBpZiAoIWF4ZXNbbnVtYmVyIC0gMV0pIHtcbiAgICAgICAgICAgICAgICBheGVzW251bWJlciAtIDFdID0ge1xuICAgICAgICAgICAgICAgICAgICBuOiBudW1iZXIsIC8vIHNhdmUgdGhlIG51bWJlciBmb3IgZnV0dXJlIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246IGF4ZXMgPT09IHhheGVzID8gXCJ4XCIgOiBcInlcIixcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogJC5leHRlbmQodHJ1ZSwge30sIGF4ZXMgPT09IHhheGVzID8gb3B0aW9ucy54YXhpcyA6IG9wdGlvbnMueWF4aXMpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGF4ZXNbbnVtYmVyIC0gMV07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBmaWxsSW5TZXJpZXNPcHRpb25zKCkge1xuICAgICAgICAgICAgdmFyIG5lZWRlZENvbG9ycyA9IHNlcmllcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgbWF4SW5kZXggPSAtMSxcbiAgICAgICAgICAgICAgICBpO1xuXG4gICAgICAgICAgICAvLyBTdWJ0cmFjdCB0aGUgbnVtYmVyIG9mIHNlcmllcyB0aGF0IGFscmVhZHkgaGF2ZSBmaXhlZCBjb2xvcnMgb3JcbiAgICAgICAgICAgIC8vIGNvbG9yIGluZGV4ZXMgZnJvbSB0aGUgbnVtYmVyIHRoYXQgd2Ugc3RpbGwgbmVlZCB0byBnZW5lcmF0ZS5cblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlcmllcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBzYyA9IHNlcmllc1tpXS5jb2xvcjtcbiAgICAgICAgICAgICAgICBpZiAoc2MgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBuZWVkZWRDb2xvcnMtLTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzYyA9PT0gXCJudW1iZXJcIiAmJiBzYyA+IG1heEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhJbmRleCA9IHNjO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBhbnkgb2YgdGhlIHNlcmllcyBoYXZlIGZpeGVkIGNvbG9yIGluZGV4ZXMsIHRoZW4gd2UgbmVlZCB0b1xuICAgICAgICAgICAgLy8gZ2VuZXJhdGUgYXQgbGVhc3QgYXMgbWFueSBjb2xvcnMgYXMgdGhlIGhpZ2hlc3QgaW5kZXguXG5cbiAgICAgICAgICAgIGlmIChuZWVkZWRDb2xvcnMgPD0gbWF4SW5kZXgpIHtcbiAgICAgICAgICAgICAgICBuZWVkZWRDb2xvcnMgPSBtYXhJbmRleCArIDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIGFsbCB0aGUgY29sb3JzLCB1c2luZyBmaXJzdCB0aGUgb3B0aW9uIGNvbG9ycyBhbmQgdGhlblxuICAgICAgICAgICAgLy8gdmFyaWF0aW9ucyBvbiB0aG9zZSBjb2xvcnMgb25jZSB0aGV5J3JlIGV4aGF1c3RlZC5cblxuICAgICAgICAgICAgdmFyIGMsIGNvbG9ycyA9IFtdLFxuICAgICAgICAgICAgICAgIGNvbG9yUG9vbCA9IG9wdGlvbnMuY29sb3JzLFxuICAgICAgICAgICAgICAgIGNvbG9yUG9vbFNpemUgPSBjb2xvclBvb2wubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHZhcmlhdGlvbiA9IDAsXG4gICAgICAgICAgICAgICAgZGVmaW5lZENvbG9ycyA9IE1hdGgubWF4KDAsIHNlcmllcy5sZW5ndGggLSBuZWVkZWRDb2xvcnMpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbmVlZGVkQ29sb3JzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjID0gJC5jb2xvci5wYXJzZShjb2xvclBvb2xbKGRlZmluZWRDb2xvcnMgKyBpKSAlIGNvbG9yUG9vbFNpemVdIHx8IFwiIzY2NlwiKTtcblxuICAgICAgICAgICAgICAgIC8vIEVhY2ggdGltZSB3ZSBleGhhdXN0IHRoZSBjb2xvcnMgaW4gdGhlIHBvb2wgd2UgYWRqdXN0XG4gICAgICAgICAgICAgICAgLy8gYSBzY2FsaW5nIGZhY3RvciB1c2VkIHRvIHByb2R1Y2UgbW9yZSB2YXJpYXRpb25zIG9uXG4gICAgICAgICAgICAgICAgLy8gdGhvc2UgY29sb3JzLiBUaGUgZmFjdG9yIGFsdGVybmF0ZXMgbmVnYXRpdmUvcG9zaXRpdmVcbiAgICAgICAgICAgICAgICAvLyB0byBwcm9kdWNlIGxpZ2h0ZXIvZGFya2VyIGNvbG9ycy5cblxuICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSB2YXJpYXRpb24gYWZ0ZXIgZXZlcnkgZmV3IGN5Y2xlcywgb3IgZWxzZVxuICAgICAgICAgICAgICAgIC8vIGl0IHdpbGwgZW5kIHVwIHByb2R1Y2luZyBvbmx5IHdoaXRlIG9yIGJsYWNrIGNvbG9ycy5cblxuICAgICAgICAgICAgICAgIGlmIChpICUgY29sb3JQb29sU2l6ZSA9PT0gMCAmJiBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YXJpYXRpb24gPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhcmlhdGlvbiA8IDAuNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhdGlvbiA9IC12YXJpYXRpb24gLSAwLjI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgdmFyaWF0aW9uID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHZhcmlhdGlvbiA9IC12YXJpYXRpb247XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29sb3JzW2ldID0gYy5zY2FsZSgncmdiJywgMSArIHZhcmlhdGlvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpbmFsaXplIHRoZSBzZXJpZXMgb3B0aW9ucywgZmlsbGluZyBpbiB0aGVpciBjb2xvcnNcblxuICAgICAgICAgICAgdmFyIGNvbG9yaSA9IDAsXG4gICAgICAgICAgICAgICAgcztcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZXJpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBzID0gc2VyaWVzW2ldO1xuXG4gICAgICAgICAgICAgICAgLy8gYXNzaWduIGNvbG9yc1xuICAgICAgICAgICAgICAgIGlmIChzLmNvbG9yID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcy5jb2xvciA9IGNvbG9yc1tjb2xvcmldLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICsrY29sb3JpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHMuY29sb3IgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcy5jb2xvciA9IGNvbG9yc1tzLmNvbG9yXS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHR1cm4gb24gbGluZXMgYXV0b21hdGljYWxseSBpbiBjYXNlIG5vdGhpbmcgaXMgc2V0XG4gICAgICAgICAgICAgICAgaWYgKHMubGluZXMuc2hvdyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2LCBzaG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2IGluIHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzW3ZdICYmIHNbdl0uc2hvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3cgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzLmxpbmVzLnNob3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgbm90aGluZyB3YXMgcHJvdmlkZWQgZm9yIGxpbmVzLnplcm8sIGRlZmF1bHQgaXQgdG8gbWF0Y2hcbiAgICAgICAgICAgICAgICAvLyBsaW5lcy5maWxsLCBzaW5jZSBhcmVhcyBieSBkZWZhdWx0IHNob3VsZCBleHRlbmQgdG8gemVyby5cblxuICAgICAgICAgICAgICAgIGlmIChzLmxpbmVzLnplcm8gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzLmxpbmVzLnplcm8gPSAhIXMubGluZXMuZmlsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBzZXR1cCBheGVzXG4gICAgICAgICAgICAgICAgcy54YXhpcyA9IGdldE9yQ3JlYXRlQXhpcyh4YXhlcywgYXhpc051bWJlcihzLCBcInhcIikpO1xuICAgICAgICAgICAgICAgIHMueWF4aXMgPSBnZXRPckNyZWF0ZUF4aXMoeWF4ZXMsIGF4aXNOdW1iZXIocywgXCJ5XCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHByb2Nlc3NEYXRhKHByZXZTZXJpZXMpIHtcbiAgICAgICAgICAgIHZhciB0b3BTZW50cnkgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgICAgICAgICAgICAgYm90dG9tU2VudHJ5ID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLFxuICAgICAgICAgICAgICAgIGksIGosIGssIG0sXG4gICAgICAgICAgICAgICAgcywgcG9pbnRzLCBwcywgdmFsLCBmLCBwLFxuICAgICAgICAgICAgICAgIGRhdGEsIGZvcm1hdDtcblxuICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlQXhpcyhheGlzLCBtaW4sIG1heCkge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPCBheGlzLmRhdGFtaW4gJiYgbWluICE9PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXhpcy5kYXRhbWluID0gbWluO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChtYXggPiBheGlzLmRhdGFtYXggJiYgbWF4ICE9PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgICAgICAgICBheGlzLmRhdGFtYXggPSBtYXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiByZXVzZVBvaW50cyhwcmV2U2VyaWVzLCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZTZXJpZXMgJiYgcHJldlNlcmllc1tpXSAmJiBwcmV2U2VyaWVzW2ldLmRhdGFwb2ludHMgJiYgcHJldlNlcmllc1tpXS5kYXRhcG9pbnRzLnBvaW50cykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJldlNlcmllc1tpXS5kYXRhcG9pbnRzLnBvaW50cztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICQuZWFjaChhbGxBeGVzKCksIGZ1bmN0aW9uKF8sIGF4aXMpIHtcbiAgICAgICAgICAgICAgICAvLyBpbml0IGF4aXNcbiAgICAgICAgICAgICAgICBpZiAoYXhpcy5vcHRpb25zLmdyb3dPbmx5ICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGF4aXMuZGF0YW1pbiA9IHRvcFNlbnRyeTtcbiAgICAgICAgICAgICAgICAgICAgYXhpcy5kYXRhbWF4ID0gYm90dG9tU2VudHJ5O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChheGlzLmRhdGFtaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXhpcy5kYXRhbWluID0gdG9wU2VudHJ5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChheGlzLmRhdGFtYXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXhpcy5kYXRhbWF4ID0gYm90dG9tU2VudHJ5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF4aXMudXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZXJpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBzID0gc2VyaWVzW2ldO1xuICAgICAgICAgICAgICAgIHMuZGF0YXBvaW50cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzOiBbXVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAocy5kYXRhcG9pbnRzLnBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcy5kYXRhcG9pbnRzLnBvaW50cyA9IHJldXNlUG9pbnRzKHByZXZTZXJpZXMsIGkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGV4ZWN1dGVIb29rcyhob29rcy5wcm9jZXNzUmF3RGF0YSwgW3MsIHMuZGF0YSwgcy5kYXRhcG9pbnRzXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGZpcnN0IHBhc3M6IGNsZWFuIGFuZCBjb3B5IGRhdGFcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZXJpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBzID0gc2VyaWVzW2ldO1xuXG4gICAgICAgICAgICAgICAgZGF0YSA9IHMuZGF0YTtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBzLmRhdGFwb2ludHMuZm9ybWF0O1xuXG4gICAgICAgICAgICAgICAgaWYgKCFmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0ID0gW107XG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbmQgb3V0IGhvdyB0byBjb3B5XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZVJhbmdlOiBzLnhheGlzLm9wdGlvbnMuYXV0b1NjYWxlICE9PSAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wdXRlUmFuZ2U6IHMueWF4aXMub3B0aW9ucy5hdXRvU2NhbGUgIT09ICdub25lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogbnVsbFxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocy5zdGFjayB8fCBzLmJhcnMuc2hvdyB8fCAocy5saW5lcy5zaG93ICYmIHMubGluZXMuZmlsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleHBlY3RlZFBzID0gcy5kYXRhcG9pbnRzLnBvaW50c2l6ZSAhPSBudWxsID8gcy5kYXRhcG9pbnRzLnBvaW50c2l6ZSA6IChzLmRhdGEgJiYgcy5kYXRhWzBdICYmIHMuZGF0YVswXS5sZW5ndGggPyBzLmRhdGFbMF0ubGVuZ3RoIDogMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwZWN0ZWRQcyA+IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZVJhbmdlOiBzLnlheGlzLm9wdGlvbnMuYXV0b1NjYWxlICE9PSAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcy5kYXRhcG9pbnRzLmZvcm1hdCA9IGZvcm1hdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzLnhheGlzLnVzZWQgPSBzLnlheGlzLnVzZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHMuZGF0YXBvaW50cy5wb2ludHNpemUgIT0gbnVsbCkgY29udGludWU7IC8vIGFscmVhZHkgZmlsbGVkIGluXG5cbiAgICAgICAgICAgICAgICBzLmRhdGFwb2ludHMucG9pbnRzaXplID0gZm9ybWF0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBwcyA9IHMuZGF0YXBvaW50cy5wb2ludHNpemU7XG4gICAgICAgICAgICAgICAgcG9pbnRzID0gcy5kYXRhcG9pbnRzLnBvaW50cztcblxuICAgICAgICAgICAgICAgIGZvciAoaiA9IGsgPSAwOyBqIDwgZGF0YS5sZW5ndGg7ICsraiwgayArPSBwcykge1xuICAgICAgICAgICAgICAgICAgICBwID0gZGF0YVtqXTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbnVsbGlmeSA9IHAgPT0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFudWxsaWZ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKG0gPSAwOyBtIDwgcHM7ICsrbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHBbbV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZiA9IGZvcm1hdFttXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmLm51bWJlciAmJiB2YWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gK3ZhbDsgLy8gY29udmVydCB0byBudW1iZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc05hTih2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGYucmVxdWlyZWQpIG51bGxpZnkgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZi5kZWZhdWx0VmFsdWUgIT0gbnVsbCkgdmFsID0gZi5kZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHNbayArIG1dID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG51bGxpZnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobSA9IDA7IG0gPCBwczsgKyttKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gcG9pbnRzW2sgKyBtXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZiA9IGZvcm1hdFttXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXh0cmFjdCBtaW4vbWF4IGluZm9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGYuY29tcHV0ZVJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZi54KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlQXhpcyhzLnhheGlzLCB2YWwsIHZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZi55KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlQXhpcyhzLnlheGlzLCB2YWwsIHZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzW2sgKyBtXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwb2ludHMubGVuZ3RoID0gazsgLy90cmltcyB0aGUgaW50ZXJuYWwgYnVmZmVyIHRvIHRoZSBjb3JyZWN0IGxlbmd0aFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBnaXZlIHRoZSBob29rcyBhIGNoYW5jZSB0byBydW5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZXJpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBzID0gc2VyaWVzW2ldO1xuXG4gICAgICAgICAgICAgICAgZXhlY3V0ZUhvb2tzKGhvb2tzLnByb2Nlc3NEYXRhcG9pbnRzLCBbcywgcy5kYXRhcG9pbnRzXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNlY29uZCBwYXNzOiBmaW5kIGRhdGFtYXgvZGF0YW1pbiBmb3IgYXV0by1zY2FsaW5nXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2VyaWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgcyA9IHNlcmllc1tpXTtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBzLmRhdGFwb2ludHMuZm9ybWF0O1xuXG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdC5ldmVyeShmdW5jdGlvbiAoZikgeyByZXR1cm4gIWYuY29tcHV0ZVJhbmdlOyB9KSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBwbG90LmFkanVzdFNlcmllc0RhdGFSYW5nZShzLFxuICAgICAgICAgICAgICAgICAgICBwbG90LmNvbXB1dGVSYW5nZUZvckRhdGFTZXJpZXMocykpO1xuXG4gICAgICAgICAgICAgICAgZXhlY3V0ZUhvb2tzKGhvb2tzLmFkanVzdFNlcmllc0RhdGFSYW5nZSwgW3MsIHJhbmdlXSk7XG5cbiAgICAgICAgICAgICAgICB1cGRhdGVBeGlzKHMueGF4aXMsIHJhbmdlLnhtaW4sIHJhbmdlLnhtYXgpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUF4aXMocy55YXhpcywgcmFuZ2UueW1pbiwgcmFuZ2UueW1heCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICQuZWFjaChhbGxBeGVzKCksIGZ1bmN0aW9uKF8sIGF4aXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXhpcy5kYXRhbWluID09PSB0b3BTZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXhpcy5kYXRhbWluID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYXhpcy5kYXRhbWF4ID09PSBib3R0b21TZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXhpcy5kYXRhbWF4ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNldHVwQ2FudmFzZXMoKSB7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHBsYWNlaG9sZGVyIGlzIGNsZWFyIG9mIGV2ZXJ5dGhpbmcgZXhjZXB0IGNhbnZhc2VzXG4gICAgICAgICAgICAvLyBmcm9tIGEgcHJldmlvdXMgcGxvdCBpbiB0aGlzIGNvbnRhaW5lciB0aGF0IHdlJ2xsIHRyeSB0byByZS11c2UuXG5cbiAgICAgICAgICAgIHBsYWNlaG9sZGVyLmNzcyhcInBhZGRpbmdcIiwgMCkgLy8gcGFkZGluZyBtZXNzZXMgdXAgdGhlIHBvc2l0aW9uaW5nXG4gICAgICAgICAgICAgICAgLmNoaWxkcmVuKCkuZmlsdGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gISQodGhpcykuaGFzQ2xhc3MoXCJmbG90LW92ZXJsYXlcIikgJiYgISQodGhpcykuaGFzQ2xhc3MoJ2Zsb3QtYmFzZScpO1xuICAgICAgICAgICAgICAgIH0pLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICBpZiAocGxhY2Vob2xkZXIuY3NzKFwicG9zaXRpb25cIikgPT09ICdzdGF0aWMnKSB7XG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXIuY3NzKFwicG9zaXRpb25cIiwgXCJyZWxhdGl2ZVwiKTsgLy8gZm9yIHBvc2l0aW9uaW5nIGxhYmVscyBhbmQgb3ZlcmxheVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdXJmYWNlID0gbmV3IENhbnZhcyhcImZsb3QtYmFzZVwiLCBwbGFjZWhvbGRlclswXSk7XG4gICAgICAgICAgICBvdmVybGF5ID0gbmV3IENhbnZhcyhcImZsb3Qtb3ZlcmxheVwiLCBwbGFjZWhvbGRlclswXSk7IC8vIG92ZXJsYXkgY2FudmFzIGZvciBpbnRlcmFjdGl2ZSBmZWF0dXJlc1xuXG4gICAgICAgICAgICBjdHggPSBzdXJmYWNlLmNvbnRleHQ7XG4gICAgICAgICAgICBvY3R4ID0gb3ZlcmxheS5jb250ZXh0O1xuXG4gICAgICAgICAgICAvLyBkZWZpbmUgd2hpY2ggZWxlbWVudCB3ZSdyZSBsaXN0ZW5pbmcgZm9yIGV2ZW50cyBvblxuICAgICAgICAgICAgZXZlbnRIb2xkZXIgPSAkKG92ZXJsYXkuZWxlbWVudCkudW5iaW5kKCk7XG5cbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIHJlLXVzaW5nIGEgcGxvdCBvYmplY3QsIHNodXQgZG93biB0aGUgb2xkIG9uZVxuXG4gICAgICAgICAgICB2YXIgZXhpc3RpbmcgPSBwbGFjZWhvbGRlci5kYXRhKFwicGxvdFwiKTtcblxuICAgICAgICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgICAgICAgZXhpc3Rpbmcuc2h1dGRvd24oKTtcbiAgICAgICAgICAgICAgICBvdmVybGF5LmNsZWFyKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNhdmUgaW4gY2FzZSB3ZSBnZXQgcmVwbG90dGVkXG4gICAgICAgICAgICBwbGFjZWhvbGRlci5kYXRhKFwicGxvdFwiLCBwbG90KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGJpbmRFdmVudHMoKSB7XG4gICAgICAgICAgICBleGVjdXRlSG9va3MoaG9va3MuYmluZEV2ZW50cywgW2V2ZW50SG9sZGVyXSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhZGRFdmVudEhhbmRsZXIoZXZlbnQsIGhhbmRsZXIsIGV2ZW50SG9sZGVyLCBwcmlvcml0eSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGV2ZW50SG9sZGVyICsgZXZlbnQ7XG4gICAgICAgICAgICB2YXIgZXZlbnRMaXN0ID0gZXZlbnRNYW5hZ2VyW2tleV0gfHwgW107XG5cbiAgICAgICAgICAgIGV2ZW50TGlzdC5wdXNoKHtcImV2ZW50XCI6IGV2ZW50LCBcImhhbmRsZXJcIjogaGFuZGxlciwgXCJldmVudEhvbGRlclwiOiBldmVudEhvbGRlciwgXCJwcmlvcml0eVwiOiBwcmlvcml0eX0pO1xuICAgICAgICAgICAgZXZlbnRMaXN0LnNvcnQoKGEsIGIpID0+IGIucHJpb3JpdHkgLSBhLnByaW9yaXR5KTtcbiAgICAgICAgICAgIGV2ZW50TGlzdC5mb3JFYWNoKGV2ZW50RGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgZXZlbnREYXRhLmV2ZW50SG9sZGVyLnVuYmluZChldmVudERhdGEuZXZlbnQsIGV2ZW50RGF0YS5oYW5kbGVyKTtcbiAgICAgICAgICAgICAgICBldmVudERhdGEuZXZlbnRIb2xkZXIuYmluZChldmVudERhdGEuZXZlbnQsIGV2ZW50RGF0YS5oYW5kbGVyKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBldmVudE1hbmFnZXJba2V5XSA9IGV2ZW50TGlzdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNodXRkb3duKCkge1xuICAgICAgICAgICAgaWYgKHJlZHJhd1RpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocmVkcmF3VGltZW91dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4ZWN1dGVIb29rcyhob29rcy5zaHV0ZG93biwgW2V2ZW50SG9sZGVyXSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzZXRUcmFuc2Zvcm1hdGlvbkhlbHBlcnMoYXhpcykge1xuICAgICAgICAgICAgLy8gc2V0IGhlbHBlciBmdW5jdGlvbnMgb24gdGhlIGF4aXMsIGFzc3VtZXMgcGxvdCBhcmVhXG4gICAgICAgICAgICAvLyBoYXMgYmVlbiBjb21wdXRlZCBhbHJlYWR5XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlkZW50aXR5KHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHMsIG0sIHQgPSBheGlzLm9wdGlvbnMudHJhbnNmb3JtIHx8IGlkZW50aXR5LFxuICAgICAgICAgICAgICAgIGl0ID0gYXhpcy5vcHRpb25zLmludmVyc2VUcmFuc2Zvcm07XG5cbiAgICAgICAgICAgIC8vIHByZWNvbXB1dGUgaG93IG11Y2ggdGhlIGF4aXMgaXMgc2NhbGluZyBhIHBvaW50XG4gICAgICAgICAgICAvLyBpbiBjYW52YXMgc3BhY2VcbiAgICAgICAgICAgIGlmIChheGlzLmRpcmVjdGlvbiA9PT0gXCJ4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNGaW5pdGUodChheGlzLm1heCkgLSB0KGF4aXMubWluKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcyA9IGF4aXMuc2NhbGUgPSBwbG90V2lkdGggLyBNYXRoLmFicyh0KGF4aXMubWF4KSAtIHQoYXhpcy5taW4pKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzID0gYXhpcy5zY2FsZSA9IDEgLyBNYXRoLmFicygkLnBsb3Quc2F0dXJhdGVkLmRlbHRhKHQoYXhpcy5taW4pLCB0KGF4aXMubWF4KSwgcGxvdFdpZHRoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG0gPSBNYXRoLm1pbih0KGF4aXMubWF4KSwgdChheGlzLm1pbikpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNGaW5pdGUodChheGlzLm1heCkgLSB0KGF4aXMubWluKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcyA9IGF4aXMuc2NhbGUgPSBwbG90SGVpZ2h0IC8gTWF0aC5hYnModChheGlzLm1heCkgLSB0KGF4aXMubWluKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcyA9IGF4aXMuc2NhbGUgPSAxIC8gTWF0aC5hYnMoJC5wbG90LnNhdHVyYXRlZC5kZWx0YSh0KGF4aXMubWluKSwgdChheGlzLm1heCksIHBsb3RIZWlnaHQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcyA9IC1zO1xuICAgICAgICAgICAgICAgIG0gPSBNYXRoLm1heCh0KGF4aXMubWF4KSwgdChheGlzLm1pbikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBkYXRhIHBvaW50IHRvIGNhbnZhcyBjb29yZGluYXRlXG4gICAgICAgICAgICBpZiAodCA9PT0gaWRlbnRpdHkpIHtcbiAgICAgICAgICAgICAgICAvLyBzbGlnaHQgb3B0aW1pemF0aW9uXG4gICAgICAgICAgICAgICAgYXhpcy5wMmMgPSBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Zpbml0ZShwIC0gbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAocCAtIG0pICogcztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAocCAvIDQgLSBtIC8gNCkgKiBzICogNDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGF4aXMucDJjID0gZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHAgPSB0KHApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Zpbml0ZSh0cCAtIG0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHRwIC0gbSkgKiBzO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0cCAvIDQgLSBtIC8gNCkgKiBzICogNDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNhbnZhcyBjb29yZGluYXRlIHRvIGRhdGEgcG9pbnRcbiAgICAgICAgICAgIGlmICghaXQpIHtcbiAgICAgICAgICAgICAgICBheGlzLmMycCA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG0gKyBjIC8gcztcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBheGlzLmMycCA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0KG0gKyBjIC8gcyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1lYXN1cmVUaWNrTGFiZWxzKGF4aXMpIHtcbiAgICAgICAgICAgIHZhciBvcHRzID0gYXhpcy5vcHRpb25zLFxuICAgICAgICAgICAgICAgIHRpY2tzID0gb3B0cy5zaG93VGlja0xhYmVscyAhPT0gJ25vbmUnICYmIGF4aXMudGlja3MgPyBheGlzLnRpY2tzIDogW10sXG4gICAgICAgICAgICAgICAgc2hvd01ham9yVGlja0xhYmVscyA9IG9wdHMuc2hvd1RpY2tMYWJlbHMgPT09ICdtYWpvcicgfHwgb3B0cy5zaG93VGlja0xhYmVscyA9PT0gJ2FsbCcsXG4gICAgICAgICAgICAgICAgc2hvd0VuZHBvaW50c1RpY2tMYWJlbHMgPSBvcHRzLnNob3dUaWNrTGFiZWxzID09PSAnZW5kcG9pbnRzJyB8fCBvcHRzLnNob3dUaWNrTGFiZWxzID09PSAnYWxsJyxcbiAgICAgICAgICAgICAgICBsYWJlbFdpZHRoID0gb3B0cy5sYWJlbFdpZHRoIHx8IDAsXG4gICAgICAgICAgICAgICAgbGFiZWxIZWlnaHQgPSBvcHRzLmxhYmVsSGVpZ2h0IHx8IDAsXG4gICAgICAgICAgICAgICAgbGVnYWN5U3R5bGVzID0gYXhpcy5kaXJlY3Rpb24gKyBcIkF4aXMgXCIgKyBheGlzLmRpcmVjdGlvbiArIGF4aXMubiArIFwiQXhpc1wiLFxuICAgICAgICAgICAgICAgIGxheWVyID0gXCJmbG90LVwiICsgYXhpcy5kaXJlY3Rpb24gKyBcIi1heGlzIGZsb3QtXCIgKyBheGlzLmRpcmVjdGlvbiArIGF4aXMubiArIFwiLWF4aXMgXCIgKyBsZWdhY3lTdHlsZXMsXG4gICAgICAgICAgICAgICAgZm9udCA9IG9wdHMuZm9udCB8fCBcImZsb3QtdGljay1sYWJlbCB0aWNrTGFiZWxcIjtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWNrcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciB0ID0gdGlja3NbaV07XG4gICAgICAgICAgICAgICAgdmFyIGxhYmVsID0gdC5sYWJlbDtcblxuICAgICAgICAgICAgICAgIGlmICghdC5sYWJlbCB8fFxuICAgICAgICAgICAgICAgICAgICAoc2hvd01ham9yVGlja0xhYmVscyA9PT0gZmFsc2UgJiYgaSA+IDAgJiYgaSA8IHRpY2tzLmxlbmd0aCAtIDEpIHx8XG4gICAgICAgICAgICAgICAgICAgIChzaG93RW5kcG9pbnRzVGlja0xhYmVscyA9PT0gZmFsc2UgJiYgKGkgPT09IDAgfHwgaSA9PT0gdGlja3MubGVuZ3RoIC0gMSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdC5sYWJlbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwgPSB0LmxhYmVsLm5hbWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGluZm8gPSBzdXJmYWNlLmdldFRleHRJbmZvKGxheWVyLCBsYWJlbCwgZm9udCk7XG5cbiAgICAgICAgICAgICAgICBsYWJlbFdpZHRoID0gTWF0aC5tYXgobGFiZWxXaWR0aCwgaW5mby53aWR0aCk7XG4gICAgICAgICAgICAgICAgbGFiZWxIZWlnaHQgPSBNYXRoLm1heChsYWJlbEhlaWdodCwgaW5mby5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBheGlzLmxhYmVsV2lkdGggPSBvcHRzLmxhYmVsV2lkdGggfHwgbGFiZWxXaWR0aDtcbiAgICAgICAgICAgIGF4aXMubGFiZWxIZWlnaHQgPSBvcHRzLmxhYmVsSGVpZ2h0IHx8IGxhYmVsSGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYWxsb2NhdGVBeGlzQm94Rmlyc3RQaGFzZShheGlzKSB7XG4gICAgICAgICAgICAvLyBmaW5kIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIGF4aXMgYnkgbG9va2luZyBhdCBsYWJlbFxuICAgICAgICAgICAgLy8gd2lkdGhzL2hlaWdodHMgYW5kIHRpY2tzLCBtYWtlIHJvb20gYnkgZGltaW5pc2hpbmcgdGhlXG4gICAgICAgICAgICAvLyBwbG90T2Zmc2V0OyB0aGlzIGZpcnN0IHBoYXNlIG9ubHkgbG9va3MgYXQgb25lXG4gICAgICAgICAgICAvLyBkaW1lbnNpb24gcGVyIGF4aXMsIHRoZSBvdGhlciBkaW1lbnNpb24gZGVwZW5kcyBvbiB0aGVcbiAgICAgICAgICAgIC8vIG90aGVyIGF4ZXMgc28gd2lsbCBoYXZlIHRvIHdhaXRcblxuICAgICAgICAgICAgLy8gaGVyZSByZXNlcnZlIGFkZGl0aW9uYWwgc3BhY2VcbiAgICAgICAgICAgIGV4ZWN1dGVIb29rcyhob29rcy5heGlzUmVzZXJ2ZVNwYWNlLCBbYXhpc10pO1xuXG4gICAgICAgICAgICB2YXIgbHcgPSBheGlzLmxhYmVsV2lkdGgsXG4gICAgICAgICAgICAgICAgbGggPSBheGlzLmxhYmVsSGVpZ2h0LFxuICAgICAgICAgICAgICAgIHBvcyA9IGF4aXMub3B0aW9ucy5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICBpc1hBeGlzID0gYXhpcy5kaXJlY3Rpb24gPT09IFwieFwiLFxuICAgICAgICAgICAgICAgIHRpY2tMZW5ndGggPSBheGlzLm9wdGlvbnMudGlja0xlbmd0aCxcbiAgICAgICAgICAgICAgICBzaG93VGlja3MgPSBheGlzLm9wdGlvbnMuc2hvd1RpY2tzLFxuICAgICAgICAgICAgICAgIHNob3dNaW5vclRpY2tzID0gYXhpcy5vcHRpb25zLnNob3dNaW5vclRpY2tzLFxuICAgICAgICAgICAgICAgIGdyaWRMaW5lcyA9IGF4aXMub3B0aW9ucy5ncmlkTGluZXMsXG4gICAgICAgICAgICAgICAgYXhpc01hcmdpbiA9IG9wdGlvbnMuZ3JpZC5heGlzTWFyZ2luLFxuICAgICAgICAgICAgICAgIHBhZGRpbmcgPSBvcHRpb25zLmdyaWQubGFiZWxNYXJnaW4sXG4gICAgICAgICAgICAgICAgaW5uZXJtb3N0ID0gdHJ1ZSxcbiAgICAgICAgICAgICAgICBvdXRlcm1vc3QgPSB0cnVlLFxuICAgICAgICAgICAgICAgIGZvdW5kID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIERldGVybWluZSB0aGUgYXhpcydzIHBvc2l0aW9uIGluIGl0cyBkaXJlY3Rpb24gYW5kIG9uIGl0cyBzaWRlXG5cbiAgICAgICAgICAgICQuZWFjaChpc1hBeGlzID8geGF4ZXMgOiB5YXhlcywgZnVuY3Rpb24oaSwgYSkge1xuICAgICAgICAgICAgICAgIGlmIChhICYmIChhLnNob3cgfHwgYS5yZXNlcnZlU3BhY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhID09PSBheGlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYS5vcHRpb25zLnBvc2l0aW9uID09PSBwb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGVybW9zdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbm5lcm1vc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBUaGUgb3V0ZXJtb3N0IGF4aXMgb24gZWFjaCBzaWRlIGhhcyBubyBtYXJnaW5cbiAgICAgICAgICAgIGlmIChvdXRlcm1vc3QpIHtcbiAgICAgICAgICAgICAgICBheGlzTWFyZ2luID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2V0IHRoZSBkZWZhdWx0IHRpY2tMZW5ndGggaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICBpZiAodGlja0xlbmd0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGlja0xlbmd0aCA9IFRJQ0tfTEVOR1RIX0NPTlNUQU5UO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBCeSBkZWZhdWx0LCBtYWpvciB0aWNrIG1hcmtzIGFyZSB2aXNpYmxlXG4gICAgICAgICAgICBpZiAoc2hvd1RpY2tzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzaG93VGlja3MgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBCeSBkZWZhdWx0LCBtaW5vciB0aWNrIG1hcmtzIGFyZSB2aXNpYmxlXG4gICAgICAgICAgICBpZiAoc2hvd01pbm9yVGlja3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHNob3dNaW5vclRpY2tzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQnkgZGVmYXVsdCwgZ3JpZCBsaW5lcyBhcmUgdmlzaWJsZVxuICAgICAgICAgICAgaWYgKGdyaWRMaW5lcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlubmVybW9zdCkge1xuICAgICAgICAgICAgICAgICAgICBncmlkTGluZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdyaWRMaW5lcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFpc05hTigrdGlja0xlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICBwYWRkaW5nICs9IHNob3dUaWNrcyA/ICt0aWNrTGVuZ3RoIDogMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzWEF4aXMpIHtcbiAgICAgICAgICAgICAgICBsaCArPSBwYWRkaW5nO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBvcyA9PT0gXCJib3R0b21cIikge1xuICAgICAgICAgICAgICAgICAgICBwbG90T2Zmc2V0LmJvdHRvbSArPSBsaCArIGF4aXNNYXJnaW47XG4gICAgICAgICAgICAgICAgICAgIGF4aXMuYm94ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBzdXJmYWNlLmhlaWdodCAtIHBsb3RPZmZzZXQuYm90dG9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBsaFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGF4aXMuYm94ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBwbG90T2Zmc2V0LnRvcCArIGF4aXNNYXJnaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGxoXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHBsb3RPZmZzZXQudG9wICs9IGxoICsgYXhpc01hcmdpbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGx3ICs9IHBhZGRpbmc7XG5cbiAgICAgICAgICAgICAgICBpZiAocG9zID09PSBcImxlZnRcIikge1xuICAgICAgICAgICAgICAgICAgICBheGlzLmJveCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHBsb3RPZmZzZXQubGVmdCArIGF4aXNNYXJnaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogbHdcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcGxvdE9mZnNldC5sZWZ0ICs9IGx3ICsgYXhpc01hcmdpbjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwbG90T2Zmc2V0LnJpZ2h0ICs9IGx3ICsgYXhpc01hcmdpbjtcbiAgICAgICAgICAgICAgICAgICAgYXhpcy5ib3ggPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBzdXJmYWNlLndpZHRoIC0gcGxvdE9mZnNldC5yaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBsd1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2F2ZSBmb3IgZnV0dXJlIHJlZmVyZW5jZVxuICAgICAgICAgICAgYXhpcy5wb3NpdGlvbiA9IHBvcztcbiAgICAgICAgICAgIGF4aXMudGlja0xlbmd0aCA9IHRpY2tMZW5ndGg7XG4gICAgICAgICAgICBheGlzLnNob3dNaW5vclRpY2tzID0gc2hvd01pbm9yVGlja3M7XG4gICAgICAgICAgICBheGlzLnNob3dUaWNrcyA9IHNob3dUaWNrcztcbiAgICAgICAgICAgIGF4aXMuZ3JpZExpbmVzID0gZ3JpZExpbmVzO1xuICAgICAgICAgICAgYXhpcy5ib3gucGFkZGluZyA9IHBhZGRpbmc7XG4gICAgICAgICAgICBheGlzLmlubmVybW9zdCA9IGlubmVybW9zdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFsbG9jYXRlQXhpc0JveFNlY29uZFBoYXNlKGF4aXMpIHtcbiAgICAgICAgICAgIC8vIG5vdyB0aGF0IGFsbCBheGlzIGJveGVzIGhhdmUgYmVlbiBwbGFjZWQgaW4gb25lXG4gICAgICAgICAgICAvLyBkaW1lbnNpb24sIHdlIGNhbiBzZXQgdGhlIHJlbWFpbmluZyBkaW1lbnNpb24gY29vcmRpbmF0ZXNcbiAgICAgICAgICAgIGlmIChheGlzLmRpcmVjdGlvbiA9PT0gXCJ4XCIpIHtcbiAgICAgICAgICAgICAgICBheGlzLmJveC5sZWZ0ID0gcGxvdE9mZnNldC5sZWZ0IC0gYXhpcy5sYWJlbFdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICBheGlzLmJveC53aWR0aCA9IHN1cmZhY2Uud2lkdGggLSBwbG90T2Zmc2V0LmxlZnQgLSBwbG90T2Zmc2V0LnJpZ2h0ICsgYXhpcy5sYWJlbFdpZHRoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBheGlzLmJveC50b3AgPSBwbG90T2Zmc2V0LnRvcCAtIGF4aXMubGFiZWxIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgIGF4aXMuYm94LmhlaWdodCA9IHN1cmZhY2UuaGVpZ2h0IC0gcGxvdE9mZnNldC5ib3R0b20gLSBwbG90T2Zmc2V0LnRvcCArIGF4aXMubGFiZWxIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhZGp1c3RMYXlvdXRGb3JUaGluZ3NTdGlja2luZ091dCgpIHtcbiAgICAgICAgICAgIC8vIHBvc3NpYmx5IGFkanVzdCBwbG90IG9mZnNldCB0byBlbnN1cmUgZXZlcnl0aGluZyBzdGF5c1xuICAgICAgICAgICAgLy8gaW5zaWRlIHRoZSBjYW52YXMgYW5kIGlzbid0IGNsaXBwZWQgb2ZmXG5cbiAgICAgICAgICAgIHZhciBtaW5NYXJnaW4gPSBvcHRpb25zLmdyaWQubWluQm9yZGVyTWFyZ2luLFxuICAgICAgICAgICAgICAgIGk7XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIHN0dWZmIGZyb20gdGhlIHBsb3QgKEZJWE1FOiB0aGlzIHNob3VsZCBqdXN0IHJlYWRcbiAgICAgICAgICAgIC8vIGEgdmFsdWUgZnJvbSB0aGUgc2VyaWVzLCBvdGhlcndpc2UgaXQncyBpbXBvc3NpYmxlIHRvXG4gICAgICAgICAgICAvLyBjdXN0b21pemUpXG4gICAgICAgICAgICBpZiAobWluTWFyZ2luID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBtaW5NYXJnaW4gPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZXJpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluTWFyZ2luID0gTWF0aC5tYXgobWluTWFyZ2luLCAyICogKHNlcmllc1tpXS5wb2ludHMucmFkaXVzICsgc2VyaWVzW2ldLnBvaW50cy5saW5lV2lkdGggLyAyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYSwgb2Zmc2V0ID0ge30sXG4gICAgICAgICAgICAgICAgbWFyZ2lucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogbWluTWFyZ2luLFxuICAgICAgICAgICAgICAgICAgICByaWdodDogbWluTWFyZ2luLFxuICAgICAgICAgICAgICAgICAgICB0b3A6IG1pbk1hcmdpbixcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tOiBtaW5NYXJnaW5cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBjaGVjayBheGlzIGxhYmVscywgbm90ZSB3ZSBkb24ndCBjaGVjayB0aGUgYWN0dWFsXG4gICAgICAgICAgICAvLyBsYWJlbHMgYnV0IGluc3RlYWQgdXNlIHRoZSBvdmVyYWxsIHdpZHRoL2hlaWdodCB0byBub3RcbiAgICAgICAgICAgIC8vIGp1bXAgYXMgbXVjaCBhcm91bmQgd2l0aCByZXBsb3RzXG4gICAgICAgICAgICAkLmVhY2goYWxsQXhlcygpLCBmdW5jdGlvbihfLCBheGlzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF4aXMucmVzZXJ2ZVNwYWNlICYmIGF4aXMudGlja3MgJiYgYXhpcy50aWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF4aXMuZGlyZWN0aW9uID09PSBcInhcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2lucy5sZWZ0ID0gTWF0aC5tYXgobWFyZ2lucy5sZWZ0LCBheGlzLmxhYmVsV2lkdGggLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbnMucmlnaHQgPSBNYXRoLm1heChtYXJnaW5zLnJpZ2h0LCBheGlzLmxhYmVsV2lkdGggLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbnMuYm90dG9tID0gTWF0aC5tYXgobWFyZ2lucy5ib3R0b20sIGF4aXMubGFiZWxIZWlnaHQgLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbnMudG9wID0gTWF0aC5tYXgobWFyZ2lucy50b3AsIGF4aXMubGFiZWxIZWlnaHQgLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBmb3IgKGEgaW4gbWFyZ2lucykge1xuICAgICAgICAgICAgICAgIG9mZnNldFthXSA9IG1hcmdpbnNbYV0gLSBwbG90T2Zmc2V0W2FdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJC5lYWNoKHhheGVzLmNvbmNhdCh5YXhlcyksIGZ1bmN0aW9uKF8sIGF4aXMpIHtcbiAgICAgICAgICAgICAgICBhbGlnbkF4aXNXaXRoR3JpZChheGlzLCBvZmZzZXQsIGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9mZnNldCA+IDA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcGxvdE9mZnNldC5sZWZ0ID0gTWF0aC5jZWlsKE1hdGgubWF4KG1hcmdpbnMubGVmdCwgcGxvdE9mZnNldC5sZWZ0KSk7XG4gICAgICAgICAgICBwbG90T2Zmc2V0LnJpZ2h0ID0gTWF0aC5jZWlsKE1hdGgubWF4KG1hcmdpbnMucmlnaHQsIHBsb3RPZmZzZXQucmlnaHQpKTtcbiAgICAgICAgICAgIHBsb3RPZmZzZXQudG9wID0gTWF0aC5jZWlsKE1hdGgubWF4KG1hcmdpbnMudG9wLCBwbG90T2Zmc2V0LnRvcCkpO1xuICAgICAgICAgICAgcGxvdE9mZnNldC5ib3R0b20gPSBNYXRoLmNlaWwoTWF0aC5tYXgobWFyZ2lucy5ib3R0b20sIHBsb3RPZmZzZXQuYm90dG9tKSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhbGlnbkF4aXNXaXRoR3JpZChheGlzLCBvZmZzZXQsIGlzVmFsaWQpIHtcbiAgICAgICAgICAgIGlmIChheGlzLmRpcmVjdGlvbiA9PT0gXCJ4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXhpcy5wb3NpdGlvbiA9PT0gXCJib3R0b21cIiAmJiBpc1ZhbGlkKG9mZnNldC5ib3R0b20pKSB7XG4gICAgICAgICAgICAgICAgICAgIGF4aXMuYm94LnRvcCAtPSBNYXRoLmNlaWwob2Zmc2V0LmJvdHRvbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChheGlzLnBvc2l0aW9uID09PSBcInRvcFwiICYmIGlzVmFsaWQob2Zmc2V0LnRvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXhpcy5ib3gudG9wICs9IE1hdGguY2VpbChvZmZzZXQudG9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChheGlzLnBvc2l0aW9uID09PSBcImxlZnRcIiAmJiBpc1ZhbGlkKG9mZnNldC5sZWZ0KSkge1xuICAgICAgICAgICAgICAgICAgICBheGlzLmJveC5sZWZ0ICs9IE1hdGguY2VpbChvZmZzZXQubGVmdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChheGlzLnBvc2l0aW9uID09PSBcInJpZ2h0XCIgJiYgaXNWYWxpZChvZmZzZXQucmlnaHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGF4aXMuYm94LmxlZnQgLT0gTWF0aC5jZWlsKG9mZnNldC5yaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc2V0dXBHcmlkKGF1dG9TY2FsZSkge1xuICAgICAgICAgICAgdmFyIGksIGEsIGF4ZXMgPSBhbGxBeGVzKCksXG4gICAgICAgICAgICAgICAgc2hvd0dyaWQgPSBvcHRpb25zLmdyaWQuc2hvdztcblxuICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgcGxvdCdzIG9mZnNldCBmcm9tIHRoZSBlZGdlIG9mIHRoZSBjYW52YXNcblxuICAgICAgICAgICAgZm9yIChhIGluIHBsb3RPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBwbG90T2Zmc2V0W2FdID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhlY3V0ZUhvb2tzKGhvb2tzLnByb2Nlc3NPZmZzZXQsIFtwbG90T2Zmc2V0XSk7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBncmlkIGlzIHZpc2libGUsIGFkZCBpdHMgYm9yZGVyIHdpZHRoIHRvIHRoZSBvZmZzZXRcbiAgICAgICAgICAgIGZvciAoYSBpbiBwbG90T2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAob3B0aW9ucy5ncmlkLmJvcmRlcldpZHRoKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICBwbG90T2Zmc2V0W2FdICs9IHNob3dHcmlkID8gb3B0aW9ucy5ncmlkLmJvcmRlcldpZHRoW2FdIDogMDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwbG90T2Zmc2V0W2FdICs9IHNob3dHcmlkID8gb3B0aW9ucy5ncmlkLmJvcmRlcldpZHRoIDogMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICQuZWFjaChheGVzLCBmdW5jdGlvbihfLCBheGlzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF4aXNPcHRzID0gYXhpcy5vcHRpb25zO1xuICAgICAgICAgICAgICAgIGF4aXMuc2hvdyA9IGF4aXNPcHRzLnNob3cgPT0gbnVsbCA/IGF4aXMudXNlZCA6IGF4aXNPcHRzLnNob3c7XG4gICAgICAgICAgICAgICAgYXhpcy5yZXNlcnZlU3BhY2UgPSBheGlzT3B0cy5yZXNlcnZlU3BhY2UgPT0gbnVsbCA/IGF4aXMuc2hvdyA6IGF4aXNPcHRzLnJlc2VydmVTcGFjZTtcbiAgICAgICAgICAgICAgICBzZXR1cFRpY2tGb3JtYXR0ZXIoYXhpcyk7XG4gICAgICAgICAgICAgICAgZXhlY3V0ZUhvb2tzKGhvb2tzLnNldFJhbmdlLCBbYXhpcywgYXV0b1NjYWxlXSk7XG4gICAgICAgICAgICAgICAgc2V0UmFuZ2UoYXhpcywgYXV0b1NjYWxlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoc2hvd0dyaWQpIHtcbiAgICAgICAgICAgICAgICBwbG90V2lkdGggPSBzdXJmYWNlLndpZHRoIC0gcGxvdE9mZnNldC5sZWZ0IC0gcGxvdE9mZnNldC5yaWdodDtcbiAgICAgICAgICAgICAgICBwbG90SGVpZ2h0ID0gc3VyZmFjZS5oZWlnaHQgLSBwbG90T2Zmc2V0LmJvdHRvbSAtIHBsb3RPZmZzZXQudG9wO1xuXG4gICAgICAgICAgICAgICAgdmFyIGFsbG9jYXRlZEF4ZXMgPSAkLmdyZXAoYXhlcywgZnVuY3Rpb24oYXhpcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXhpcy5zaG93IHx8IGF4aXMucmVzZXJ2ZVNwYWNlO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgJC5lYWNoKGFsbG9jYXRlZEF4ZXMsIGZ1bmN0aW9uKF8sIGF4aXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSB0aGUgdGlja3NcbiAgICAgICAgICAgICAgICAgICAgc2V0dXBUaWNrR2VuZXJhdGlvbihheGlzKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0TWFqb3JUaWNrcyhheGlzKTtcbiAgICAgICAgICAgICAgICAgICAgc25hcFJhbmdlVG9UaWNrcyhheGlzLCBheGlzLnRpY2tzLCBzZXJpZXMpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vZm9yIGNvbXB1dGluZyB0aGUgZW5kcG9pbnRzIHByZWNpc2lvbiwgdHJhbnNmb3JtYXRpb25IZWxwZXJzIGFyZSBuZWVkZWRcbiAgICAgICAgICAgICAgICAgICAgc2V0VHJhbnNmb3JtYXRpb25IZWxwZXJzKGF4aXMpO1xuICAgICAgICAgICAgICAgICAgICBzZXRFbmRwb2ludFRpY2tzKGF4aXMsIHNlcmllcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZmluZCBsYWJlbFdpZHRoL0hlaWdodCBmb3IgYXhpc1xuICAgICAgICAgICAgICAgICAgICBtZWFzdXJlVGlja0xhYmVscyhheGlzKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIHdpdGggYWxsIGRpbWVuc2lvbnMgY2FsY3VsYXRlZCwgd2UgY2FuIGNvbXB1dGUgdGhlXG4gICAgICAgICAgICAgICAgLy8gYXhpcyBib3VuZGluZyBib3hlcywgc3RhcnQgZnJvbSB0aGUgb3V0c2lkZVxuICAgICAgICAgICAgICAgIC8vIChyZXZlcnNlIG9yZGVyKVxuICAgICAgICAgICAgICAgIGZvciAoaSA9IGFsbG9jYXRlZEF4ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsb2NhdGVBeGlzQm94Rmlyc3RQaGFzZShhbGxvY2F0ZWRBeGVzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgd2UndmUgZ290IGVub3VnaCBzcGFjZSBmb3IgdGhpbmdzIHRoYXRcbiAgICAgICAgICAgICAgICAvLyBtaWdodCBzdGljayBvdXRcbiAgICAgICAgICAgICAgICBhZGp1c3RMYXlvdXRGb3JUaGluZ3NTdGlja2luZ091dCgpO1xuXG4gICAgICAgICAgICAgICAgJC5lYWNoKGFsbG9jYXRlZEF4ZXMsIGZ1bmN0aW9uKF8sIGF4aXMpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsb2NhdGVBeGlzQm94U2Vjb25kUGhhc2UoYXhpcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vYWRqdXN0IGF4aXMgYW5kIHBsb3RPZmZzZXQgYWNjb3JkaW5nIHRvIGdyaWQubWFyZ2luc1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZ3JpZC5tYXJnaW4pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGEgaW4gcGxvdE9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWFyZ2luID0gb3B0aW9ucy5ncmlkLm1hcmdpbiB8fCAwO1xuICAgICAgICAgICAgICAgICAgICBwbG90T2Zmc2V0W2FdICs9IHR5cGVvZiBtYXJnaW4gPT09IFwibnVtYmVyXCIgPyBtYXJnaW4gOiAobWFyZ2luW2FdIHx8IDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkLmVhY2goeGF4ZXMuY29uY2F0KHlheGVzKSwgZnVuY3Rpb24oXywgYXhpcykge1xuICAgICAgICAgICAgICAgICAgICBhbGlnbkF4aXNXaXRoR3JpZChheGlzLCBvcHRpb25zLmdyaWQubWFyZ2luLCBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2FmdGVyIGFkanVzdGluZyB0aGUgYXhpcywgcGxvdCB3aWR0aCBhbmQgaGVpZ2h0IHdpbGwgYmUgbW9kaWZpZWRcbiAgICAgICAgICAgIHBsb3RXaWR0aCA9IHN1cmZhY2Uud2lkdGggLSBwbG90T2Zmc2V0LmxlZnQgLSBwbG90T2Zmc2V0LnJpZ2h0O1xuICAgICAgICAgICAgcGxvdEhlaWdodCA9IHN1cmZhY2UuaGVpZ2h0IC0gcGxvdE9mZnNldC5ib3R0b20gLSBwbG90T2Zmc2V0LnRvcDtcblxuICAgICAgICAgICAgLy8gbm93IHdlIGdvdCB0aGUgcHJvcGVyIHBsb3QgZGltZW5zaW9ucywgd2UgY2FuIGNvbXB1dGUgdGhlIHNjYWxpbmdcbiAgICAgICAgICAgICQuZWFjaChheGVzLCBmdW5jdGlvbihfLCBheGlzKSB7XG4gICAgICAgICAgICAgICAgc2V0VHJhbnNmb3JtYXRpb25IZWxwZXJzKGF4aXMpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChzaG93R3JpZCkge1xuICAgICAgICAgICAgICAgIGRyYXdBeGlzTGFiZWxzKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4ZWN1dGVIb29rcyhob29rcy5zZXR1cEdyaWQsIFtdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHdpZGVuTWluTWF4KG1pbmltdW0sIG1heGltdW0pIHtcbiAgICAgICAgICAgIHZhciBtaW4gPSAobWluaW11bSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IG1pbmltdW0pO1xuICAgICAgICAgICAgdmFyIG1heCA9IChtYXhpbXVtID09PSB1bmRlZmluZWQgPyBudWxsIDogbWF4aW11bSk7XG4gICAgICAgICAgICB2YXIgZGVsdGEgPSBtYXggLSBtaW47XG4gICAgICAgICAgICBpZiAoZGVsdGEgPT09IDAuMCkge1xuICAgICAgICAgICAgICAgIC8vIGRlZ2VuZXJhdGUgY2FzZVxuICAgICAgICAgICAgICAgIHZhciB3aWRlbiA9IG1heCA9PT0gMCA/IDEgOiAwLjAxO1xuICAgICAgICAgICAgICAgIHZhciB3bWluID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAobWluID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgd21pbiAtPSB3aWRlbjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBhbHdheXMgd2lkZW4gbWF4IGlmIHdlIGNvdWxkbid0IHdpZGVuIG1pbiB0byBlbnN1cmUgd2VcbiAgICAgICAgICAgICAgICAvLyBkb24ndCBmYWxsIGludG8gbWluID09IG1heCB3aGljaCBkb2Vzbid0IHdvcmtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09IG51bGwgfHwgbWluICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4ICs9IHdpZGVuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh3bWluICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluID0gd21pbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWluOiBtaW4sXG4gICAgICAgICAgICAgICAgbWF4OiBtYXhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhdXRvU2NhbGVBeGlzKGF4aXMpIHtcbiAgICAgICAgICAgIHZhciBvcHRzID0gYXhpcy5vcHRpb25zLFxuICAgICAgICAgICAgICAgIG1pbiA9IG9wdHMubWluLFxuICAgICAgICAgICAgICAgIG1heCA9IG9wdHMubWF4LFxuICAgICAgICAgICAgICAgIGRhdGFtaW4gPSBheGlzLmRhdGFtaW4sXG4gICAgICAgICAgICAgICAgZGF0YW1heCA9IGF4aXMuZGF0YW1heCxcbiAgICAgICAgICAgICAgICBkZWx0YTtcblxuICAgICAgICAgICAgc3dpdGNoIChvcHRzLmF1dG9TY2FsZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJub25lXCI6XG4gICAgICAgICAgICAgICAgICAgIG1pbiA9ICsob3B0cy5taW4gIT0gbnVsbCA/IG9wdHMubWluIDogZGF0YW1pbik7XG4gICAgICAgICAgICAgICAgICAgIG1heCA9ICsob3B0cy5tYXggIT0gbnVsbCA/IG9wdHMubWF4IDogZGF0YW1heCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJsb29zZVwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YW1pbiAhPSBudWxsICYmIGRhdGFtYXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluID0gZGF0YW1pbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heCA9IGRhdGFtYXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWx0YSA9ICQucGxvdC5zYXR1cmF0ZWQuc2F0dXJhdGUobWF4IC0gbWluKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXJnaW4gPSAoKHR5cGVvZiBvcHRzLmF1dG9TY2FsZU1hcmdpbiA9PT0gJ251bWJlcicpID8gb3B0cy5hdXRvU2NhbGVNYXJnaW4gOiAwLjAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbiA9ICQucGxvdC5zYXR1cmF0ZWQuc2F0dXJhdGUobWluIC0gZGVsdGEgKiBtYXJnaW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4ID0gJC5wbG90LnNhdHVyYXRlZC5zYXR1cmF0ZShtYXggKyBkZWx0YSAqIG1hcmdpbik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBkb24ndCBnbyBiZWxvdyB6ZXJvIGlmIGFsbCB2YWx1ZXMgYXJlIHBvc2l0aXZlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWluIDwgMCAmJiBkYXRhbWluID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW4gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluID0gb3B0cy5taW47XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXggPSBvcHRzLm1heDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXhhY3RcIjpcbiAgICAgICAgICAgICAgICAgICAgbWluID0gKGRhdGFtaW4gIT0gbnVsbCA/IGRhdGFtaW4gOiBvcHRzLm1pbik7XG4gICAgICAgICAgICAgICAgICAgIG1heCA9IChkYXRhbWF4ICE9IG51bGwgPyBkYXRhbWF4IDogb3B0cy5tYXgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwic2xpZGluZy13aW5kb3dcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFtYXggPiBtYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgdGhlIHdpbmRvdyB0byBmaXQgdGhlIG5ldyBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8ga2VlcGluZyB0aGUgYXhpcyByYW5nZSBjb25zdGFudFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4ID0gZGF0YW1heDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbiA9IE1hdGgubWF4KGRhdGFtYXggLSAob3B0cy53aW5kb3dTaXplIHx8IDEwMCksIG1pbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB3aWRlbmVkTWluTWF4ID0gd2lkZW5NaW5NYXgobWluLCBtYXgpO1xuICAgICAgICAgICAgbWluID0gd2lkZW5lZE1pbk1heC5taW47XG4gICAgICAgICAgICBtYXggPSB3aWRlbmVkTWluTWF4Lm1heDtcblxuICAgICAgICAgICAgLy8gZ3JvdyBsb29zZSBvciBncm93IGV4YWN0IHN1cHBvcnRlZFxuICAgICAgICAgICAgaWYgKG9wdHMuZ3Jvd09ubHkgPT09IHRydWUgJiYgb3B0cy5hdXRvU2NhbGUgIT09IFwibm9uZVwiICYmIG9wdHMuYXV0b1NjYWxlICE9PSBcInNsaWRpbmctd2luZG93XCIpIHtcbiAgICAgICAgICAgICAgICBtaW4gPSAobWluIDwgZGF0YW1pbikgPyBtaW4gOiAoZGF0YW1pbiAhPT0gbnVsbCA/IGRhdGFtaW4gOiBtaW4pO1xuICAgICAgICAgICAgICAgIG1heCA9IChtYXggPiBkYXRhbWF4KSA/IG1heCA6IChkYXRhbWF4ICE9PSBudWxsID8gZGF0YW1heCA6IG1heCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGF4aXMuYXV0b1NjYWxlZE1pbiA9IG1pbjtcbiAgICAgICAgICAgIGF4aXMuYXV0b1NjYWxlZE1heCA9IG1heDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNldFJhbmdlKGF4aXMsIGF1dG9TY2FsZSkge1xuICAgICAgICAgICAgdmFyIG1pbiA9IHR5cGVvZiBheGlzLm9wdGlvbnMubWluID09PSAnbnVtYmVyJyA/IGF4aXMub3B0aW9ucy5taW4gOiBheGlzLm1pbixcbiAgICAgICAgICAgICAgICBtYXggPSB0eXBlb2YgYXhpcy5vcHRpb25zLm1heCA9PT0gJ251bWJlcicgPyBheGlzLm9wdGlvbnMubWF4IDogYXhpcy5tYXgsXG4gICAgICAgICAgICAgICAgcGxvdE9mZnNldCA9IGF4aXMub3B0aW9ucy5vZmZzZXQ7XG5cbiAgICAgICAgICAgIGlmIChhdXRvU2NhbGUpIHtcbiAgICAgICAgICAgICAgICBhdXRvU2NhbGVBeGlzKGF4aXMpO1xuICAgICAgICAgICAgICAgIG1pbiA9IGF4aXMuYXV0b1NjYWxlZE1pbjtcbiAgICAgICAgICAgICAgICBtYXggPSBheGlzLmF1dG9TY2FsZWRNYXg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1pbiA9IChtaW4gIT0gbnVsbCA/IG1pbiA6IC0xKSArIChwbG90T2Zmc2V0LmJlbG93IHx8IDApO1xuICAgICAgICAgICAgbWF4ID0gKG1heCAhPSBudWxsID8gbWF4IDogMSkgKyAocGxvdE9mZnNldC5hYm92ZSB8fCAwKTtcblxuICAgICAgICAgICAgaWYgKG1pbiA+IG1heCkge1xuICAgICAgICAgICAgICAgIHZhciB0bXAgPSBtaW47XG4gICAgICAgICAgICAgICAgbWluID0gbWF4O1xuICAgICAgICAgICAgICAgIG1heCA9IHRtcDtcbiAgICAgICAgICAgICAgICBheGlzLm9wdGlvbnMub2Zmc2V0ID0geyBhYm92ZTogMCwgYmVsb3c6IDAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXhpcy5taW4gPSAkLnBsb3Quc2F0dXJhdGVkLnNhdHVyYXRlKG1pbik7XG4gICAgICAgICAgICBheGlzLm1heCA9ICQucGxvdC5zYXR1cmF0ZWQuc2F0dXJhdGUobWF4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVWYWx1ZVByZWNpc2lvbiAobWluLCBtYXgsIGRpcmVjdGlvbiwgdGlja3MsIHRpY2tEZWNpbWFscykge1xuICAgICAgICAgICAgdmFyIG5vVGlja3MgPSBmaXh1cE51bWJlck9mVGlja3MoZGlyZWN0aW9uLCBzdXJmYWNlLCB0aWNrcyk7XG5cbiAgICAgICAgICAgIHZhciBkZWx0YSA9ICQucGxvdC5zYXR1cmF0ZWQuZGVsdGEobWluLCBtYXgsIG5vVGlja3MpLFxuICAgICAgICAgICAgICAgIGRlYyA9IC1NYXRoLmZsb29yKE1hdGgubG9nKGRlbHRhKSAvIE1hdGguTE4xMCk7XG5cbiAgICAgICAgICAgIC8vaWYgaXQgaXMgY2FsbGVkIHdpdGggdGlja0RlY2ltYWxzLCB0aGVuIHRoZSBwcmVjaXNpb24gc2hvdWxkIG5vdCBiZSBncmVhdGhlciB0aGVuIHRoYXRcbiAgICAgICAgICAgIGlmICh0aWNrRGVjaW1hbHMgJiYgZGVjID4gdGlja0RlY2ltYWxzKSB7XG4gICAgICAgICAgICAgICAgZGVjID0gdGlja0RlY2ltYWxzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbWFnbiA9IHBhcnNlRmxvYXQoJzFlJyArICgtZGVjKSksXG4gICAgICAgICAgICAgICAgbm9ybSA9IGRlbHRhIC8gbWFnbjtcblxuICAgICAgICAgICAgaWYgKG5vcm0gPiAyLjI1ICYmIG5vcm0gPCAzICYmIChkZWMgKyAxKSA8PSB0aWNrRGVjaW1hbHMpIHtcbiAgICAgICAgICAgICAgICAvL3dlIG5lZWQgYW4gZXh0cmEgZGVjaW1hbHMgd2hlbiB0aWNrU2l6ZSBpcyAyLjVcbiAgICAgICAgICAgICAgICArK2RlYztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGlzRmluaXRlKGRlYykgPyBkZWMgOiAwO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVUaWNrU2l6ZSAobWluLCBtYXgsIG5vVGlja3MsIHRpY2tEZWNpbWFscykge1xuICAgICAgICAgICAgdmFyIGRlbHRhID0gJC5wbG90LnNhdHVyYXRlZC5kZWx0YShtaW4sIG1heCwgbm9UaWNrcyksXG4gICAgICAgICAgICAgICAgZGVjID0gLU1hdGguZmxvb3IoTWF0aC5sb2coZGVsdGEpIC8gTWF0aC5MTjEwKTtcblxuICAgICAgICAgICAgLy9pZiBpdCBpcyBjYWxsZWQgd2l0aCB0aWNrRGVjaW1hbHMsIHRoZW4gdGhlIHByZWNpc2lvbiBzaG91bGQgbm90IGJlIGdyZWF0aGVyIHRoZW4gdGhhdFxuICAgICAgICAgICAgaWYgKHRpY2tEZWNpbWFscyAmJiBkZWMgPiB0aWNrRGVjaW1hbHMpIHtcbiAgICAgICAgICAgICAgICBkZWMgPSB0aWNrRGVjaW1hbHM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtYWduID0gcGFyc2VGbG9hdCgnMWUnICsgKC1kZWMpKSxcbiAgICAgICAgICAgICAgICBub3JtID0gZGVsdGEgLyBtYWduLCAvLyBub3JtIGlzIGJldHdlZW4gMS4wIGFuZCAxMC4wXG4gICAgICAgICAgICAgICAgc2l6ZTtcblxuICAgICAgICAgICAgaWYgKG5vcm0gPCAxLjUpIHtcbiAgICAgICAgICAgICAgICBzaXplID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9ybSA8IDMpIHtcbiAgICAgICAgICAgICAgICBzaXplID0gMjtcbiAgICAgICAgICAgICAgICBpZiAobm9ybSA+IDIuMjUgJiYgKHRpY2tEZWNpbWFscyA9PSBudWxsIHx8IChkZWMgKyAxKSA8PSB0aWNrRGVjaW1hbHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpemUgPSAyLjU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChub3JtIDwgNy41KSB7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IDU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNpemUgPSAxMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2l6ZSAqPSBtYWduO1xuICAgICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRBeGlzVGlja1NpemUobWluLCBtYXgsIGRpcmVjdGlvbiwgb3B0aW9ucywgdGlja0RlY2ltYWxzKSB7XG4gICAgICAgICAgICB2YXIgbm9UaWNrcztcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnRpY2tzID09PSBcIm51bWJlclwiICYmIG9wdGlvbnMudGlja3MgPiAwKSB7XG4gICAgICAgICAgICAgICAgbm9UaWNrcyA9IG9wdGlvbnMudGlja3M7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaGV1cmlzdGljIGJhc2VkIG9uIHRoZSBtb2RlbCBhKnNxcnQoeCkgZml0dGVkIHRvXG4gICAgICAgICAgICAvLyBzb21lIGRhdGEgcG9pbnRzIHRoYXQgc2VlbWVkIHJlYXNvbmFibGVcbiAgICAgICAgICAgICAgICBub1RpY2tzID0gMC4zICogTWF0aC5zcXJ0KGRpcmVjdGlvbiA9PT0gXCJ4XCIgPyBzdXJmYWNlLndpZHRoIDogc3VyZmFjZS5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc2l6ZSA9IGNvbXB1dGVUaWNrU2l6ZShtaW4sIG1heCwgbm9UaWNrcywgdGlja0RlY2ltYWxzKTtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubWluVGlja1NpemUgIT0gbnVsbCAmJiBzaXplIDwgb3B0aW9ucy5taW5UaWNrU2l6ZSkge1xuICAgICAgICAgICAgICAgIHNpemUgPSBvcHRpb25zLm1pblRpY2tTaXplO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy50aWNrU2l6ZSB8fCBzaXplO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGZpeHVwTnVtYmVyT2ZUaWNrcyhkaXJlY3Rpb24sIHN1cmZhY2UsIHRpY2tzT3B0aW9uKSB7XG4gICAgICAgICAgICB2YXIgbm9UaWNrcztcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aWNrc09wdGlvbiA9PT0gXCJudW1iZXJcIiAmJiB0aWNrc09wdGlvbiA+IDApIHtcbiAgICAgICAgICAgICAgICBub1RpY2tzID0gdGlja3NPcHRpb247XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vVGlja3MgPSAwLjMgKiBNYXRoLnNxcnQoZGlyZWN0aW9uID09PSBcInhcIiA/IHN1cmZhY2Uud2lkdGggOiBzdXJmYWNlLmhlaWdodCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBub1RpY2tzO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc2V0dXBUaWNrRm9ybWF0dGVyKGF4aXMpIHtcbiAgICAgICAgICAgIHZhciBvcHRzID0gYXhpcy5vcHRpb25zO1xuICAgICAgICAgICAgaWYgKCFheGlzLnRpY2tGb3JtYXR0ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9wdHMudGlja0Zvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBheGlzLnRpY2tGb3JtYXR0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlwiICsgb3B0cy50aWNrRm9ybWF0dGVyLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGF4aXMudGlja0Zvcm1hdHRlciA9IGRlZmF1bHRUaWNrRm9ybWF0dGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNldHVwVGlja0dlbmVyYXRpb24oYXhpcykge1xuICAgICAgICAgICAgdmFyIG9wdHMgPSBheGlzLm9wdGlvbnM7XG4gICAgICAgICAgICB2YXIgbm9UaWNrcztcblxuICAgICAgICAgICAgbm9UaWNrcyA9IGZpeHVwTnVtYmVyT2ZUaWNrcyhheGlzLmRpcmVjdGlvbiwgc3VyZmFjZSwgb3B0cy50aWNrcyk7XG5cbiAgICAgICAgICAgIGF4aXMuZGVsdGEgPSAkLnBsb3Quc2F0dXJhdGVkLmRlbHRhKGF4aXMubWluLCBheGlzLm1heCwgbm9UaWNrcyk7XG4gICAgICAgICAgICB2YXIgcHJlY2lzaW9uID0gcGxvdC5jb21wdXRlVmFsdWVQcmVjaXNpb24oYXhpcy5taW4sIGF4aXMubWF4LCBheGlzLmRpcmVjdGlvbiwgbm9UaWNrcywgb3B0cy50aWNrRGVjaW1hbHMpO1xuXG4gICAgICAgICAgICBheGlzLnRpY2tEZWNpbWFscyA9IE1hdGgubWF4KDAsIG9wdHMudGlja0RlY2ltYWxzICE9IG51bGwgPyBvcHRzLnRpY2tEZWNpbWFscyA6IHByZWNpc2lvbik7XG4gICAgICAgICAgICBheGlzLnRpY2tTaXplID0gZ2V0QXhpc1RpY2tTaXplKGF4aXMubWluLCBheGlzLm1heCwgYXhpcy5kaXJlY3Rpb24sIG9wdHMsIG9wdHMudGlja0RlY2ltYWxzKTtcblxuICAgICAgICAgICAgLy8gRmxvdCBzdXBwb3J0cyBiYXNlLTEwIGF4ZXM7IGFueSBvdGhlciBtb2RlIGVsc2UgaXMgaGFuZGxlZCBieSBhIHBsdWctaW4sXG4gICAgICAgICAgICAvLyBsaWtlIGZsb3QudGltZS5qcy5cblxuICAgICAgICAgICAgaWYgKCFheGlzLnRpY2tHZW5lcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9wdHMudGlja0dlbmVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBheGlzLnRpY2tHZW5lcmF0b3IgPSBvcHRzLnRpY2tHZW5lcmF0b3I7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXhpcy50aWNrR2VuZXJhdG9yID0gZGVmYXVsdFRpY2tHZW5lcmF0b3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3B0cy5hbGlnblRpY2tzV2l0aEF4aXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBvdGhlckF4aXMgPSAoYXhpcy5kaXJlY3Rpb24gPT09IFwieFwiID8geGF4ZXMgOiB5YXhlcylbb3B0cy5hbGlnblRpY2tzV2l0aEF4aXMgLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAob3RoZXJBeGlzICYmIG90aGVyQXhpcy51c2VkICYmIG90aGVyQXhpcyAhPT0gYXhpcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zaWRlciBzbmFwcGluZyBtaW4vbWF4IHRvIG91dGVybW9zdCBuaWNlIHRpY2tzXG4gICAgICAgICAgICAgICAgICAgIHZhciBuaWNlVGlja3MgPSBheGlzLnRpY2tHZW5lcmF0b3IoYXhpcywgcGxvdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuaWNlVGlja3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdHMubWluID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBheGlzLm1pbiA9IE1hdGgubWluKGF4aXMubWluLCBuaWNlVGlja3NbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0cy5tYXggPT0gbnVsbCAmJiBuaWNlVGlja3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF4aXMubWF4ID0gTWF0aC5tYXgoYXhpcy5tYXgsIG5pY2VUaWNrc1tuaWNlVGlja3MubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYXhpcy50aWNrR2VuZXJhdG9yID0gZnVuY3Rpb24oYXhpcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29weSB0aWNrcywgc2NhbGVkIHRvIHRoaXMgYXhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpY2tzID0gW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiwgaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBvdGhlckF4aXMudGlja3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gKG90aGVyQXhpcy50aWNrc1tpXS52IC0gb3RoZXJBeGlzLm1pbikgLyAob3RoZXJBeGlzLm1heCAtIG90aGVyQXhpcy5taW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBheGlzLm1pbiArIHYgKiAoYXhpcy5tYXggLSBheGlzLm1pbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlja3MucHVzaCh2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aWNrcztcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBtaWdodCBuZWVkIGFuIGV4dHJhIGRlY2ltYWwgc2luY2UgZm9yY2VkXG4gICAgICAgICAgICAgICAgICAgIC8vIHRpY2tzIGRvbid0IG5lY2Vzc2FyaWx5IGZpdCBuYXR1cmFsbHlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFheGlzLm1vZGUgJiYgb3B0cy50aWNrRGVjaW1hbHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4dHJhRGVjID0gTWF0aC5tYXgoMCwgLU1hdGguZmxvb3IoTWF0aC5sb2coYXhpcy5kZWx0YSkgLyBNYXRoLkxOMTApICsgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHMgPSBheGlzLnRpY2tHZW5lcmF0b3IoYXhpcywgcGxvdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgcHJvY2VlZCBpZiB0aGUgdGljayBpbnRlcnZhbCByb3VuZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aXRoIGFuIGV4dHJhIGRlY2ltYWwgZG9lc24ndCBnaXZlIHVzIGFcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHplcm8gYXQgZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0cy5sZW5ndGggPiAxICYmIC9cXC4uKjAkLy50ZXN0KCh0c1sxXSAtIHRzWzBdKS50b0ZpeGVkKGV4dHJhRGVjKSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXhpcy50aWNrRGVjaW1hbHMgPSBleHRyYURlYztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNldE1ham9yVGlja3MoYXhpcykge1xuICAgICAgICAgICAgdmFyIG90aWNrcyA9IGF4aXMub3B0aW9ucy50aWNrcyxcbiAgICAgICAgICAgICAgICB0aWNrcyA9IFtdO1xuICAgICAgICAgICAgaWYgKG90aWNrcyA9PSBudWxsIHx8ICh0eXBlb2Ygb3RpY2tzID09PSBcIm51bWJlclwiICYmIG90aWNrcyA+IDApKSB7XG4gICAgICAgICAgICAgICAgdGlja3MgPSBheGlzLnRpY2tHZW5lcmF0b3IoYXhpcywgcGxvdCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG90aWNrcykge1xuICAgICAgICAgICAgICAgIGlmICgkLmlzRnVuY3Rpb24ob3RpY2tzKSkge1xuICAgICAgICAgICAgICAgIC8vIGdlbmVyYXRlIHRoZSB0aWNrc1xuICAgICAgICAgICAgICAgICAgICB0aWNrcyA9IG90aWNrcyhheGlzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aWNrcyA9IG90aWNrcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNsZWFuIHVwL2xhYmVsaWZ5IHRoZSBzdXBwbGllZCB0aWNrcywgY29weSB0aGVtIG92ZXJcbiAgICAgICAgICAgIHZhciBpLCB2O1xuICAgICAgICAgICAgYXhpcy50aWNrcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRpY2tzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhYmVsID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHRpY2tzW2ldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICB2ID0gK3RbMF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsID0gdFsxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHYgPSArdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKHYpKSB7XG4gICAgICAgICAgICAgICAgICAgIGF4aXMudGlja3MucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1RpY2sodiwgbGFiZWwsIGF4aXMsICdtYWpvcicpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBuZXdUaWNrKHYsIGxhYmVsLCBheGlzLCB0eXBlKSB7XG4gICAgICAgICAgICBpZiAobGFiZWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWluJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWF4JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaW1wcm92aW5nIHRoZSBwcmVjaXNpb24gb2YgZW5kcG9pbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJlY2lzaW9uID0gZ2V0RW5kcG9pbnRQcmVjaXNpb24odiwgYXhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbCA9IGlzRmluaXRlKHByZWNpc2lvbikgPyBheGlzLnRpY2tGb3JtYXR0ZXIodiwgYXhpcywgcHJlY2lzaW9uLCBwbG90KSA6IGF4aXMudGlja0Zvcm1hdHRlcih2LCBheGlzLCBwcmVjaXNpb24sIHBsb3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21ham9yJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsID0gYXhpcy50aWNrRm9ybWF0dGVyKHYsIGF4aXMsIHVuZGVmaW5lZCwgcGxvdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2OiB2LFxuICAgICAgICAgICAgICAgIGxhYmVsOiBsYWJlbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNuYXBSYW5nZVRvVGlja3MoYXhpcywgdGlja3MsIHNlcmllcykge1xuICAgICAgICAgICAgdmFyIGFueURhdGFJblNlcmllcyA9IGZ1bmN0aW9uKHNlcmllcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXJpZXMuc29tZShlID0+IGUuZGF0YXBvaW50cy5wb2ludHMubGVuZ3RoID4gMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChheGlzLm9wdGlvbnMuYXV0b1NjYWxlID09PSBcImxvb3NlXCIgJiYgdGlja3MubGVuZ3RoID4gMCAmJiBhbnlEYXRhSW5TZXJpZXMoc2VyaWVzKSkge1xuICAgICAgICAgICAgICAgIC8vIHNuYXAgdG8gdGlja3NcbiAgICAgICAgICAgICAgICBheGlzLm1pbiA9IE1hdGgubWluKGF4aXMubWluLCB0aWNrc1swXS52KTtcbiAgICAgICAgICAgICAgICBheGlzLm1heCA9IE1hdGgubWF4KGF4aXMubWF4LCB0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldEVuZHBvaW50UHJlY2lzaW9uKHZhbHVlLCBheGlzKSB7XG4gICAgICAgICAgICB2YXIgY2FudmFzMSA9IE1hdGguZmxvb3IoYXhpcy5wMmModmFsdWUpKSxcbiAgICAgICAgICAgICAgICBjYW52YXMyID0gYXhpcy5kaXJlY3Rpb24gPT09IFwieFwiID8gY2FudmFzMSArIDEgOiBjYW52YXMxIC0gMSxcbiAgICAgICAgICAgICAgICBwb2ludDEgPSBheGlzLmMycChjYW52YXMxKSxcbiAgICAgICAgICAgICAgICBwb2ludDIgPSBheGlzLmMycChjYW52YXMyKSxcbiAgICAgICAgICAgICAgICBwcmVjaXNpb24gPSBjb21wdXRlVmFsdWVQcmVjaXNpb24ocG9pbnQxLCBwb2ludDIsIGF4aXMuZGlyZWN0aW9uLCAxKTtcblxuICAgICAgICAgICAgcmV0dXJuIHByZWNpc2lvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNldEVuZHBvaW50VGlja3MoYXhpcywgc2VyaWVzKSB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZEVuZHBvaW50VGljayhheGlzLCBzZXJpZXMpKSB7XG4gICAgICAgICAgICAgICAgYXhpcy50aWNrcy51bnNoaWZ0KG5ld1RpY2soYXhpcy5taW4sIG51bGwsIGF4aXMsICdtaW4nKSk7XG4gICAgICAgICAgICAgICAgYXhpcy50aWNrcy5wdXNoKG5ld1RpY2soYXhpcy5tYXgsIG51bGwsIGF4aXMsICdtYXgnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpc1ZhbGlkRW5kcG9pbnRUaWNrKGF4aXMsIHNlcmllcykge1xuICAgICAgICAgICAgaWYgKGF4aXMub3B0aW9ucy5zaG93VGlja0xhYmVscyA9PT0gJ2VuZHBvaW50cycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChheGlzLm9wdGlvbnMuc2hvd1RpY2tMYWJlbHMgPT09ICdhbGwnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFzc29jaWF0ZWRTZXJpZXMgPSBzZXJpZXMuZmlsdGVyKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzLmJhcnMuaG9yaXpvbnRhbCA/IHMueWF4aXMgPT09IGF4aXMgOiBzLnhheGlzID09PSBheGlzO1xuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgbm90QWxsQmFyU2VyaWVzID0gYXNzb2NpYXRlZFNlcmllcy5zb21lKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhcy5iYXJzLnNob3c7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBhc3NvY2lhdGVkU2VyaWVzLmxlbmd0aCA9PT0gMCB8fCBub3RBbGxCYXJTZXJpZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXhpcy5vcHRpb25zLnNob3dUaWNrTGFiZWxzID09PSAnbWFqb3InIHx8IGF4aXMub3B0aW9ucy5zaG93VGlja0xhYmVscyA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZHJhdygpIHtcbiAgICAgICAgICAgIHN1cmZhY2UuY2xlYXIoKTtcbiAgICAgICAgICAgIGV4ZWN1dGVIb29rcyhob29rcy5kcmF3QmFja2dyb3VuZCwgW2N0eF0pO1xuXG4gICAgICAgICAgICB2YXIgZ3JpZCA9IG9wdGlvbnMuZ3JpZDtcblxuICAgICAgICAgICAgLy8gZHJhdyBiYWNrZ3JvdW5kLCBpZiBhbnlcbiAgICAgICAgICAgIGlmIChncmlkLnNob3cgJiYgZ3JpZC5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgICAgICAgICBkcmF3QmFja2dyb3VuZCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZ3JpZC5zaG93ICYmICFncmlkLmFib3ZlRGF0YSkge1xuICAgICAgICAgICAgICAgIGRyYXdHcmlkKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VyaWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgZXhlY3V0ZUhvb2tzKGhvb2tzLmRyYXdTZXJpZXMsIFtjdHgsIHNlcmllc1tpXSwgaSwgZ2V0Q29sb3JPckdyYWRpZW50XSk7XG4gICAgICAgICAgICAgICAgZHJhd1NlcmllcyhzZXJpZXNbaV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleGVjdXRlSG9va3MoaG9va3MuZHJhdywgW2N0eF0pO1xuXG4gICAgICAgICAgICBpZiAoZ3JpZC5zaG93ICYmIGdyaWQuYWJvdmVEYXRhKSB7XG4gICAgICAgICAgICAgICAgZHJhd0dyaWQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3VyZmFjZS5yZW5kZXIoKTtcblxuICAgICAgICAgICAgLy8gQSBkcmF3IGltcGxpZXMgdGhhdCBlaXRoZXIgdGhlIGF4ZXMgb3IgZGF0YSBoYXZlIGNoYW5nZWQsIHNvIHdlXG4gICAgICAgICAgICAvLyBzaG91bGQgcHJvYmFibHkgdXBkYXRlIHRoZSBvdmVybGF5IGhpZ2hsaWdodHMgYXMgd2VsbC5cbiAgICAgICAgICAgIHRyaWdnZXJSZWRyYXdPdmVybGF5KCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBleHRyYWN0UmFuZ2UocmFuZ2VzLCBjb29yZCkge1xuICAgICAgICAgICAgdmFyIGF4aXMsIGZyb20sIHRvLCBrZXksIGF4ZXMgPSBhbGxBeGVzKCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGF4aXMgPSBheGVzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChheGlzLmRpcmVjdGlvbiA9PT0gY29vcmQpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gY29vcmQgKyBheGlzLm4gKyBcImF4aXNcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyYW5nZXNba2V5XSAmJiBheGlzLm4gPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN1cHBvcnQgeDFheGlzIGFzIHhheGlzXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBjb29yZCArIFwiYXhpc1wiO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tID0gcmFuZ2VzW2tleV0uZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvID0gcmFuZ2VzW2tleV0udG87XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYmFja3dhcmRzLWNvbXBhdCBzdHVmZiAtIHRvIGJlIHJlbW92ZWQgaW4gZnV0dXJlXG4gICAgICAgICAgICBpZiAoIXJhbmdlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgYXhpcyA9IGNvb3JkID09PSBcInhcIiA/IHhheGVzWzBdIDogeWF4ZXNbMF07XG4gICAgICAgICAgICAgICAgZnJvbSA9IHJhbmdlc1tjb29yZCArIFwiMVwiXTtcbiAgICAgICAgICAgICAgICB0byA9IHJhbmdlc1tjb29yZCArIFwiMlwiXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYXV0by1yZXZlcnNlIGFzIGFuIGFkZGVkIGJvbnVzXG4gICAgICAgICAgICBpZiAoZnJvbSAhPSBudWxsICYmIHRvICE9IG51bGwgJiYgZnJvbSA+IHRvKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRtcCA9IGZyb207XG4gICAgICAgICAgICAgICAgZnJvbSA9IHRvO1xuICAgICAgICAgICAgICAgIHRvID0gdG1wO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZyb206IGZyb20sXG4gICAgICAgICAgICAgICAgdG86IHRvLFxuICAgICAgICAgICAgICAgIGF4aXM6IGF4aXNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBkcmF3QmFja2dyb3VuZCgpIHtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKHBsb3RPZmZzZXQubGVmdCwgcGxvdE9mZnNldC50b3ApO1xuXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZ2V0Q29sb3JPckdyYWRpZW50KG9wdGlvbnMuZ3JpZC5iYWNrZ3JvdW5kQ29sb3IsIHBsb3RIZWlnaHQsIDAsIFwicmdiYSgyNTUsIDI1NSwgMjU1LCAwKVwiKTtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBwbG90V2lkdGgsIHBsb3RIZWlnaHQpO1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGRyYXdNYXJraW5ncygpIHtcbiAgICAgICAgICAgIC8vIGRyYXcgbWFya2luZ3NcbiAgICAgICAgICAgIHZhciBtYXJraW5ncyA9IG9wdGlvbnMuZ3JpZC5tYXJraW5ncyxcbiAgICAgICAgICAgICAgICBheGVzO1xuXG4gICAgICAgICAgICBpZiAobWFya2luZ3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoJC5pc0Z1bmN0aW9uKG1hcmtpbmdzKSkge1xuICAgICAgICAgICAgICAgICAgICBheGVzID0gcGxvdC5nZXRBeGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHhtaW4gZXRjLiBpcyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgdG8gYmVcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlZCBpbiB0aGUgZnV0dXJlXG4gICAgICAgICAgICAgICAgICAgIGF4ZXMueG1pbiA9IGF4ZXMueGF4aXMubWluO1xuICAgICAgICAgICAgICAgICAgICBheGVzLnhtYXggPSBheGVzLnhheGlzLm1heDtcbiAgICAgICAgICAgICAgICAgICAgYXhlcy55bWluID0gYXhlcy55YXhpcy5taW47XG4gICAgICAgICAgICAgICAgICAgIGF4ZXMueW1heCA9IGF4ZXMueWF4aXMubWF4O1xuXG4gICAgICAgICAgICAgICAgICAgIG1hcmtpbmdzID0gbWFya2luZ3MoYXhlcyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG1hcmtpbmdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtID0gbWFya2luZ3NbaV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB4cmFuZ2UgPSBleHRyYWN0UmFuZ2UobSwgXCJ4XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgeXJhbmdlID0gZXh0cmFjdFJhbmdlKG0sIFwieVwiKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBmaWxsIGluIG1pc3NpbmdcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhyYW5nZS5mcm9tID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhyYW5nZS5mcm9tID0geHJhbmdlLmF4aXMubWluO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHhyYW5nZS50byA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4cmFuZ2UudG8gPSB4cmFuZ2UuYXhpcy5tYXg7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoeXJhbmdlLmZyb20gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeXJhbmdlLmZyb20gPSB5cmFuZ2UuYXhpcy5taW47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoeXJhbmdlLnRvID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlyYW5nZS50byA9IHlyYW5nZS5heGlzLm1heDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNsaXBcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhyYW5nZS50byA8IHhyYW5nZS5heGlzLm1pbiB8fCB4cmFuZ2UuZnJvbSA+IHhyYW5nZS5heGlzLm1heCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgeXJhbmdlLnRvIDwgeXJhbmdlLmF4aXMubWluIHx8IHlyYW5nZS5mcm9tID4geXJhbmdlLmF4aXMubWF4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHhyYW5nZS5mcm9tID0gTWF0aC5tYXgoeHJhbmdlLmZyb20sIHhyYW5nZS5heGlzLm1pbik7XG4gICAgICAgICAgICAgICAgICAgIHhyYW5nZS50byA9IE1hdGgubWluKHhyYW5nZS50bywgeHJhbmdlLmF4aXMubWF4KTtcbiAgICAgICAgICAgICAgICAgICAgeXJhbmdlLmZyb20gPSBNYXRoLm1heCh5cmFuZ2UuZnJvbSwgeXJhbmdlLmF4aXMubWluKTtcbiAgICAgICAgICAgICAgICAgICAgeXJhbmdlLnRvID0gTWF0aC5taW4oeXJhbmdlLnRvLCB5cmFuZ2UuYXhpcy5tYXgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB4ZXF1YWwgPSB4cmFuZ2UuZnJvbSA9PT0geHJhbmdlLnRvLFxuICAgICAgICAgICAgICAgICAgICAgICAgeWVxdWFsID0geXJhbmdlLmZyb20gPT09IHlyYW5nZS50bztcblxuICAgICAgICAgICAgICAgICAgICBpZiAoeGVxdWFsICYmIHllcXVhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyB0aGVuIGRyYXdcbiAgICAgICAgICAgICAgICAgICAgeHJhbmdlLmZyb20gPSBNYXRoLmZsb29yKHhyYW5nZS5heGlzLnAyYyh4cmFuZ2UuZnJvbSkpO1xuICAgICAgICAgICAgICAgICAgICB4cmFuZ2UudG8gPSBNYXRoLmZsb29yKHhyYW5nZS5heGlzLnAyYyh4cmFuZ2UudG8pKTtcbiAgICAgICAgICAgICAgICAgICAgeXJhbmdlLmZyb20gPSBNYXRoLmZsb29yKHlyYW5nZS5heGlzLnAyYyh5cmFuZ2UuZnJvbSkpO1xuICAgICAgICAgICAgICAgICAgICB5cmFuZ2UudG8gPSBNYXRoLmZsb29yKHlyYW5nZS5heGlzLnAyYyh5cmFuZ2UudG8pKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoeGVxdWFsIHx8IHllcXVhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVXaWR0aCA9IG0ubGluZVdpZHRoIHx8IG9wdGlvbnMuZ3JpZC5tYXJraW5nc0xpbmVXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJQaXhlbCA9IGxpbmVXaWR0aCAlIDIgPyAwLjUgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gbS5jb2xvciB8fCBvcHRpb25zLmdyaWQubWFya2luZ3NDb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeGVxdWFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh4cmFuZ2UudG8gKyBzdWJQaXhlbCwgeXJhbmdlLmZyb20pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeHJhbmdlLnRvICsgc3ViUGl4ZWwsIHlyYW5nZS50byk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oeHJhbmdlLmZyb20sIHlyYW5nZS50byArIHN1YlBpeGVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHhyYW5nZS50bywgeXJhbmdlLnRvICsgc3ViUGl4ZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG0uY29sb3IgfHwgb3B0aW9ucy5ncmlkLm1hcmtpbmdzQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoeHJhbmdlLmZyb20sIHlyYW5nZS50byxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4cmFuZ2UudG8gLSB4cmFuZ2UuZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5cmFuZ2UuZnJvbSAtIHlyYW5nZS50byk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBmaW5kRWRnZXMoYXhpcykge1xuICAgICAgICAgICAgdmFyIGJveCA9IGF4aXMuYm94LFxuICAgICAgICAgICAgICAgIHggPSAwLFxuICAgICAgICAgICAgICAgIHkgPSAwO1xuXG4gICAgICAgICAgICAvLyBmaW5kIHRoZSBlZGdlc1xuICAgICAgICAgICAgaWYgKGF4aXMuZGlyZWN0aW9uID09PSBcInhcIikge1xuICAgICAgICAgICAgICAgIHggPSAwO1xuICAgICAgICAgICAgICAgIHkgPSBib3gudG9wIC0gcGxvdE9mZnNldC50b3AgKyAoYXhpcy5wb3NpdGlvbiA9PT0gXCJ0b3BcIiA/IGJveC5oZWlnaHQgOiAwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeSA9IDA7XG4gICAgICAgICAgICAgICAgeCA9IGJveC5sZWZ0IC0gcGxvdE9mZnNldC5sZWZ0ICsgKGF4aXMucG9zaXRpb24gPT09IFwibGVmdFwiID8gYm94LndpZHRoIDogMCkgKyBheGlzLmJveFBvc2l0aW9uLmNlbnRlclg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgICB5OiB5XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGFsaWduUG9zaXRpb24obGluZVdpZHRoLCBwb3MpIHtcbiAgICAgICAgICAgIHJldHVybiAoKGxpbmVXaWR0aCAlIDIpICE9PSAwKSA/IE1hdGguZmxvb3IocG9zKSArIDAuNSA6IHBvcztcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBkcmF3VGlja0JhcihheGlzKSB7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMTtcbiAgICAgICAgICAgIHZhciBlZGdlcyA9IGZpbmRFZGdlcyhheGlzKSxcbiAgICAgICAgICAgICAgICB4ID0gZWRnZXMueCxcbiAgICAgICAgICAgICAgICB5ID0gZWRnZXMueTtcblxuICAgICAgICAgICAgLy8gZHJhdyB0aWNrIGJhclxuICAgICAgICAgICAgaWYgKGF4aXMuc2hvdykge1xuICAgICAgICAgICAgICAgIHZhciB4b2ZmID0gMCxcbiAgICAgICAgICAgICAgICAgICAgeW9mZiA9IDA7XG5cbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBheGlzLm9wdGlvbnMuY29sb3I7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGlmIChheGlzLmRpcmVjdGlvbiA9PT0gXCJ4XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgeG9mZiA9IHBsb3RXaWR0aCArIDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeW9mZiA9IHBsb3RIZWlnaHQgKyAxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChheGlzLmRpcmVjdGlvbiA9PT0gXCJ4XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgeSA9IGFsaWduUG9zaXRpb24oY3R4LmxpbmVXaWR0aCwgeSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IGFsaWduUG9zaXRpb24oY3R4LmxpbmVXaWR0aCwgeCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHggKyB4b2ZmLCB5ICsgeW9mZik7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGRyYXdUaWNrTWFya3MoYXhpcykge1xuICAgICAgICAgICAgdmFyIHQgPSBheGlzLnRpY2tMZW5ndGgsXG4gICAgICAgICAgICAgICAgbWlub3JUaWNrcyA9IGF4aXMuc2hvd01pbm9yVGlja3MsXG4gICAgICAgICAgICAgICAgbWlub3JUaWNrc05yID0gTUlOT1JfVElDS1NfQ09VTlRfQ09OU1RBTlQsXG4gICAgICAgICAgICAgICAgZWRnZXMgPSBmaW5kRWRnZXMoYXhpcyksXG4gICAgICAgICAgICAgICAgeCA9IGVkZ2VzLngsXG4gICAgICAgICAgICAgICAgeSA9IGVkZ2VzLnksXG4gICAgICAgICAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgICAgIC8vIGRyYXcgbWFqb3IgdGljayBtYXJrc1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gYXhpcy5vcHRpb25zLmNvbG9yO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXhpcy50aWNrcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciB2ID0gYXhpcy50aWNrc1tpXS52LFxuICAgICAgICAgICAgICAgICAgICB4b2ZmID0gMCxcbiAgICAgICAgICAgICAgICAgICAgeW9mZiA9IDAsXG4gICAgICAgICAgICAgICAgICAgIHhtaW5vciA9IDAsXG4gICAgICAgICAgICAgICAgICAgIHltaW5vciA9IDAsXG4gICAgICAgICAgICAgICAgICAgIGo7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKHYpICYmIHYgPj0gYXhpcy5taW4gJiYgdiA8PSBheGlzLm1heCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXhpcy5kaXJlY3Rpb24gPT09IFwieFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gYXhpcy5wMmModik7XG4gICAgICAgICAgICAgICAgICAgICAgICB5b2ZmID0gdDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF4aXMucG9zaXRpb24gPT09IFwidG9wXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5b2ZmID0gLXlvZmY7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gYXhpcy5wMmModik7XG4gICAgICAgICAgICAgICAgICAgICAgICB4b2ZmID0gdDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF4aXMucG9zaXRpb24gPT09IFwibGVmdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeG9mZiA9IC14b2ZmO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGF4aXMuZGlyZWN0aW9uID09PSBcInhcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGFsaWduUG9zaXRpb24oY3R4LmxpbmVXaWR0aCwgeCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gYWxpZ25Qb3NpdGlvbihjdHgubGluZVdpZHRoLCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIHhvZmYsIHkgKyB5b2ZmKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL2RyYXcgbWlub3IgdGljayBtYXJrc1xuICAgICAgICAgICAgICAgIGlmIChtaW5vclRpY2tzID09PSB0cnVlICYmIGkgPCBheGlzLnRpY2tzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHYxID0gYXhpcy50aWNrc1tpXS52LFxuICAgICAgICAgICAgICAgICAgICAgICAgdjIgPSBheGlzLnRpY2tzW2kgKyAxXS52LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RlcCA9ICh2MiAtIHYxKSAvIChtaW5vclRpY2tzTnIgKyAxKTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAxOyBqIDw9IG1pbm9yVGlja3NOcjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb21wdXRlIG1pbm9yIHRpY2sgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChheGlzLmRpcmVjdGlvbiA9PT0gXCJ4XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5bWlub3IgPSB0IC8gMjsgLy8gbWlub3IgdGlja3MgYXJlIGhhbGYgbGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGFsaWduUG9zaXRpb24oY3R4LmxpbmVXaWR0aCwgYXhpcy5wMmModjEgKyBqICogc3RlcCkpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXhpcy5wb3NpdGlvbiA9PT0gXCJ0b3BcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5bWlub3IgPSAteW1pbm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IGdvIG92ZXIgdGhlIHBsb3QgYm9yZGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoeCA8IDApIHx8ICh4ID4gcGxvdFdpZHRoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhtaW5vciA9IHQgLyAyOyAvLyBtaW5vciB0aWNrcyBhcmUgaGFsZiBsZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ID0gYWxpZ25Qb3NpdGlvbihjdHgubGluZVdpZHRoLCBheGlzLnAyYyh2MSArIGogKiBzdGVwKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXhpcy5wb3NpdGlvbiA9PT0gXCJsZWZ0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeG1pbm9yID0gLXhtaW5vcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBnbyBvdmVyIHRoZSBwbG90IGJvcmRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHkgPCAwKSB8fCAoeSA+IHBsb3RIZWlnaHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIHhtaW5vciwgeSArIHltaW5vcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBkcmF3R3JpZExpbmVzKGF4aXMpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBsaW5lIHdpbGwgYmUgb3ZlcmxhcHBlZCB3aXRoIGEgYm9yZGVyXG4gICAgICAgICAgICB2YXIgb3ZlcmxhcHBlZFdpdGhCb3JkZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYncgPSBvcHRpb25zLmdyaWQuYm9yZGVyV2lkdGg7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgoKHR5cGVvZiBidyA9PT0gXCJvYmplY3RcIiAmJiBid1theGlzLnBvc2l0aW9uXSA+IDApIHx8IGJ3ID4gMCkgJiYgKHZhbHVlID09PSBheGlzLm1pbiB8fCB2YWx1ZSA9PT0gYXhpcy5tYXgpKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuZ3JpZC50aWNrQ29sb3I7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBheGlzLnRpY2tzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHYgPSBheGlzLnRpY2tzW2ldLnYsXG4gICAgICAgICAgICAgICAgICAgIHhvZmYgPSAwLFxuICAgICAgICAgICAgICAgICAgICB5b2ZmID0gMCxcbiAgICAgICAgICAgICAgICAgICAgeCA9IDAsXG4gICAgICAgICAgICAgICAgICAgIHkgPSAwO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKHYpIHx8IHYgPCBheGlzLm1pbiB8fCB2ID4gYXhpcy5tYXgpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgLy8gc2tpcCB0aG9zZSBseWluZyBvbiB0aGUgYXhlcyBpZiB3ZSBnb3QgYSBib3JkZXJcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxhcHBlZFdpdGhCb3JkZXIodikpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGF4aXMuZGlyZWN0aW9uID09PSBcInhcIikge1xuICAgICAgICAgICAgICAgICAgICB4ID0gYXhpcy5wMmModik7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBwbG90SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB5b2ZmID0gLXBsb3RIZWlnaHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBheGlzLnAyYyh2KTtcbiAgICAgICAgICAgICAgICAgICAgeG9mZiA9IHBsb3RXaWR0aDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYXhpcy5kaXJlY3Rpb24gPT09IFwieFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSBhbGlnblBvc2l0aW9uKGN0eC5saW5lV2lkdGgsIHgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBhbGlnblBvc2l0aW9uKGN0eC5saW5lV2lkdGgsIHkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgeG9mZiwgeSArIHlvZmYpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gZHJhd0JvcmRlcigpIHtcbiAgICAgICAgICAgIC8vIElmIGVpdGhlciBib3JkZXJXaWR0aCBvciBib3JkZXJDb2xvciBpcyBhbiBvYmplY3QsIHRoZW4gZHJhdyB0aGUgYm9yZGVyXG4gICAgICAgICAgICAvLyBsaW5lIGJ5IGxpbmUgaW5zdGVhZCBvZiBhcyBvbmUgcmVjdGFuZ2xlXG4gICAgICAgICAgICB2YXIgYncgPSBvcHRpb25zLmdyaWQuYm9yZGVyV2lkdGgsXG4gICAgICAgICAgICAgICAgYmMgPSBvcHRpb25zLmdyaWQuYm9yZGVyQ29sb3I7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgYncgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGJjID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBidyAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICBidyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogYncsXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogYncsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b206IGJ3LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogYndcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBiYyAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICBiYyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogYmMsXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogYmMsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b206IGJjLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogYmNcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYncudG9wID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBiYy50b3A7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBidy50b3A7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbygwIC0gYncubGVmdCwgMCAtIGJ3LnRvcCAvIDIpO1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHBsb3RXaWR0aCwgMCAtIGJ3LnRvcCAvIDIpO1xuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGJ3LnJpZ2h0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBiYy5yaWdodDtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGJ3LnJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8ocGxvdFdpZHRoICsgYncucmlnaHQgLyAyLCAwIC0gYncudG9wKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhwbG90V2lkdGggKyBidy5yaWdodCAvIDIsIHBsb3RIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGJ3LmJvdHRvbSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gYmMuYm90dG9tO1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gYncuYm90dG9tO1xuICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8ocGxvdFdpZHRoICsgYncucmlnaHQsIHBsb3RIZWlnaHQgKyBidy5ib3R0b20gLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbygwLCBwbG90SGVpZ2h0ICsgYncuYm90dG9tIC8gMik7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYncubGVmdCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gYmMubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGJ3LmxlZnQ7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbygwIC0gYncubGVmdCAvIDIsIHBsb3RIZWlnaHQgKyBidy5ib3R0b20pO1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKDAgLSBidy5sZWZ0IC8gMiwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBidztcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLmdyaWQuYm9yZGVyQ29sb3I7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVJlY3QoLWJ3IC8gMiwgLWJ3IC8gMiwgcGxvdFdpZHRoICsgYncsIHBsb3RIZWlnaHQgKyBidyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gZHJhd0dyaWQoKSB7XG4gICAgICAgICAgICB2YXIgYXhlcywgYnc7XG5cbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKHBsb3RPZmZzZXQubGVmdCwgcGxvdE9mZnNldC50b3ApO1xuXG4gICAgICAgICAgICBkcmF3TWFya2luZ3MoKTtcblxuICAgICAgICAgICAgYXhlcyA9IGFsbEF4ZXMoKTtcbiAgICAgICAgICAgIGJ3ID0gb3B0aW9ucy5ncmlkLmJvcmRlcldpZHRoO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGF4ZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICB2YXIgYXhpcyA9IGF4ZXNbal07XG5cbiAgICAgICAgICAgICAgICBpZiAoIWF4aXMuc2hvdykge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkcmF3VGlja0JhcihheGlzKTtcbiAgICAgICAgICAgICAgICBpZiAoYXhpcy5zaG93VGlja3MgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhd1RpY2tNYXJrcyhheGlzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYXhpcy5ncmlkTGluZXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhd0dyaWRMaW5lcyhheGlzLCBidyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBkcmF3IGJvcmRlclxuICAgICAgICAgICAgaWYgKGJ3KSB7XG4gICAgICAgICAgICAgICAgZHJhd0JvcmRlcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZHJhd0F4aXNMYWJlbHMoKSB7XG4gICAgICAgICAgICAkLmVhY2goYWxsQXhlcygpLCBmdW5jdGlvbihfLCBheGlzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJveCA9IGF4aXMuYm94LFxuICAgICAgICAgICAgICAgICAgICBsZWdhY3lTdHlsZXMgPSBheGlzLmRpcmVjdGlvbiArIFwiQXhpcyBcIiArIGF4aXMuZGlyZWN0aW9uICsgYXhpcy5uICsgXCJBeGlzXCIsXG4gICAgICAgICAgICAgICAgICAgIGxheWVyID0gXCJmbG90LVwiICsgYXhpcy5kaXJlY3Rpb24gKyBcIi1heGlzIGZsb3QtXCIgKyBheGlzLmRpcmVjdGlvbiArIGF4aXMubiArIFwiLWF4aXMgXCIgKyBsZWdhY3lTdHlsZXMsXG4gICAgICAgICAgICAgICAgICAgIGZvbnQgPSBheGlzLm9wdGlvbnMuZm9udCB8fCBcImZsb3QtdGljay1sYWJlbCB0aWNrTGFiZWxcIixcbiAgICAgICAgICAgICAgICAgICAgaSwgeCwgeSwgaGFsaWduLCB2YWxpZ24sIGluZm8sXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbiA9IDMsXG4gICAgICAgICAgICAgICAgICAgIG51bGxCb3ggPSB7eDogTmFOLCB5OiBOYU4sIHdpZHRoOiBOYU4sIGhlaWdodDogTmFOfSwgbmV3TGFiZWxCb3gsIGxhYmVsQm94ZXMgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcHBpbmcgPSBmdW5jdGlvbih4MTEsIHkxMSwgeDEyLCB5MTIsIHgyMSwgeTIxLCB4MjIsIHkyMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgoeDExIDw9IHgyMSAmJiB4MjEgPD0geDEyKSB8fCAoeDIxIDw9IHgxMSAmJiB4MTEgPD0geDIyKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKHkxMSA8PSB5MjEgJiYgeTIxIDw9IHkxMikgfHwgKHkyMSA8PSB5MTEgJiYgeTExIDw9IHkyMikpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvdmVybGFwc090aGVyTGFiZWxzID0gZnVuY3Rpb24obmV3TGFiZWxCb3gsIHByZXZpb3VzTGFiZWxCb3hlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzTGFiZWxCb3hlcy5zb21lKGZ1bmN0aW9uKGxhYmVsQm94KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG92ZXJsYXBwaW5nKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdMYWJlbEJveC54LCBuZXdMYWJlbEJveC55LCBuZXdMYWJlbEJveC54ICsgbmV3TGFiZWxCb3gud2lkdGgsIG5ld0xhYmVsQm94LnkgKyBuZXdMYWJlbEJveC5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsQm94LngsIGxhYmVsQm94LnksIGxhYmVsQm94LnggKyBsYWJlbEJveC53aWR0aCwgbGFiZWxCb3gueSArIGxhYmVsQm94LmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZHJhd0F4aXNMYWJlbCA9IGZ1bmN0aW9uICh0aWNrLCBsYWJlbEJveGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRpY2sgfHwgIXRpY2subGFiZWwgfHwgdGljay52IDwgYXhpcy5taW4gfHwgdGljay52ID4gYXhpcy5tYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbEJveDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaW5mbyA9IHN1cmZhY2UuZ2V0VGV4dEluZm8obGF5ZXIsIHRpY2subGFiZWwsIGZvbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXhpcy5kaXJlY3Rpb24gPT09IFwieFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gcGxvdE9mZnNldC5sZWZ0ICsgYXhpcy5wMmModGljay52KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXhpcy5wb3NpdGlvbiA9PT0gXCJib3R0b21cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ID0gYm94LnRvcCArIGJveC5wYWRkaW5nIC0gYXhpcy5ib3hQb3NpdGlvbi5jZW50ZXJZO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBib3gudG9wICsgYm94LmhlaWdodCAtIGJveC5wYWRkaW5nICsgYXhpcy5ib3hQb3NpdGlvbi5jZW50ZXJZO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZ24gPSBcImJvdHRvbVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdMYWJlbEJveCA9IHt4OiB4IC0gaW5mby53aWR0aCAvIDIgLSBtYXJnaW4sIHk6IHkgLSBtYXJnaW4sIHdpZHRoOiBpbmZvLndpZHRoICsgMiAqIG1hcmdpbiwgaGVpZ2h0OiBpbmZvLmhlaWdodCArIDIgKiBtYXJnaW59O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZ24gPSBcIm1pZGRsZVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBwbG90T2Zmc2V0LnRvcCArIGF4aXMucDJjKHRpY2sudik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF4aXMucG9zaXRpb24gPT09IFwibGVmdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBib3gubGVmdCArIGJveC53aWR0aCAtIGJveC5wYWRkaW5nIC0gYXhpcy5ib3hQb3NpdGlvbi5jZW50ZXJYO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYWxpZ24gPSBcInJpZ2h0XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGJveC5sZWZ0ICsgYm94LnBhZGRpbmcgKyBheGlzLmJveFBvc2l0aW9uLmNlbnRlclg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0xhYmVsQm94ID0ge3g6IHggLSBpbmZvLndpZHRoIC8gMiAtIG1hcmdpbiwgeTogeSAtIG1hcmdpbiwgd2lkdGg6IGluZm8ud2lkdGggKyAyICogbWFyZ2luLCBoZWlnaHQ6IGluZm8uaGVpZ2h0ICsgMiAqIG1hcmdpbn07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdmVybGFwc090aGVyTGFiZWxzKG5ld0xhYmVsQm94LCBsYWJlbEJveGVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsQm94O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBzdXJmYWNlLmFkZFRleHQobGF5ZXIsIHgsIHksIHRpY2subGFiZWwsIGZvbnQsIG51bGwsIG51bGwsIGhhbGlnbiwgdmFsaWduKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld0xhYmVsQm94O1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRleHQgYmVmb3JlIGNoZWNraW5nIGZvciBheGlzLnNob3cgYW5kIHRpY2tzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgcGx1Z2lucywgbGlrZSBmbG90LXRpY2tyb3RvciwgdGhhdCBkcmF3IHRoZWlyIG93blxuICAgICAgICAgICAgICAgIC8vIHRpY2sgbGFiZWxzIHdpbGwgZW5kIHVwIHdpdGggYm90aCB0aGVpcnMgYW5kIHRoZSBkZWZhdWx0cy5cblxuICAgICAgICAgICAgICAgIHN1cmZhY2UucmVtb3ZlVGV4dChsYXllcik7XG5cbiAgICAgICAgICAgICAgICBleGVjdXRlSG9va3MoaG9va3MuZHJhd0F4aXMsIFtheGlzLCBzdXJmYWNlXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWF4aXMuc2hvdykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3dpdGNoIChheGlzLm9wdGlvbnMuc2hvd1RpY2tMYWJlbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbm9uZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZW5kcG9pbnRzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsQm94ZXMucHVzaChkcmF3QXhpc0xhYmVsKGF4aXMudGlja3NbMF0sIGxhYmVsQm94ZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsQm94ZXMucHVzaChkcmF3QXhpc0xhYmVsKGF4aXMudGlja3NbYXhpcy50aWNrcy5sZW5ndGggLSAxXSwgbGFiZWxCb3hlcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21ham9yJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsQm94ZXMucHVzaChkcmF3QXhpc0xhYmVsKGF4aXMudGlja3NbMF0sIGxhYmVsQm94ZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsQm94ZXMucHVzaChkcmF3QXhpc0xhYmVsKGF4aXMudGlja3NbYXhpcy50aWNrcy5sZW5ndGggLSAxXSwgbGFiZWxCb3hlcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IGF4aXMudGlja3MubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxCb3hlcy5wdXNoKGRyYXdBeGlzTGFiZWwoYXhpcy50aWNrc1tpXSwgbGFiZWxCb3hlcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2FsbCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbEJveGVzLnB1c2goZHJhd0F4aXNMYWJlbChheGlzLnRpY2tzWzBdLCBbXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxCb3hlcy5wdXNoKGRyYXdBeGlzTGFiZWwoYXhpcy50aWNrc1theGlzLnRpY2tzLmxlbmd0aCAtIDFdLCBsYWJlbEJveGVzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgYXhpcy50aWNrcy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbEJveGVzLnB1c2goZHJhd0F4aXNMYWJlbChheGlzLnRpY2tzW2ldLCBsYWJlbEJveGVzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGRyYXdTZXJpZXMoc2VyaWVzKSB7XG4gICAgICAgICAgICBpZiAoc2VyaWVzLmxpbmVzLnNob3cpIHtcbiAgICAgICAgICAgICAgICAkLnBsb3QuZHJhd1Nlcmllcy5kcmF3U2VyaWVzTGluZXMoc2VyaWVzLCBjdHgsIHBsb3RPZmZzZXQsIHBsb3RXaWR0aCwgcGxvdEhlaWdodCwgcGxvdC5kcmF3U3ltYm9sLCBnZXRDb2xvck9yR3JhZGllbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2VyaWVzLmJhcnMuc2hvdykge1xuICAgICAgICAgICAgICAgICQucGxvdC5kcmF3U2VyaWVzLmRyYXdTZXJpZXNCYXJzKHNlcmllcywgY3R4LCBwbG90T2Zmc2V0LCBwbG90V2lkdGgsIHBsb3RIZWlnaHQsIHBsb3QuZHJhd1N5bWJvbCwgZ2V0Q29sb3JPckdyYWRpZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlcmllcy5wb2ludHMuc2hvdykge1xuICAgICAgICAgICAgICAgICQucGxvdC5kcmF3U2VyaWVzLmRyYXdTZXJpZXNQb2ludHMoc2VyaWVzLCBjdHgsIHBsb3RPZmZzZXQsIHBsb3RXaWR0aCwgcGxvdEhlaWdodCwgcGxvdC5kcmF3U3ltYm9sLCBnZXRDb2xvck9yR3JhZGllbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY29tcHV0ZVJhbmdlRm9yRGF0YVNlcmllcyhzZXJpZXMsIGZvcmNlLCBpc1ZhbGlkKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gc2VyaWVzLmRhdGFwb2ludHMucG9pbnRzLFxuICAgICAgICAgICAgICAgIHBzID0gc2VyaWVzLmRhdGFwb2ludHMucG9pbnRzaXplLFxuICAgICAgICAgICAgICAgIGZvcm1hdCA9IHNlcmllcy5kYXRhcG9pbnRzLmZvcm1hdCxcbiAgICAgICAgICAgICAgICB0b3BTZW50cnkgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgICAgICAgICAgICAgYm90dG9tU2VudHJ5ID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLFxuICAgICAgICAgICAgICAgIHJhbmdlID0ge1xuICAgICAgICAgICAgICAgICAgICB4bWluOiB0b3BTZW50cnksXG4gICAgICAgICAgICAgICAgICAgIHltaW46IHRvcFNlbnRyeSxcbiAgICAgICAgICAgICAgICAgICAgeG1heDogYm90dG9tU2VudHJ5LFxuICAgICAgICAgICAgICAgICAgICB5bWF4OiBib3R0b21TZW50cnlcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBvaW50cy5sZW5ndGg7IGogKz0gcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocG9pbnRzW2pdID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGlzVmFsaWQpID09PSAnZnVuY3Rpb24nICYmICFpc1ZhbGlkKHBvaW50c1tqXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbSA9IDA7IG0gPCBwczsgKyttKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBwb2ludHNbaiArIG1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgZiA9IGZvcm1hdFttXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGYgPT09IG51bGwgfHwgZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGlzVmFsaWQpID09PSAnZnVuY3Rpb24nICYmICFpc1ZhbGlkKHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCghZm9yY2UgJiYgIWYuY29tcHV0ZVJhbmdlKSB8fCB2YWwgPT09IEluZmluaXR5IHx8IHZhbCA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChmLnggPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPCByYW5nZS54bWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UueG1pbiA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA+IHJhbmdlLnhtYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZS54bWF4ID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGYueSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA8IHJhbmdlLnltaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZS55bWluID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsID4gcmFuZ2UueW1heCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlLnltYXggPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBhZGp1c3RTZXJpZXNEYXRhUmFuZ2Uoc2VyaWVzLCByYW5nZSkge1xuICAgICAgICAgICAgaWYgKHNlcmllcy5iYXJzLnNob3cpIHtcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgd2UgZ290IHJvb20gZm9yIHRoZSBiYXIgb24gdGhlIGRhbmNpbmcgZmxvb3JcbiAgICAgICAgICAgICAgICB2YXIgZGVsdGE7XG5cbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgYmFyIHdpZHRoIGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgIHZhciB1c2VBYnNvbHV0ZUJhcldpZHRoID0gc2VyaWVzLmJhcnMuYmFyV2lkdGhbMV07XG4gICAgICAgICAgICAgICAgaWYgKHNlcmllcy5kYXRhcG9pbnRzICYmIHNlcmllcy5kYXRhcG9pbnRzLnBvaW50cyAmJiAhdXNlQWJzb2x1dGVCYXJXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb21wdXRlQmFyV2lkdGgoc2VyaWVzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgYmFyV2lkdGggPSBzZXJpZXMuYmFycy5iYXJXaWR0aFswXSB8fCBzZXJpZXMuYmFycy5iYXJXaWR0aDtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHNlcmllcy5iYXJzLmFsaWduKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWx0YSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWx0YSA9IC1iYXJXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGEgPSAtYmFyV2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzZXJpZXMuYmFycy5ob3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnltaW4gKz0gZGVsdGE7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnltYXggKz0gZGVsdGEgKyBiYXJXaWR0aDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByYW5nZS54bWluICs9IGRlbHRhO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS54bWF4ICs9IGRlbHRhICsgYmFyV2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoKHNlcmllcy5iYXJzLnNob3cgJiYgc2VyaWVzLmJhcnMuemVybykgfHwgKHNlcmllcy5saW5lcy5zaG93ICYmIHNlcmllcy5saW5lcy56ZXJvKSkge1xuICAgICAgICAgICAgICAgIHZhciBwcyA9IHNlcmllcy5kYXRhcG9pbnRzLnBvaW50c2l6ZTtcblxuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgMCBwb2ludCBpcyBpbmNsdWRlZCBpbiB0aGUgY29tcHV0ZWQgeSByYW5nZSB3aGVuIHJlcXVlc3RlZFxuICAgICAgICAgICAgICAgIGlmIChwcyA8PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qaWYgcHMgPiAwIHRoZSBwb2ludHMgd2VyZSBhbHJlYWR5IHRha2VuIGludG8gYWNjb3VudCBmb3IgYXV0b1NjYWxlICovXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnltaW4gPSBNYXRoLm1pbigwLCByYW5nZS55bWluKTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UueW1heCA9IE1hdGgubWF4KDAsIHJhbmdlLnltYXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVCYXJXaWR0aChzZXJpZXMpIHtcbiAgICAgICAgICAgIHZhciB4VmFsdWVzID0gW107XG4gICAgICAgICAgICB2YXIgcG9pbnRzaXplID0gc2VyaWVzLmRhdGFwb2ludHMucG9pbnRzaXplLCBtaW5EaXN0YW5jZSA9IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgICAgICAgICAgIGlmIChzZXJpZXMuZGF0YXBvaW50cy5wb2ludHMubGVuZ3RoIDw9IHBvaW50c2l6ZSkge1xuICAgICAgICAgICAgICAgIG1pbkRpc3RhbmNlID0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gc2VyaWVzLmJhcnMuaG9yaXpvbnRhbCA/IDEgOiAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IHN0YXJ0OyBqIDwgc2VyaWVzLmRhdGFwb2ludHMucG9pbnRzLmxlbmd0aDsgaiArPSBwb2ludHNpemUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNGaW5pdGUoc2VyaWVzLmRhdGFwb2ludHMucG9pbnRzW2pdKSAmJiBzZXJpZXMuZGF0YXBvaW50cy5wb2ludHNbal0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgeFZhbHVlcy5wdXNoKHNlcmllcy5kYXRhcG9pbnRzLnBvaW50c1tqXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBvbmx5VW5pcXVlKHZhbHVlLCBpbmRleCwgc2VsZikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmluZGV4T2YodmFsdWUpID09PSBpbmRleDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgeFZhbHVlcyA9IHhWYWx1ZXMuZmlsdGVyKG9ubHlVbmlxdWUpO1xuICAgICAgICAgICAgeFZhbHVlcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEgLSBiIH0pO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMTsgaiA8IHhWYWx1ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLmFicyh4VmFsdWVzW2pdIC0geFZhbHVlc1tqIC0gMV0pO1xuICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8IG1pbkRpc3RhbmNlICYmIGlzRmluaXRlKGRpc3RhbmNlKSkge1xuICAgICAgICAgICAgICAgICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXJpZXMuYmFycy5iYXJXaWR0aCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHNlcmllcy5iYXJzLmJhcldpZHRoID0gc2VyaWVzLmJhcnMuYmFyV2lkdGggKiBtaW5EaXN0YW5jZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VyaWVzLmJhcnMuYmFyV2lkdGhbMF0gPSBzZXJpZXMuYmFycy5iYXJXaWR0aFswXSAqIG1pbkRpc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZmluZE5lYXJieUl0ZW1zKG1vdXNlWCwgbW91c2VZLCBzZXJpZXNGaWx0ZXIsIHJhZGl1cywgY29tcHV0ZURpc3RhbmNlKSB7XG4gICAgICAgICAgICB2YXIgaXRlbXMgPSBmaW5kSXRlbXMobW91c2VYLCBtb3VzZVksIHNlcmllc0ZpbHRlciwgcmFkaXVzLCBjb21wdXRlRGlzdGFuY2UpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXJpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VyaWVzRmlsdGVyKGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVIb29rcyhob29rcy5maW5kTmVhcmJ5SXRlbXMsIFttb3VzZVgsIG1vdXNlWSwgc2VyaWVzLCBpLCByYWRpdXMsIGNvbXB1dGVEaXN0YW5jZSwgaXRlbXNdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpdGVtcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGIuZGlzdGFuY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhLmRpc3RhbmNlID09PSB1bmRlZmluZWQgJiYgYi5kaXN0YW5jZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBhLmRpc3RhbmNlIC0gYi5kaXN0YW5jZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZmluZE5lYXJieUl0ZW0obW91c2VYLCBtb3VzZVksIHNlcmllc0ZpbHRlciwgcmFkaXVzLCBjb21wdXRlRGlzdGFuY2UpIHtcbiAgICAgICAgICAgIHZhciBpdGVtcyA9IGZpbmROZWFyYnlJdGVtcyhtb3VzZVgsIG1vdXNlWSwgc2VyaWVzRmlsdGVyLCByYWRpdXMsIGNvbXB1dGVEaXN0YW5jZSk7XG4gICAgICAgICAgICByZXR1cm4gaXRlbXNbMF0gIT09IHVuZGVmaW5lZCA/IGl0ZW1zWzBdIDogbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJldHVybnMgdGhlIGRhdGEgaXRlbSB0aGUgbW91c2UgaXMgb3Zlci8gdGhlIGN1cnNvciBpcyBjbG9zZXN0IHRvLCBvciBudWxsIGlmIG5vbmUgaXMgZm91bmRcbiAgICAgICAgZnVuY3Rpb24gZmluZEl0ZW1zKG1vdXNlWCwgbW91c2VZLCBzZXJpZXNGaWx0ZXIsIHJhZGl1cywgY29tcHV0ZURpc3RhbmNlKSB7XG4gICAgICAgICAgICB2YXIgaSwgZm91bmRJdGVtcyA9IFtdLFxuICAgICAgICAgICAgICAgIGl0ZW1zID0gW10sXG4gICAgICAgICAgICAgICAgc21hbGxlc3REaXN0YW5jZSA9IHJhZGl1cyAqIHJhZGl1cyArIDE7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IHNlcmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgIGlmICghc2VyaWVzRmlsdGVyKGkpKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIHZhciBzID0gc2VyaWVzW2ldO1xuICAgICAgICAgICAgICAgIGlmICghcy5kYXRhcG9pbnRzKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICB2YXIgZm91bmRQb2ludCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChzLmxpbmVzLnNob3cgfHwgcy5wb2ludHMuc2hvdykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm91bmQgPSBmaW5kTmVhcmJ5UG9pbnQocywgbW91c2VYLCBtb3VzZVksIHJhZGl1cywgY29tcHV0ZURpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKHsgc2VyaWVzSW5kZXg6IGksIGRhdGFJbmRleDogZm91bmQuZGF0YUluZGV4LCBkaXN0YW5jZTogZm91bmQuZGlzdGFuY2UgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZFBvaW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzLmJhcnMuc2hvdyAmJiAhZm91bmRQb2ludCkgeyAvLyBubyBvdGhlciBwb2ludCBjYW4gYmUgbmVhcmJ5XG4gICAgICAgICAgICAgICAgICAgIHZhciBmb3VuZEluZGV4ID0gZmluZE5lYXJieUJhcihzLCBtb3VzZVgsIG1vdXNlWSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZEluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goeyBzZXJpZXNJbmRleDogaSwgZGF0YUluZGV4OiBmb3VuZEluZGV4LCBkaXN0YW5jZTogc21hbGxlc3REaXN0YW5jZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlcmllc0luZGV4ID0gaXRlbXNbaV0uc2VyaWVzSW5kZXg7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFJbmRleCA9IGl0ZW1zW2ldLmRhdGFJbmRleDtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbURpc3RhbmNlID0gaXRlbXNbaV0uZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdmFyIHBzID0gc2VyaWVzW3Nlcmllc0luZGV4XS5kYXRhcG9pbnRzLnBvaW50c2l6ZTtcblxuICAgICAgICAgICAgICAgIGZvdW5kSXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFwb2ludDogc2VyaWVzW3Nlcmllc0luZGV4XS5kYXRhcG9pbnRzLnBvaW50cy5zbGljZShkYXRhSW5kZXggKiBwcywgKGRhdGFJbmRleCArIDEpICogcHMpLFxuICAgICAgICAgICAgICAgICAgICBkYXRhSW5kZXg6IGRhdGFJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBzZXJpZXNbc2VyaWVzSW5kZXhdLFxuICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogc2VyaWVzSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlOiBNYXRoLnNxcnQoaXRlbURpc3RhbmNlKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZm91bmRJdGVtcztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGZpbmROZWFyYnlQb2ludCAoc2VyaWVzLCBtb3VzZVgsIG1vdXNlWSwgbWF4RGlzdGFuY2UsIGNvbXB1dGVEaXN0YW5jZSkge1xuICAgICAgICAgICAgdmFyIG14ID0gc2VyaWVzLnhheGlzLmMycChtb3VzZVgpLFxuICAgICAgICAgICAgICAgIG15ID0gc2VyaWVzLnlheGlzLmMycChtb3VzZVkpLFxuICAgICAgICAgICAgICAgIG1heHggPSBtYXhEaXN0YW5jZSAvIHNlcmllcy54YXhpcy5zY2FsZSxcbiAgICAgICAgICAgICAgICBtYXh5ID0gbWF4RGlzdGFuY2UgLyBzZXJpZXMueWF4aXMuc2NhbGUsXG4gICAgICAgICAgICAgICAgcG9pbnRzID0gc2VyaWVzLmRhdGFwb2ludHMucG9pbnRzLFxuICAgICAgICAgICAgICAgIHBzID0gc2VyaWVzLmRhdGFwb2ludHMucG9pbnRzaXplLFxuICAgICAgICAgICAgICAgIHNtYWxsZXN0RGlzdGFuY2UgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cbiAgICAgICAgICAgIC8vIHdpdGggaW52ZXJzZSB0cmFuc2Zvcm1zLCB3ZSBjYW4ndCB1c2UgdGhlIG1heHgvbWF4eVxuICAgICAgICAgICAgLy8gb3B0aW1pemF0aW9uLCBzYWRseVxuICAgICAgICAgICAgaWYgKHNlcmllcy54YXhpcy5vcHRpb25zLmludmVyc2VUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICBtYXh4ID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlcmllcy55YXhpcy5vcHRpb25zLmludmVyc2VUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICBtYXh5ID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGZvdW5kID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcG9pbnRzLmxlbmd0aDsgaiArPSBwcykge1xuICAgICAgICAgICAgICAgIHZhciB4ID0gcG9pbnRzW2pdO1xuICAgICAgICAgICAgICAgIHZhciB5ID0gcG9pbnRzW2ogKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoeCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh4IC0gbXggPiBtYXh4IHx8IHggLSBteCA8IC1tYXh4IHx8XG4gICAgICAgICAgICAgICAgICAgIHkgLSBteSA+IG1heHkgfHwgeSAtIG15IDwgLW1heHkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byBjYWxjdWxhdGUgZGlzdGFuY2VzIGluIHBpeGVscywgbm90IGluXG4gICAgICAgICAgICAgICAgLy8gZGF0YSB1bml0cywgYmVjYXVzZSB0aGUgc2NhbGVzIG9mIHRoZSBheGVzIG1heSBiZSBkaWZmZXJlbnRcbiAgICAgICAgICAgICAgICB2YXIgZHggPSBNYXRoLmFicyhzZXJpZXMueGF4aXMucDJjKHgpIC0gbW91c2VYKTtcbiAgICAgICAgICAgICAgICB2YXIgZHkgPSBNYXRoLmFicyhzZXJpZXMueWF4aXMucDJjKHkpIC0gbW91c2VZKTtcbiAgICAgICAgICAgICAgICB2YXIgZGlzdCA9IGNvbXB1dGVEaXN0YW5jZSA/IGNvbXB1dGVEaXN0YW5jZShkeCwgZHkpIDogZHggKiBkeCArIGR5ICogZHk7XG5cbiAgICAgICAgICAgICAgICAvLyB1c2UgPD0gdG8gZW5zdXJlIGxhc3QgcG9pbnQgdGFrZXMgcHJlY2VkZW5jZVxuICAgICAgICAgICAgICAgIC8vIChsYXN0IGdlbmVyYWxseSBtZWFucyBvbiB0b3Agb2YpXG4gICAgICAgICAgICAgICAgaWYgKGRpc3QgPCBzbWFsbGVzdERpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNtYWxsZXN0RGlzdGFuY2UgPSBkaXN0O1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHsgZGF0YUluZGV4OiBqIC8gcHMsIGRpc3RhbmNlOiBkaXN0IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBmaW5kTmVhcmJ5QmFyIChzZXJpZXMsIG1vdXNlWCwgbW91c2VZKSB7XG4gICAgICAgICAgICB2YXIgYmFyTGVmdCwgYmFyUmlnaHQsXG4gICAgICAgICAgICAgICAgYmFyV2lkdGggPSBzZXJpZXMuYmFycy5iYXJXaWR0aFswXSB8fCBzZXJpZXMuYmFycy5iYXJXaWR0aCxcbiAgICAgICAgICAgICAgICBteCA9IHNlcmllcy54YXhpcy5jMnAobW91c2VYKSxcbiAgICAgICAgICAgICAgICBteSA9IHNlcmllcy55YXhpcy5jMnAobW91c2VZKSxcbiAgICAgICAgICAgICAgICBwb2ludHMgPSBzZXJpZXMuZGF0YXBvaW50cy5wb2ludHMsXG4gICAgICAgICAgICAgICAgcHMgPSBzZXJpZXMuZGF0YXBvaW50cy5wb2ludHNpemU7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoc2VyaWVzLmJhcnMuYWxpZ24pIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICAgICAgICAgICAgICBiYXJMZWZ0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgICAgICAgICAgICAgIGJhckxlZnQgPSAtYmFyV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGJhckxlZnQgPSAtYmFyV2lkdGggLyAyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBiYXJSaWdodCA9IGJhckxlZnQgKyBiYXJXaWR0aDtcblxuICAgICAgICAgICAgdmFyIGZpbGxUb3dhcmRzID0gc2VyaWVzLmJhcnMuZmlsbFRvd2FyZHMgfHwgMDtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0Qm90dG9tID0gZmlsbFRvd2FyZHMgPiBzZXJpZXMueWF4aXMubWluID8gTWF0aC5taW4oc2VyaWVzLnlheGlzLm1heCwgZmlsbFRvd2FyZHMpIDogc2VyaWVzLnlheGlzLm1pbjtcblxuICAgICAgICAgICAgdmFyIGZvdW5kSW5kZXggPSAtMTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcG9pbnRzLmxlbmd0aDsgaiArPSBwcykge1xuICAgICAgICAgICAgICAgIHZhciB4ID0gcG9pbnRzW2pdLCB5ID0gcG9pbnRzW2ogKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoeCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBib3R0b20gPSBwcyA9PT0gMyA/IHBvaW50c1tqICsgMl0gOiBkZWZhdWx0Qm90dG9tO1xuICAgICAgICAgICAgICAgIC8vIGZvciBhIGJhciBncmFwaCwgdGhlIGN1cnNvciBtdXN0IGJlIGluc2lkZSB0aGUgYmFyXG4gICAgICAgICAgICAgICAgaWYgKHNlcmllcy5iYXJzLmhvcml6b250YWxcbiAgICAgICAgICAgICAgICAgICAgPyAobXggPD0gTWF0aC5tYXgoYm90dG9tLCB4KSAmJiBteCA+PSBNYXRoLm1pbihib3R0b20sIHgpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBteSA+PSB5ICsgYmFyTGVmdCAmJiBteSA8PSB5ICsgYmFyUmlnaHQpXG4gICAgICAgICAgICAgICAgICAgIDogKG14ID49IHggKyBiYXJMZWZ0ICYmIG14IDw9IHggKyBiYXJSaWdodCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbXkgPj0gTWF0aC5taW4oYm90dG9tLCB5KSAmJiBteSA8PSBNYXRoLm1heChib3R0b20sIHkpKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZEluZGV4ID0gaiAvIHBzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZvdW5kSW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBmaW5kTmVhcmJ5SW50ZXJwb2xhdGlvblBvaW50KHBvc1gsIHBvc1ksIHNlcmllc0ZpbHRlcikge1xuICAgICAgICAgICAgdmFyIGksIGosIGRpc3QsIGR4LCBkeSwgcHMsXG4gICAgICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgICAgICBzbWFsbGVzdERpc3RhbmNlID0gTnVtYmVyLk1BWF9WQUxVRTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlcmllcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICghc2VyaWVzRmlsdGVyKGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRzID0gc2VyaWVzW2ldLmRhdGFwb2ludHMucG9pbnRzO1xuICAgICAgICAgICAgICAgIHBzID0gc2VyaWVzW2ldLmRhdGFwb2ludHMucG9pbnRzaXplO1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGRhdGEgaXMgY29taW5nIGZyb20gcG9zaXRpdmUgLT4gbmVnYXRpdmUsIHJldmVyc2UgdGhlIGNvbXBhcmlzb25cbiAgICAgICAgICAgICAgICBjb25zdCBjb21wYXJlciA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gcHNdIDwgcG9pbnRzWzBdXG4gICAgICAgICAgICAgICAgICAgID8gZnVuY3Rpb24gKHgxLCB4MikgeyByZXR1cm4geDEgPiB4MiB9XG4gICAgICAgICAgICAgICAgICAgIDogZnVuY3Rpb24gKHgxLCB4MikgeyByZXR1cm4geDIgPiB4MSB9O1xuXG4gICAgICAgICAgICAgICAgLy8gZG8gbm90IGludGVycG9sYXRlIG91dHNpZGUgdGhlIGJvdW5kcyBvZiB0aGUgZGF0YS5cbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyZXIocG9zWCwgcG9pbnRzWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBuZWFyZXN0IHBvaW50cywgeC13aXNlXG4gICAgICAgICAgICAgICAgZm9yIChqID0gcHM7IGogPCBwb2ludHMubGVuZ3RoOyBqICs9IHBzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wYXJlcihwb3NYLCBwb2ludHNbal0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE5vdyBJbnRlcnBvbGF0ZVxuICAgICAgICAgICAgICAgIHZhciB5LFxuICAgICAgICAgICAgICAgICAgICBwMXggPSBwb2ludHNbaiAtIHBzXSxcbiAgICAgICAgICAgICAgICAgICAgcDF5ID0gcG9pbnRzW2ogLSBwcyArIDFdLFxuICAgICAgICAgICAgICAgICAgICBwMnggPSBwb2ludHNbal0sXG4gICAgICAgICAgICAgICAgICAgIHAyeSA9IHBvaW50c1tqICsgMV07XG5cbiAgICAgICAgICAgICAgICBpZiAoKHAxeCA9PT0gdW5kZWZpbmVkKSB8fCAocDJ4ID09PSB1bmRlZmluZWQpIHx8XG4gICAgICAgICAgICAgICAgICAgIChwMXkgPT09IHVuZGVmaW5lZCkgfHwgKHAyeSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocDF4ID09PSBwMngpIHtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHAyeVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBwMXkgKyAocDJ5IC0gcDF5KSAqIChwb3NYIC0gcDF4KSAvIChwMnggLSBwMXgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBvc1kgPSB5O1xuXG4gICAgICAgICAgICAgICAgZHggPSBNYXRoLmFicyhzZXJpZXNbaV0ueGF4aXMucDJjKHAyeCkgLSBwb3NYKTtcbiAgICAgICAgICAgICAgICBkeSA9IE1hdGguYWJzKHNlcmllc1tpXS55YXhpcy5wMmMocDJ5KSAtIHBvc1kpO1xuICAgICAgICAgICAgICAgIGRpc3QgPSBkeCAqIGR4ICsgZHkgKiBkeTtcblxuICAgICAgICAgICAgICAgIGlmIChkaXN0IDwgc21hbGxlc3REaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICBzbWFsbGVzdERpc3RhbmNlID0gZGlzdDtcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IFtwb3NYLCBwb3NZLCBpLCBqXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgaSA9IGl0ZW1bMl07XG4gICAgICAgICAgICAgICAgaiA9IGl0ZW1bM107XG4gICAgICAgICAgICAgICAgcHMgPSBzZXJpZXNbaV0uZGF0YXBvaW50cy5wb2ludHNpemU7XG4gICAgICAgICAgICAgICAgcG9pbnRzID0gc2VyaWVzW2ldLmRhdGFwb2ludHMucG9pbnRzO1xuICAgICAgICAgICAgICAgIHAxeCA9IHBvaW50c1tqIC0gcHNdO1xuICAgICAgICAgICAgICAgIHAxeSA9IHBvaW50c1tqIC0gcHMgKyAxXTtcbiAgICAgICAgICAgICAgICBwMnggPSBwb2ludHNbal07XG4gICAgICAgICAgICAgICAgcDJ5ID0gcG9pbnRzW2ogKyAxXTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFwb2ludDogW2l0ZW1bMF0sIGl0ZW1bMV1dLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0UG9pbnQ6IFtwMXgsIHAxeV0sXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0UG9pbnQ6IFtwMngsIHAyeV0sXG4gICAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB0cmlnZ2VyUmVkcmF3T3ZlcmxheSgpIHtcbiAgICAgICAgICAgIHZhciB0ID0gb3B0aW9ucy5pbnRlcmFjdGlvbi5yZWRyYXdPdmVybGF5SW50ZXJ2YWw7XG4gICAgICAgICAgICBpZiAodCA9PT0gLTEpIHsgLy8gc2tpcCBldmVudCBxdWV1ZVxuICAgICAgICAgICAgICAgIGRyYXdPdmVybGF5KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXJlZHJhd1RpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICByZWRyYXdUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhd092ZXJsYXkocGxvdCk7XG4gICAgICAgICAgICAgICAgfSwgdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBkcmF3T3ZlcmxheShwbG90KSB7XG4gICAgICAgICAgICByZWRyYXdUaW1lb3V0ID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKCFvY3R4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3ZlcmxheS5jbGVhcigpO1xuICAgICAgICAgICAgZXhlY3V0ZUhvb2tzKGhvb2tzLmRyYXdPdmVybGF5LCBbb2N0eCwgb3ZlcmxheV0pO1xuICAgICAgICAgICAgdmFyIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdvbkRyYXdpbmdEb25lJyk7XG4gICAgICAgICAgICBwbG90LmdldEV2ZW50SG9sZGVyKCkuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgICBwbG90LmdldFBsYWNlaG9sZGVyKCkudHJpZ2dlcignZHJhd2luZ2RvbmUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldENvbG9yT3JHcmFkaWVudChzcGVjLCBib3R0b20sIHRvcCwgZGVmYXVsdENvbG9yKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNwZWMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3BlYztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gYXNzdW1lIHRoaXMgaXMgYSBncmFkaWVudCBzcGVjOyBJRSBjdXJyZW50bHkgb25seVxuICAgICAgICAgICAgICAgIC8vIHN1cHBvcnRzIGEgc2ltcGxlIHZlcnRpY2FsIGdyYWRpZW50IHByb3Blcmx5LCBzbyB0aGF0J3NcbiAgICAgICAgICAgICAgICAvLyB3aGF0IHdlIHN1cHBvcnQgdG9vXG4gICAgICAgICAgICAgICAgdmFyIGdyYWRpZW50ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIHRvcCwgMCwgYm90dG9tKTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gc3BlYy5jb2xvcnMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gc3BlYy5jb2xvcnNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvID0gJC5jb2xvci5wYXJzZShkZWZhdWx0Q29sb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMuYnJpZ2h0bmVzcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY28gPSBjby5zY2FsZSgncmdiJywgYy5icmlnaHRuZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMub3BhY2l0eSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY28uYSAqPSBjLm9wYWNpdHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBjby50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcChpIC8gKGwgLSAxKSwgYyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdyYWRpZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSBwbG90IGZ1bmN0aW9uIHRvIHRoZSB0b3AgbGV2ZWwgb2YgdGhlIGpRdWVyeSBvYmplY3RcblxuICAgICQucGxvdCA9IGZ1bmN0aW9uKHBsYWNlaG9sZGVyLCBkYXRhLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBwbG90ID0gbmV3IFBsb3QoJChwbGFjZWhvbGRlciksIGRhdGEsIG9wdGlvbnMsICQucGxvdC5wbHVnaW5zKTtcbiAgICAgICAgcmV0dXJuIHBsb3Q7XG4gICAgfTtcblxuICAgICQucGxvdC52ZXJzaW9uID0gXCIzLjAuMFwiO1xuXG4gICAgJC5wbG90LnBsdWdpbnMgPSBbXTtcblxuICAgIC8vIEFsc28gYWRkIHRoZSBwbG90IGZ1bmN0aW9uIGFzIGEgY2hhaW5hYmxlIHByb3BlcnR5XG4gICAgJC5mbi5wbG90ID0gZnVuY3Rpb24oZGF0YSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJC5wbG90KHRoaXMsIGRhdGEsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgJC5wbG90LmxpbmVhclRpY2tHZW5lcmF0b3IgPSBkZWZhdWx0VGlja0dlbmVyYXRvcjtcbiAgICAkLnBsb3QuZGVmYXVsdFRpY2tGb3JtYXR0ZXIgPSBkZWZhdWx0VGlja0Zvcm1hdHRlcjtcbiAgICAkLnBsb3QuZXhwUmVwVGlja0Zvcm1hdHRlciA9IGV4cFJlcFRpY2tGb3JtYXR0ZXI7XG59KShqUXVlcnkpO1xuIiwiLyogRmxvdCBwbHVnaW4gZm9yIGRyYXdpbmcgbGVnZW5kcy5cblxuKi9cblxuKGZ1bmN0aW9uKCQpIHtcbiAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICAgIGxlZ2VuZDoge1xuICAgICAgICAgICAgc2hvdzogZmFsc2UsXG4gICAgICAgICAgICBub0NvbHVtbnM6IDEsXG4gICAgICAgICAgICBsYWJlbEZvcm1hdHRlcjogbnVsbCwgLy8gZm46IHN0cmluZyAtPiBzdHJpbmdcbiAgICAgICAgICAgIGNvbnRhaW5lcjogbnVsbCwgLy8gY29udGFpbmVyIChhcyBqUXVlcnkgb2JqZWN0KSB0byBwdXQgbGVnZW5kIGluLCBudWxsIG1lYW5zIGRlZmF1bHQgb24gdG9wIG9mIGdyYXBoXG4gICAgICAgICAgICBwb3NpdGlvbjogJ25lJywgLy8gcG9zaXRpb24gb2YgZGVmYXVsdCBsZWdlbmQgY29udGFpbmVyIHdpdGhpbiBwbG90XG4gICAgICAgICAgICBtYXJnaW46IDUsIC8vIGRpc3RhbmNlIGZyb20gZ3JpZCBlZGdlIHRvIGRlZmF1bHQgbGVnZW5kIGNvbnRhaW5lciB3aXRoaW4gcGxvdFxuICAgICAgICAgICAgc29ydGVkOiBudWxsIC8vIGRlZmF1bHQgdG8gbm8gbGVnZW5kIHNvcnRpbmdcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpbnNlcnRMZWdlbmQocGxvdCwgb3B0aW9ucywgcGxhY2Vob2xkZXIsIGxlZ2VuZEVudHJpZXMpIHtcbiAgICAgICAgLy8gY2xlYXIgYmVmb3JlIHJlZHJhd1xuICAgICAgICBpZiAob3B0aW9ucy5sZWdlbmQuY29udGFpbmVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICQob3B0aW9ucy5sZWdlbmQuY29udGFpbmVyKS5odG1sKCcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyLmZpbmQoJy5sZWdlbmQnKS5yZW1vdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3B0aW9ucy5sZWdlbmQuc2hvdykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2F2ZSB0aGUgbGVnZW5kIGVudHJpZXMgaW4gbGVnZW5kIG9wdGlvbnNcbiAgICAgICAgdmFyIGVudHJpZXMgPSBvcHRpb25zLmxlZ2VuZC5sZWdlbmRFbnRyaWVzID0gbGVnZW5kRW50cmllcyxcbiAgICAgICAgICAgIHBsb3RPZmZzZXQgPSBvcHRpb25zLmxlZ2VuZC5wbG90T2Zmc2V0ID0gcGxvdC5nZXRQbG90T2Zmc2V0KCksXG4gICAgICAgICAgICBodG1sID0gW10sXG4gICAgICAgICAgICBlbnRyeSwgbGFiZWxIdG1sLCBpY29uSHRtbCxcbiAgICAgICAgICAgIGogPSAwLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIHBvcyA9IFwiXCIsXG4gICAgICAgICAgICBwID0gb3B0aW9ucy5sZWdlbmQucG9zaXRpb24sXG4gICAgICAgICAgICBtID0gb3B0aW9ucy5sZWdlbmQubWFyZ2luLFxuICAgICAgICAgICAgc2hhcGUgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogJycsXG4gICAgICAgICAgICAgICAgbGFiZWw6ICcnLFxuICAgICAgICAgICAgICAgIHhQb3M6ICcnLFxuICAgICAgICAgICAgICAgIHlQb3M6ICcnXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGh0bWxbaisrXSA9ICc8c3ZnIGNsYXNzPVwibGVnZW5kTGF5ZXJcIiBzdHlsZT1cIndpZHRoOmluaGVyaXQ7aGVpZ2h0OmluaGVyaXQ7XCI+JztcbiAgICAgICAgaHRtbFtqKytdID0gJzxyZWN0IGNsYXNzPVwiYmFja2dyb3VuZFwiIHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIi8+JztcbiAgICAgICAgaHRtbFtqKytdID0gc3ZnU2hhcGVEZWZzO1xuXG4gICAgICAgIHZhciBsZWZ0ID0gMDtcbiAgICAgICAgdmFyIGNvbHVtbldpZHRocyA9IFtdO1xuICAgICAgICB2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdib2R5JykpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbGV0IGNvbHVtbkluZGV4ID0gaSAlIG9wdGlvbnMubGVnZW5kLm5vQ29sdW1ucztcbiAgICAgICAgICAgIGVudHJ5ID0gZW50cmllc1tpXTtcbiAgICAgICAgICAgIHNoYXBlLmxhYmVsID0gZW50cnkubGFiZWw7XG4gICAgICAgICAgICB2YXIgaW5mbyA9IHBsb3QuZ2V0U3VyZmFjZSgpLmdldFRleHRJbmZvKCcnLCBzaGFwZS5sYWJlbCwge1xuICAgICAgICAgICAgICAgIHN0eWxlOiBzdHlsZS5mb250U3R5bGUsXG4gICAgICAgICAgICAgICAgdmFyaWFudDogc3R5bGUuZm9udFZhcmlhbnQsXG4gICAgICAgICAgICAgICAgd2VpZ2h0OiBzdHlsZS5mb250V2VpZ2h0LFxuICAgICAgICAgICAgICAgIHNpemU6IHBhcnNlSW50KHN0eWxlLmZvbnRTaXplKSxcbiAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0OiBwYXJzZUludChzdHlsZS5saW5lSGVpZ2h0KSxcbiAgICAgICAgICAgICAgICBmYW1pbHk6IHN0eWxlLmZvbnRGYW1pbHlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgbGFiZWxXaWR0aCA9IGluZm8ud2lkdGg7XG4gICAgICAgICAgICAvLyAzNnB4ID0gMS41ZW0gKyA2cHggbWFyZ2luXG4gICAgICAgICAgICB2YXIgaWNvbldpZHRoID0gNDg7XG4gICAgICAgICAgICBpZiAoY29sdW1uV2lkdGhzW2NvbHVtbkluZGV4XSkge1xuICAgICAgICAgICAgICAgIGlmIChsYWJlbFdpZHRoID4gY29sdW1uV2lkdGhzW2NvbHVtbkluZGV4XSkge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW5XaWR0aHNbY29sdW1uSW5kZXhdID0gbGFiZWxXaWR0aCArIGljb25XaWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbHVtbldpZHRoc1tjb2x1bW5JbmRleF0gPSBsYWJlbFdpZHRoICsgaWNvbldpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2VuZXJhdGUgaHRtbCBmb3IgaWNvbnMgYW5kIGxhYmVscyBmcm9tIGEgbGlzdCBvZiBlbnRyaWVzXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBsZXQgY29sdW1uSW5kZXggPSBpICUgb3B0aW9ucy5sZWdlbmQubm9Db2x1bW5zO1xuICAgICAgICAgICAgZW50cnkgPSBlbnRyaWVzW2ldO1xuICAgICAgICAgICAgaWNvbkh0bWwgPSAnJztcbiAgICAgICAgICAgIHNoYXBlLmxhYmVsID0gZW50cnkubGFiZWw7XG4gICAgICAgICAgICBzaGFwZS54UG9zID0gKGxlZnQgKyAzKSArICdweCc7XG4gICAgICAgICAgICBsZWZ0ICs9IGNvbHVtbldpZHRoc1tjb2x1bW5JbmRleF07XG4gICAgICAgICAgICBpZiAoKGkgKyAxKSAlIG9wdGlvbnMubGVnZW5kLm5vQ29sdW1ucyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGxlZnQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2hhcGUueVBvcyA9IE1hdGguZmxvb3IoaSAvIG9wdGlvbnMubGVnZW5kLm5vQ29sdW1ucykgKiAxLjUgKyAnZW0nO1xuICAgICAgICAgICAgLy8gYXJlYVxuICAgICAgICAgICAgaWYgKGVudHJ5Lm9wdGlvbnMubGluZXMuc2hvdyAmJiBlbnRyeS5vcHRpb25zLmxpbmVzLmZpbGwpIHtcbiAgICAgICAgICAgICAgICBzaGFwZS5uYW1lID0gJ2FyZWEnO1xuICAgICAgICAgICAgICAgIHNoYXBlLmZpbGxDb2xvciA9IGVudHJ5LmNvbG9yO1xuICAgICAgICAgICAgICAgIGljb25IdG1sICs9IGdldEVudHJ5SWNvbkh0bWwoc2hhcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYmFyc1xuICAgICAgICAgICAgaWYgKGVudHJ5Lm9wdGlvbnMuYmFycy5zaG93KSB7XG4gICAgICAgICAgICAgICAgc2hhcGUubmFtZSA9ICdiYXInO1xuICAgICAgICAgICAgICAgIHNoYXBlLmZpbGxDb2xvciA9IGVudHJ5LmNvbG9yO1xuICAgICAgICAgICAgICAgIGljb25IdG1sICs9IGdldEVudHJ5SWNvbkh0bWwoc2hhcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbGluZXNcbiAgICAgICAgICAgIGlmIChlbnRyeS5vcHRpb25zLmxpbmVzLnNob3cgJiYgIWVudHJ5Lm9wdGlvbnMubGluZXMuZmlsbCkge1xuICAgICAgICAgICAgICAgIHNoYXBlLm5hbWUgPSAnbGluZSc7XG4gICAgICAgICAgICAgICAgc2hhcGUuc3Ryb2tlQ29sb3IgPSBlbnRyeS5jb2xvcjtcbiAgICAgICAgICAgICAgICBzaGFwZS5zdHJva2VXaWR0aCA9IGVudHJ5Lm9wdGlvbnMubGluZXMubGluZVdpZHRoO1xuICAgICAgICAgICAgICAgIGljb25IdG1sICs9IGdldEVudHJ5SWNvbkh0bWwoc2hhcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcG9pbnRzXG4gICAgICAgICAgICBpZiAoZW50cnkub3B0aW9ucy5wb2ludHMuc2hvdykge1xuICAgICAgICAgICAgICAgIHNoYXBlLm5hbWUgPSBlbnRyeS5vcHRpb25zLnBvaW50cy5zeW1ib2w7XG4gICAgICAgICAgICAgICAgc2hhcGUuc3Ryb2tlQ29sb3IgPSBlbnRyeS5jb2xvcjtcbiAgICAgICAgICAgICAgICBzaGFwZS5maWxsQ29sb3IgPSBlbnRyeS5vcHRpb25zLnBvaW50cy5maWxsQ29sb3I7XG4gICAgICAgICAgICAgICAgc2hhcGUuc3Ryb2tlV2lkdGggPSBlbnRyeS5vcHRpb25zLnBvaW50cy5saW5lV2lkdGg7XG4gICAgICAgICAgICAgICAgaWNvbkh0bWwgKz0gZ2V0RW50cnlJY29uSHRtbChzaGFwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxhYmVsSHRtbCA9ICc8dGV4dCB4PVwiJyArIHNoYXBlLnhQb3MgKyAnXCIgeT1cIicgKyBzaGFwZS55UG9zICsgJ1wiIHRleHQtYW5jaG9yPVwic3RhcnRcIj48dHNwYW4gZHg9XCIyZW1cIiBkeT1cIjEuMmVtXCI+JyArIHNoYXBlLmxhYmVsICsgJzwvdHNwYW4+PC90ZXh0PidcbiAgICAgICAgICAgIGh0bWxbaisrXSA9ICc8Zz4nICsgaWNvbkh0bWwgKyBsYWJlbEh0bWwgKyAnPC9nPic7XG4gICAgICAgIH1cblxuICAgICAgICBodG1sW2orK10gPSAnPC9zdmc+JztcbiAgICAgICAgaWYgKG1bMF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgbSA9IFttLCBtXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwLmNoYXJBdCgwKSA9PT0gJ24nKSB7XG4gICAgICAgICAgICBwb3MgKz0gJ3RvcDonICsgKG1bMV0gKyBwbG90T2Zmc2V0LnRvcCkgKyAncHg7JztcbiAgICAgICAgfSBlbHNlIGlmIChwLmNoYXJBdCgwKSA9PT0gJ3MnKSB7XG4gICAgICAgICAgICBwb3MgKz0gJ2JvdHRvbTonICsgKG1bMV0gKyBwbG90T2Zmc2V0LmJvdHRvbSkgKyAncHg7JztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwLmNoYXJBdCgxKSA9PT0gJ2UnKSB7XG4gICAgICAgICAgICBwb3MgKz0gJ3JpZ2h0OicgKyAobVswXSArIHBsb3RPZmZzZXQucmlnaHQpICsgJ3B4Oyc7XG4gICAgICAgIH0gZWxzZSBpZiAocC5jaGFyQXQoMSkgPT09ICd3Jykge1xuICAgICAgICAgICAgcG9zICs9ICdsZWZ0OicgKyAobVswXSArIHBsb3RPZmZzZXQubGVmdCkgKyAncHg7JztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3aWR0aCA9IDY7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb2x1bW5XaWR0aHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHdpZHRoICs9IGNvbHVtbldpZHRoc1tpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZWdlbmRFbCxcbiAgICAgICAgICAgIGhlaWdodCA9IE1hdGguY2VpbChlbnRyaWVzLmxlbmd0aCAvIG9wdGlvbnMubGVnZW5kLm5vQ29sdW1ucykgKiAxLjY7XG4gICAgICAgIGlmICghb3B0aW9ucy5sZWdlbmQuY29udGFpbmVyKSB7XG4gICAgICAgICAgICBsZWdlbmRFbCA9ICQoJzxkaXYgY2xhc3M9XCJsZWdlbmRcIiBzdHlsZT1cInBvc2l0aW9uOmFic29sdXRlOycgKyBwb3MgKyAnXCI+JyArIGh0bWwuam9pbignJykgKyAnPC9kaXY+JykuYXBwZW5kVG8ocGxhY2Vob2xkZXIpO1xuICAgICAgICAgICAgbGVnZW5kRWwuY3NzKCd3aWR0aCcsIHdpZHRoICsgJ3B4Jyk7XG4gICAgICAgICAgICBsZWdlbmRFbC5jc3MoJ2hlaWdodCcsIGhlaWdodCArICdlbScpO1xuICAgICAgICAgICAgbGVnZW5kRWwuY3NzKCdwb2ludGVyRXZlbnRzJywgJ25vbmUnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxlZ2VuZEVsID0gJChodG1sLmpvaW4oJycpKS5hcHBlbmRUbyhvcHRpb25zLmxlZ2VuZC5jb250YWluZXIpWzBdO1xuICAgICAgICAgICAgb3B0aW9ucy5sZWdlbmQuY29udGFpbmVyLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICAgICAgb3B0aW9ucy5sZWdlbmQuY29udGFpbmVyLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdlbSc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBHZW5lcmF0ZSBodG1sIGZvciBhIHNoYXBlXG4gICAgZnVuY3Rpb24gZ2V0RW50cnlJY29uSHRtbChzaGFwZSkge1xuICAgICAgICB2YXIgaHRtbCA9ICcnLFxuICAgICAgICAgICAgbmFtZSA9IHNoYXBlLm5hbWUsXG4gICAgICAgICAgICB4ID0gc2hhcGUueFBvcyxcbiAgICAgICAgICAgIHkgPSBzaGFwZS55UG9zLFxuICAgICAgICAgICAgZmlsbCA9IHNoYXBlLmZpbGxDb2xvcixcbiAgICAgICAgICAgIHN0cm9rZSA9IHNoYXBlLnN0cm9rZUNvbG9yLFxuICAgICAgICAgICAgd2lkdGggPSBzaGFwZS5zdHJva2VXaWR0aDtcbiAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICBjYXNlICdjaXJjbGUnOlxuICAgICAgICAgICAgICAgIGh0bWwgPSAnPHVzZSB4bGluazpocmVmPVwiI2NpcmNsZVwiIGNsYXNzPVwibGVnZW5kSWNvblwiICcgK1xuICAgICAgICAgICAgICAgICAgICAneD1cIicgKyB4ICsgJ1wiICcgK1xuICAgICAgICAgICAgICAgICAgICAneT1cIicgKyB5ICsgJ1wiICcgK1xuICAgICAgICAgICAgICAgICAgICAnZmlsbD1cIicgKyBmaWxsICsgJ1wiICcgK1xuICAgICAgICAgICAgICAgICAgICAnc3Ryb2tlPVwiJyArIHN0cm9rZSArICdcIiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aD1cIicgKyB3aWR0aCArICdcIiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3dpZHRoPVwiMS41ZW1cIiBoZWlnaHQ9XCIxLjVlbVwiJyArXG4gICAgICAgICAgICAgICAgICAgICcvPic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkaWFtb25kJzpcbiAgICAgICAgICAgICAgICBodG1sID0gJzx1c2UgeGxpbms6aHJlZj1cIiNkaWFtb25kXCIgY2xhc3M9XCJsZWdlbmRJY29uXCIgJyArXG4gICAgICAgICAgICAgICAgICAgICd4PVwiJyArIHggKyAnXCIgJyArXG4gICAgICAgICAgICAgICAgICAgICd5PVwiJyArIHkgKyAnXCIgJyArXG4gICAgICAgICAgICAgICAgICAgICdmaWxsPVwiJyArIGZpbGwgKyAnXCIgJyArXG4gICAgICAgICAgICAgICAgICAgICdzdHJva2U9XCInICsgc3Ryb2tlICsgJ1wiICcgK1xuICAgICAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoPVwiJyArIHdpZHRoICsgJ1wiICcgK1xuICAgICAgICAgICAgICAgICAgICAnd2lkdGg9XCIxLjVlbVwiIGhlaWdodD1cIjEuNWVtXCInICtcbiAgICAgICAgICAgICAgICAgICAgJy8+JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Nyb3NzJzpcbiAgICAgICAgICAgICAgICBodG1sID0gJzx1c2UgeGxpbms6aHJlZj1cIiNjcm9zc1wiIGNsYXNzPVwibGVnZW5kSWNvblwiICcgK1xuICAgICAgICAgICAgICAgICAgICAneD1cIicgKyB4ICsgJ1wiICcgK1xuICAgICAgICAgICAgICAgICAgICAneT1cIicgKyB5ICsgJ1wiICcgK1xuICAgICAgICAgICAgICAgICAgICAvLyAnZmlsbD1cIicgKyBmaWxsICsgJ1wiICcgK1xuICAgICAgICAgICAgICAgICAgICAnc3Ryb2tlPVwiJyArIHN0cm9rZSArICdcIiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aD1cIicgKyB3aWR0aCArICdcIiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3dpZHRoPVwiMS41ZW1cIiBoZWlnaHQ9XCIxLjVlbVwiJyArXG4gICAgICAgICAgICAgICAgICAgICcvPic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyZWN0YW5nbGUnOlxuICAgICAgICAgICAgICAgIGh0bWwgPSAnPHVzZSB4bGluazpocmVmPVwiI3JlY3RhbmdsZVwiIGNsYXNzPVwibGVnZW5kSWNvblwiICcgK1xuICAgICAgICAgICAgICAgICAgICAneD1cIicgKyB4ICsgJ1wiICcgK1xuICAgICAgICAgICAgICAgICAgICAneT1cIicgKyB5ICsgJ1wiICcgK1xuICAgICAgICAgICAgICAgICAgICAnZmlsbD1cIicgKyBmaWxsICsgJ1wiICcgK1xuICAgICAgICAgICAgICAgICAgICAnc3Ryb2tlPVwiJyArIHN0cm9rZSArICdcIiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aD1cIicgKyB3aWR0aCArICdcIiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3dpZHRoPVwiMS41ZW1cIiBoZWlnaHQ9XCIxLjVlbVwiJyArXG4gICAgICAgICAgICAgICAgICAgICcvPic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdwbHVzJzpcbiAgICAgICAgICAgICAgICBodG1sID0gJzx1c2UgeGxpbms6aHJlZj1cIiNwbHVzXCIgY2xhc3M9XCJsZWdlbmRJY29uXCIgJyArXG4gICAgICAgICAgICAgICAgICAgICd4PVwiJyArIHggKyAnXCIgJyArXG4gICAgICAgICAgICAgICAgICAgICd5PVwiJyArIHkgKyAnXCIgJyArXG4gICAgICAgICAgICAgICAgICAgIC8vICdmaWxsPVwiJyArIGZpbGwgKyAnXCIgJyArXG4gICAgICAgICAgICAgICAgICAgICdzdHJva2U9XCInICsgc3Ryb2tlICsgJ1wiICcgK1xuICAgICAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoPVwiJyArIHdpZHRoICsgJ1wiICcgK1xuICAgICAgICAgICAgICAgICAgICAnd2lkdGg9XCIxLjVlbVwiIGhlaWdodD1cIjEuNWVtXCInICtcbiAgICAgICAgICAgICAgICAgICAgJy8+JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Jhcic6XG4gICAgICAgICAgICAgICAgaHRtbCA9ICc8dXNlIHhsaW5rOmhyZWY9XCIjYmFyc1wiIGNsYXNzPVwibGVnZW5kSWNvblwiICcgK1xuICAgICAgICAgICAgICAgICAgICAneD1cIicgKyB4ICsgJ1wiICcgK1xuICAgICAgICAgICAgICAgICAgICAneT1cIicgKyB5ICsgJ1wiICcgK1xuICAgICAgICAgICAgICAgICAgICAnZmlsbD1cIicgKyBmaWxsICsgJ1wiICcgK1xuICAgICAgICAgICAgICAgICAgICAvLyAnc3Ryb2tlPVwiJyArIHN0cm9rZSArICdcIiAnICtcbiAgICAgICAgICAgICAgICAgICAgLy8gJ3N0cm9rZS13aWR0aD1cIicgKyB3aWR0aCArICdcIiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3dpZHRoPVwiMS41ZW1cIiBoZWlnaHQ9XCIxLjVlbVwiJyArXG4gICAgICAgICAgICAgICAgICAgICcvPic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhcmVhJzpcbiAgICAgICAgICAgICAgICBodG1sID0gJzx1c2UgeGxpbms6aHJlZj1cIiNhcmVhXCIgY2xhc3M9XCJsZWdlbmRJY29uXCIgJyArXG4gICAgICAgICAgICAgICAgICAgICd4PVwiJyArIHggKyAnXCIgJyArXG4gICAgICAgICAgICAgICAgICAgICd5PVwiJyArIHkgKyAnXCIgJyArXG4gICAgICAgICAgICAgICAgICAgICdmaWxsPVwiJyArIGZpbGwgKyAnXCIgJyArXG4gICAgICAgICAgICAgICAgICAgIC8vICdzdHJva2U9XCInICsgc3Ryb2tlICsgJ1wiICcgK1xuICAgICAgICAgICAgICAgICAgICAvLyAnc3Ryb2tlLXdpZHRoPVwiJyArIHdpZHRoICsgJ1wiICcgK1xuICAgICAgICAgICAgICAgICAgICAnd2lkdGg9XCIxLjVlbVwiIGhlaWdodD1cIjEuNWVtXCInICtcbiAgICAgICAgICAgICAgICAgICAgJy8+JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2xpbmUnOlxuICAgICAgICAgICAgICAgIGh0bWwgPSAnPHVzZSB4bGluazpocmVmPVwiI2xpbmVcIiBjbGFzcz1cImxlZ2VuZEljb25cIiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3g9XCInICsgeCArICdcIiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3k9XCInICsgeSArICdcIiAnICtcbiAgICAgICAgICAgICAgICAgICAgLy8gJ2ZpbGw9XCInICsgZmlsbCArICdcIiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3N0cm9rZT1cIicgKyBzdHJva2UgKyAnXCIgJyArXG4gICAgICAgICAgICAgICAgICAgICdzdHJva2Utd2lkdGg9XCInICsgd2lkdGggKyAnXCIgJyArXG4gICAgICAgICAgICAgICAgICAgICd3aWR0aD1cIjEuNWVtXCIgaGVpZ2h0PVwiMS41ZW1cIicgK1xuICAgICAgICAgICAgICAgICAgICAnLz4nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IGlzIGNpcmNsZVxuICAgICAgICAgICAgICAgIGh0bWwgPSAnPHVzZSB4bGluazpocmVmPVwiI2NpcmNsZVwiIGNsYXNzPVwibGVnZW5kSWNvblwiICcgK1xuICAgICAgICAgICAgICAgICAgICAneD1cIicgKyB4ICsgJ1wiICcgK1xuICAgICAgICAgICAgICAgICAgICAneT1cIicgKyB5ICsgJ1wiICcgK1xuICAgICAgICAgICAgICAgICAgICAnZmlsbD1cIicgKyBmaWxsICsgJ1wiICcgK1xuICAgICAgICAgICAgICAgICAgICAnc3Ryb2tlPVwiJyArIHN0cm9rZSArICdcIiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aD1cIicgKyB3aWR0aCArICdcIiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3dpZHRoPVwiMS41ZW1cIiBoZWlnaHQ9XCIxLjVlbVwiJyArXG4gICAgICAgICAgICAgICAgICAgICcvPic7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaHRtbDtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgc3ZnIHN5bWJvbHMgZm9yIHNoYXBlc1xuICAgIHZhciBzdmdTaGFwZURlZnMgPSAnJyArXG4gICAgICAgICc8ZGVmcz4nICtcbiAgICAgICAgICAgICc8c3ltYm9sIGlkPVwibGluZVwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIi01IC01IDI1IDI1XCI+JyArXG4gICAgICAgICAgICAgICAgJzxwb2x5bGluZSBwb2ludHM9XCIwLDE1IDUsNSAxMCwxMCAxNSwwXCIvPicgK1xuICAgICAgICAgICAgJzwvc3ltYm9sPicgK1xuXG4gICAgICAgICAgICAnPHN5bWJvbCBpZD1cImFyZWFcIiBzdHJva2Utd2lkdGg9XCIxXCIgdmlld0JveD1cIi01IC01IDI1IDI1XCI+JyArXG4gICAgICAgICAgICAgICAgJzxwb2x5bGluZSBwb2ludHM9XCIwLDE1IDUsNSAxMCwxMCAxNSwwLCAxNSwxNSwgMCwxNVwiLz4nICtcbiAgICAgICAgICAgICc8L3N5bWJvbD4nICtcblxuICAgICAgICAgICAgJzxzeW1ib2wgaWQ9XCJiYXJzXCIgc3Ryb2tlLXdpZHRoPVwiMVwiIHZpZXdCb3g9XCItNSAtNSAyNSAyNVwiPicgK1xuICAgICAgICAgICAgICAgICc8cG9seWxpbmUgcG9pbnRzPVwiMS41LDE1LjUgMS41LDEyLjUsIDQuNSwxMi41IDQuNSwxNS41IDYuNSwxNS41IDYuNSwzLjUsIDkuNSwzLjUgOS41LDE1LjUgMTEuNSwxNS41IDExLjUsNy41IDE0LjUsNy41IDE0LjUsMTUuNSAxLjUsMTUuNVwiLz4nICtcbiAgICAgICAgICAgICc8L3N5bWJvbD4nICtcblxuICAgICAgICAgICAgJzxzeW1ib2wgaWQ9XCJjaXJjbGVcIiB2aWV3Qm94PVwiLTUgLTUgMjUgMjVcIj4nICtcbiAgICAgICAgICAgICAgICAnPGNpcmNsZSBjeD1cIjBcIiBjeT1cIjE1XCIgcj1cIjIuNVwiLz4nICtcbiAgICAgICAgICAgICAgICAnPGNpcmNsZSBjeD1cIjVcIiBjeT1cIjVcIiByPVwiMi41XCIvPicgK1xuICAgICAgICAgICAgICAgICc8Y2lyY2xlIGN4PVwiMTBcIiBjeT1cIjEwXCIgcj1cIjIuNVwiLz4nICtcbiAgICAgICAgICAgICAgICAnPGNpcmNsZSBjeD1cIjE1XCIgY3k9XCIwXCIgcj1cIjIuNVwiLz4nICtcbiAgICAgICAgICAgICc8L3N5bWJvbD4nICtcblxuICAgICAgICAgICAgJzxzeW1ib2wgaWQ9XCJyZWN0YW5nbGVcIiB2aWV3Qm94PVwiLTUgLTUgMjUgMjVcIj4nICtcbiAgICAgICAgICAgICAgICAnPHJlY3QgeD1cIi0yLjFcIiB5PVwiMTIuOVwiIHdpZHRoPVwiNC4yXCIgaGVpZ2h0PVwiNC4yXCIvPicgK1xuICAgICAgICAgICAgICAgICc8cmVjdCB4PVwiMi45XCIgeT1cIjIuOVwiIHdpZHRoPVwiNC4yXCIgaGVpZ2h0PVwiNC4yXCIvPicgK1xuICAgICAgICAgICAgICAgICc8cmVjdCB4PVwiNy45XCIgeT1cIjcuOVwiIHdpZHRoPVwiNC4yXCIgaGVpZ2h0PVwiNC4yXCIvPicgK1xuICAgICAgICAgICAgICAgICc8cmVjdCB4PVwiMTIuOVwiIHk9XCItMi4xXCIgd2lkdGg9XCI0LjJcIiBoZWlnaHQ9XCI0LjJcIi8+JyArXG4gICAgICAgICAgICAnPC9zeW1ib2w+JyArXG5cbiAgICAgICAgICAgICc8c3ltYm9sIGlkPVwiZGlhbW9uZFwiIHZpZXdCb3g9XCItNSAtNSAyNSAyNVwiPicgK1xuICAgICAgICAgICAgICAgICc8cGF0aCBkPVwiTS0zLDE1IEwwLDEyIEwzLDE1LCBMMCwxOCBaXCIvPicgK1xuICAgICAgICAgICAgICAgICc8cGF0aCBkPVwiTTIsNSBMNSwyIEw4LDUsIEw1LDggWlwiLz4nICtcbiAgICAgICAgICAgICAgICAnPHBhdGggZD1cIk03LDEwIEwxMCw3IEwxMywxMCwgTDEwLDEzIFpcIi8+JyArXG4gICAgICAgICAgICAgICAgJzxwYXRoIGQ9XCJNMTIsMCBMMTUsLTMgTDE4LDAsIEwxNSwzIFpcIi8+JyArXG4gICAgICAgICAgICAnPC9zeW1ib2w+JyArXG5cbiAgICAgICAgICAgICc8c3ltYm9sIGlkPVwiY3Jvc3NcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCItNSAtNSAyNSAyNVwiPicgK1xuICAgICAgICAgICAgICAgICc8cGF0aCBkPVwiTS0yLjEsMTIuOSBMMi4xLDE3LjEsIE0yLjEsMTIuOSBMLTIuMSwxNy4xIFpcIi8+JyArXG4gICAgICAgICAgICAgICAgJzxwYXRoIGQ9XCJNMi45LDIuOSBMNy4xLDcuMSBNNy4xLDIuOSBMMi45LDcuMSBaXCIvPicgK1xuICAgICAgICAgICAgICAgICc8cGF0aCBkPVwiTTcuOSw3LjkgTDEyLjEsMTIuMSBNMTIuMSw3LjkgTDcuOSwxMi4xIFpcIi8+JyArXG4gICAgICAgICAgICAgICAgJzxwYXRoIGQ9XCJNMTIuOSwtMi4xIEwxNy4xLDIuMSBNMTcuMSwtMi4xIEwxMi45LDIuMSBaXCIvPicgK1xuICAgICAgICAgICAgJzwvc3ltYm9sPicgK1xuXG4gICAgICAgICAgICAnPHN5bWJvbCBpZD1cInBsdXNcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCItNSAtNSAyNSAyNVwiPicgK1xuICAgICAgICAgICAgICAgICc8cGF0aCBkPVwiTTAsMTIgTDAsMTgsIE0tMywxNSBMMywxNSBaXCIvPicgK1xuICAgICAgICAgICAgICAgICc8cGF0aCBkPVwiTTUsMiBMNSw4IE0yLDUgTDgsNSBaXCIvPicgK1xuICAgICAgICAgICAgICAgICc8cGF0aCBkPVwiTTEwLDcgTDEwLDEzIE03LDEwIEwxMywxMCBaXCIvPicgK1xuICAgICAgICAgICAgICAgICc8cGF0aCBkPVwiTTE1LC0zIEwxNSwzIE0xMiwwIEwxOCwwIFpcIi8+JyArXG4gICAgICAgICAgICAnPC9zeW1ib2w+JyArXG4gICAgICAgICc8L2RlZnM+JztcblxuICAgIC8vIEdlbmVyYXRlIGEgbGlzdCBvZiBsZWdlbmQgZW50cmllcyBpbiB0aGVpciBmaW5hbCBvcmRlclxuICAgIGZ1bmN0aW9uIGdldExlZ2VuZEVudHJpZXMoc2VyaWVzLCBsYWJlbEZvcm1hdHRlciwgc29ydGVkKSB7XG4gICAgICAgIHZhciBsZiA9IGxhYmVsRm9ybWF0dGVyLFxuICAgICAgICAgICAgbGVnZW5kRW50cmllcyA9IHNlcmllcy5yZWR1Y2UoZnVuY3Rpb24odmFsaWRFbnRyaWVzLCBzLCBpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhYmVsRXZhbCA9IChsZiA/IGxmKHMubGFiZWwsIHMpIDogcy5sYWJlbClcbiAgICAgICAgICAgICAgICBpZiAocy5oYXNPd25Qcm9wZXJ0eShcImxhYmVsXCIpID8gbGFiZWxFdmFsIDogdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogbGFiZWxFdmFsIHx8ICdQbG90ICcgKyAoaSArIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IHMuY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZXM6IHMubGluZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzOiBzLnBvaW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXJzOiBzLmJhcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YWxpZEVudHJpZXMucHVzaChlbnRyeSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkRW50cmllcztcbiAgICAgICAgICAgIH0sIFtdKTtcblxuICAgICAgICAvLyBTb3J0IHRoZSBsZWdlbmQgdXNpbmcgZWl0aGVyIHRoZSBkZWZhdWx0IG9yIGEgY3VzdG9tIGNvbXBhcmF0b3JcbiAgICAgICAgaWYgKHNvcnRlZCkge1xuICAgICAgICAgICAgaWYgKCQuaXNGdW5jdGlvbihzb3J0ZWQpKSB7XG4gICAgICAgICAgICAgICAgbGVnZW5kRW50cmllcy5zb3J0KHNvcnRlZCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNvcnRlZCA9PT0gJ3JldmVyc2UnKSB7XG4gICAgICAgICAgICAgICAgbGVnZW5kRW50cmllcy5yZXZlcnNlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBhc2NlbmRpbmcgPSAoc29ydGVkICE9PSAnZGVzY2VuZGluZycpO1xuICAgICAgICAgICAgICAgIGxlZ2VuZEVudHJpZXMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhLmxhYmVsID09PSBiLmxhYmVsXG4gICAgICAgICAgICAgICAgICAgICAgICA/IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogKChhLmxhYmVsIDwgYi5sYWJlbCkgIT09IGFzY2VuZGluZyA/IDEgOiAtMSAvLyBMb2dpY2FsIFhPUlxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsZWdlbmRFbnRyaWVzO1xuICAgIH1cblxuICAgIC8vIHJldHVybiBmYWxzZSBpZiBvcHRzMSBzYW1lIGFzIG9wdHMyXG4gICAgZnVuY3Rpb24gY2hlY2tPcHRpb25zKG9wdHMxLCBvcHRzMikge1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIG9wdHMxKSB7XG4gICAgICAgICAgICBpZiAob3B0czEuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0czFbcHJvcF0gIT09IG9wdHMyW3Byb3BdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ29tcGFyZSB0d28gbGlzdHMgb2YgbGVnZW5kIGVudHJpZXNcbiAgICBmdW5jdGlvbiBzaG91bGRSZWRyYXcob2xkRW50cmllcywgbmV3RW50cmllcykge1xuICAgICAgICBpZiAoIW9sZEVudHJpZXMgfHwgIW5ld0VudHJpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9sZEVudHJpZXMubGVuZ3RoICE9PSBuZXdFbnRyaWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGksIG5ld0VudHJ5LCBvbGRFbnRyeSwgbmV3T3B0cywgb2xkT3B0cztcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG5ld0VudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG5ld0VudHJ5ID0gbmV3RW50cmllc1tpXTtcbiAgICAgICAgICAgIG9sZEVudHJ5ID0gb2xkRW50cmllc1tpXTtcblxuICAgICAgICAgICAgaWYgKG5ld0VudHJ5LmxhYmVsICE9PSBvbGRFbnRyeS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobmV3RW50cnkuY29sb3IgIT09IG9sZEVudHJ5LmNvbG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBjaGFuZ2VzIGluIGxpbmVzIG9wdGlvbnNcbiAgICAgICAgICAgIG5ld09wdHMgPSBuZXdFbnRyeS5vcHRpb25zLmxpbmVzO1xuICAgICAgICAgICAgb2xkT3B0cyA9IG9sZEVudHJ5Lm9wdGlvbnMubGluZXM7XG4gICAgICAgICAgICBpZiAoY2hlY2tPcHRpb25zKG5ld09wdHMsIG9sZE9wdHMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBjaGFuZ2VzIGluIHBvaW50cyBvcHRpb25zXG4gICAgICAgICAgICBuZXdPcHRzID0gbmV3RW50cnkub3B0aW9ucy5wb2ludHM7XG4gICAgICAgICAgICBvbGRPcHRzID0gb2xkRW50cnkub3B0aW9ucy5wb2ludHM7XG4gICAgICAgICAgICBpZiAoY2hlY2tPcHRpb25zKG5ld09wdHMsIG9sZE9wdHMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBjaGFuZ2VzIGluIGJhcnMgb3B0aW9uc1xuICAgICAgICAgICAgbmV3T3B0cyA9IG5ld0VudHJ5Lm9wdGlvbnMuYmFycztcbiAgICAgICAgICAgIG9sZE9wdHMgPSBvbGRFbnRyeS5vcHRpb25zLmJhcnM7XG4gICAgICAgICAgICBpZiAoY2hlY2tPcHRpb25zKG5ld09wdHMsIG9sZE9wdHMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5pdChwbG90KSB7XG4gICAgICAgIHBsb3QuaG9va3Muc2V0dXBHcmlkLnB1c2goZnVuY3Rpb24gKHBsb3QpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gcGxvdC5nZXRPcHRpb25zKCk7XG4gICAgICAgICAgICB2YXIgc2VyaWVzID0gcGxvdC5nZXREYXRhKCksXG4gICAgICAgICAgICAgICAgbGFiZWxGb3JtYXR0ZXIgPSBvcHRpb25zLmxlZ2VuZC5sYWJlbEZvcm1hdHRlcixcbiAgICAgICAgICAgICAgICBvbGRFbnRyaWVzID0gb3B0aW9ucy5sZWdlbmQubGVnZW5kRW50cmllcyxcbiAgICAgICAgICAgICAgICBvbGRQbG90T2Zmc2V0ID0gb3B0aW9ucy5sZWdlbmQucGxvdE9mZnNldCxcbiAgICAgICAgICAgICAgICBuZXdFbnRyaWVzID0gZ2V0TGVnZW5kRW50cmllcyhzZXJpZXMsIGxhYmVsRm9ybWF0dGVyLCBvcHRpb25zLmxlZ2VuZC5zb3J0ZWQpLFxuICAgICAgICAgICAgICAgIG5ld1Bsb3RPZmZzZXQgPSBwbG90LmdldFBsb3RPZmZzZXQoKTtcblxuICAgICAgICAgICAgaWYgKHNob3VsZFJlZHJhdyhvbGRFbnRyaWVzLCBuZXdFbnRyaWVzKSB8fFxuICAgICAgICAgICAgICAgIGNoZWNrT3B0aW9ucyhvbGRQbG90T2Zmc2V0LCBuZXdQbG90T2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgIGluc2VydExlZ2VuZChwbG90LCBvcHRpb25zLCBwbG90LmdldFBsYWNlaG9sZGVyKCksIG5ld0VudHJpZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAkLnBsb3QucGx1Z2lucy5wdXNoKHtcbiAgICAgICAgaW5pdDogaW5pdCxcbiAgICAgICAgb3B0aW9uczogZGVmYXVsdE9wdGlvbnMsXG4gICAgICAgIG5hbWU6ICdsZWdlbmQnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4wJ1xuICAgIH0pO1xufSkoalF1ZXJ5KTtcbiIsIi8qIFByZXR0eSBoYW5kbGluZyBvZiBsb2cgYXhlcy5cblxuQ29weXJpZ2h0IChjKSAyMDA3LTIwMTQgSU9MQSBhbmQgT2xlIExhdXJzZW4uXG5Db3B5cmlnaHQgKGMpIDIwMTUgQ2lwcmlhbiBDZXRlcmFzIGNpcGl4MjAwMEBnbWFpbC5jb20uXG5Db3B5cmlnaHQgKGMpIDIwMTcgUmFsdWNhIFBvcnRhc2VcbkxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuU2V0IGF4aXMubW9kZSB0byBcImxvZ1wiIHRvIGVuYWJsZS5cbiovXG5cbi8qIGdsb2JhbCBqUXVlcnkqL1xuXG4vKipcbiMjIGpxdWVyeS5mbG90LmxvZ2F4aXNcblRoaXMgcGx1Z2luIGlzIHVzZWQgdG8gY3JlYXRlIGxvZ2FyaXRobWljIGF4aXMuIFRoaXMgaW5jbHVkZXMgdGljayBnZW5lcmF0aW9uLFxuZm9ybWF0dGVycyBhbmQgdHJhbnNmb3JtZXJzIHRvIGFuZCBmcm9tIGxvZ2FyaXRobWljIHJlcHJlc2VudGF0aW9uLlxuXG4jIyMgTWV0aG9kcyBhbmQgaG9va3NcbiovXG5cbihmdW5jdGlvbiAoJCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICB4YXhpczoge31cbiAgICB9O1xuXG4gICAgLyp0aWNrIGdlbmVyYXRvcnMgYW5kIGZvcm1hdHRlcnMqL1xuICAgIHZhciBQUkVGRVJSRURfTE9HX1RJQ0tfVkFMVUVTID0gY29tcHV0ZVByZWZlcmVkTG9nVGlja1ZhbHVlcyhOdW1iZXIuTUFYX1ZBTFVFLCAxMCksXG4gICAgICAgIEVYVEVOREVEX0xPR19USUNLX1ZBTFVFUyA9IGNvbXB1dGVQcmVmZXJlZExvZ1RpY2tWYWx1ZXMoTnVtYmVyLk1BWF9WQUxVRSwgNCk7XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlUHJlZmVyZWRMb2dUaWNrVmFsdWVzKGVuZExpbWl0LCByYW5nZVN0ZXApIHtcbiAgICAgICAgdmFyIGxvZzEwRW5kID0gTWF0aC5mbG9vcihNYXRoLmxvZyhlbmRMaW1pdCkgKiBNYXRoLkxPRzEwRSkgLSAxLFxuICAgICAgICAgICAgbG9nMTBTdGFydCA9IC1sb2cxMEVuZCxcbiAgICAgICAgICAgIHZhbCwgcmFuZ2UsIHZhbHMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBwb3dlciA9IGxvZzEwU3RhcnQ7IHBvd2VyIDw9IGxvZzEwRW5kOyBwb3dlcisrKSB7XG4gICAgICAgICAgICByYW5nZSA9IHBhcnNlRmxvYXQoJzFlJyArIHBvd2VyKTtcbiAgICAgICAgICAgIGZvciAodmFyIG11bHQgPSAxOyBtdWx0IDwgOTsgbXVsdCArPSByYW5nZVN0ZXApIHtcbiAgICAgICAgICAgICAgICB2YWwgPSByYW5nZSAqIG11bHQ7XG4gICAgICAgICAgICAgICAgdmFscy5wdXNoKHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgLSBsb2dUaWNrR2VuZXJhdG9yKHBsb3QsIGF4aXMsIG5vVGlja3MpXG5cbiAgICBHZW5lcmF0ZXMgbG9nYXJpdGhtaWMgdGlja3MsIGRlcGVuZGluZyBvbiBheGlzIHJhbmdlLlxuICAgIEluIGNhc2UgdGhlIG51bWJlciBvZiB0aWNrcyB0aGF0IGNhbiBiZSBnZW5lcmF0ZWQgaXMgbGVzcyB0aGFuIHRoZSBleHBlY3RlZCBub1RpY2tzLzQsXG4gICAgYSBsaW5lYXIgdGljayBnZW5lcmF0aW9uIGlzIHVzZWQuXG4gICAgKi9cbiAgICB2YXIgbG9nVGlja0dlbmVyYXRvciA9IGZ1bmN0aW9uIChwbG90LCBheGlzLCBub1RpY2tzKSB7XG4gICAgICAgIHZhciB0aWNrcyA9IFtdLFxuICAgICAgICAgICAgbWluSWR4ID0gLTEsXG4gICAgICAgICAgICBtYXhJZHggPSAtMSxcbiAgICAgICAgICAgIHN1cmZhY2UgPSBwbG90LmdldENhbnZhcygpLFxuICAgICAgICAgICAgbG9nVGlja1ZhbHVlcyA9IFBSRUZFUlJFRF9MT0dfVElDS19WQUxVRVMsXG4gICAgICAgICAgICBtaW4gPSBjbGFtcEF4aXMoYXhpcywgcGxvdCksXG4gICAgICAgICAgICBtYXggPSBheGlzLm1heDtcblxuICAgICAgICBpZiAoIW5vVGlja3MpIHtcbiAgICAgICAgICAgIG5vVGlja3MgPSAwLjMgKiBNYXRoLnNxcnQoYXhpcy5kaXJlY3Rpb24gPT09IFwieFwiID8gc3VyZmFjZS53aWR0aCA6IHN1cmZhY2UuaGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIFBSRUZFUlJFRF9MT0dfVElDS19WQUxVRVMuc29tZShmdW5jdGlvbiAodmFsLCBpKSB7XG4gICAgICAgICAgICBpZiAodmFsID49IG1pbikge1xuICAgICAgICAgICAgICAgIG1pbklkeCA9IGk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgUFJFRkVSUkVEX0xPR19USUNLX1ZBTFVFUy5zb21lKGZ1bmN0aW9uICh2YWwsIGkpIHtcbiAgICAgICAgICAgIGlmICh2YWwgPj0gbWF4KSB7XG4gICAgICAgICAgICAgICAgbWF4SWR4ID0gaTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobWF4SWR4ID09PSAtMSkge1xuICAgICAgICAgICAgbWF4SWR4ID0gUFJFRkVSUkVEX0xPR19USUNLX1ZBTFVFUy5sZW5ndGggLSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1heElkeCAtIG1pbklkeCA8PSBub1RpY2tzIC8gNCAmJiBsb2dUaWNrVmFsdWVzLmxlbmd0aCAhPT0gRVhURU5ERURfTE9HX1RJQ0tfVkFMVUVTLmxlbmd0aCkge1xuICAgICAgICAgICAgLy90cnkgd2l0aCBtdWx0aXBsZSBvZiA1IGZvciB0aWNrIHZhbHVlc1xuICAgICAgICAgICAgbG9nVGlja1ZhbHVlcyA9IEVYVEVOREVEX0xPR19USUNLX1ZBTFVFUztcbiAgICAgICAgICAgIG1pbklkeCAqPSAyO1xuICAgICAgICAgICAgbWF4SWR4ICo9IDI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGFzdERpc3BsYXllZCA9IG51bGwsXG4gICAgICAgICAgICBpbnZlcnNlTm9UaWNrcyA9IDEgLyBub1RpY2tzLFxuICAgICAgICAgICAgdGlja1ZhbHVlLCBwaXhlbENvb3JkLCB0aWNrO1xuXG4gICAgICAgIC8vIENvdW50IHRoZSBudW1iZXIgb2YgdGljayB2YWx1ZXMgd291bGQgYXBwZWFyLCBpZiB3ZSBjYW4gZ2V0IGF0IGxlYXN0XG4gICAgICAgIC8vIG5UaWNrcyAvIDQgYWNjZXB0IHRoZW0uXG4gICAgICAgIGlmIChtYXhJZHggLSBtaW5JZHggPj0gbm9UaWNrcyAvIDQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGlkeCA9IG1heElkeDsgaWR4ID49IG1pbklkeDsgaWR4LS0pIHtcbiAgICAgICAgICAgICAgICB0aWNrVmFsdWUgPSBsb2dUaWNrVmFsdWVzW2lkeF07XG4gICAgICAgICAgICAgICAgcGl4ZWxDb29yZCA9IChNYXRoLmxvZyh0aWNrVmFsdWUpIC0gTWF0aC5sb2cobWluKSkgLyAoTWF0aC5sb2cobWF4KSAtIE1hdGgubG9nKG1pbikpO1xuICAgICAgICAgICAgICAgIHRpY2sgPSB0aWNrVmFsdWU7XG5cbiAgICAgICAgICAgICAgICBpZiAobGFzdERpc3BsYXllZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0RGlzcGxheWVkID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGl4ZWxDb29yZDogcGl4ZWxDb29yZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkZWFsUGl4ZWxDb29yZDogcGl4ZWxDb29yZFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhwaXhlbENvb3JkIC0gbGFzdERpc3BsYXllZC5waXhlbENvb3JkKSA+PSBpbnZlcnNlTm9UaWNrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdERpc3BsYXllZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaXhlbENvb3JkOiBwaXhlbENvb3JkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkZWFsUGl4ZWxDb29yZDogbGFzdERpc3BsYXllZC5pZGVhbFBpeGVsQ29vcmQgLSBpbnZlcnNlTm9UaWNrc1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpY2sgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGlja3MucHVzaCh0aWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTaW5jZSB3ZSB3ZW50IGluIGJhY2t3YXJkcyBvcmRlci5cbiAgICAgICAgICAgIHRpY2tzLnJldmVyc2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0aWNrU2l6ZSA9IHBsb3QuY29tcHV0ZVRpY2tTaXplKG1pbiwgbWF4LCBub1RpY2tzKSxcbiAgICAgICAgICAgICAgICBjdXN0b21BeGlzID0ge21pbjogbWluLCBtYXg6IG1heCwgdGlja1NpemU6IHRpY2tTaXplfTtcbiAgICAgICAgICAgIHRpY2tzID0gJC5wbG90LmxpbmVhclRpY2tHZW5lcmF0b3IoY3VzdG9tQXhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGlja3M7XG4gICAgfTtcblxuICAgIHZhciBjbGFtcEF4aXMgPSBmdW5jdGlvbiAoYXhpcywgcGxvdCkge1xuICAgICAgICB2YXIgbWluID0gYXhpcy5taW4sXG4gICAgICAgICAgICBtYXggPSBheGlzLm1heDtcblxuICAgICAgICBpZiAobWluIDw9IDApIHtcbiAgICAgICAgICAgIC8vZm9yIGVtcHR5IGdyYXBoIGlmIGF4aXMubWluIGlzIG5vdCBzdHJpY3RseSBwb3NpdGl2ZSBtYWtlIGl0IDAuMVxuICAgICAgICAgICAgaWYgKGF4aXMuZGF0YW1pbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG1pbiA9IGF4aXMubWluID0gMC4xO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtaW4gPSBwcm9jZXNzQXhpc09mZnNldChwbG90LCBheGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1heCA8IG1pbikge1xuICAgICAgICAgICAgICAgIGF4aXMubWF4ID0gYXhpcy5kYXRhbWF4ICE9PSBudWxsID8gYXhpcy5kYXRhbWF4IDogYXhpcy5vcHRpb25zLm1heDtcbiAgICAgICAgICAgICAgICBheGlzLm9wdGlvbnMub2Zmc2V0LmJlbG93ID0gMDtcbiAgICAgICAgICAgICAgICBheGlzLm9wdGlvbnMub2Zmc2V0LmFib3ZlID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtaW47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgLSBsb2dUaWNrRm9ybWF0dGVyKHZhbHVlLCBheGlzLCBwcmVjaXNpb24pXG5cbiAgICBUaGlzIGlzIHRoZSBjb3JyZXNwb25kaW5nIHRpY2tGb3JtYXR0ZXIgb2YgdGhlIGxvZ2F4aXMuXG4gICAgRm9yIGEgbnVtYmVyIGdyZWF0ZXIgdGhhdCAxMF42IG9yIHNtYWxsZXIgdGhhbiAxMF4oLTMpLCB0aGlzIHdpbGwgYmUgZHJhd25cbiAgICB3aXRoIGUgcmVwcmVzZW50YXRpb25cbiAgICAqL1xuICAgIHZhciBsb2dUaWNrRm9ybWF0dGVyID0gZnVuY3Rpb24gKHZhbHVlLCBheGlzLCBwcmVjaXNpb24pIHtcbiAgICAgICAgdmFyIHRlbkV4cG9uZW50ID0gdmFsdWUgPiAwID8gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMTApIDogMDtcblxuICAgICAgICBpZiAocHJlY2lzaW9uKSB7XG4gICAgICAgICAgICBpZiAoKHRlbkV4cG9uZW50ID49IC00KSAmJiAodGVuRXhwb25lbnQgPD0gNykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJC5wbG90LmRlZmF1bHRUaWNrRm9ybWF0dGVyKHZhbHVlLCBheGlzLCBwcmVjaXNpb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJC5wbG90LmV4cFJlcFRpY2tGb3JtYXR0ZXIodmFsdWUsIGF4aXMsIHByZWNpc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh0ZW5FeHBvbmVudCA+PSAtNCkgJiYgKHRlbkV4cG9uZW50IDw9IDcpKSB7XG4gICAgICAgICAgICAvL2lmIHdlIGhhdmUgZmxvYXQgbnVtYmVycywgcmV0dXJuIGEgbGltaXRlZCBsZW5ndGggc3RyaW5nKGV4OiAwLjAwMDkgaXMgcmVwcmVzZW50ZWQgYXMgMC4wMDA5MDAwMDEpXG4gICAgICAgICAgICB2YXIgZm9ybWF0dGVkVmFsdWUgPSB0ZW5FeHBvbmVudCA8IDAgPyB2YWx1ZS50b0ZpeGVkKC10ZW5FeHBvbmVudCkgOiB2YWx1ZS50b0ZpeGVkKHRlbkV4cG9uZW50ICsgMik7XG4gICAgICAgICAgICBpZiAoZm9ybWF0dGVkVmFsdWUuaW5kZXhPZignLicpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHZhciBsYXN0WmVybyA9IGZvcm1hdHRlZFZhbHVlLmxhc3RJbmRleE9mKCcwJyk7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAobGFzdFplcm8gPT09IGZvcm1hdHRlZFZhbHVlLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWUgPSBmb3JtYXR0ZWRWYWx1ZS5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RaZXJvID0gZm9ybWF0dGVkVmFsdWUubGFzdEluZGV4T2YoJzAnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL2RlbGV0ZSB0aGUgZG90IGlmIGlzIGxhc3RcbiAgICAgICAgICAgICAgICBpZiAoZm9ybWF0dGVkVmFsdWUuaW5kZXhPZignLicpID09PSBmb3JtYXR0ZWRWYWx1ZS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlID0gZm9ybWF0dGVkVmFsdWUuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAkLnBsb3QuZXhwUmVwVGlja0Zvcm1hdHRlcih2YWx1ZSwgYXhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLypsb2dheGlzIGNhcmFjdGVyaXN0aWMgZnVuY3Rpb25zKi9cbiAgICB2YXIgbG9nVHJhbnNmb3JtID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgaWYgKHYgPCBQUkVGRVJSRURfTE9HX1RJQ0tfVkFMVUVTWzBdKSB7XG4gICAgICAgICAgICB2ID0gUFJFRkVSUkVEX0xPR19USUNLX1ZBTFVFU1swXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBNYXRoLmxvZyh2KTtcbiAgICB9O1xuXG4gICAgdmFyIGxvZ0ludmVyc2VUcmFuc2Zvcm0gPSBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gTWF0aC5leHAodik7XG4gICAgfTtcblxuICAgIHZhciBpbnZlcnRlZFRyYW5zZm9ybSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiAtdjtcbiAgICB9XG5cbiAgICB2YXIgaW52ZXJ0ZWRMb2dUcmFuc2Zvcm0gPSBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gLWxvZ1RyYW5zZm9ybSh2KTtcbiAgICB9XG5cbiAgICB2YXIgaW52ZXJ0ZWRMb2dJbnZlcnNlVHJhbnNmb3JtID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIGxvZ0ludmVyc2VUcmFuc2Zvcm0oLXYpO1xuICAgIH1cblxuICAgIC8qKlxuICAgIC0gc2V0RGF0YW1pblJhbmdlKHBsb3QsIGF4aXMpXG5cbiAgICBJdCBpcyB1c2VkIGZvciBjbGFtcGluZyB0aGUgc3RhcnRpbmcgcG9pbnQgb2YgYSBsb2dhcml0aG1pYyBheGlzLlxuICAgIFRoaXMgd2lsbCBzZXQgdGhlIGF4aXMgZGF0YW1pbiByYW5nZSB0byAwLjEgb3IgdG8gdGhlIGZpcnN0IGRhdGFwb2ludCBncmVhdGVyIHRoZW4gMC5cbiAgICBUaGUgZnVuY3Rpb24gaXMgdXNlZnVsbCBzaW5jZSB0aGUgbG9nYXJpdGhtaWMgcmVwcmVzZW50YXRpb24gY2FuIG5vdCBzaG93XG4gICAgdmFsdWVzIGxlc3MgdGhhbiBvciBlcXVhbCB0byAwLlxuICAgICovXG4gICAgZnVuY3Rpb24gc2V0RGF0YW1pblJhbmdlKHBsb3QsIGF4aXMpIHtcbiAgICAgICAgaWYgKGF4aXMub3B0aW9ucy5tb2RlID09PSAnbG9nJyAmJiBheGlzLmRhdGFtaW4gPD0gMCkge1xuICAgICAgICAgICAgaWYgKGF4aXMuZGF0YW1pbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF4aXMuZGF0YW1pbiA9IDAuMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXhpcy5kYXRhbWluID0gcHJvY2Vzc0F4aXNPZmZzZXQocGxvdCwgYXhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzQXhpc09mZnNldChwbG90LCBheGlzKSB7XG4gICAgICAgIHZhciBzZXJpZXMgPSBwbG90LmdldERhdGEoKSxcbiAgICAgICAgICAgIHJhbmdlID0gc2VyaWVzXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihzZXJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlcmllcy54YXhpcyA9PT0gYXhpcyB8fCBzZXJpZXMueWF4aXMgPT09IGF4aXM7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKHNlcmllcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGxvdC5jb21wdXRlUmFuZ2VGb3JEYXRhU2VyaWVzKHNlcmllcywgbnVsbCwgaXNWYWxpZCk7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBtaW4gPSBheGlzLmRpcmVjdGlvbiA9PT0gJ3gnXG4gICAgICAgICAgICAgICAgPyBNYXRoLm1pbigwLjEsIHJhbmdlICYmIHJhbmdlWzBdID8gcmFuZ2VbMF0ueG1pbiA6IDAuMSlcbiAgICAgICAgICAgICAgICA6IE1hdGgubWluKDAuMSwgcmFuZ2UgJiYgcmFuZ2VbMF0gPyByYW5nZVswXS55bWluIDogMC4xKTtcblxuICAgICAgICBheGlzLm1pbiA9IG1pbjtcblxuICAgICAgICByZXR1cm4gbWluO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVmFsaWQoYSkge1xuICAgICAgICByZXR1cm4gYSA+IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5pdChwbG90KSB7XG4gICAgICAgIHBsb3QuaG9va3MucHJvY2Vzc09wdGlvbnMucHVzaChmdW5jdGlvbiAocGxvdCkge1xuICAgICAgICAgICAgJC5lYWNoKHBsb3QuZ2V0QXhlcygpLCBmdW5jdGlvbiAoYXhpc05hbWUsIGF4aXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0cyA9IGF4aXMub3B0aW9ucztcbiAgICAgICAgICAgICAgICBpZiAob3B0cy5tb2RlID09PSAnbG9nJykge1xuICAgICAgICAgICAgICAgICAgICBheGlzLnRpY2tHZW5lcmF0b3IgPSBmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vVGlja3MgPSAxMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2dUaWNrR2VuZXJhdG9yKHBsb3QsIGF4aXMsIG5vVGlja3MpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGF4aXMub3B0aW9ucy50aWNrRm9ybWF0dGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzLm9wdGlvbnMudGlja0Zvcm1hdHRlciA9IGxvZ1RpY2tGb3JtYXR0ZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXhpcy5vcHRpb25zLnRyYW5zZm9ybSA9IG9wdHMuaW52ZXJ0ZWQgPyBpbnZlcnRlZExvZ1RyYW5zZm9ybSA6IGxvZ1RyYW5zZm9ybTtcbiAgICAgICAgICAgICAgICAgICAgYXhpcy5vcHRpb25zLmludmVyc2VUcmFuc2Zvcm0gPSBvcHRzLmludmVydGVkID8gaW52ZXJ0ZWRMb2dJbnZlcnNlVHJhbnNmb3JtIDogbG9nSW52ZXJzZVRyYW5zZm9ybTtcbiAgICAgICAgICAgICAgICAgICAgYXhpcy5vcHRpb25zLmF1dG9TY2FsZU1hcmdpbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHBsb3QuaG9va3Muc2V0UmFuZ2UucHVzaChzZXREYXRhbWluUmFuZ2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0cy5pbnZlcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBheGlzLm9wdGlvbnMudHJhbnNmb3JtID0gaW52ZXJ0ZWRUcmFuc2Zvcm07XG4gICAgICAgICAgICAgICAgICAgIGF4aXMub3B0aW9ucy5pbnZlcnNlVHJhbnNmb3JtID0gaW52ZXJ0ZWRUcmFuc2Zvcm07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgICQucGxvdC5wbHVnaW5zLnB1c2goe1xuICAgICAgICBpbml0OiBpbml0LFxuICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICBuYW1lOiAnbG9nJyxcbiAgICAgICAgdmVyc2lvbjogJzAuMSdcbiAgICB9KTtcblxuICAgICQucGxvdC5sb2dUaWNrc0dlbmVyYXRvciA9IGxvZ1RpY2tHZW5lcmF0b3I7XG4gICAgJC5wbG90LmxvZ1RpY2tGb3JtYXR0ZXIgPSBsb2dUaWNrRm9ybWF0dGVyO1xufSkoalF1ZXJ5KTtcbiIsIi8qIEZsb3QgcGx1Z2luIGZvciBhZGRpbmcgdGhlIGFiaWxpdHkgdG8gcGFuIGFuZCB6b29tIHRoZSBwbG90LlxuXG5Db3B5cmlnaHQgKGMpIDIwMDctMjAxNCBJT0xBIGFuZCBPbGUgTGF1cnNlbi5cbkNvcHlyaWdodCAoYykgMjAxNiBDaXByaWFuIENldGVyYXMuXG5Db3B5cmlnaHQgKGMpIDIwMTcgUmFsdWNhIFBvcnRhc2UuXG5MaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cbiovXG5cbi8qKlxuIyMganF1ZXJ5LmZsb3QubmF2aWdhdGUuanNcblxuVGhpcyBmbG90IHBsdWdpbiBpcyB1c2VkIGZvciBhZGRpbmcgdGhlIGFiaWxpdHkgdG8gcGFuIGFuZCB6b29tIHRoZSBwbG90LlxuQSBoaWdoZXIgbGV2ZWwgb3ZlcnZpZXcgaXMgYXZhaWxhYmxlIGF0IFtpbnRlcmFjdGlvbnNdKGludGVyYWN0aW9ucy5tZCkgZG9jdW1lbnRhdGlvbi5cblxuVGhlIGRlZmF1bHQgYmVoYXZpb3VyIGlzIHNjcm9sbHdoZWVsIHVwL2Rvd24gdG8gem9vbSBpbiwgZHJhZ1xudG8gcGFuLiBUaGUgcGx1Z2luIGRlZmluZXMgcGxvdC56b29tKHsgY2VudGVyIH0pLCBwbG90Lnpvb21PdXQoKSBhbmRcbnBsb3QucGFuKCBvZmZzZXQgKSBzbyB5b3UgZWFzaWx5IGNhbiBhZGQgY3VzdG9tIGNvbnRyb2xzLiBJdCBhbHNvIGZpcmVzXG5cInBsb3RwYW5cIiBhbmQgXCJwbG90em9vbVwiIGV2ZW50cywgdXNlZnVsIGZvciBzeW5jaHJvbml6aW5nIHBsb3RzLlxuXG5UaGUgcGx1Z2luIHN1cHBvcnRzIHRoZXNlIG9wdGlvbnM6XG5gYGBqc1xuICAgIHpvb206IHtcbiAgICAgICAgaW50ZXJhY3RpdmU6IGZhbHNlLFxuICAgICAgICBhY3RpdmU6IGZhbHNlLFxuICAgICAgICBhbW91bnQ6IDEuNSAgICAgICAgIC8vIDIgPSAyMDAlICh6b29tIGluKSwgMC41ID0gNTAlICh6b29tIG91dClcbiAgICB9XG5cbiAgICBwYW46IHtcbiAgICAgICAgaW50ZXJhY3RpdmU6IGZhbHNlLFxuICAgICAgICBhY3RpdmU6IGZhbHNlLFxuICAgICAgICBjdXJzb3I6IFwibW92ZVwiLCAgICAgLy8gQ1NTIG1vdXNlIGN1cnNvciB2YWx1ZSB1c2VkIHdoZW4gZHJhZ2dpbmcsIGUuZy4gXCJwb2ludGVyXCJcbiAgICAgICAgZnJhbWVSYXRlOiA2MCxcbiAgICAgICAgbW9kZTogXCJzbWFydFwiICAgICAgIC8vIGVuYWJsZSBzbWFydCBwYW4gbW9kZVxuICAgIH1cblxuICAgIHhheGlzOiB7XG4gICAgICAgIGF4aXNab29tOiB0cnVlLCAvL3pvb20gYXhpcyB3aGVuIG1vdXNlIG92ZXIgaXQgaXMgYWxsb3dlZFxuICAgICAgICBwbG90Wm9vbTogdHJ1ZSwgLy96b29tIGF4aXMgaXMgYWxsb3dlZCBmb3IgcGxvdCB6b29tXG4gICAgICAgIGF4aXNQYW46IHRydWUsIC8vcGFuIGF4aXMgd2hlbiBtb3VzZSBvdmVyIGl0IGlzIGFsbG93ZWRcbiAgICAgICAgcGxvdFBhbjogdHJ1ZSwgLy9wYW4gYXhpcyBpcyBhbGxvd2VkIGZvciBwbG90IHBhblxuICAgICAgICBwYW5SYW5nZTogW3VuZGVmaW5lZCwgdW5kZWZpbmVkXSwgLy8gbm8gbGltaXQgb24gcGFuIHJhbmdlLCBvciBbbWluLCBtYXhdIGluIGF4aXMgdW5pdHNcbiAgICAgICAgem9vbVJhbmdlOiBbdW5kZWZpbmVkLCB1bmRlZmluZWRdLCAvLyBubyBsaW1pdCBvbiB6b29tIHJhbmdlLCBvciBbY2xvc2VzdCB6b29tLCBmdXJ0aGVzdCB6b29tXSBpbiBheGlzIHVuaXRzXG4gICAgfVxuXG4gICAgeWF4aXM6IHtcbiAgICAgICAgYXhpc1pvb206IHRydWUsIC8vem9vbSBheGlzIHdoZW4gbW91c2Ugb3ZlciBpdCBpcyBhbGxvd2VkXG4gICAgICAgIHBsb3Rab29tOiB0cnVlLCAvL3pvb20gYXhpcyBpcyBhbGxvd2VkIGZvciBwbG90IHpvb21cbiAgICAgICAgYXhpc1BhbjogdHJ1ZSwgLy9wYW4gYXhpcyB3aGVuIG1vdXNlIG92ZXIgaXQgaXMgYWxsb3dlZFxuICAgICAgICBwbG90UGFuOiB0cnVlIC8vcGFuIGF4aXMgaXMgYWxsb3dlZCBmb3IgcGxvdCBwYW5cbiAgICAgICAgcGFuUmFuZ2U6IFt1bmRlZmluZWQsIHVuZGVmaW5lZF0sIC8vIG5vIGxpbWl0IG9uIHBhbiByYW5nZSwgb3IgW21pbiwgbWF4XSBpbiBheGlzIHVuaXRzXG4gICAgICAgIHpvb21SYW5nZTogW3VuZGVmaW5lZCwgdW5kZWZpbmVkXSwgLy8gbm8gbGltaXQgb24gem9vbSByYW5nZSwgb3IgW2Nsb3Nlc3Qgem9vbSwgZnVydGhlc3Qgem9vbV0gaW4gYXhpcyB1bml0c1xuICAgIH1cbmBgYFxuKippbnRlcmFjdGl2ZSoqIGVuYWJsZXMgdGhlIGJ1aWx0LWluIGRyYWcvY2xpY2sgYmVoYXZpb3VyLiBJZiB5b3UgZW5hYmxlXG5pbnRlcmFjdGl2ZSBmb3IgcGFuLCB0aGVuIHlvdSdsbCBoYXZlIGEgYmFzaWMgcGxvdCB0aGF0IHN1cHBvcnRzIG1vdmluZ1xuYXJvdW5kOyB0aGUgc2FtZSBmb3Igem9vbS5cblxuKiphY3RpdmUqKiBpcyB0cnVlIGFmdGVyIGEgdG91Y2ggdGFwIG9uIHBsb3QuIFRoaXMgZW5hYmxlcyBwbG90IG5hdmlnYXRpb24uXG5PbmNlIGFjdGl2YXRlZCwgem9vbSBhbmQgcGFuIGNhbm5vdCBiZSBkZWFjdGl2YXRlZC4gV2hlbiB0aGUgcGxvdCBiZWNvbWVzIGFjdGl2ZSxcblwicGxvdGFjdGl2YXRlZFwiIGV2ZW50IGlzIHRyaWdnZXJlZC5cblxuKiphbW91bnQqKiBzcGVjaWZpZXMgdGhlIGRlZmF1bHQgYW1vdW50IHRvIHpvb20gaW4gKHNvIDEuNSA9IDE1MCUpIHJlbGF0aXZlIHRvXG50aGUgY3VycmVudCB2aWV3cG9ydC5cblxuKipjdXJzb3IqKiBpcyBhIHN0YW5kYXJkIENTUyBtb3VzZSBjdXJzb3Igc3RyaW5nIHVzZWQgZm9yIHZpc3VhbCBmZWVkYmFjayB0byB0aGVcbnVzZXIgd2hlbiBkcmFnZ2luZy5cblxuKipmcmFtZVJhdGUqKiBzcGVjaWZpZXMgdGhlIG1heGltdW0gbnVtYmVyIG9mIHRpbWVzIHBlciBzZWNvbmQgdGhlIHBsb3Qgd2lsbFxudXBkYXRlIGl0c2VsZiB3aGlsZSB0aGUgdXNlciBpcyBwYW5uaW5nIGFyb3VuZCBvbiBpdCAoc2V0IHRvIG51bGwgdG8gZGlzYWJsZVxuaW50ZXJtZWRpYXRlIHBhbnMsIHRoZSBwbG90IHdpbGwgdGhlbiBub3QgdXBkYXRlIHVudGlsIHRoZSBtb3VzZSBidXR0b24gaXNcbnJlbGVhc2VkKS5cblxuKiptb2RlKiogYSBzdHJpbmcgc3BlY2lmaWVzIHRoZSBwYW4gbW9kZSBmb3IgbW91c2UgaW50ZXJhY3Rpb24uIEFjY2VwdGVkIHZhbHVlczpcbidtYW51YWwnOiBubyBwYW4gaGludCBvciBkaXJlY3Rpb24gc25hcHBpbmc7XG4nc21hcnQnOiBUaGUgZ3JhcGggc2hvd3MgcGFuIGhpbnQgYmFyIGFuZCB0aGUgcGFuIG1vdmVtZW50IHdpbGwgc25hcFxudG8gb25lIGRpcmVjdGlvbiB3aGVuIHRoZSBkcmFnIGRpcmVjdGlvbiBpcyBjbG9zZSB0byBpdDtcbidzbWFydExvY2snLiBUaGUgZ3JhcGggc2hvd3MgcGFuIGhpbnQgYmFyIGFuZCB0aGUgcGFuIG1vdmVtZW50IHdpbGwgYWx3YXlzXG5zbmFwIHRvIGEgZGlyZWN0aW9uIHRoYXQgdGhlIGRyYWcgZGlvcmVjdGlvbiBzdGFydGVkIHdpdGguXG5cbkV4YW1wbGUgQVBJIHVzYWdlOlxuYGBganNcbiAgICBwbG90ID0gJC5wbG90KC4uLik7XG5cbiAgICAvLyB6b29tIGRlZmF1bHQgYW1vdW50IGluIG9uIHRoZSBwaXhlbCAoIDEwLCAyMCApXG4gICAgcGxvdC56b29tKHsgY2VudGVyOiB7IGxlZnQ6IDEwLCB0b3A6IDIwIH0gfSk7XG5cbiAgICAvLyB6b29tIG91dCBhZ2FpblxuICAgIHBsb3Quem9vbU91dCh7IGNlbnRlcjogeyBsZWZ0OiAxMCwgdG9wOiAyMCB9IH0pO1xuXG4gICAgLy8gem9vbSAyMDAlIGluIG9uIHRoZSBwaXhlbCAoMTAsIDIwKVxuICAgIHBsb3Quem9vbSh7IGFtb3VudDogMiwgY2VudGVyOiB7IGxlZnQ6IDEwLCB0b3A6IDIwIH0gfSk7XG5cbiAgICAvLyBwYW4gMTAwIHBpeGVscyB0byB0aGUgbGVmdCAoY2hhbmdpbmcgeC1yYW5nZSBpbiBhIHBvc2l0aXZlIHdheSkgYW5kIDIwIGRvd25cbiAgICBwbG90LnBhbih7IGxlZnQ6IC0xMDAsIHRvcDogMjAgfSlcbmBgYFxuXG5IZXJlLCBcImNlbnRlclwiIHNwZWNpZmllcyB3aGVyZSB0aGUgY2VudGVyIG9mIHRoZSB6b29taW5nIHNob3VsZCBoYXBwZW4uIE5vdGVcbnRoYXQgdGhpcyBpcyBkZWZpbmVkIGluIHBpeGVsIHNwYWNlLCBub3QgdGhlIHNwYWNlIG9mIHRoZSBkYXRhIHBvaW50cyAoeW91IGNhblxudXNlIHRoZSBwMmMgaGVscGVycyBvbiB0aGUgYXhlcyBpbiBGbG90IHRvIGhlbHAgeW91IGNvbnZlcnQgYmV0d2VlbiB0aGVzZSkuXG5cbioqYW1vdW50KiogaXMgdGhlIGFtb3VudCB0byB6b29tIHRoZSB2aWV3cG9ydCByZWxhdGl2ZSB0byB0aGUgY3VycmVudCByYW5nZSwgc29cbjEgaXMgMTAwJSAoaS5lLiBubyBjaGFuZ2UpLCAxLjUgaXMgMTUwJSAoem9vbSBpbiksIDAuNyBpcyA3MCUgKHpvb20gb3V0KS4gWW91XG5jYW4gc2V0IHRoZSBkZWZhdWx0IGluIHRoZSBvcHRpb25zLlxuKi9cblxuLyogZXNsaW50LWVuYWJsZSAqL1xuKGZ1bmN0aW9uKCQpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgem9vbToge1xuICAgICAgICAgICAgaW50ZXJhY3RpdmU6IGZhbHNlLFxuICAgICAgICAgICAgYWN0aXZlOiBmYWxzZSxcbiAgICAgICAgICAgIGFtb3VudDogMS41IC8vIGhvdyBtdWNoIHRvIHpvb20gcmVsYXRpdmUgdG8gY3VycmVudCBwb3NpdGlvbiwgMiA9IDIwMCUgKHpvb20gaW4pLCAwLjUgPSA1MCUgKHpvb20gb3V0KVxuICAgICAgICB9LFxuICAgICAgICBwYW46IHtcbiAgICAgICAgICAgIGludGVyYWN0aXZlOiBmYWxzZSxcbiAgICAgICAgICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgICAgICAgICBjdXJzb3I6IFwibW92ZVwiLFxuICAgICAgICAgICAgZnJhbWVSYXRlOiA2MCxcbiAgICAgICAgICAgIG1vZGU6ICdzbWFydCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVjZW50ZXI6IHtcbiAgICAgICAgICAgIGludGVyYWN0aXZlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIHhheGlzOiB7XG4gICAgICAgICAgICBheGlzWm9vbTogdHJ1ZSwgLy96b29tIGF4aXMgd2hlbiBtb3VzZSBvdmVyIGl0IGlzIGFsbG93ZWRcbiAgICAgICAgICAgIHBsb3Rab29tOiB0cnVlLCAvL3pvb20gYXhpcyBpcyBhbGxvd2VkIGZvciBwbG90IHpvb21cbiAgICAgICAgICAgIGF4aXNQYW46IHRydWUsIC8vcGFuIGF4aXMgd2hlbiBtb3VzZSBvdmVyIGl0IGlzIGFsbG93ZWRcbiAgICAgICAgICAgIHBsb3RQYW46IHRydWUsIC8vcGFuIGF4aXMgaXMgYWxsb3dlZCBmb3IgcGxvdCBwYW5cbiAgICAgICAgICAgIHBhblJhbmdlOiBbdW5kZWZpbmVkLCB1bmRlZmluZWRdLCAvLyBubyBsaW1pdCBvbiBwYW4gcmFuZ2UsIG9yIFttaW4sIG1heF0gaW4gYXhpcyB1bml0c1xuICAgICAgICAgICAgem9vbVJhbmdlOiBbdW5kZWZpbmVkLCB1bmRlZmluZWRdIC8vIG5vIGxpbWl0IG9uIHpvb20gcmFuZ2UsIG9yIFtjbG9zZXN0IHpvb20sIGZ1cnRoZXN0IHpvb21dIGluIGF4aXMgdW5pdHNcbiAgICAgICAgfSxcbiAgICAgICAgeWF4aXM6IHtcbiAgICAgICAgICAgIGF4aXNab29tOiB0cnVlLFxuICAgICAgICAgICAgcGxvdFpvb206IHRydWUsXG4gICAgICAgICAgICBheGlzUGFuOiB0cnVlLFxuICAgICAgICAgICAgcGxvdFBhbjogdHJ1ZSxcbiAgICAgICAgICAgIHBhblJhbmdlOiBbdW5kZWZpbmVkLCB1bmRlZmluZWRdLCAvLyBubyBsaW1pdCBvbiBwYW4gcmFuZ2UsIG9yIFttaW4sIG1heF0gaW4gYXhpcyB1bml0c1xuICAgICAgICAgICAgem9vbVJhbmdlOiBbdW5kZWZpbmVkLCB1bmRlZmluZWRdIC8vIG5vIGxpbWl0IG9uIHpvb20gcmFuZ2UsIG9yIFtjbG9zZXN0IHpvb20sIGZ1cnRoZXN0IHpvb21dIGluIGF4aXMgdW5pdHNcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgc2F0dXJhdGVkID0gJC5wbG90LnNhdHVyYXRlZDtcbiAgICB2YXIgYnJvd3NlciA9ICQucGxvdC5icm93c2VyO1xuICAgIHZhciBTTkFQUElOR19DT05TVEFOVCA9ICQucGxvdC51aUNvbnN0YW50cy5TTkFQUElOR19DT05TVEFOVDtcbiAgICB2YXIgUEFOSElOVF9MRU5HVEhfQ09OU1RBTlQgPSAkLnBsb3QudWlDb25zdGFudHMuUEFOSElOVF9MRU5HVEhfQ09OU1RBTlQ7XG5cbiAgICBmdW5jdGlvbiBpbml0KHBsb3QpIHtcbiAgICAgICAgcGxvdC5ob29rcy5wcm9jZXNzT3B0aW9ucy5wdXNoKGluaXROZXZpZ2F0aW9uKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0TmV2aWdhdGlvbihwbG90LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBwYW5BeGVzID0gbnVsbDtcbiAgICAgICAgdmFyIGNhbkRyYWcgPSBmYWxzZTtcbiAgICAgICAgdmFyIHVzZU1hbnVhbFBhbiA9IG9wdGlvbnMucGFuLm1vZGUgPT09ICdtYW51YWwnLFxuICAgICAgICAgICAgc21hcnRQYW5Mb2NrID0gb3B0aW9ucy5wYW4ubW9kZSA9PT0gJ3NtYXJ0TG9jaycsXG4gICAgICAgICAgICB1c2VTbWFydFBhbiA9IHNtYXJ0UGFuTG9jayB8fCBvcHRpb25zLnBhbi5tb2RlID09PSAnc21hcnQnO1xuXG4gICAgICAgIGZ1bmN0aW9uIG9uWm9vbUNsaWNrKGUsIHpvb21PdXQsIGFtb3VudCkge1xuICAgICAgICAgICAgdmFyIHBhZ2UgPSBicm93c2VyLmdldFBhZ2VYWShlKTtcblxuICAgICAgICAgICAgdmFyIGMgPSBwbG90Lm9mZnNldCgpO1xuICAgICAgICAgICAgYy5sZWZ0ID0gcGFnZS5YIC0gYy5sZWZ0O1xuICAgICAgICAgICAgYy50b3AgPSBwYWdlLlkgLSBjLnRvcDtcblxuICAgICAgICAgICAgdmFyIGVjID0gcGxvdC5nZXRQbGFjZWhvbGRlcigpLm9mZnNldCgpO1xuICAgICAgICAgICAgZWMubGVmdCA9IHBhZ2UuWCAtIGVjLmxlZnQ7XG4gICAgICAgICAgICBlYy50b3AgPSBwYWdlLlkgLSBlYy50b3A7XG5cbiAgICAgICAgICAgIHZhciBheGVzID0gcGxvdC5nZXRYQXhlcygpLmNvbmNhdChwbG90LmdldFlBeGVzKCkpLmZpbHRlcihmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICAgICAgICAgIHZhciBib3ggPSBheGlzLmJveDtcbiAgICAgICAgICAgICAgICBpZiAoYm94ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlYy5sZWZ0ID4gYm94LmxlZnQpICYmIChlYy5sZWZ0IDwgYm94LmxlZnQgKyBib3gud2lkdGgpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoZWMudG9wID4gYm94LnRvcCkgJiYgKGVjLnRvcCA8IGJveC50b3AgKyBib3guaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGF4ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYXhlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHpvb21PdXQpIHtcbiAgICAgICAgICAgICAgICBwbG90Lnpvb21PdXQoe1xuICAgICAgICAgICAgICAgICAgICBjZW50ZXI6IGMsXG4gICAgICAgICAgICAgICAgICAgIGF4ZXM6IGF4ZXMsXG4gICAgICAgICAgICAgICAgICAgIGFtb3VudDogYW1vdW50XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBsb3Quem9vbSh7XG4gICAgICAgICAgICAgICAgICAgIGNlbnRlcjogYyxcbiAgICAgICAgICAgICAgICAgICAgYXhlczogYXhlcyxcbiAgICAgICAgICAgICAgICAgICAgYW1vdW50OiBhbW91bnRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcmV2Q3Vyc29yID0gJ2RlZmF1bHQnLFxuICAgICAgICAgICAgcGFuSGludCA9IG51bGwsXG4gICAgICAgICAgICBwYW5UaW1lb3V0ID0gbnVsbCxcbiAgICAgICAgICAgIHBsb3RTdGF0ZSxcbiAgICAgICAgICAgIHByZXZEcmFnUG9zaXRpb24gPSB7IHg6IDAsIHk6IDAgfSxcbiAgICAgICAgICAgIGlzUGFuQWN0aW9uID0gZmFsc2U7XG5cbiAgICAgICAgZnVuY3Rpb24gb25Nb3VzZVdoZWVsKGUsIGRlbHRhKSB7XG4gICAgICAgICAgICB2YXIgbWF4QWJzb2x1dGVEZWx0YU9uTWFjID0gMSxcbiAgICAgICAgICAgICAgICBpc01hY1Njcm9sbCA9IE1hdGguYWJzKGUub3JpZ2luYWxFdmVudC5kZWx0YVkpIDw9IG1heEFic29sdXRlRGVsdGFPbk1hYyxcbiAgICAgICAgICAgICAgICBkZWZhdWx0Tm9uTWFjU2Nyb2xsQW1vdW50ID0gbnVsbCxcbiAgICAgICAgICAgICAgICBtYWNNYWdpY1JhdGlvID0gNTAsXG4gICAgICAgICAgICAgICAgYW1vdW50ID0gaXNNYWNTY3JvbGwgPyAxICsgTWF0aC5hYnMoZS5vcmlnaW5hbEV2ZW50LmRlbHRhWSkgLyBtYWNNYWdpY1JhdGlvIDogZGVmYXVsdE5vbk1hY1Njcm9sbEFtb3VudDtcblxuICAgICAgICAgICAgaWYgKGlzUGFuQWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgb25EcmFnRW5kKGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGxvdC5nZXRPcHRpb25zKCkuem9vbS5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgb25ab29tQ2xpY2soZSwgZGVsdGEgPCAwLCBhbW91bnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHBsb3QubmF2aWdhdGlvblN0YXRlID0gZnVuY3Rpb24oc3RhcnRQYWdlWCwgc3RhcnRQYWdlWSkge1xuICAgICAgICAgICAgdmFyIGF4ZXMgPSB0aGlzLmdldEF4ZXMoKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF4ZXMpLmZvckVhY2goZnVuY3Rpb24oYXhpc05hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXhpcyA9IGF4ZXNbYXhpc05hbWVdO1xuICAgICAgICAgICAgICAgIHJlc3VsdFtheGlzTmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIG5hdmlnYXRpb25PZmZzZXQ6IHsgYmVsb3c6IGF4aXMub3B0aW9ucy5vZmZzZXQuYmVsb3cgfHwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFib3ZlOiBheGlzLm9wdGlvbnMub2Zmc2V0LmFib3ZlIHx8IDB9LFxuICAgICAgICAgICAgICAgICAgICBheGlzTWluOiBheGlzLm1pbixcbiAgICAgICAgICAgICAgICAgICAgYXhpc01heDogYXhpcy5tYXgsXG4gICAgICAgICAgICAgICAgICAgIGRpYWdNb2RlOiBmYWxzZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXN1bHQuc3RhcnRQYWdlWCA9IHN0YXJ0UGFnZVggfHwgMDtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydFBhZ2VZID0gc3RhcnRQYWdlWSB8fCAwO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG9uTW91c2VEb3duKGUpIHtcbiAgICAgICAgICAgIGNhbkRyYWcgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gb25Nb3VzZVVwKGUpIHtcbiAgICAgICAgICAgIGNhbkRyYWcgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGlzTGVmdE1vdXNlQnV0dG9uUHJlc3NlZChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZS5idXR0b24gPT09IDA7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBvbkRyYWdTdGFydChlKSB7XG4gICAgICAgICAgICBpZiAoIWNhbkRyYWcgfHwgIWlzTGVmdE1vdXNlQnV0dG9uUHJlc3NlZChlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaXNQYW5BY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgdmFyIHBhZ2UgPSBicm93c2VyLmdldFBhZ2VYWShlKTtcblxuICAgICAgICAgICAgdmFyIGVjID0gcGxvdC5nZXRQbGFjZWhvbGRlcigpLm9mZnNldCgpO1xuICAgICAgICAgICAgZWMubGVmdCA9IHBhZ2UuWCAtIGVjLmxlZnQ7XG4gICAgICAgICAgICBlYy50b3AgPSBwYWdlLlkgLSBlYy50b3A7XG5cbiAgICAgICAgICAgIHBhbkF4ZXMgPSBwbG90LmdldFhBeGVzKCkuY29uY2F0KHBsb3QuZ2V0WUF4ZXMoKSkuZmlsdGVyKGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJveCA9IGF4aXMuYm94O1xuICAgICAgICAgICAgICAgIGlmIChib3ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGVjLmxlZnQgPiBib3gubGVmdCkgJiYgKGVjLmxlZnQgPCBib3gubGVmdCArIGJveC53aWR0aCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChlYy50b3AgPiBib3gudG9wKSAmJiAoZWMudG9wIDwgYm94LnRvcCArIGJveC5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAocGFuQXhlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBwYW5BeGVzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYyA9IHBsb3QuZ2V0UGxhY2Vob2xkZXIoKS5jc3MoJ2N1cnNvcicpO1xuICAgICAgICAgICAgaWYgKGMpIHtcbiAgICAgICAgICAgICAgICBwcmV2Q3Vyc29yID0gYztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGxvdC5nZXRQbGFjZWhvbGRlcigpLmNzcygnY3Vyc29yJywgcGxvdC5nZXRPcHRpb25zKCkucGFuLmN1cnNvcik7XG5cbiAgICAgICAgICAgIGlmICh1c2VTbWFydFBhbikge1xuICAgICAgICAgICAgICAgIHBsb3RTdGF0ZSA9IHBsb3QubmF2aWdhdGlvblN0YXRlKHBhZ2UuWCwgcGFnZS5ZKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodXNlTWFudWFsUGFuKSB7XG4gICAgICAgICAgICAgICAgcHJldkRyYWdQb3NpdGlvbi54ID0gcGFnZS5YO1xuICAgICAgICAgICAgICAgIHByZXZEcmFnUG9zaXRpb24ueSA9IHBhZ2UuWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG9uRHJhZyhlKSB7XG4gICAgICAgICAgICBpZiAoIWlzUGFuQWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcGFnZSA9IGJyb3dzZXIuZ2V0UGFnZVhZKGUpO1xuICAgICAgICAgICAgdmFyIGZyYW1lUmF0ZSA9IHBsb3QuZ2V0T3B0aW9ucygpLnBhbi5mcmFtZVJhdGU7XG5cbiAgICAgICAgICAgIGlmIChmcmFtZVJhdGUgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVzZVNtYXJ0UGFuKSB7XG4gICAgICAgICAgICAgICAgICAgIHBsb3Quc21hcnRQYW4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogcGxvdFN0YXRlLnN0YXJ0UGFnZVggLSBwYWdlLlgsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBwbG90U3RhdGUuc3RhcnRQYWdlWSAtIHBhZ2UuWVxuICAgICAgICAgICAgICAgICAgICB9LCBwbG90U3RhdGUsIHBhbkF4ZXMsIGZhbHNlLCBzbWFydFBhbkxvY2spO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodXNlTWFudWFsUGFuKSB7XG4gICAgICAgICAgICAgICAgICAgIHBsb3QucGFuKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHByZXZEcmFnUG9zaXRpb24ueCAtIHBhZ2UuWCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogcHJldkRyYWdQb3NpdGlvbi55IC0gcGFnZS5ZLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXhlczogcGFuQXhlc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcHJldkRyYWdQb3NpdGlvbi54ID0gcGFnZS5YO1xuICAgICAgICAgICAgICAgICAgICBwcmV2RHJhZ1Bvc2l0aW9uLnkgPSBwYWdlLlk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBhblRpbWVvdXQgfHwgIWZyYW1lUmF0ZSkgcmV0dXJuO1xuXG4gICAgICAgICAgICBwYW5UaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAodXNlU21hcnRQYW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcGxvdC5zbWFydFBhbih7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBwbG90U3RhdGUuc3RhcnRQYWdlWCAtIHBhZ2UuWCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHBsb3RTdGF0ZS5zdGFydFBhZ2VZIC0gcGFnZS5ZXG4gICAgICAgICAgICAgICAgICAgIH0sIHBsb3RTdGF0ZSwgcGFuQXhlcywgZmFsc2UsIHNtYXJ0UGFuTG9jayk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh1c2VNYW51YWxQYW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcGxvdC5wYW4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogcHJldkRyYWdQb3NpdGlvbi54IC0gcGFnZS5YLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBwcmV2RHJhZ1Bvc2l0aW9uLnkgLSBwYWdlLlksXG4gICAgICAgICAgICAgICAgICAgICAgICBheGVzOiBwYW5BeGVzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBwcmV2RHJhZ1Bvc2l0aW9uLnggPSBwYWdlLlg7XG4gICAgICAgICAgICAgICAgICAgIHByZXZEcmFnUG9zaXRpb24ueSA9IHBhZ2UuWTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwYW5UaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgIH0sIDEgLyBmcmFtZVJhdGUgKiAxMDAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG9uRHJhZ0VuZChlKSB7XG4gICAgICAgICAgICBpZiAoIWlzUGFuQWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFuVGltZW91dCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChwYW5UaW1lb3V0KTtcbiAgICAgICAgICAgICAgICBwYW5UaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaXNQYW5BY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBwYWdlID0gYnJvd3Nlci5nZXRQYWdlWFkoZSk7XG5cbiAgICAgICAgICAgIHBsb3QuZ2V0UGxhY2Vob2xkZXIoKS5jc3MoJ2N1cnNvcicsIHByZXZDdXJzb3IpO1xuXG4gICAgICAgICAgICBpZiAodXNlU21hcnRQYW4pIHtcbiAgICAgICAgICAgICAgICBwbG90LnNtYXJ0UGFuKHtcbiAgICAgICAgICAgICAgICAgICAgeDogcGxvdFN0YXRlLnN0YXJ0UGFnZVggLSBwYWdlLlgsXG4gICAgICAgICAgICAgICAgICAgIHk6IHBsb3RTdGF0ZS5zdGFydFBhZ2VZIC0gcGFnZS5ZXG4gICAgICAgICAgICAgICAgfSwgcGxvdFN0YXRlLCBwYW5BeGVzLCBmYWxzZSwgc21hcnRQYW5Mb2NrKTtcbiAgICAgICAgICAgICAgICBwbG90LnNtYXJ0UGFuLmVuZCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh1c2VNYW51YWxQYW4pIHtcbiAgICAgICAgICAgICAgICBwbG90LnBhbih7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IHByZXZEcmFnUG9zaXRpb24ueCAtIHBhZ2UuWCxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiBwcmV2RHJhZ1Bvc2l0aW9uLnkgLSBwYWdlLlksXG4gICAgICAgICAgICAgICAgICAgIGF4ZXM6IHBhbkF4ZXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBwcmV2RHJhZ1Bvc2l0aW9uLnggPSAwO1xuICAgICAgICAgICAgICAgIHByZXZEcmFnUG9zaXRpb24ueSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBvbkRibENsaWNrKGUpIHtcbiAgICAgICAgICAgIHBsb3QuYWN0aXZhdGUoKTtcbiAgICAgICAgICAgIHZhciBvID0gcGxvdC5nZXRPcHRpb25zKClcblxuICAgICAgICAgICAgaWYgKCFvLnJlY2VudGVyLmludGVyYWN0aXZlKSB7IHJldHVybjsgfVxuXG4gICAgICAgICAgICB2YXIgYXhlcyA9IHBsb3QuZ2V0VG91Y2hlZEF4aXMoZS5jbGllbnRYLCBlLmNsaWVudFkpLFxuICAgICAgICAgICAgICAgIGV2ZW50O1xuXG4gICAgICAgICAgICBwbG90LnJlY2VudGVyKHsgYXhlczogYXhlc1swXSA/IGF4ZXMgOiBudWxsIH0pO1xuXG4gICAgICAgICAgICBpZiAoYXhlc1swXSkge1xuICAgICAgICAgICAgICAgIGV2ZW50ID0gbmV3ICQuRXZlbnQoJ3JlLWNlbnRlcicsIHsgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgICAgIGF4aXNUb3VjaGVkOiBheGVzWzBdXG4gICAgICAgICAgICAgICAgfX0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBldmVudCA9IG5ldyAkLkV2ZW50KCdyZS1jZW50ZXInLCB7IGRldGFpbDogZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBsb3QuZ2V0UGxhY2Vob2xkZXIoKS50cmlnZ2VyKGV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG9uQ2xpY2soZSkge1xuICAgICAgICAgICAgcGxvdC5hY3RpdmF0ZSgpO1xuXG4gICAgICAgICAgICBpZiAoaXNQYW5BY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBvbkRyYWdFbmQoZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBsb3QuYWN0aXZhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBvID0gcGxvdC5nZXRPcHRpb25zKCk7XG4gICAgICAgICAgICBpZiAoIW8ucGFuLmFjdGl2ZSB8fCAhby56b29tLmFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIG8ucGFuLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgby56b29tLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcGxvdC5nZXRQbGFjZWhvbGRlcigpLnRyaWdnZXIoXCJwbG90YWN0aXZhdGVkXCIsIFtwbG90XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBiaW5kRXZlbnRzKHBsb3QsIGV2ZW50SG9sZGVyKSB7XG4gICAgICAgICAgICB2YXIgbyA9IHBsb3QuZ2V0T3B0aW9ucygpO1xuICAgICAgICAgICAgaWYgKG8uem9vbS5pbnRlcmFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIGV2ZW50SG9sZGVyLm1vdXNld2hlZWwob25Nb3VzZVdoZWVsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG8ucGFuLmludGVyYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgcGxvdC5hZGRFdmVudEhhbmRsZXIoXCJkcmFnc3RhcnRcIiwgb25EcmFnU3RhcnQsIGV2ZW50SG9sZGVyLCAwKTtcbiAgICAgICAgICAgICAgICBwbG90LmFkZEV2ZW50SGFuZGxlcihcImRyYWdcIiwgb25EcmFnLCBldmVudEhvbGRlciwgMCk7XG4gICAgICAgICAgICAgICAgcGxvdC5hZGRFdmVudEhhbmRsZXIoXCJkcmFnZW5kXCIsIG9uRHJhZ0VuZCwgZXZlbnRIb2xkZXIsIDApO1xuICAgICAgICAgICAgICAgIGV2ZW50SG9sZGVyLmJpbmQoXCJtb3VzZWRvd25cIiwgb25Nb3VzZURvd24pO1xuICAgICAgICAgICAgICAgIGV2ZW50SG9sZGVyLmJpbmQoXCJtb3VzZXVwXCIsIG9uTW91c2VVcCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV2ZW50SG9sZGVyLmRibGNsaWNrKG9uRGJsQ2xpY2spO1xuICAgICAgICAgICAgZXZlbnRIb2xkZXIuY2xpY2sob25DbGljayk7XG4gICAgICAgIH1cblxuICAgICAgICBwbG90Lnpvb21PdXQgPSBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3MpIHtcbiAgICAgICAgICAgICAgICBhcmdzID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghYXJncy5hbW91bnQpIHtcbiAgICAgICAgICAgICAgICBhcmdzLmFtb3VudCA9IHBsb3QuZ2V0T3B0aW9ucygpLnpvb20uYW1vdW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhcmdzLmFtb3VudCA9IDEgLyBhcmdzLmFtb3VudDtcbiAgICAgICAgICAgIHBsb3Quem9vbShhcmdzKTtcbiAgICAgICAgfTtcblxuICAgICAgICBwbG90Lnpvb20gPSBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3MpIHtcbiAgICAgICAgICAgICAgICBhcmdzID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjID0gYXJncy5jZW50ZXIsXG4gICAgICAgICAgICAgICAgYW1vdW50ID0gYXJncy5hbW91bnQgfHwgcGxvdC5nZXRPcHRpb25zKCkuem9vbS5hbW91bnQsXG4gICAgICAgICAgICAgICAgdyA9IHBsb3Qud2lkdGgoKSxcbiAgICAgICAgICAgICAgICBoID0gcGxvdC5oZWlnaHQoKSxcbiAgICAgICAgICAgICAgICBheGVzID0gYXJncy5heGVzIHx8IHBsb3QuZ2V0QXhlcygpO1xuXG4gICAgICAgICAgICBpZiAoIWMpIHtcbiAgICAgICAgICAgICAgICBjID0ge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiB3IC8gMixcbiAgICAgICAgICAgICAgICAgICAgdG9wOiBoIC8gMlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB4ZiA9IGMubGVmdCAvIHcsXG4gICAgICAgICAgICAgICAgeWYgPSBjLnRvcCAvIGgsXG4gICAgICAgICAgICAgICAgbWlubWF4ID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW46IGMubGVmdCAtIHhmICogdyAvIGFtb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heDogYy5sZWZ0ICsgKDEgLSB4ZikgKiB3IC8gYW1vdW50XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbjogYy50b3AgLSB5ZiAqIGggLyBhbW91bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXg6IGMudG9wICsgKDEgLSB5ZikgKiBoIC8gYW1vdW50XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gYXhlcykge1xuICAgICAgICAgICAgICAgIGlmICghYXhlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBheGlzID0gYXhlc1trZXldLFxuICAgICAgICAgICAgICAgICAgICBvcHRzID0gYXhpcy5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBtaW5tYXhbYXhpcy5kaXJlY3Rpb25dLm1pbixcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gbWlubWF4W2F4aXMuZGlyZWN0aW9uXS5tYXgsXG4gICAgICAgICAgICAgICAgICAgIG5hdmlnYXRpb25PZmZzZXQgPSBheGlzLm9wdGlvbnMub2Zmc2V0O1xuXG4gICAgICAgICAgICAgICAgLy9za2lwIGF4aXMgd2l0aG91dCBheGlzWm9vbSB3aGVuIHpvb21pbmcgb25seSBvbiBjZXJ0YWluIGF4aXMgb3IgYXhpcyB3aXRob3V0IHBsb3Rab29tIGZvciB6b29tIG9uIGVudGlyZSBwbG90XG4gICAgICAgICAgICAgICAgaWYgKCghb3B0cy5heGlzWm9vbSAmJiBhcmdzLmF4ZXMpIHx8ICghYXJncy5heGVzICYmICFvcHRzLnBsb3Rab29tKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtaW4gPSAkLnBsb3Quc2F0dXJhdGVkLnNhdHVyYXRlKGF4aXMuYzJwKG1pbikpO1xuICAgICAgICAgICAgICAgIG1heCA9ICQucGxvdC5zYXR1cmF0ZWQuc2F0dXJhdGUoYXhpcy5jMnAobWF4KSk7XG4gICAgICAgICAgICAgICAgaWYgKG1pbiA+IG1heCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgbWluIDwgbWF4XG4gICAgICAgICAgICAgICAgICAgIHZhciB0bXAgPSBtaW47XG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IG1heDtcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gdG1wO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHRlc3QgZm9yIHpvb20gbGltaXRzIHpvb21SYW5nZTogW21pbixtYXhdXG4gICAgICAgICAgICAgICAgaWYgKG9wdHMuem9vbVJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHpvb21lZCBpbiB0b28gZmFyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXggLSBtaW4gPCBvcHRzLnpvb21SYW5nZVswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gem9vbWVkIG91dCB0byBmYXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heCAtIG1pbiA+IG9wdHMuem9vbVJhbmdlWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXRCZWxvdyA9ICQucGxvdC5zYXR1cmF0ZWQuc2F0dXJhdGUobmF2aWdhdGlvbk9mZnNldC5iZWxvdyAtIChheGlzLm1pbiAtIG1pbikpO1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXRBYm92ZSA9ICQucGxvdC5zYXR1cmF0ZWQuc2F0dXJhdGUobmF2aWdhdGlvbk9mZnNldC5hYm92ZSAtIChheGlzLm1heCAtIG1heCkpO1xuICAgICAgICAgICAgICAgIG9wdHMub2Zmc2V0ID0geyBiZWxvdzogb2Zmc2V0QmVsb3csIGFib3ZlOiBvZmZzZXRBYm92ZSB9O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcGxvdC5zZXR1cEdyaWQodHJ1ZSk7XG4gICAgICAgICAgICBwbG90LmRyYXcoKTtcblxuICAgICAgICAgICAgaWYgKCFhcmdzLnByZXZlbnRFdmVudCkge1xuICAgICAgICAgICAgICAgIHBsb3QuZ2V0UGxhY2Vob2xkZXIoKS50cmlnZ2VyKFwicGxvdHpvb21cIiwgW3Bsb3QsIGFyZ3NdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBwbG90LnBhbiA9IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBkZWx0YSA9IHtcbiAgICAgICAgICAgICAgICB4OiArYXJncy5sZWZ0LFxuICAgICAgICAgICAgICAgIHk6ICthcmdzLnRvcFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKGlzTmFOKGRlbHRhLngpKSBkZWx0YS54ID0gMDtcbiAgICAgICAgICAgIGlmIChpc05hTihkZWx0YS55KSkgZGVsdGEueSA9IDA7XG5cbiAgICAgICAgICAgICQuZWFjaChhcmdzLmF4ZXMgfHwgcGxvdC5nZXRBeGVzKCksIGZ1bmN0aW9uKF8sIGF4aXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0cyA9IGF4aXMub3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgZCA9IGRlbHRhW2F4aXMuZGlyZWN0aW9uXTtcblxuICAgICAgICAgICAgICAgIC8vc2tpcCBheGlzIHdpdGhvdXQgYXhpc1BhbiB3aGVuIHBhbm5pbmcgb25seSBvbiBjZXJ0YWluIGF4aXMgb3IgYXhpcyB3aXRob3V0IHBsb3RQYW4gZm9yIHBhbiB0aGUgZW50aXJlIHBsb3RcbiAgICAgICAgICAgICAgICBpZiAoKCFvcHRzLmF4aXNQYW4gJiYgYXJncy5heGVzKSB8fCAoIW9wdHMucGxvdFBhbiAmJiAhYXJncy5heGVzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY2FsYyBtaW4gZGVsdGEgKHJldmVhbGluZyBsZWZ0IGVkZ2Ugb2YgcGxvdClcbiAgICAgICAgICAgICAgICB2YXIgbWluRCA9IGF4aXMucDJjKG9wdHMucGFuUmFuZ2VbMF0pIC0gYXhpcy5wMmMoYXhpcy5taW4pO1xuICAgICAgICAgICAgICAgIC8vIGNhbGMgbWF4IGRlbHRhIChyZXZlYWxpbmcgcmlnaHQgZWRnZSBvZiBwbG90KVxuICAgICAgICAgICAgICAgIHZhciBtYXhEID0gYXhpcy5wMmMob3B0cy5wYW5SYW5nZVsxXSkgLSBheGlzLnAyYyhheGlzLm1heCk7XG4gICAgICAgICAgICAgICAgLy8gbGltaXQgZGVsdGEgdG8gbWluIG9yIG1heCBpZiBlbmFibGVkXG4gICAgICAgICAgICAgICAgaWYgKG9wdHMucGFuUmFuZ2VbMF0gIT09IHVuZGVmaW5lZCAmJiBkID49IG1heEQpIGQgPSBtYXhEO1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLnBhblJhbmdlWzFdICE9PSB1bmRlZmluZWQgJiYgZCA8PSBtaW5EKSBkID0gbWluRDtcblxuICAgICAgICAgICAgICAgIGlmIChkICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYXZpZ2F0aW9uT2Zmc2V0QmVsb3cgPSBzYXR1cmF0ZWQuc2F0dXJhdGUoYXhpcy5jMnAoYXhpcy5wMmMoYXhpcy5taW4pICsgZCkgLSBheGlzLmMycChheGlzLnAyYyhheGlzLm1pbikpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRpb25PZmZzZXRBYm92ZSA9IHNhdHVyYXRlZC5zYXR1cmF0ZShheGlzLmMycChheGlzLnAyYyhheGlzLm1heCkgKyBkKSAtIGF4aXMuYzJwKGF4aXMucDJjKGF4aXMubWF4KSkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNGaW5pdGUobmF2aWdhdGlvbk9mZnNldEJlbG93KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGlvbk9mZnNldEJlbG93ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNGaW5pdGUobmF2aWdhdGlvbk9mZnNldEFib3ZlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGlvbk9mZnNldEFib3ZlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG9wdHMub2Zmc2V0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVsb3c6IHNhdHVyYXRlZC5zYXR1cmF0ZShuYXZpZ2F0aW9uT2Zmc2V0QmVsb3cgKyAob3B0cy5vZmZzZXQuYmVsb3cgfHwgMCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWJvdmU6IHNhdHVyYXRlZC5zYXR1cmF0ZShuYXZpZ2F0aW9uT2Zmc2V0QWJvdmUgKyAob3B0cy5vZmZzZXQuYWJvdmUgfHwgMCkpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHBsb3Quc2V0dXBHcmlkKHRydWUpO1xuICAgICAgICAgICAgcGxvdC5kcmF3KCk7XG4gICAgICAgICAgICBpZiAoIWFyZ3MucHJldmVudEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgcGxvdC5nZXRQbGFjZWhvbGRlcigpLnRyaWdnZXIoXCJwbG90cGFuXCIsIFtwbG90LCBhcmdzXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcGxvdC5yZWNlbnRlciA9IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgICAgICQuZWFjaChhcmdzLmF4ZXMgfHwgcGxvdC5nZXRBeGVzKCksIGZ1bmN0aW9uKF8sIGF4aXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJncy5heGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gJ3gnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzLm9wdGlvbnMub2Zmc2V0ID0geyBiZWxvdzogMCB9O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAneScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXMub3B0aW9ucy5vZmZzZXQgPSB7IGFib3ZlOiAwIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBheGlzLm9wdGlvbnMub2Zmc2V0ID0geyBiZWxvdzogMCwgYWJvdmU6IDAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBsb3Quc2V0dXBHcmlkKHRydWUpO1xuICAgICAgICAgICAgcGxvdC5kcmF3KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHNob3VsZFNuYXAgPSBmdW5jdGlvbihkZWx0YSkge1xuICAgICAgICAgICAgcmV0dXJuIChNYXRoLmFicyhkZWx0YS55KSA8IFNOQVBQSU5HX0NPTlNUQU5UICYmIE1hdGguYWJzKGRlbHRhLngpID49IFNOQVBQSU5HX0NPTlNUQU5UKSB8fFxuICAgICAgICAgICAgICAgIChNYXRoLmFicyhkZWx0YS54KSA8IFNOQVBQSU5HX0NPTlNUQU5UICYmIE1hdGguYWJzKGRlbHRhLnkpID49IFNOQVBQSU5HX0NPTlNUQU5UKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkanVzdCBkZWx0YSBzbyB0aGUgcGFuIGFjdGlvbiBpcyBjb25zdHJhaW5lZCBvbiB0aGUgdmVydGljYWwgb3IgaG9yaXpvbnRhbCBkaXJlY3Rpb25cbiAgICAgICAgLy8gaXQgdGhlIG1vdmVtZW50cyBpbiB0aGUgb3RoZXIgZGlyZWN0aW9uIGFyZSBzbWFsbFxuICAgICAgICB2YXIgYWRqdXN0RGVsdGFUb1NuYXAgPSBmdW5jdGlvbihkZWx0YSkge1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGRlbHRhLngpIDwgU05BUFBJTkdfQ09OU1RBTlQgJiYgTWF0aC5hYnMoZGVsdGEueSkgPj0gU05BUFBJTkdfQ09OU1RBTlQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge3g6IDAsIHk6IGRlbHRhLnl9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoZGVsdGEueSkgPCBTTkFQUElOR19DT05TVEFOVCAmJiBNYXRoLmFicyhkZWx0YS54KSA+PSBTTkFQUElOR19DT05TVEFOVCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7eDogZGVsdGEueCwgeTogMH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkZWx0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2NrZWREaXJlY3Rpb24gPSBudWxsO1xuICAgICAgICB2YXIgbG9ja0RlbHRhRGlyZWN0aW9uID0gZnVuY3Rpb24oZGVsdGEpIHtcbiAgICAgICAgICAgIGlmICghbG9ja2VkRGlyZWN0aW9uICYmIE1hdGgubWF4KE1hdGguYWJzKGRlbHRhLngpLCBNYXRoLmFicyhkZWx0YS55KSkgPj0gU05BUFBJTkdfQ09OU1RBTlQpIHtcbiAgICAgICAgICAgICAgICBsb2NrZWREaXJlY3Rpb24gPSBNYXRoLmFicyhkZWx0YS54KSA8IE1hdGguYWJzKGRlbHRhLnkpID8gJ3knIDogJ3gnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzd2l0Y2ggKGxvY2tlZERpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB4OiBkZWx0YS54LCB5OiAwIH07XG4gICAgICAgICAgICAgICAgY2FzZSAneSc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IDAsIHk6IGRlbHRhLnkgfTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB4OiAwLCB5OiAwIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXNEaWFnb25hbE1vZGUgPSBmdW5jdGlvbihkZWx0YSkge1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGRlbHRhLngpID4gMCAmJiBNYXRoLmFicyhkZWx0YS55KSA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN0b3JlQXhpc09mZnNldCA9IGZ1bmN0aW9uKGF4ZXMsIGluaXRpYWxTdGF0ZSwgZGVsdGEpIHtcbiAgICAgICAgICAgIHZhciBheGlzO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXhlcykuZm9yRWFjaChmdW5jdGlvbihheGlzTmFtZSkge1xuICAgICAgICAgICAgICAgIGF4aXMgPSBheGVzW2F4aXNOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoZGVsdGFbYXhpcy5kaXJlY3Rpb25dID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGF4aXMub3B0aW9ucy5vZmZzZXQuYmVsb3cgPSBpbml0aWFsU3RhdGVbYXhpc05hbWVdLm5hdmlnYXRpb25PZmZzZXQuYmVsb3c7XG4gICAgICAgICAgICAgICAgICAgIGF4aXMub3B0aW9ucy5vZmZzZXQuYWJvdmUgPSBpbml0aWFsU3RhdGVbYXhpc05hbWVdLm5hdmlnYXRpb25PZmZzZXQuYWJvdmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJldkRlbHRhID0geyB4OiAwLCB5OiAwIH07XG4gICAgICAgIHBsb3Quc21hcnRQYW4gPSBmdW5jdGlvbihkZWx0YSwgaW5pdGlhbFN0YXRlLCBwYW5BeGVzLCBwcmV2ZW50RXZlbnQsIHNtYXJ0TG9jaykge1xuICAgICAgICAgICAgdmFyIHNuYXAgPSBzbWFydExvY2sgPyB0cnVlIDogc2hvdWxkU25hcChkZWx0YSksXG4gICAgICAgICAgICAgICAgYXhlcyA9IHBsb3QuZ2V0QXhlcygpLFxuICAgICAgICAgICAgICAgIG9wdHM7XG4gICAgICAgICAgICBkZWx0YSA9IHNtYXJ0TG9jayA/IGxvY2tEZWx0YURpcmVjdGlvbihkZWx0YSkgOiBhZGp1c3REZWx0YVRvU25hcChkZWx0YSk7XG5cbiAgICAgICAgICAgIGlmIChpc0RpYWdvbmFsTW9kZShkZWx0YSkpIHtcbiAgICAgICAgICAgICAgICBpbml0aWFsU3RhdGUuZGlhZ01vZGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc25hcCAmJiBpbml0aWFsU3RhdGUuZGlhZ01vZGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBpbml0aWFsU3RhdGUuZGlhZ01vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXN0b3JlQXhpc09mZnNldChheGVzLCBpbml0aWFsU3RhdGUsIGRlbHRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNuYXApIHtcbiAgICAgICAgICAgICAgICBwYW5IaW50ID0ge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogaW5pdGlhbFN0YXRlLnN0YXJ0UGFnZVggLSBwbG90Lm9mZnNldCgpLmxlZnQgKyBwbG90LmdldFBsb3RPZmZzZXQoKS5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogaW5pdGlhbFN0YXRlLnN0YXJ0UGFnZVkgLSBwbG90Lm9mZnNldCgpLnRvcCArIHBsb3QuZ2V0UGxvdE9mZnNldCgpLnRvcFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IGluaXRpYWxTdGF0ZS5zdGFydFBhZ2VYIC0gZGVsdGEueCAtIHBsb3Qub2Zmc2V0KCkubGVmdCArIHBsb3QuZ2V0UGxvdE9mZnNldCgpLmxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBpbml0aWFsU3RhdGUuc3RhcnRQYWdlWSAtIGRlbHRhLnkgLSBwbG90Lm9mZnNldCgpLnRvcCArIHBsb3QuZ2V0UGxvdE9mZnNldCgpLnRvcFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYW5IaW50ID0ge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogaW5pdGlhbFN0YXRlLnN0YXJ0UGFnZVggLSBwbG90Lm9mZnNldCgpLmxlZnQgKyBwbG90LmdldFBsb3RPZmZzZXQoKS5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogaW5pdGlhbFN0YXRlLnN0YXJ0UGFnZVkgLSBwbG90Lm9mZnNldCgpLnRvcCArIHBsb3QuZ2V0UGxvdE9mZnNldCgpLnRvcFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNOYU4oZGVsdGEueCkpIGRlbHRhLnggPSAwO1xuICAgICAgICAgICAgaWYgKGlzTmFOKGRlbHRhLnkpKSBkZWx0YS55ID0gMDtcblxuICAgICAgICAgICAgaWYgKHBhbkF4ZXMpIHtcbiAgICAgICAgICAgICAgICBheGVzID0gcGFuQXhlcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGF4aXMsIGF4aXNNaW4sIGF4aXNNYXgsIHAsIGQ7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhheGVzKS5mb3JFYWNoKGZ1bmN0aW9uKGF4aXNOYW1lKSB7XG4gICAgICAgICAgICAgICAgYXhpcyA9IGF4ZXNbYXhpc05hbWVdO1xuICAgICAgICAgICAgICAgIGF4aXNNaW4gPSBheGlzLm1pbjtcbiAgICAgICAgICAgICAgICBheGlzTWF4ID0gYXhpcy5tYXg7XG4gICAgICAgICAgICAgICAgb3B0cyA9IGF4aXMub3B0aW9ucztcblxuICAgICAgICAgICAgICAgIGQgPSBkZWx0YVtheGlzLmRpcmVjdGlvbl07XG4gICAgICAgICAgICAgICAgcCA9IHByZXZEZWx0YVtheGlzLmRpcmVjdGlvbl07XG5cbiAgICAgICAgICAgICAgICAvL3NraXAgYXhpcyB3aXRob3V0IGF4aXNQYW4gd2hlbiBwYW5uaW5nIG9ubHkgb24gY2VydGFpbiBheGlzIG9yIGF4aXMgd2l0aG91dCBwbG90UGFuIGZvciBwYW4gdGhlIGVudGlyZSBwbG90XG4gICAgICAgICAgICAgICAgaWYgKCghb3B0cy5heGlzUGFuICYmIHBhbkF4ZXMpIHx8ICghcGFuQXhlcyAmJiAhb3B0cy5wbG90UGFuKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY2FsYyBtaW4gZGVsdGEgKHJldmVhbGluZyBsZWZ0IGVkZ2Ugb2YgcGxvdClcbiAgICAgICAgICAgICAgICB2YXIgbWluRCA9IHAgKyBheGlzLnAyYyhvcHRzLnBhblJhbmdlWzBdKSAtIGF4aXMucDJjKGF4aXNNaW4pO1xuICAgICAgICAgICAgICAgIC8vIGNhbGMgbWF4IGRlbHRhIChyZXZlYWxpbmcgcmlnaHQgZWRnZSBvZiBwbG90KVxuICAgICAgICAgICAgICAgIHZhciBtYXhEID0gcCArIGF4aXMucDJjKG9wdHMucGFuUmFuZ2VbMV0pIC0gYXhpcy5wMmMoYXhpc01heCk7XG4gICAgICAgICAgICAgICAgLy8gbGltaXQgZGVsdGEgdG8gbWluIG9yIG1heCBpZiBlbmFibGVkXG4gICAgICAgICAgICAgICAgaWYgKG9wdHMucGFuUmFuZ2VbMF0gIT09IHVuZGVmaW5lZCAmJiBkID49IG1heEQpIGQgPSBtYXhEO1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLnBhblJhbmdlWzFdICE9PSB1bmRlZmluZWQgJiYgZCA8PSBtaW5EKSBkID0gbWluRDtcblxuICAgICAgICAgICAgICAgIGlmIChkICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYXZpZ2F0aW9uT2Zmc2V0QmVsb3cgPSBzYXR1cmF0ZWQuc2F0dXJhdGUoYXhpcy5jMnAoYXhpcy5wMmMoYXhpc01pbikgLSAocCAtIGQpKSAtIGF4aXMuYzJwKGF4aXMucDJjKGF4aXNNaW4pKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0aW9uT2Zmc2V0QWJvdmUgPSBzYXR1cmF0ZWQuc2F0dXJhdGUoYXhpcy5jMnAoYXhpcy5wMmMoYXhpc01heCkgLSAocCAtIGQpKSAtIGF4aXMuYzJwKGF4aXMucDJjKGF4aXNNYXgpKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZShuYXZpZ2F0aW9uT2Zmc2V0QmVsb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0aW9uT2Zmc2V0QmVsb3cgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZShuYXZpZ2F0aW9uT2Zmc2V0QWJvdmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0aW9uT2Zmc2V0QWJvdmUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYXhpcy5vcHRpb25zLm9mZnNldC5iZWxvdyA9IHNhdHVyYXRlZC5zYXR1cmF0ZShuYXZpZ2F0aW9uT2Zmc2V0QmVsb3cgKyAoYXhpcy5vcHRpb25zLm9mZnNldC5iZWxvdyB8fCAwKSk7XG4gICAgICAgICAgICAgICAgICAgIGF4aXMub3B0aW9ucy5vZmZzZXQuYWJvdmUgPSBzYXR1cmF0ZWQuc2F0dXJhdGUobmF2aWdhdGlvbk9mZnNldEFib3ZlICsgKGF4aXMub3B0aW9ucy5vZmZzZXQuYWJvdmUgfHwgMCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBwcmV2RGVsdGEgPSBkZWx0YTtcbiAgICAgICAgICAgIHBsb3Quc2V0dXBHcmlkKHRydWUpO1xuICAgICAgICAgICAgcGxvdC5kcmF3KCk7XG5cbiAgICAgICAgICAgIGlmICghcHJldmVudEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgcGxvdC5nZXRQbGFjZWhvbGRlcigpLnRyaWdnZXIoXCJwbG90cGFuXCIsIFtwbG90LCBkZWx0YSwgcGFuQXhlcywgaW5pdGlhbFN0YXRlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcGxvdC5zbWFydFBhbi5lbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHBhbkhpbnQgPSBudWxsO1xuICAgICAgICAgICAgbG9ja2VkRGlyZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIHByZXZEZWx0YSA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgICAgICAgcGxvdC50cmlnZ2VyUmVkcmF3T3ZlcmxheSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc2h1dGRvd24ocGxvdCwgZXZlbnRIb2xkZXIpIHtcbiAgICAgICAgICAgIGV2ZW50SG9sZGVyLnVuYmluZChcIm1vdXNld2hlZWxcIiwgb25Nb3VzZVdoZWVsKTtcbiAgICAgICAgICAgIGV2ZW50SG9sZGVyLnVuYmluZChcIm1vdXNlZG93blwiLCBvbk1vdXNlRG93bik7XG4gICAgICAgICAgICBldmVudEhvbGRlci51bmJpbmQoXCJtb3VzZXVwXCIsIG9uTW91c2VVcCk7XG4gICAgICAgICAgICBldmVudEhvbGRlci51bmJpbmQoXCJkcmFnc3RhcnRcIiwgb25EcmFnU3RhcnQpO1xuICAgICAgICAgICAgZXZlbnRIb2xkZXIudW5iaW5kKFwiZHJhZ1wiLCBvbkRyYWcpO1xuICAgICAgICAgICAgZXZlbnRIb2xkZXIudW5iaW5kKFwiZHJhZ2VuZFwiLCBvbkRyYWdFbmQpO1xuICAgICAgICAgICAgZXZlbnRIb2xkZXIudW5iaW5kKFwiZGJsY2xpY2tcIiwgb25EYmxDbGljayk7XG4gICAgICAgICAgICBldmVudEhvbGRlci51bmJpbmQoXCJjbGlja1wiLCBvbkNsaWNrKTtcblxuICAgICAgICAgICAgaWYgKHBhblRpbWVvdXQpIGNsZWFyVGltZW91dChwYW5UaW1lb3V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGRyYXdPdmVybGF5KHBsb3QsIGN0eCkge1xuICAgICAgICAgICAgaWYgKHBhbkhpbnQpIHtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAncmdiYSg5NiwgMTYwLCAyMDgsIDAuNyknO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAyO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lSm9pbiA9IFwicm91bmRcIjtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnR4ID0gTWF0aC5yb3VuZChwYW5IaW50LnN0YXJ0LngpLFxuICAgICAgICAgICAgICAgICAgICBzdGFydHkgPSBNYXRoLnJvdW5kKHBhbkhpbnQuc3RhcnQueSksXG4gICAgICAgICAgICAgICAgICAgIGVuZHgsIGVuZHk7XG5cbiAgICAgICAgICAgICAgICBpZiAocGFuQXhlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFuQXhlc1swXS5kaXJlY3Rpb24gPT09ICd4Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5keSA9IE1hdGgucm91bmQocGFuSGludC5zdGFydC55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZHggPSBNYXRoLnJvdW5kKHBhbkhpbnQuZW5kLngpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhbkF4ZXNbMF0uZGlyZWN0aW9uID09PSAneScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZHggPSBNYXRoLnJvdW5kKHBhbkhpbnQuc3RhcnQueCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmR5ID0gTWF0aC5yb3VuZChwYW5IaW50LmVuZC55KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZHggPSBNYXRoLnJvdW5kKHBhbkhpbnQuZW5kLngpO1xuICAgICAgICAgICAgICAgICAgICBlbmR5ID0gTWF0aC5yb3VuZChwYW5IaW50LmVuZC55KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAocGFuSGludC5lbmQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oc3RhcnR4LCBzdGFydHkgLSBQQU5ISU5UX0xFTkdUSF9DT05TVEFOVCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oc3RhcnR4LCBzdGFydHkgKyBQQU5ISU5UX0xFTkdUSF9DT05TVEFOVCk7XG5cbiAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhzdGFydHggKyBQQU5ISU5UX0xFTkdUSF9DT05TVEFOVCwgc3RhcnR5KTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhzdGFydHggLSBQQU5ISU5UX0xFTkdUSF9DT05TVEFOVCwgc3RhcnR5KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGlyWCA9IHN0YXJ0eSA9PT0gZW5keTtcblxuICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHN0YXJ0eCAtIChkaXJYID8gMCA6IFBBTkhJTlRfTEVOR1RIX0NPTlNUQU5UKSwgc3RhcnR5IC0gKGRpclggPyBQQU5ISU5UX0xFTkdUSF9DT05TVEFOVCA6IDApKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhzdGFydHggKyAoZGlyWCA/IDAgOiBQQU5ISU5UX0xFTkdUSF9DT05TVEFOVCksIHN0YXJ0eSArIChkaXJYID8gUEFOSElOVF9MRU5HVEhfQ09OU1RBTlQgOiAwKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhzdGFydHgsIHN0YXJ0eSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oZW5keCwgZW5keSk7XG5cbiAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhlbmR4IC0gKGRpclggPyAwIDogUEFOSElOVF9MRU5HVEhfQ09OU1RBTlQpLCBlbmR5IC0gKGRpclggPyBQQU5ISU5UX0xFTkdUSF9DT05TVEFOVCA6IDApKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhlbmR4ICsgKGRpclggPyAwIDogUEFOSElOVF9MRU5HVEhfQ09OU1RBTlQpLCBlbmR5ICsgKGRpclggPyBQQU5ISU5UX0xFTkdUSF9DT05TVEFOVCA6IDApKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwbG90LmdldFRvdWNoZWRBeGlzID0gZnVuY3Rpb24odG91Y2hQb2ludFgsIHRvdWNoUG9pbnRZKSB7XG4gICAgICAgICAgICB2YXIgZWMgPSBwbG90LmdldFBsYWNlaG9sZGVyKCkub2Zmc2V0KCk7XG4gICAgICAgICAgICBlYy5sZWZ0ID0gdG91Y2hQb2ludFggLSBlYy5sZWZ0O1xuICAgICAgICAgICAgZWMudG9wID0gdG91Y2hQb2ludFkgLSBlYy50b3A7XG5cbiAgICAgICAgICAgIHZhciBheGlzID0gcGxvdC5nZXRYQXhlcygpLmNvbmNhdChwbG90LmdldFlBeGVzKCkpLmZpbHRlcihmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICAgICAgICAgIHZhciBib3ggPSBheGlzLmJveDtcbiAgICAgICAgICAgICAgICBpZiAoYm94ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlYy5sZWZ0ID4gYm94LmxlZnQpICYmIChlYy5sZWZ0IDwgYm94LmxlZnQgKyBib3gud2lkdGgpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGVjLnRvcCA+IGJveC50b3ApICYmIChlYy50b3AgPCBib3gudG9wICsgYm94LmhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBheGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgcGxvdC5ob29rcy5kcmF3T3ZlcmxheS5wdXNoKGRyYXdPdmVybGF5KTtcbiAgICAgICAgcGxvdC5ob29rcy5iaW5kRXZlbnRzLnB1c2goYmluZEV2ZW50cyk7XG4gICAgICAgIHBsb3QuaG9va3Muc2h1dGRvd24ucHVzaChzaHV0ZG93bik7XG4gICAgfVxuXG4gICAgJC5wbG90LnBsdWdpbnMucHVzaCh7XG4gICAgICAgIGluaXQ6IGluaXQsXG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgIG5hbWU6ICduYXZpZ2F0ZScsXG4gICAgICAgIHZlcnNpb246ICcxLjMnXG4gICAgfSk7XG59KShqUXVlcnkpO1xuIiwiLyogRmxvdCBwbHVnaW4gZm9yIHJlbmRlcmluZyBwaWUgY2hhcnRzLlxuXG5Db3B5cmlnaHQgKGMpIDIwMDctMjAxNCBJT0xBIGFuZCBPbGUgTGF1cnNlbi5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuVGhlIHBsdWdpbiBhc3N1bWVzIHRoYXQgZWFjaCBzZXJpZXMgaGFzIGEgc2luZ2xlIGRhdGEgdmFsdWUsIGFuZCB0aGF0IGVhY2hcbnZhbHVlIGlzIGEgcG9zaXRpdmUgaW50ZWdlciBvciB6ZXJvLiAgTmVnYXRpdmUgbnVtYmVycyBkb24ndCBtYWtlIHNlbnNlIGZvciBhXG5waWUgY2hhcnQsIGFuZCBoYXZlIHVucHJlZGljdGFibGUgcmVzdWx0cy4gIFRoZSB2YWx1ZXMgZG8gTk9UIG5lZWQgdG8gYmVcbnBhc3NlZCBpbiBhcyBwZXJjZW50YWdlczsgdGhlIHBsdWdpbiB3aWxsIGNhbGN1bGF0ZSB0aGUgdG90YWwgYW5kIHBlci1zbGljZVxucGVyY2VudGFnZXMgaW50ZXJuYWxseS5cblxuKiBDcmVhdGVkIGJ5IEJyaWFuIE1lZGVuZG9ycFxuXG4qIFVwZGF0ZWQgd2l0aCBjb250cmlidXRpb25zIGZyb20gYnRidXJuZXR0MywgQW50aG9ueSBBcmFndWVzIGFuZCBYYXZpIEl2YXJzXG5cblRoZSBwbHVnaW4gc3VwcG9ydHMgdGhlc2Ugb3B0aW9uczpcblxuICAgIHNlcmllczoge1xuICAgICAgICBwaWU6IHtcbiAgICAgICAgICAgIHNob3c6IHRydWUvZmFsc2VcbiAgICAgICAgICAgIHJhZGl1czogMC0xIGZvciBwZXJjZW50YWdlIG9mIGZ1bGxzaXplLCBvciBhIHNwZWNpZmllZCBwaXhlbCBsZW5ndGgsIG9yICdhdXRvJ1xuICAgICAgICAgICAgaW5uZXJSYWRpdXM6IDAtMSBmb3IgcGVyY2VudGFnZSBvZiBmdWxsc2l6ZSBvciBhIHNwZWNpZmllZCBwaXhlbCBsZW5ndGgsIGZvciBjcmVhdGluZyBhIGRvbnV0IGVmZmVjdFxuICAgICAgICAgICAgc3RhcnRBbmdsZTogMC0yIGZhY3RvciBvZiBQSSB1c2VkIGZvciBzdGFydGluZyBhbmdsZSAoaW4gcmFkaWFucykgaS5lIDMvMiBzdGFydHMgYXQgdGhlIHRvcCwgMCBhbmQgMiBoYXZlIHRoZSBzYW1lIHJlc3VsdFxuICAgICAgICAgICAgdGlsdDogMC0xIGZvciBwZXJjZW50YWdlIHRvIHRpbHQgdGhlIHBpZSwgd2hlcmUgMSBpcyBubyB0aWx0LCBhbmQgMCBpcyBjb21wbGV0ZWx5IGZsYXQgKG5vdGhpbmcgd2lsbCBzaG93KVxuICAgICAgICAgICAgb2Zmc2V0OiB7XG4gICAgICAgICAgICAgICAgdG9wOiBpbnRlZ2VyIHZhbHVlIHRvIG1vdmUgdGhlIHBpZSB1cCBvciBkb3duXG4gICAgICAgICAgICAgICAgbGVmdDogaW50ZWdlciB2YWx1ZSB0byBtb3ZlIHRoZSBwaWUgbGVmdCBvciByaWdodCwgb3IgJ2F1dG8nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3Ryb2tlOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6IGFueSBoZXhpZGVjaW1hbCBjb2xvciB2YWx1ZSAob3RoZXIgZm9ybWF0cyBtYXkgb3IgbWF5IG5vdCB3b3JrLCBzbyBiZXN0IHRvIHN0aWNrIHdpdGggc29tZXRoaW5nIGxpa2UgJyNGRkYnKVxuICAgICAgICAgICAgICAgIHdpZHRoOiBpbnRlZ2VyIHBpeGVsIHdpZHRoIG9mIHRoZSBzdHJva2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgICAgIHNob3c6IHRydWUvZmFsc2UsIG9yICdhdXRvJ1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogIGEgdXNlci1kZWZpbmVkIGZ1bmN0aW9uIHRoYXQgbW9kaWZpZXMgdGhlIHRleHQvc3R5bGUgb2YgdGhlIGxhYmVsIHRleHRcbiAgICAgICAgICAgICAgICByYWRpdXM6IDAtMSBmb3IgcGVyY2VudGFnZSBvZiBmdWxsc2l6ZSwgb3IgYSBzcGVjaWZpZWQgcGl4ZWwgbGVuZ3RoXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDoge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcjogYW55IGhleGlkZWNpbWFsIGNvbG9yIHZhbHVlIChvdGhlciBmb3JtYXRzIG1heSBvciBtYXkgbm90IHdvcmssIHNvIGJlc3QgdG8gc3RpY2sgd2l0aCBzb21ldGhpbmcgbGlrZSAnIzAwMCcpXG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAtMVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGhyZXNob2xkOiAwLTEgZm9yIHRoZSBwZXJjZW50YWdlIHZhbHVlIGF0IHdoaWNoIHRvIGhpZGUgbGFiZWxzIChpZiB0aGV5J3JlIHRvbyBzbWFsbClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb21iaW5lOiB7XG4gICAgICAgICAgICAgICAgdGhyZXNob2xkOiAwLTEgZm9yIHRoZSBwZXJjZW50YWdlIHZhbHVlIGF0IHdoaWNoIHRvIGNvbWJpbmUgc2xpY2VzIChpZiB0aGV5J3JlIHRvbyBzbWFsbClcbiAgICAgICAgICAgICAgICBjb2xvcjogYW55IGhleGlkZWNpbWFsIGNvbG9yIHZhbHVlIChvdGhlciBmb3JtYXRzIG1heSBvciBtYXkgbm90IHdvcmssIHNvIGJlc3QgdG8gc3RpY2sgd2l0aCBzb21ldGhpbmcgbGlrZSAnI0NDQycpLCBpZiBudWxsLCB0aGUgcGx1Z2luIHdpbGwgYXV0b21hdGljYWxseSB1c2UgdGhlIGNvbG9yIG9mIHRoZSBmaXJzdCBzbGljZSB0byBiZSBjb21iaW5lZFxuICAgICAgICAgICAgICAgIGxhYmVsOiBhbnkgdGV4dCB2YWx1ZSBvZiB3aGF0IHRoZSBjb21iaW5lZCBzbGljZSBzaG91bGQgYmUgbGFiZWxlZFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMC0xXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbk1vcmUgZGV0YWlsIGFuZCBzcGVjaWZpYyBleGFtcGxlcyBjYW4gYmUgZm91bmQgaW4gdGhlIGluY2x1ZGVkIEhUTUwgZmlsZS5cblxuKi9cblxuKGZ1bmN0aW9uKCQpIHtcbiAgICAvLyBNYXhpbXVtIHJlZHJhdyBhdHRlbXB0cyB3aGVuIGZpdHRpbmcgbGFiZWxzIHdpdGhpbiB0aGUgcGxvdFxuXG4gICAgdmFyIFJFRFJBV19BVFRFTVBUUyA9IDEwO1xuXG4gICAgLy8gRmFjdG9yIGJ5IHdoaWNoIHRvIHNocmluayB0aGUgcGllIHdoZW4gZml0dGluZyBsYWJlbHMgd2l0aGluIHRoZSBwbG90XG5cbiAgICB2YXIgUkVEUkFXX1NIUklOSyA9IDAuOTU7XG5cbiAgICBmdW5jdGlvbiBpbml0KHBsb3QpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IG51bGwsXG4gICAgICAgICAgICB0YXJnZXQgPSBudWxsLFxuICAgICAgICAgICAgb3B0aW9ucyA9IG51bGwsXG4gICAgICAgICAgICBtYXhSYWRpdXMgPSBudWxsLFxuICAgICAgICAgICAgY2VudGVyTGVmdCA9IG51bGwsXG4gICAgICAgICAgICBjZW50ZXJUb3AgPSBudWxsLFxuICAgICAgICAgICAgcHJvY2Vzc2VkID0gZmFsc2UsXG4gICAgICAgICAgICBjdHggPSBudWxsO1xuXG4gICAgICAgIC8vIGludGVyYWN0aXZlIHZhcmlhYmxlc1xuXG4gICAgICAgIHZhciBoaWdobGlnaHRzID0gW107XG5cbiAgICAgICAgLy8gYWRkIGhvb2sgdG8gZGV0ZXJtaW5lIGlmIHBpZSBwbHVnaW4gaW4gZW5hYmxlZCwgYW5kIHRoZW4gcGVyZm9ybSBuZWNlc3Nhcnkgb3BlcmF0aW9uc1xuXG4gICAgICAgIHBsb3QuaG9va3MucHJvY2Vzc09wdGlvbnMucHVzaChmdW5jdGlvbihwbG90LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zZXJpZXMucGllLnNob3cpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmdyaWQuc2hvdyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgLy8gc2V0IGxhYmVscy5zaG93XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zZXJpZXMucGllLmxhYmVsLnNob3cgPT09IFwiYXV0b1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmxlZ2VuZC5zaG93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnNlcmllcy5waWUubGFiZWwuc2hvdyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zZXJpZXMucGllLmxhYmVsLnNob3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gc2V0IHJhZGl1c1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2VyaWVzLnBpZS5yYWRpdXMgPT09IFwiYXV0b1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnNlcmllcy5waWUubGFiZWwuc2hvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zZXJpZXMucGllLnJhZGl1cyA9IDMgLyA0O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zZXJpZXMucGllLnJhZGl1cyA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBlbnN1cmUgc2FuZSB0aWx0XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zZXJpZXMucGllLnRpbHQgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc2VyaWVzLnBpZS50aWx0ID0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuc2VyaWVzLnBpZS50aWx0IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnNlcmllcy5waWUudGlsdCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBwbG90Lmhvb2tzLmJpbmRFdmVudHMucHVzaChmdW5jdGlvbihwbG90LCBldmVudEhvbGRlcikge1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBwbG90LmdldE9wdGlvbnMoKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNlcmllcy5waWUuc2hvdykge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmdyaWQuaG92ZXJhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50SG9sZGVyLnVuYmluZChcIm1vdXNlbW92ZVwiKS5tb3VzZW1vdmUob25Nb3VzZU1vdmUpO1xuICAgICAgICAgICAgICAgICAgICBldmVudEhvbGRlci5iaW5kKFwibW91c2VsZWF2ZVwiLCBvbk1vdXNlTW92ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmdyaWQuY2xpY2thYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50SG9sZGVyLnVuYmluZChcImNsaWNrXCIpLmNsaWNrKG9uQ2xpY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcGxvdC5ob29rcy5zaHV0ZG93bi5wdXNoKGZ1bmN0aW9uIChwbG90LCBldmVudEhvbGRlcikge1xuICAgICAgICAgICAgZXZlbnRIb2xkZXIudW5iaW5kKFwibW91c2Vtb3ZlXCIsIG9uTW91c2VNb3ZlKTtcbiAgICAgICAgICAgIGV2ZW50SG9sZGVyLnVuYmluZChcIm1vdXNlbGVhdmVcIiwgb25Nb3VzZU1vdmUpO1xuICAgICAgICAgICAgZXZlbnRIb2xkZXIudW5iaW5kKFwiY2xpY2tcIiwgb25DbGljayk7XG4gICAgICAgICAgICBoaWdobGlnaHRzID0gW107XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHBsb3QuaG9va3MucHJvY2Vzc0RhdGFwb2ludHMucHVzaChmdW5jdGlvbihwbG90LCBzZXJpZXMsIGRhdGEsIGRhdGFwb2ludHMpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gcGxvdC5nZXRPcHRpb25zKCk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zZXJpZXMucGllLnNob3cpIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzRGF0YXBvaW50cyhwbG90LCBzZXJpZXMsIGRhdGEsIGRhdGFwb2ludHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBwbG90Lmhvb2tzLmRyYXdPdmVybGF5LnB1c2goZnVuY3Rpb24ocGxvdCwgb2N0eCkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBwbG90LmdldE9wdGlvbnMoKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNlcmllcy5waWUuc2hvdykge1xuICAgICAgICAgICAgICAgIGRyYXdPdmVybGF5KHBsb3QsIG9jdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBwbG90Lmhvb2tzLmRyYXcucHVzaChmdW5jdGlvbihwbG90LCBuZXdDdHgpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gcGxvdC5nZXRPcHRpb25zKCk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zZXJpZXMucGllLnNob3cpIHtcbiAgICAgICAgICAgICAgICBkcmF3KHBsb3QsIG5ld0N0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZ1bmN0aW9uIHByb2Nlc3NEYXRhcG9pbnRzKHBsb3QsIHNlcmllcywgZGF0YXBvaW50cykge1xuICAgICAgICAgICAgaWYgKCFwcm9jZXNzZWQpIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNhbnZhcyA9IHBsb3QuZ2V0Q2FudmFzKCk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gJChjYW52YXMpLnBhcmVudCgpO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBwbG90LmdldE9wdGlvbnMoKTtcbiAgICAgICAgICAgICAgICBwbG90LnNldERhdGEoY29tYmluZShwbG90LmdldERhdGEoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY29tYmluZShkYXRhKSB7XG4gICAgICAgICAgICB2YXIgdG90YWwgPSAwLFxuICAgICAgICAgICAgICAgIGNvbWJpbmVkID0gMCxcbiAgICAgICAgICAgICAgICBudW1Db21iaW5lZCA9IDAsXG4gICAgICAgICAgICAgICAgY29sb3IgPSBvcHRpb25zLnNlcmllcy5waWUuY29tYmluZS5jb2xvcixcbiAgICAgICAgICAgICAgICBuZXdkYXRhID0gW10sXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICB2YWx1ZTtcblxuICAgICAgICAgICAgLy8gRml4IHVwIHRoZSByYXcgZGF0YSBmcm9tIEZsb3QsIGVuc3VyaW5nIHRoZSBkYXRhIGlzIG51bWVyaWNcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGRhdGFbaV0uZGF0YTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBkYXRhIGlzIGFuIGFycmF5LCB3ZSdsbCBhc3N1bWUgdGhhdCBpdCdzIGEgc3RhbmRhcmRcbiAgICAgICAgICAgICAgICAvLyBGbG90IHgteSBwYWlyLCBhbmQgYXJlIGNvbmNlcm5lZCBvbmx5IHdpdGggdGhlIHNlY29uZCB2YWx1ZS5cblxuICAgICAgICAgICAgICAgIC8vIE5vdGUgaG93IHdlIHVzZSB0aGUgb3JpZ2luYWwgYXJyYXksIHJhdGhlciB0aGFuIGNyZWF0aW5nIGFcbiAgICAgICAgICAgICAgICAvLyBuZXcgb25lOyB0aGlzIGlzIG1vcmUgZWZmaWNpZW50IGFuZCBwcmVzZXJ2ZXMgYW55IGV4dHJhIGRhdGFcbiAgICAgICAgICAgICAgICAvLyB0aGF0IHRoZSB1c2VyIG1heSBoYXZlIHN0b3JlZCBpbiBoaWdoZXIgaW5kZXhlcy5cblxuICAgICAgICAgICAgICAgIGlmICgkLmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlWzBdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICgkLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVxdWl2YWxlbnQgdG8gJC5pc051bWVyaWMoKSBidXQgY29tcGF0aWJsZSB3aXRoIGpRdWVyeSA8IDEuN1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKHBhcnNlRmxvYXQodmFsdWVbMV0pKSAmJiBpc0Zpbml0ZSh2YWx1ZVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlWzFdID0gK3ZhbHVlWzFdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbMV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghaXNOYU4ocGFyc2VGbG9hdCh2YWx1ZSkpICYmIGlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFsxLCArdmFsdWVdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gWzEsIDBdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRhdGFbaV0uZGF0YSA9IFt2YWx1ZV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN1bSB1cCBhbGwgdGhlIHNsaWNlcywgc28gd2UgY2FuIGNhbGN1bGF0ZSBwZXJjZW50YWdlcyBmb3IgZWFjaFxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHRvdGFsICs9IGRhdGFbaV0uZGF0YVswXVsxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ291bnQgdGhlIG51bWJlciBvZiBzbGljZXMgd2l0aCBwZXJjZW50YWdlcyBiZWxvdyB0aGUgY29tYmluZVxuICAgICAgICAgICAgLy8gdGhyZXNob2xkOyBpZiBpdCB0dXJucyBvdXQgdG8gYmUganVzdCBvbmUsIHdlIHdvbid0IGNvbWJpbmUuXG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBkYXRhW2ldLmRhdGFbMF1bMV07XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIC8gdG90YWwgPD0gb3B0aW9ucy5zZXJpZXMucGllLmNvbWJpbmUudGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbWJpbmVkICs9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBudW1Db21iaW5lZCsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvciA9IGRhdGFbaV0uY29sb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBkYXRhW2ldLmRhdGFbMF1bMV07XG4gICAgICAgICAgICAgICAgaWYgKG51bUNvbWJpbmVkIDwgMiB8fCB2YWx1ZSAvIHRvdGFsID4gb3B0aW9ucy5zZXJpZXMucGllLmNvbWJpbmUudGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld2RhdGEucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgICQuZXh0ZW5kKGRhdGFbaV0sIHsgICAgIC8qIGV4dGVuZCB0byBhbGxvdyBrZWVwaW5nIGFsbCBvdGhlciBvcmlnaW5hbCBkYXRhIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIHVzaW5nIHRoZW0gZS5nLiBpbiBsYWJlbEZvcm1hdHRlci4gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBbWzEsIHZhbHVlXV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGRhdGFbaV0uY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGRhdGFbaV0ubGFiZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5nbGU6IHZhbHVlICogTWF0aC5QSSAqIDIgLyB0b3RhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJjZW50OiB2YWx1ZSAvICh0b3RhbCAvIDEwMClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobnVtQ29tYmluZWQgPiAxKSB7XG4gICAgICAgICAgICAgICAgbmV3ZGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogW1sxLCBjb21iaW5lZF1dLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBvcHRpb25zLnNlcmllcy5waWUuY29tYmluZS5sYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgYW5nbGU6IGNvbWJpbmVkICogTWF0aC5QSSAqIDIgLyB0b3RhbCxcbiAgICAgICAgICAgICAgICAgICAgcGVyY2VudDogY29tYmluZWQgLyAodG90YWwgLyAxMDApXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXdkYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZHJhdyhwbG90LCBuZXdDdHgpIHtcbiAgICAgICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBpZiBubyBzZXJpZXMgd2VyZSBwYXNzZWRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNhbnZhc1dpZHRoID0gcGxvdC5nZXRQbGFjZWhvbGRlcigpLndpZHRoKCksXG4gICAgICAgICAgICAgICAgY2FudmFzSGVpZ2h0ID0gcGxvdC5nZXRQbGFjZWhvbGRlcigpLmhlaWdodCgpLFxuICAgICAgICAgICAgICAgIGxlZ2VuZFdpZHRoID0gdGFyZ2V0LmNoaWxkcmVuKCkuZmlsdGVyKFwiLmxlZ2VuZFwiKS5jaGlsZHJlbigpLndpZHRoKCkgfHwgMDtcblxuICAgICAgICAgICAgY3R4ID0gbmV3Q3R4O1xuXG4gICAgICAgICAgICAvLyBXQVJOSU5HOiBIQUNLISBSRVdSSVRFIFRISVMgQ09ERSBBUyBTT09OIEFTIFBPU1NJQkxFIVxuXG4gICAgICAgICAgICAvLyBXaGVuIGNvbWJpbmluZyBzbWFsbGVyIHNsaWNlcyBpbnRvIGFuICdvdGhlcicgc2xpY2UsIHdlIG5lZWQgdG9cbiAgICAgICAgICAgIC8vIGFkZCBhIG5ldyBzZXJpZXMuICBTaW5jZSBGbG90IGdpdmVzIHBsdWdpbnMgbm8gd2F5IHRvIG1vZGlmeSB0aGVcbiAgICAgICAgICAgIC8vIGxpc3Qgb2Ygc2VyaWVzLCB0aGUgcGllIHBsdWdpbiB1c2VzIGEgaGFjayB3aGVyZSB0aGUgZmlyc3QgY2FsbFxuICAgICAgICAgICAgLy8gdG8gcHJvY2Vzc0RhdGFwb2ludHMgcmVzdWx0cyBpbiBhIGNhbGwgdG8gc2V0RGF0YSB3aXRoIHRoZSBuZXdcbiAgICAgICAgICAgIC8vIGxpc3Qgb2Ygc2VyaWVzLCB0aGVuIHN1YnNlcXVlbnQgcHJvY2Vzc0RhdGFwb2ludHMgZG8gbm90aGluZy5cblxuICAgICAgICAgICAgLy8gVGhlIHBsdWdpbi1nbG9iYWwgJ3Byb2Nlc3NlZCcgZmxhZyBpcyB1c2VkIHRvIGNvbnRyb2wgdGhpcyBoYWNrO1xuICAgICAgICAgICAgLy8gaXQgc3RhcnRzIG91dCBmYWxzZSwgYW5kIGlzIHNldCB0byB0cnVlIGFmdGVyIHRoZSBmaXJzdCBjYWxsIHRvXG4gICAgICAgICAgICAvLyBwcm9jZXNzRGF0YXBvaW50cy5cblxuICAgICAgICAgICAgLy8gVW5mb3J0dW5hdGVseSB0aGlzIHR1cm5zIGZ1dHVyZSBzZXREYXRhIGNhbGxzIGludG8gbm8tb3BzOyB0aGV5XG4gICAgICAgICAgICAvLyBjYWxsIHByb2Nlc3NEYXRhcG9pbnRzLCB0aGUgZmxhZyBpcyB0cnVlLCBhbmQgbm90aGluZyBoYXBwZW5zLlxuXG4gICAgICAgICAgICAvLyBUbyBmaXggdGhpcyB3ZSdsbCBzZXQgdGhlIGZsYWcgYmFjayB0byBmYWxzZSBoZXJlIGluIGRyYXcsIHdoZW5cbiAgICAgICAgICAgIC8vIGFsbCBzZXJpZXMgaGF2ZSBiZWVuIHByb2Nlc3NlZCwgc28gdGhlIG5leHQgc2VxdWVuY2Ugb2YgY2FsbHMgdG9cbiAgICAgICAgICAgIC8vIHByb2Nlc3NEYXRhcG9pbnRzIG9uY2UgYWdhaW4gc3RhcnRzIG91dCB3aXRoIGEgc2xpY2UtY29tYmluZS5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgcmVhbGx5IGEgaGFjazsgaW4gMC45IHdlIG5lZWQgdG8gZ2l2ZSBwbHVnaW5zIGEgcHJvcGVyXG4gICAgICAgICAgICAvLyB3YXkgdG8gbW9kaWZ5IHNlcmllcyBiZWZvcmUgYW55IHByb2Nlc3NpbmcgYmVnaW5zLlxuXG4gICAgICAgICAgICBwcm9jZXNzZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIG1heGltdW0gcmFkaXVzIGFuZCBjZW50ZXIgcG9pbnRcbiAgICAgICAgICAgIG1heFJhZGl1cyA9IE1hdGgubWluKGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQgLyBvcHRpb25zLnNlcmllcy5waWUudGlsdCkgLyAyO1xuICAgICAgICAgICAgY2VudGVyVG9wID0gY2FudmFzSGVpZ2h0IC8gMiArIG9wdGlvbnMuc2VyaWVzLnBpZS5vZmZzZXQudG9wO1xuICAgICAgICAgICAgY2VudGVyTGVmdCA9IGNhbnZhc1dpZHRoIC8gMjtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2VyaWVzLnBpZS5vZmZzZXQubGVmdCA9PT0gXCJhdXRvXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5sZWdlbmQucG9zaXRpb24ubWF0Y2goXCJ3XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbnRlckxlZnQgKz0gbGVnZW5kV2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbnRlckxlZnQgLT0gbGVnZW5kV2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2VudGVyTGVmdCA8IG1heFJhZGl1cykge1xuICAgICAgICAgICAgICAgICAgICBjZW50ZXJMZWZ0ID0gbWF4UmFkaXVzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2VudGVyTGVmdCA+IGNhbnZhc1dpZHRoIC0gbWF4UmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbnRlckxlZnQgPSBjYW52YXNXaWR0aCAtIG1heFJhZGl1cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNlbnRlckxlZnQgKz0gb3B0aW9ucy5zZXJpZXMucGllLm9mZnNldC5sZWZ0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc2xpY2VzID0gcGxvdC5nZXREYXRhKCksXG4gICAgICAgICAgICAgICAgYXR0ZW1wdHMgPSAwO1xuXG4gICAgICAgICAgICAvLyBLZWVwIHNocmlua2luZyB0aGUgcGllJ3MgcmFkaXVzIHVudGlsIGRyYXdQaWUgcmV0dXJucyB0cnVlLFxuICAgICAgICAgICAgLy8gaW5kaWNhdGluZyB0aGF0IGFsbCB0aGUgbGFiZWxzIGZpdCwgb3Igd2UgdHJ5IHRvbyBtYW55IHRpbWVzLlxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmIChhdHRlbXB0cyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4UmFkaXVzICo9IFJFRFJBV19TSFJJTks7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF0dGVtcHRzICs9IDE7XG4gICAgICAgICAgICAgICAgY2xlYXIoKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zZXJpZXMucGllLnRpbHQgPD0gMC44KSB7XG4gICAgICAgICAgICAgICAgICAgIGRyYXdTaGFkb3coKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlICghZHJhd1BpZSgpICYmIGF0dGVtcHRzIDwgUkVEUkFXX0FUVEVNUFRTKVxuXG4gICAgICAgICAgICBpZiAoYXR0ZW1wdHMgPj0gUkVEUkFXX0FUVEVNUFRTKSB7XG4gICAgICAgICAgICAgICAgY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB0YXJnZXQucHJlcGVuZChcIjxkaXYgY2xhc3M9J2Vycm9yJz5Db3VsZCBub3QgZHJhdyBwaWUgd2l0aCBsYWJlbHMgY29udGFpbmVkIGluc2lkZSBjYW52YXM8L2Rpdj5cIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwbG90LnNldFNlcmllcyAmJiBwbG90Lmluc2VydExlZ2VuZCkge1xuICAgICAgICAgICAgICAgIHBsb3Quc2V0U2VyaWVzKHNsaWNlcyk7XG4gICAgICAgICAgICAgICAgcGxvdC5pbnNlcnRMZWdlbmQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gd2UncmUgYWN0dWFsbHkgZG9uZSBhdCB0aGlzIHBvaW50LCBqdXN0IGRlZmluaW5nIGludGVybmFsIGZ1bmN0aW9ucyBhdCB0aGlzIHBvaW50XG4gICAgICAgICAgICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xuICAgICAgICAgICAgICAgIHRhcmdldC5jaGlsZHJlbigpLmZpbHRlcihcIi5waWVMYWJlbCwgLnBpZUxhYmVsQmFja2dyb3VuZFwiKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gZHJhd1NoYWRvdygpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2hhZG93TGVmdCA9IG9wdGlvbnMuc2VyaWVzLnBpZS5zaGFkb3cubGVmdDtcbiAgICAgICAgICAgICAgICB2YXIgc2hhZG93VG9wID0gb3B0aW9ucy5zZXJpZXMucGllLnNoYWRvdy50b3A7XG4gICAgICAgICAgICAgICAgdmFyIGVkZ2UgPSAxMDtcbiAgICAgICAgICAgICAgICB2YXIgYWxwaGEgPSBvcHRpb25zLnNlcmllcy5waWUuc2hhZG93LmFscGhhO1xuICAgICAgICAgICAgICAgIHZhciByYWRpdXMgPSBvcHRpb25zLnNlcmllcy5waWUucmFkaXVzID4gMSA/IG9wdGlvbnMuc2VyaWVzLnBpZS5yYWRpdXMgOiBtYXhSYWRpdXMgKiBvcHRpb25zLnNlcmllcy5waWUucmFkaXVzO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJhZGl1cyA+PSBjYW52YXNXaWR0aCAvIDIgLSBzaGFkb3dMZWZ0IHx8IHJhZGl1cyAqIG9wdGlvbnMuc2VyaWVzLnBpZS50aWx0ID49IGNhbnZhc0hlaWdodCAvIDIgLSBzaGFkb3dUb3AgfHwgcmFkaXVzIDw9IGVkZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAgICAvLyBzaGFkb3cgd291bGQgYmUgb3V0c2lkZSBjYW52YXMsIHNvIGRvbid0IGRyYXcgaXRcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoc2hhZG93TGVmdCwgc2hhZG93VG9wKTtcbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBhbHBoYTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gXCIjMDAwXCI7XG5cbiAgICAgICAgICAgICAgICAvLyBjZW50ZXIgYW5kIHJvdGF0ZSB0byBzdGFydGluZyBwb3NpdGlvblxuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoY2VudGVyTGVmdCwgY2VudGVyVG9wKTtcbiAgICAgICAgICAgICAgICBjdHguc2NhbGUoMSwgb3B0aW9ucy5zZXJpZXMucGllLnRpbHQpO1xuXG4gICAgICAgICAgICAgICAgLy9yYWRpdXMgLT0gZWRnZTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBlZGdlOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICBjdHguYXJjKDAsIDAsIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgcmFkaXVzIC09IGk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gZHJhd1BpZSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRBbmdsZSA9IE1hdGguUEkgKiBvcHRpb25zLnNlcmllcy5waWUuc3RhcnRBbmdsZTtcbiAgICAgICAgICAgICAgICB2YXIgcmFkaXVzID0gb3B0aW9ucy5zZXJpZXMucGllLnJhZGl1cyA+IDEgPyBvcHRpb25zLnNlcmllcy5waWUucmFkaXVzIDogbWF4UmFkaXVzICogb3B0aW9ucy5zZXJpZXMucGllLnJhZGl1cztcbiAgICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgICAvLyBjZW50ZXIgYW5kIHJvdGF0ZSB0byBzdGFydGluZyBwb3NpdGlvblxuXG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKGNlbnRlckxlZnQsIGNlbnRlclRvcCk7XG4gICAgICAgICAgICAgICAgY3R4LnNjYWxlKDEsIG9wdGlvbnMuc2VyaWVzLnBpZS50aWx0KTtcbiAgICAgICAgICAgICAgICAvL2N0eC5yb3RhdGUoc3RhcnRBbmdsZSk7IC8vIHN0YXJ0IGF0IHRvcDsgLS0gVGhpcyBkb2Vzbid0IHdvcmsgcHJvcGVybHkgaW4gT3BlcmFcblxuICAgICAgICAgICAgICAgIC8vIGRyYXcgc2xpY2VzXG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcblxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50QW5nbGUgPSBzdGFydEFuZ2xlO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzbGljZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgc2xpY2VzW2ldLnN0YXJ0QW5nbGUgPSBjdXJyZW50QW5nbGU7XG4gICAgICAgICAgICAgICAgICAgIGRyYXdTbGljZShzbGljZXNbaV0uYW5nbGUsIHNsaWNlc1tpXS5jb2xvciwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgICAgICAgICAgIC8vIGRyYXcgc2xpY2Ugb3V0bGluZXNcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zZXJpZXMucGllLnN0cm9rZS53aWR0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IG9wdGlvbnMuc2VyaWVzLnBpZS5zdHJva2Uud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBbmdsZSA9IHN0YXJ0QW5nbGU7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzbGljZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdTbGljZShzbGljZXNbaV0uYW5nbGUsIG9wdGlvbnMuc2VyaWVzLnBpZS5zdHJva2UuY29sb3IsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gZHJhdyBkb251dCBob2xlXG4gICAgICAgICAgICAgICAgZHJhd0RvbnV0SG9sZShjdHgpO1xuXG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgICAgICAgICAgIC8vIERyYXcgdGhlIGxhYmVscywgcmV0dXJuaW5nIHRydWUgaWYgdGhleSBmaXQgd2l0aGluIHRoZSBwbG90XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2VyaWVzLnBpZS5sYWJlbC5zaG93KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkcmF3TGFiZWxzKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZHJhd1NsaWNlKGFuZ2xlLCBjb2xvciwgZmlsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYW5nbGUgPD0gMCB8fCBpc05hTihhbmdsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lSm9pbiA9IFwicm91bmRcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGFuZ2xlIC0gTWF0aC5QSSAqIDIpID4gMC4wMDAwMDAwMDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oMCwgMCk7IC8vIENlbnRlciBvZiB0aGUgcGllXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvL2N0eC5hcmMoMCwgMCwgcmFkaXVzLCAwLCBhbmdsZSwgZmFsc2UpOyAvLyBUaGlzIGRvZXNuJ3Qgd29yayBwcm9wZXJseSBpbiBPcGVyYVxuICAgICAgICAgICAgICAgICAgICBjdHguYXJjKDAsIDAsIHJhZGl1cywgY3VycmVudEFuZ2xlLCBjdXJyZW50QW5nbGUgKyBhbmdsZSAvIDIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmFyYygwLCAwLCByYWRpdXMsIGN1cnJlbnRBbmdsZSArIGFuZ2xlIC8gMiwgY3VycmVudEFuZ2xlICsgYW5nbGUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICAvL2N0eC5yb3RhdGUoYW5nbGUpOyAvLyBUaGlzIGRvZXNuJ3Qgd29yayBwcm9wZXJseSBpbiBPcGVyYVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50QW5nbGUgKz0gYW5nbGU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBkcmF3TGFiZWxzKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudEFuZ2xlID0gc3RhcnRBbmdsZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJhZGl1cyA9IG9wdGlvbnMuc2VyaWVzLnBpZS5sYWJlbC5yYWRpdXMgPiAxID8gb3B0aW9ucy5zZXJpZXMucGllLmxhYmVsLnJhZGl1cyA6IG1heFJhZGl1cyAqIG9wdGlvbnMuc2VyaWVzLnBpZS5sYWJlbC5yYWRpdXM7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzbGljZXNbaV0ucGVyY2VudCA+PSBvcHRpb25zLnNlcmllcy5waWUubGFiZWwudGhyZXNob2xkICogMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkcmF3TGFiZWwoc2xpY2VzW2ldLCBjdXJyZW50QW5nbGUsIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50QW5nbGUgKz0gc2xpY2VzW2ldLmFuZ2xlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZHJhd0xhYmVsKHNsaWNlLCBzdGFydEFuZ2xlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNsaWNlLmRhdGFbMF1bMV0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9ybWF0IGxhYmVsIHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZiA9IG9wdGlvbnMubGVnZW5kLmxhYmVsRm9ybWF0dGVyLCB0ZXh0LCBwbGYgPSBvcHRpb25zLnNlcmllcy5waWUubGFiZWwuZm9ybWF0dGVyO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gbGYoc2xpY2UubGFiZWwsIHNsaWNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHNsaWNlLmxhYmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGxmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHBsZih0ZXh0LCBzbGljZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYWxmQW5nbGUgPSAoKHN0YXJ0QW5nbGUgKyBzbGljZS5hbmdsZSkgKyBzdGFydEFuZ2xlKSAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IGNlbnRlckxlZnQgKyBNYXRoLnJvdW5kKE1hdGguY29zKGhhbGZBbmdsZSkgKiByYWRpdXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSBjZW50ZXJUb3AgKyBNYXRoLnJvdW5kKE1hdGguc2luKGhhbGZBbmdsZSkgKiByYWRpdXMpICogb3B0aW9ucy5zZXJpZXMucGllLnRpbHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBodG1sID0gXCI8c3BhbiBjbGFzcz0ncGllTGFiZWwnIGlkPSdwaWVMYWJlbFwiICsgaW5kZXggKyBcIicgc3R5bGU9J3Bvc2l0aW9uOmFic29sdXRlO3RvcDpcIiArIHkgKyBcInB4O2xlZnQ6XCIgKyB4ICsgXCJweDsnPlwiICsgdGV4dCArIFwiPC9zcGFuPlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmFwcGVuZChodG1sKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhYmVsID0gdGFyZ2V0LmNoaWxkcmVuKFwiI3BpZUxhYmVsXCIgKyBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFiZWxUb3AgPSAoeSAtIGxhYmVsLmhlaWdodCgpIC8gMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFiZWxMZWZ0ID0gKHggLSBsYWJlbC53aWR0aCgpIC8gMik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsLmNzcyhcInRvcFwiLCBsYWJlbFRvcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbC5jc3MoXCJsZWZ0XCIsIGxhYmVsTGVmdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBsYWJlbCBpcyBub3Qgb3V0c2lkZSB0aGUgY2FudmFzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoMCAtIGxhYmVsVG9wID4gMCB8fCAwIC0gbGFiZWxMZWZ0ID4gMCB8fCBjYW52YXNIZWlnaHQgLSAobGFiZWxUb3AgKyBsYWJlbC5oZWlnaHQoKSkgPCAwIHx8IGNhbnZhc1dpZHRoIC0gKGxhYmVsTGVmdCArIGxhYmVsLndpZHRoKCkpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2VyaWVzLnBpZS5sYWJlbC5iYWNrZ3JvdW5kLm9wYWNpdHkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwdXQgaW4gdGhlIHRyYW5zcGFyZW50IGJhY2tncm91bmQgc2VwYXJhdGVseSB0byBhdm9pZCBibGVuZGVkIGxhYmVscyBhbmQgbGFiZWwgYm94ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IG9wdGlvbnMuc2VyaWVzLnBpZS5sYWJlbC5iYWNrZ3JvdW5kLmNvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IHNsaWNlLmNvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSBcInRvcDpcIiArIGxhYmVsVG9wICsgXCJweDtsZWZ0OlwiICsgbGFiZWxMZWZ0ICsgXCJweDtcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKFwiPGRpdiBjbGFzcz0ncGllTGFiZWxCYWNrZ3JvdW5kJyBzdHlsZT0ncG9zaXRpb246YWJzb2x1dGU7d2lkdGg6XCIgKyBsYWJlbC53aWR0aCgpICsgXCJweDtoZWlnaHQ6XCIgKyBsYWJlbC5oZWlnaHQoKSArIFwicHg7XCIgKyBwb3MgKyBcImJhY2tncm91bmQtY29sb3I6XCIgKyBjICsgXCI7Jz48L2Rpdj5cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNzcyhcIm9wYWNpdHlcIiwgb3B0aW9ucy5zZXJpZXMucGllLmxhYmVsLmJhY2tncm91bmQub3BhY2l0eSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmluc2VydEJlZm9yZShsYWJlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IC8vIGVuZCBpbmRpdmlkdWFsIGxhYmVsIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgfSAvLyBlbmQgZHJhd0xhYmVscyBmdW5jdGlvblxuICAgICAgICAgICAgfSAvLyBlbmQgZHJhd1BpZSBmdW5jdGlvblxuICAgICAgICB9IC8vIGVuZCBkcmF3IGZ1bmN0aW9uXG5cbiAgICAgICAgLy8gUGxhY2VkIGhlcmUgYmVjYXVzZSBpdCBuZWVkcyB0byBiZSBhY2Nlc3NlZCBmcm9tIG11bHRpcGxlIGxvY2F0aW9uc1xuXG4gICAgICAgIGZ1bmN0aW9uIGRyYXdEb251dEhvbGUobGF5ZXIpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNlcmllcy5waWUuaW5uZXJSYWRpdXMgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gc3VidHJhY3QgdGhlIGNlbnRlclxuICAgICAgICAgICAgICAgIGxheWVyLnNhdmUoKTtcbiAgICAgICAgICAgICAgICB2YXIgaW5uZXJSYWRpdXMgPSBvcHRpb25zLnNlcmllcy5waWUuaW5uZXJSYWRpdXMgPiAxID8gb3B0aW9ucy5zZXJpZXMucGllLmlubmVyUmFkaXVzIDogbWF4UmFkaXVzICogb3B0aW9ucy5zZXJpZXMucGllLmlubmVyUmFkaXVzO1xuICAgICAgICAgICAgICAgIGxheWVyLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwiZGVzdGluYXRpb24tb3V0XCI7IC8vIHRoaXMgZG9lcyBub3Qgd29yayB3aXRoIGV4Y2FudmFzLCBidXQgaXQgd2lsbCBmYWxsIGJhY2sgdG8gdXNpbmcgdGhlIHN0cm9rZSBjb2xvclxuICAgICAgICAgICAgICAgIGxheWVyLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGxheWVyLmZpbGxTdHlsZSA9IG9wdGlvbnMuc2VyaWVzLnBpZS5zdHJva2UuY29sb3I7XG4gICAgICAgICAgICAgICAgbGF5ZXIuYXJjKDAsIDAsIGlubmVyUmFkaXVzLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGxheWVyLmZpbGwoKTtcbiAgICAgICAgICAgICAgICBsYXllci5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICBsYXllci5yZXN0b3JlKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBhZGQgaW5uZXIgc3Ryb2tlXG4gICAgICAgICAgICAgICAgbGF5ZXIuc2F2ZSgpO1xuICAgICAgICAgICAgICAgIGxheWVyLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGxheWVyLnN0cm9rZVN0eWxlID0gb3B0aW9ucy5zZXJpZXMucGllLnN0cm9rZS5jb2xvcjtcbiAgICAgICAgICAgICAgICBsYXllci5hcmMoMCwgMCwgaW5uZXJSYWRpdXMsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgbGF5ZXIuc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgbGF5ZXIuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgbGF5ZXIucmVzdG9yZSgpO1xuXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogYWRkIGV4dHJhIHNoYWRvdyBpbnNpZGUgaG9sZSAod2l0aCBhIG1hc2spIGlmIHRoZSBwaWUgaXMgdGlsdGVkLlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8tLSBBZGRpdGlvbmFsIEludGVyYWN0aXZlIHJlbGF0ZWQgZnVuY3Rpb25zIC0tXG5cbiAgICAgICAgZnVuY3Rpb24gaXNQb2ludEluUG9seShwb2x5LCBwdCkge1xuICAgICAgICAgICAgZm9yICh2YXIgYyA9IGZhbHNlLCBpID0gLTEsIGwgPSBwb2x5Lmxlbmd0aCwgaiA9IGwgLSAxOyArK2kgPCBsOyBqID0gaSkge1xuICAgICAgICAgICAgICAgICgocG9seVtpXVsxXSA8PSBwdFsxXSAmJiBwdFsxXSA8IHBvbHlbal1bMV0pIHx8XG4gICAgICAgICAgICAgICAgKHBvbHlbal1bMV0gPD0gcHRbMV0gJiYgcHRbMV0gPCBwb2x5W2ldWzFdKSkgJiZcbiAgICAgICAgICAgICAgICAocHRbMF0gPCAocG9seVtqXVswXSAtIHBvbHlbaV1bMF0pICogKHB0WzFdIC0gcG9seVtpXVsxXSkgLyAocG9seVtqXVsxXSAtIHBvbHlbaV1bMV0pICsgcG9seVtpXVswXSkgJiZcbiAgICAgICAgICAgICAgICAoYyA9ICFjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZmluZE5lYXJieVNsaWNlKG1vdXNlWCwgbW91c2VZKSB7XG4gICAgICAgICAgICB2YXIgc2xpY2VzID0gcGxvdC5nZXREYXRhKCksXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHBsb3QuZ2V0T3B0aW9ucygpLFxuICAgICAgICAgICAgICAgIHJhZGl1cyA9IG9wdGlvbnMuc2VyaWVzLnBpZS5yYWRpdXMgPiAxID8gb3B0aW9ucy5zZXJpZXMucGllLnJhZGl1cyA6IG1heFJhZGl1cyAqIG9wdGlvbnMuc2VyaWVzLnBpZS5yYWRpdXMsXG4gICAgICAgICAgICAgICAgeCwgeTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IHNsaWNlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocy5waWUuc2hvdykge1xuICAgICAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oMCwgMCk7IC8vIENlbnRlciBvZiB0aGUgcGllXG4gICAgICAgICAgICAgICAgICAgIC8vY3R4LnNjYWxlKDEsIG9wdGlvbnMuc2VyaWVzLnBpZS50aWx0KTsgICAgLy8gdGhpcyBhY3R1YWxseSBzZWVtcyB0byBicmVhayBldmVyeXRoaW5nIHdoZW4gaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgY3R4LmFyYygwLCAwLCByYWRpdXMsIHMuc3RhcnRBbmdsZSwgcy5zdGFydEFuZ2xlICsgcy5hbmdsZSAvIDIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmFyYygwLCAwLCByYWRpdXMsIHMuc3RhcnRBbmdsZSArIHMuYW5nbGUgLyAyLCBzLnN0YXJ0QW5nbGUgKyBzLmFuZ2xlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgeCA9IG1vdXNlWCAtIGNlbnRlckxlZnQ7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBtb3VzZVkgLSBjZW50ZXJUb3A7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN0eC5pc1BvaW50SW5QYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3R4LmlzUG9pbnRJblBhdGgobW91c2VYIC0gY2VudGVyTGVmdCwgbW91c2VZIC0gY2VudGVyVG9wKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YXBvaW50OiBbcy5wZXJjZW50LCBzLmRhdGFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhSW5kZXg6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllczogcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IGlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhjYW52YXMgZm9yIElFIGRvZXNuO3Qgc3VwcG9ydCBpc1BvaW50SW5QYXRoLCB0aGlzIGlzIGEgd29ya2Fyb3VuZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwMVggPSByYWRpdXMgKiBNYXRoLmNvcyhzLnN0YXJ0QW5nbGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAxWSA9IHJhZGl1cyAqIE1hdGguc2luKHMuc3RhcnRBbmdsZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcDJYID0gcmFkaXVzICogTWF0aC5jb3Mocy5zdGFydEFuZ2xlICsgcy5hbmdsZSAvIDQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAyWSA9IHJhZGl1cyAqIE1hdGguc2luKHMuc3RhcnRBbmdsZSArIHMuYW5nbGUgLyA0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwM1ggPSByYWRpdXMgKiBNYXRoLmNvcyhzLnN0YXJ0QW5nbGUgKyBzLmFuZ2xlIC8gMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcDNZID0gcmFkaXVzICogTWF0aC5zaW4ocy5zdGFydEFuZ2xlICsgcy5hbmdsZSAvIDIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHA0WCA9IHJhZGl1cyAqIE1hdGguY29zKHMuc3RhcnRBbmdsZSArIHMuYW5nbGUgLyAxLjUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHA0WSA9IHJhZGl1cyAqIE1hdGguc2luKHMuc3RhcnRBbmdsZSArIHMuYW5nbGUgLyAxLjUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHA1WCA9IHJhZGl1cyAqIE1hdGguY29zKHMuc3RhcnRBbmdsZSArIHMuYW5nbGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHA1WSA9IHJhZGl1cyAqIE1hdGguc2luKHMuc3RhcnRBbmdsZSArIHMuYW5nbGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyclBvbHkgPSBbWzAsIDBdLCBbcDFYLCBwMVldLCBbcDJYLCBwMlldLCBbcDNYLCBwM1ldLCBbcDRYLCBwNFldLCBbcDVYLCBwNVldXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJQb2ludCA9IFt4LCB5XTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogcGVyaGFwcyBkbyBzb21lIG1hdGhtYXRpY2FsIHRyaWNrZXJ5IGhlcmUgd2l0aCB0aGUgWS1jb29yZGluYXRlIHRvIGNvbXBlbnNhdGUgZm9yIHBpZSB0aWx0P1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNQb2ludEluUG9seShhcnJQb2x5LCBhcnJQb2ludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFwb2ludDogW3MucGVyY2VudCwgcy5kYXRhXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUluZGV4OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG9uTW91c2VNb3ZlKGUpIHtcbiAgICAgICAgICAgIHRyaWdnZXJDbGlja0hvdmVyRXZlbnQoXCJwbG90aG92ZXJcIiwgZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBvbkNsaWNrKGUpIHtcbiAgICAgICAgICAgIHRyaWdnZXJDbGlja0hvdmVyRXZlbnQoXCJwbG90Y2xpY2tcIiwgZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0cmlnZ2VyIGNsaWNrIG9yIGhvdmVyIGV2ZW50ICh0aGV5IHNlbmQgdGhlIHNhbWUgcGFyYW1ldGVycyBzbyB3ZSBzaGFyZSB0aGVpciBjb2RlKVxuXG4gICAgICAgIGZ1bmN0aW9uIHRyaWdnZXJDbGlja0hvdmVyRXZlbnQoZXZlbnRuYW1lLCBlKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gcGxvdC5vZmZzZXQoKTtcbiAgICAgICAgICAgIHZhciBjYW52YXNYID0gcGFyc2VJbnQoZS5wYWdlWCAtIG9mZnNldC5sZWZ0KTtcbiAgICAgICAgICAgIHZhciBjYW52YXNZID0gcGFyc2VJbnQoZS5wYWdlWSAtIG9mZnNldC50b3ApO1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBmaW5kTmVhcmJ5U2xpY2UoY2FudmFzWCwgY2FudmFzWSk7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmdyaWQuYXV0b0hpZ2hsaWdodCkge1xuICAgICAgICAgICAgICAgIC8vIGNsZWFyIGF1dG8taGlnaGxpZ2h0c1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGlnaGxpZ2h0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaCA9IGhpZ2hsaWdodHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChoLmF1dG8gPT09IGV2ZW50bmFtZSAmJiAhKGl0ZW0gJiYgaC5zZXJpZXMgPT09IGl0ZW0uc2VyaWVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5oaWdobGlnaHQoaC5zZXJpZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBoaWdobGlnaHQgdGhlIHNsaWNlXG5cbiAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgaGlnaGxpZ2h0KGl0ZW0uc2VyaWVzLCBldmVudG5hbWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0cmlnZ2VyIGFueSBob3ZlciBiaW5kIGV2ZW50c1xuXG4gICAgICAgICAgICB2YXIgcG9zID0geyBwYWdlWDogZS5wYWdlWCwgcGFnZVk6IGUucGFnZVkgfTtcbiAgICAgICAgICAgIHRhcmdldC50cmlnZ2VyKGV2ZW50bmFtZSwgW3BvcywgaXRlbV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaGlnaGxpZ2h0KHMsIGF1dG8pIHtcbiAgICAgICAgICAgIC8vaWYgKHR5cGVvZiBzID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIC8vICAgIHMgPSBzZXJpZXNbc107XG4gICAgICAgICAgICAvL31cblxuICAgICAgICAgICAgdmFyIGkgPSBpbmRleE9mSGlnaGxpZ2h0KHMpO1xuXG4gICAgICAgICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBoaWdobGlnaHRzLnB1c2goeyBzZXJpZXM6IHMsIGF1dG86IGF1dG8gfSk7XG4gICAgICAgICAgICAgICAgcGxvdC50cmlnZ2VyUmVkcmF3T3ZlcmxheSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghYXV0bykge1xuICAgICAgICAgICAgICAgIGhpZ2hsaWdodHNbaV0uYXV0byA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdW5oaWdobGlnaHQocykge1xuICAgICAgICAgICAgaWYgKHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGhpZ2hsaWdodHMgPSBbXTtcbiAgICAgICAgICAgICAgICBwbG90LnRyaWdnZXJSZWRyYXdPdmVybGF5KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vaWYgKHR5cGVvZiBzID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIC8vICAgIHMgPSBzZXJpZXNbc107XG4gICAgICAgICAgICAvL31cblxuICAgICAgICAgICAgdmFyIGkgPSBpbmRleE9mSGlnaGxpZ2h0KHMpO1xuXG4gICAgICAgICAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBoaWdobGlnaHRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICBwbG90LnRyaWdnZXJSZWRyYXdPdmVybGF5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpbmRleE9mSGlnaGxpZ2h0KHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGlnaGxpZ2h0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBoID0gaGlnaGxpZ2h0c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoaC5zZXJpZXMgPT09IHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZHJhd092ZXJsYXkocGxvdCwgb2N0eCkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBwbG90LmdldE9wdGlvbnMoKTtcbiAgICAgICAgICAgIHZhciByYWRpdXMgPSBvcHRpb25zLnNlcmllcy5waWUucmFkaXVzID4gMSA/IG9wdGlvbnMuc2VyaWVzLnBpZS5yYWRpdXMgOiBtYXhSYWRpdXMgKiBvcHRpb25zLnNlcmllcy5waWUucmFkaXVzO1xuXG4gICAgICAgICAgICBvY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIG9jdHgudHJhbnNsYXRlKGNlbnRlckxlZnQsIGNlbnRlclRvcCk7XG4gICAgICAgICAgICBvY3R4LnNjYWxlKDEsIG9wdGlvbnMuc2VyaWVzLnBpZS50aWx0KTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoaWdobGlnaHRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgZHJhd0hpZ2hsaWdodChoaWdobGlnaHRzW2ldLnNlcmllcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRyYXdEb251dEhvbGUob2N0eCk7XG5cbiAgICAgICAgICAgIG9jdHgucmVzdG9yZSgpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBkcmF3SGlnaGxpZ2h0KHNlcmllcykge1xuICAgICAgICAgICAgICAgIGlmIChzZXJpZXMuYW5nbGUgPD0gMCB8fCBpc05hTihzZXJpZXMuYW5nbGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL29jdHguZmlsbFN0eWxlID0gcGFyc2VDb2xvcihvcHRpb25zLnNlcmllcy5waWUuaGlnaGxpZ2h0LmNvbG9yKS5zY2FsZShudWxsLCBudWxsLCBudWxsLCBvcHRpb25zLnNlcmllcy5waWUuaGlnaGxpZ2h0Lm9wYWNpdHkpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgb2N0eC5maWxsU3R5bGUgPSBcInJnYmEoMjU1LCAyNTUsIDI1NSwgXCIgKyBvcHRpb25zLnNlcmllcy5waWUuaGlnaGxpZ2h0Lm9wYWNpdHkgKyBcIilcIjsgLy8gdGhpcyBpcyB0ZW1wb3JhcnkgdW50aWwgd2UgaGF2ZSBhY2Nlc3MgdG8gcGFyc2VDb2xvclxuICAgICAgICAgICAgICAgIG9jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHNlcmllcy5hbmdsZSAtIE1hdGguUEkgKiAyKSA+IDAuMDAwMDAwMDAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG9jdHgubW92ZVRvKDAsIDApOyAvLyBDZW50ZXIgb2YgdGhlIHBpZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvY3R4LmFyYygwLCAwLCByYWRpdXMsIHNlcmllcy5zdGFydEFuZ2xlLCBzZXJpZXMuc3RhcnRBbmdsZSArIHNlcmllcy5hbmdsZSAvIDIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBvY3R4LmFyYygwLCAwLCByYWRpdXMsIHNlcmllcy5zdGFydEFuZ2xlICsgc2VyaWVzLmFuZ2xlIC8gMiwgc2VyaWVzLnN0YXJ0QW5nbGUgKyBzZXJpZXMuYW5nbGUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBvY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgIG9jdHguZmlsbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSAvLyBlbmQgaW5pdCAocGx1Z2luIGJvZHkpXG5cbiAgICAvLyBkZWZpbmUgcGllIHNwZWNpZmljIG9wdGlvbnMgYW5kIHRoZWlyIGRlZmF1bHQgdmFsdWVzXG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIHNlcmllczoge1xuICAgICAgICAgICAgcGllOiB7XG4gICAgICAgICAgICAgICAgc2hvdzogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmFkaXVzOiBcImF1dG9cIiwgICAgLy8gYWN0dWFsIHJhZGl1cyBvZiB0aGUgdmlzaWJsZSBwaWUgKGJhc2VkIG9uIGZ1bGwgY2FsY3VsYXRlZCByYWRpdXMgaWYgPD0xLCBvciBoYXJkIHBpeGVsIHZhbHVlKVxuICAgICAgICAgICAgICAgIGlubmVyUmFkaXVzOiAwLCAvKiBmb3IgZG9udXQgKi9cbiAgICAgICAgICAgICAgICBzdGFydEFuZ2xlOiAzIC8gMixcbiAgICAgICAgICAgICAgICB0aWx0OiAxLFxuICAgICAgICAgICAgICAgIHNoYWRvdzoge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiA1LCAgICAvLyBzaGFkb3cgbGVmdCBvZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgdG9wOiAxNSwgICAgLy8gc2hhZG93IHRvcCBvZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgYWxwaGE6IDAuMDIgICAgLy8gc2hhZG93IGFscGhhXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBcImF1dG9cIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBcIiNmZmZcIixcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDFcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICAgICAgICAgIHNob3c6IFwiYXV0b1wiLFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uKGxhYmVsLCBzbGljZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiPGRpdiBzdHlsZT0nZm9udC1zaXplOngtc21hbGw7dGV4dC1hbGlnbjpjZW50ZXI7cGFkZGluZzoycHg7Y29sb3I6XCIgKyBzbGljZS5jb2xvciArIFwiOyc+XCIgKyBsYWJlbCArIFwiPGJyLz5cIiArIE1hdGgucm91bmQoc2xpY2UucGVyY2VudCkgKyBcIiU8L2Rpdj5cIjtcbiAgICAgICAgICAgICAgICAgICAgfSwgICAgLy8gZm9ybWF0dGVyIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgIHJhZGl1czogMSwgICAgLy8gcmFkaXVzIGF0IHdoaWNoIHRvIHBsYWNlIHRoZSBsYWJlbHMgKGJhc2VkIG9uIGZ1bGwgY2FsY3VsYXRlZCByYWRpdXMgaWYgPD0xLCBvciBoYXJkIHBpeGVsIHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdGhyZXNob2xkOiAwICAgIC8vIHBlcmNlbnRhZ2UgYXQgd2hpY2ggdG8gaGlkZSB0aGUgbGFiZWwgKGkuZS4gdGhlIHNsaWNlIGlzIHRvbyBuYXJyb3cpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb21iaW5lOiB7XG4gICAgICAgICAgICAgICAgICAgIHRocmVzaG9sZDogLTEsICAgIC8vIHBlcmNlbnRhZ2UgYXQgd2hpY2ggdG8gY29tYmluZSBsaXR0bGUgc2xpY2VzIGludG8gb25lIGxhcmdlciBzbGljZVxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogbnVsbCwgICAgLy8gY29sb3IgdG8gZ2l2ZSB0aGUgbmV3IHNsaWNlIChhdXRvLWdlbmVyYXRlZCBpZiBudWxsKVxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogXCJPdGhlclwiICAgIC8vIGxhYmVsIHRvIGdpdmUgdGhlIG5ldyBzbGljZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgICAgICAgICAgICAgIC8vY29sb3I6IFwiI2ZmZlwiLCAgICAgICAgLy8gd2lsbCBhZGQgdGhpcyBmdW5jdGlvbmFsaXR5IG9uY2UgcGFyc2VDb2xvciBpcyBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMC41XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgICQucGxvdC5wbHVnaW5zLnB1c2goe1xuICAgICAgICBpbml0OiBpbml0LFxuICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICBuYW1lOiBcInBpZVwiLFxuICAgICAgICB2ZXJzaW9uOiBcIjEuMVwiXG4gICAgfSk7XG59KShqUXVlcnkpO1xuIiwiLyogZXNsaW50LWRpc2FibGUgKi9cbi8qIEZsb3QgcGx1Z2luIGZvciBhdXRvbWF0aWNhbGx5IHJlZHJhd2luZyBwbG90cyBhcyB0aGUgcGxhY2Vob2xkZXIgcmVzaXplcy5cblxuQ29weXJpZ2h0IChjKSAyMDA3LTIwMTQgSU9MQSBhbmQgT2xlIExhdXJzZW4uXG5MaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cbkl0IHdvcmtzIGJ5IGxpc3RlbmluZyBmb3IgY2hhbmdlcyBvbiB0aGUgcGxhY2Vob2xkZXIgZGl2ICh0aHJvdWdoIHRoZSBqUXVlcnlcbnJlc2l6ZSBldmVudCBwbHVnaW4pIC0gaWYgdGhlIHNpemUgY2hhbmdlcywgaXQgd2lsbCByZWRyYXcgdGhlIHBsb3QuXG5cblRoZXJlIGFyZSBubyBvcHRpb25zLiBJZiB5b3UgbmVlZCB0byBkaXNhYmxlIHRoZSBwbHVnaW4gZm9yIHNvbWUgcGxvdHMsIHlvdVxuY2FuIGp1c3QgZml4IHRoZSBzaXplIG9mIHRoZWlyIHBsYWNlaG9sZGVycy5cblxuKi9cblxuLyogSW5saW5lIGRlcGVuZGVuY3k6XG4gKiBqUXVlcnkgcmVzaXplIGV2ZW50IC0gdjEuMSAtIDMvMTQvMjAxMFxuICogaHR0cDovL2JlbmFsbWFuLmNvbS9wcm9qZWN0cy9qcXVlcnktcmVzaXplLXBsdWdpbi9cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAgXCJDb3dib3lcIiBCZW4gQWxtYW5cbiAqIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBhbmQgR1BMIGxpY2Vuc2VzLlxuICogaHR0cDovL2JlbmFsbWFuLmNvbS9hYm91dC9saWNlbnNlL1xuICovXG4oZnVuY3Rpb24oJCxlLHQpe1wiJDpub211bmdlXCI7dmFyIGk9W10sbj0kLnJlc2l6ZT0kLmV4dGVuZCgkLnJlc2l6ZSx7fSksYSxyPWZhbHNlLHM9XCJzZXRUaW1lb3V0XCIsdT1cInJlc2l6ZVwiLG09dStcIi1zcGVjaWFsLWV2ZW50XCIsbz1cInBlbmRpbmdEZWxheVwiLGw9XCJhY3RpdmVEZWxheVwiLGY9XCJ0aHJvdHRsZVdpbmRvd1wiO25bb109MjAwO25bbF09MjA7bltmXT10cnVlOyQuZXZlbnQuc3BlY2lhbFt1XT17c2V0dXA6ZnVuY3Rpb24oKXtpZighbltmXSYmdGhpc1tzXSl7cmV0dXJuIGZhbHNlfXZhciBlPSQodGhpcyk7aS5wdXNoKHRoaXMpO2UuZGF0YShtLHt3OmUud2lkdGgoKSxoOmUuaGVpZ2h0KCl9KTtpZihpLmxlbmd0aD09PTEpe2E9dDtoKCl9fSx0ZWFyZG93bjpmdW5jdGlvbigpe2lmKCFuW2ZdJiZ0aGlzW3NdKXtyZXR1cm4gZmFsc2V9dmFyIGU9JCh0aGlzKTtmb3IodmFyIHQ9aS5sZW5ndGgtMTt0Pj0wO3QtLSl7aWYoaVt0XT09dGhpcyl7aS5zcGxpY2UodCwxKTticmVha319ZS5yZW1vdmVEYXRhKG0pO2lmKCFpLmxlbmd0aCl7aWYocil7Y2FuY2VsQW5pbWF0aW9uRnJhbWUoYSl9ZWxzZXtjbGVhclRpbWVvdXQoYSl9YT1udWxsfX0sYWRkOmZ1bmN0aW9uKGUpe2lmKCFuW2ZdJiZ0aGlzW3NdKXtyZXR1cm4gZmFsc2V9dmFyIGk7ZnVuY3Rpb24gYShlLG4sYSl7dmFyIHI9JCh0aGlzKSxzPXIuZGF0YShtKXx8e307cy53PW4hPT10P246ci53aWR0aCgpO3MuaD1hIT09dD9hOnIuaGVpZ2h0KCk7aS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9aWYoJC5pc0Z1bmN0aW9uKGUpKXtpPWU7cmV0dXJuIGF9ZWxzZXtpPWUuaGFuZGxlcjtlLmhhbmRsZXI9YX19fTtmdW5jdGlvbiBoKHQpe2lmKHI9PT10cnVlKXtyPXR8fDF9Zm9yKHZhciBzPWkubGVuZ3RoLTE7cz49MDtzLS0pe3ZhciBsPSQoaVtzXSk7aWYobFswXT09ZXx8bC5pcyhcIjp2aXNpYmxlXCIpKXt2YXIgZj1sLndpZHRoKCksYz1sLmhlaWdodCgpLGQ9bC5kYXRhKG0pO2lmKGQmJihmIT09ZC53fHxjIT09ZC5oKSl7bC50cmlnZ2VyKHUsW2Qudz1mLGQuaD1jXSk7cj10fHx0cnVlfX1lbHNle2Q9bC5kYXRhKG0pO2Qudz0wO2QuaD0wfX1pZihhIT09bnVsbCl7aWYociYmKHQ9PW51bGx8fHQtcjwxZTMpKXthPWUucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGgpfWVsc2V7YT1zZXRUaW1lb3V0KGgsbltvXSk7cj1mYWxzZX19fWlmKCFlLnJlcXVlc3RBbmltYXRpb25GcmFtZSl7ZS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU9ZnVuY3Rpb24oKXtyZXR1cm4gZS53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fGUubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lfHxlLm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fGUubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fGZ1bmN0aW9uKHQsaSl7cmV0dXJuIGUuc2V0VGltZW91dChmdW5jdGlvbigpe3QoKG5ldyBEYXRlKS5nZXRUaW1lKCkpfSxuW2xdKX19KCl9aWYoIWUuY2FuY2VsQW5pbWF0aW9uRnJhbWUpe2UuY2FuY2VsQW5pbWF0aW9uRnJhbWU9ZnVuY3Rpb24oKXtyZXR1cm4gZS53ZWJraXRDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fGUubW96Q2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lfHxlLm9DYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fGUubXNDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fGNsZWFyVGltZW91dH0oKX19KShqUXVlcnksd2luZG93KTtcblxuLyogZXNsaW50LWVuYWJsZSAqL1xuKGZ1bmN0aW9uICgkKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7IH07IC8vIG5vIG9wdGlvbnNcblxuICAgIGZ1bmN0aW9uIGluaXQocGxvdCkge1xuICAgICAgICBmdW5jdGlvbiBvblJlc2l6ZSgpIHtcbiAgICAgICAgICAgIHZhciBwbGFjZWhvbGRlciA9IHBsb3QuZ2V0UGxhY2Vob2xkZXIoKTtcblxuICAgICAgICAgICAgLy8gc29tZWJvZHkgbWlnaHQgaGF2ZSBoaWRkZW4gdXMgYW5kIHdlIGNhbid0IHBsb3RcbiAgICAgICAgICAgIC8vIHdoZW4gd2UgZG9uJ3QgaGF2ZSB0aGUgZGltZW5zaW9uc1xuICAgICAgICAgICAgaWYgKHBsYWNlaG9sZGVyLndpZHRoKCkgPT09IDAgfHwgcGxhY2Vob2xkZXIuaGVpZ2h0KCkgPT09IDApIHJldHVybjtcblxuICAgICAgICAgICAgcGxvdC5yZXNpemUoKTtcbiAgICAgICAgICAgIHBsb3Quc2V0dXBHcmlkKCk7XG4gICAgICAgICAgICBwbG90LmRyYXcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGJpbmRFdmVudHMocGxvdCwgZXZlbnRIb2xkZXIpIHtcbiAgICAgICAgICAgIHBsb3QuZ2V0UGxhY2Vob2xkZXIoKS5yZXNpemUob25SZXNpemUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc2h1dGRvd24ocGxvdCwgZXZlbnRIb2xkZXIpIHtcbiAgICAgICAgICAgIHBsb3QuZ2V0UGxhY2Vob2xkZXIoKS51bmJpbmQoXCJyZXNpemVcIiwgb25SZXNpemUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGxvdC5ob29rcy5iaW5kRXZlbnRzLnB1c2goYmluZEV2ZW50cyk7XG4gICAgICAgIHBsb3QuaG9va3Muc2h1dGRvd24ucHVzaChzaHV0ZG93bik7XG4gICAgfVxuXG4gICAgJC5wbG90LnBsdWdpbnMucHVzaCh7XG4gICAgICAgIGluaXQ6IGluaXQsXG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgIG5hbWU6ICdyZXNpemUnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4wJ1xuICAgIH0pO1xufSkoalF1ZXJ5KTtcbiIsIihmdW5jdGlvbiAoJCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgc2F0dXJhdGVkID0ge1xuICAgICAgICBzYXR1cmF0ZTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGlmIChhID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYSA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC1OdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVsdGE6IGZ1bmN0aW9uKG1pbiwgbWF4LCBub1RpY2tzKSB7XG4gICAgICAgICAgICByZXR1cm4gKChtYXggLSBtaW4pIC8gbm9UaWNrcykgPT09IEluZmluaXR5ID8gKG1heCAvIG5vVGlja3MgLSBtaW4gLyBub1RpY2tzKSA6IChtYXggLSBtaW4pIC8gbm9UaWNrc1xuICAgICAgICB9LFxuICAgICAgICBtdWx0aXBseTogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBzYXR1cmF0ZWQuc2F0dXJhdGUoYSAqIGIpO1xuICAgICAgICB9LFxuICAgICAgICAvLyByZXR1cm5zIGMgKiBiSW50ICogYS4gQmVhaHZlcyBwcm9wZXJseSBpbiB0aGUgY2FzZSB3aGVyZSBjIGlzIG5lZ2F0aXZlXG4gICAgICAgIC8vIGFuZCBiSW50ICogYSBpcyBiaWdnZXIgdGhhdCBOdW1iZXIuTUFYX1ZBTFVFIChJbmZpbml0eSlcbiAgICAgICAgbXVsdGlwbHlBZGQ6IGZ1bmN0aW9uIChhLCBiSW50LCBjKSB7XG4gICAgICAgICAgICBpZiAoaXNGaW5pdGUoYSAqIGJJbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNhdHVyYXRlZC5zYXR1cmF0ZShhICogYkludCArIGMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gYztcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYkludDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBhO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBzYXR1cmF0ZWQuc2F0dXJhdGUocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gcm91bmQgdG8gbmVhcmJ5IGxvd2VyIG11bHRpcGxlIG9mIGJhc2VcbiAgICAgICAgZmxvb3JJbkJhc2U6IGZ1bmN0aW9uKG4sIGJhc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBiYXNlICogTWF0aC5mbG9vcihuIC8gYmFzZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgJC5wbG90LnNhdHVyYXRlZCA9IHNhdHVyYXRlZDtcbn0pKGpRdWVyeSk7XG4iLCIvKiBGbG90IHBsdWdpbiBmb3Igc2VsZWN0aW5nIHJlZ2lvbnMgb2YgYSBwbG90LlxuXG5Db3B5cmlnaHQgKGMpIDIwMDctMjAxNCBJT0xBIGFuZCBPbGUgTGF1cnNlbi5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuVGhlIHBsdWdpbiBzdXBwb3J0cyB0aGVzZSBvcHRpb25zOlxuXG5zZWxlY3Rpb246IHtcbiAgICBtb2RlOiBudWxsIG9yIFwieFwiIG9yIFwieVwiIG9yIFwieHlcIiBvciBcInNtYXJ0XCIsXG4gICAgY29sb3I6IGNvbG9yLFxuICAgIHNoYXBlOiBcInJvdW5kXCIgb3IgXCJtaXRlclwiIG9yIFwiYmV2ZWxcIixcbiAgICB2aXN1YWxpemF0aW9uOiBcImZpbGxcIiBvciBcImZvY3VzXCIsXG4gICAgZGlzcGxheVNlbGVjdGlvbkRlY29yYXRpb25zOiB0cnVlIG9yIGZhbHNlLFxuICAgIG1pblNpemU6IG51bWJlciBvZiBwaXhlbHNcbn1cblxuU2VsZWN0aW9uIHN1cHBvcnQgaXMgZW5hYmxlZCBieSBzZXR0aW5nIHRoZSBtb2RlIHRvIG9uZSBvZiBcInhcIiwgXCJ5XCIgb3IgXCJ4eVwiLlxuSW4gXCJ4XCIgbW9kZSwgdGhlIHVzZXIgd2lsbCBvbmx5IGJlIGFibGUgdG8gc3BlY2lmeSB0aGUgeCByYW5nZSwgc2ltaWxhcmx5IGZvclxuXCJ5XCIgbW9kZS4gRm9yIFwieHlcIiwgdGhlIHNlbGVjdGlvbiBiZWNvbWVzIGEgcmVjdGFuZ2xlIHdoZXJlIGJvdGggcmFuZ2VzIGNhbiBiZVxuc3BlY2lmaWVkLiBcImNvbG9yXCIgaXMgY29sb3Igb2YgdGhlIHNlbGVjdGlvbiAoaWYgeW91IG5lZWQgdG8gY2hhbmdlIHRoZSBjb2xvclxubGF0ZXIgb24sIHlvdSBjYW4gZ2V0IHRvIGl0IHdpdGggcGxvdC5nZXRPcHRpb25zKCkuc2VsZWN0aW9uLmNvbG9yKS4gXCJzaGFwZVwiXG5pcyB0aGUgc2hhcGUgb2YgdGhlIGNvcm5lcnMgb2YgdGhlIHNlbGVjdGlvbi5cblxuVGhlIHdheSBob3cgdGhlIHNlbGVjdGlvbiBpcyB2aXN1YWxpemVkLCBjYW4gYmUgY2hhbmdlZCBieSB1c2luZyB0aGUgb3B0aW9uXG5cInZpc3VhbGl6YXRpb25cIi4gRmxvdCBjdXJyZW50bHkgc3VwcG9ydHMgdHdvIG1vZGVzOiBcImZvY3VzXCIgYW5kIFwiZmlsbFwiLiBUaGVcbm9wdGlvbiBcImZvY3VzXCIgZHJhd3MgYSBjb2xvcmVkIGJlemVsIGFyb3VuZCB0aGUgc2VsZWN0ZWQgYXJlYSB3aGlsZSBrZWVwaW5nXG50aGUgc2VsZWN0ZWQgYXJlYSBjbGVhci4gVGhlIG9wdGlvbiBcImZpbGxcIiBoaWdobGlnaHRzIChpLmUuLCBmaWxscykgdGhlXG5zZWxlY3RlZCBhcmVhIHdpdGggYSBjb2xvcmVkIGhpZ2hsaWdodC5cblxuVGhlcmUgYXJlIG9wdGlvbmFsIHNlbGVjdGlvbiBkZWNvcmF0aW9ucyAoaGFuZGxlcykgdGhhdCBhcmUgcmVuZGVyZWQgd2l0aCB0aGVcblwiZm9jdXNcIiB2aXN1YWxpemF0aW9uIG9wdGlvbi4gVGhlIHNlbGVjdGlvbiBkZWNvcmF0aW9uIGlzIHJlbmRlcmVkIGJ5IGRlZmF1bHRcbmJ1dCBjYW4gYmUgdHVybmVkIG9mZiBieSBzZXR0aW5nIGRpc3BsYXlTZWxlY3Rpb25EZWNvcmF0aW9ucyB0byBmYWxzZS5cblxuXCJtaW5TaXplXCIgaXMgdGhlIG1pbmltdW0gc2l6ZSBhIHNlbGVjdGlvbiBjYW4gYmUgaW4gcGl4ZWxzLiBUaGlzIHZhbHVlIGNhblxuYmUgY3VzdG9taXplZCB0byBkZXRlcm1pbmUgdGhlIHNtYWxsZXN0IHNpemUgYSBzZWxlY3Rpb24gY2FuIGJlIGFuZCBzdGlsbFxuaGF2ZSB0aGUgc2VsZWN0aW9uIHJlY3RhbmdsZSBiZSBkaXNwbGF5ZWQuIFdoZW4gY3VzdG9taXppbmcgdGhpcyB2YWx1ZSwgdGhlXG5mYWN0IHRoYXQgaXQgcmVmZXJzIHRvIHBpeGVscywgbm90IGF4aXMgdW5pdHMgbXVzdCBiZSB0YWtlbiBpbnRvIGFjY291bnQuXG5UaHVzLCBmb3IgZXhhbXBsZSwgaWYgdGhlcmUgaXMgYSBiYXIgZ3JhcGggaW4gdGltZSBtb2RlIHdpdGggQmFyV2lkdGggc2V0IHRvIDFcbm1pbnV0ZSwgc2V0dGluZyBcIm1pblNpemVcIiB0byAxIHdpbGwgbm90IG1ha2UgdGhlIG1pbmltdW0gc2VsZWN0aW9uIHNpemUgMVxubWludXRlLCBidXQgcmF0aGVyIDEgcGl4ZWwuIE5vdGUgYWxzbyB0aGF0IHNldHRpbmcgXCJtaW5TaXplXCIgdG8gMCB3aWxsIHByZXZlbnRcblwicGxvdHVuc2VsZWN0ZWRcIiBldmVudHMgZnJvbSBiZWluZyBmaXJlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgbW91c2Ugd2l0aG91dFxuZHJhZ2dpbmcuXG5cbldoZW4gc2VsZWN0aW9uIHN1cHBvcnQgaXMgZW5hYmxlZCwgYSBcInBsb3RzZWxlY3RlZFwiIGV2ZW50IHdpbGwgYmUgZW1pdHRlZCBvblxudGhlIERPTSBlbGVtZW50IHlvdSBwYXNzZWQgaW50byB0aGUgcGxvdCBmdW5jdGlvbi4gVGhlIGV2ZW50IGhhbmRsZXIgZ2V0cyBhXG5wYXJhbWV0ZXIgd2l0aCB0aGUgcmFuZ2VzIHNlbGVjdGVkIG9uIHRoZSBheGVzLCBsaWtlIHRoaXM6XG5cbiAgICBwbGFjZWhvbGRlci5iaW5kKCBcInBsb3RzZWxlY3RlZFwiLCBmdW5jdGlvbiggZXZlbnQsIHJhbmdlcyApIHtcbiAgICAgICAgYWxlcnQoXCJZb3Ugc2VsZWN0ZWQgXCIgKyByYW5nZXMueGF4aXMuZnJvbSArIFwiIHRvIFwiICsgcmFuZ2VzLnhheGlzLnRvKVxuICAgICAgICAvLyBzaW1pbGFyIGZvciB5YXhpcyAtIHdpdGggbXVsdGlwbGUgYXhlcywgdGhlIGV4dHJhIG9uZXMgYXJlIGluXG4gICAgICAgIC8vIHgyYXhpcywgeDNheGlzLCAuLi5cbiAgICB9KTtcblxuVGhlIFwicGxvdHNlbGVjdGVkXCIgZXZlbnQgaXMgb25seSBmaXJlZCB3aGVuIHRoZSB1c2VyIGhhcyBmaW5pc2hlZCBtYWtpbmcgdGhlXG5zZWxlY3Rpb24uIEEgXCJwbG90c2VsZWN0aW5nXCIgZXZlbnQgaXMgZmlyZWQgZHVyaW5nIHRoZSBwcm9jZXNzIHdpdGggdGhlIHNhbWVcbnBhcmFtZXRlcnMgYXMgdGhlIFwicGxvdHNlbGVjdGVkXCIgZXZlbnQsIGluIGNhc2UgeW91IHdhbnQgdG8ga25vdyB3aGF0J3NcbmhhcHBlbmluZyB3aGlsZSBpdCdzIGhhcHBlbmluZyxcblxuQSBcInBsb3R1bnNlbGVjdGVkXCIgZXZlbnQgd2l0aCBubyBhcmd1bWVudHMgaXMgZW1pdHRlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGVcbm1vdXNlIHRvIHJlbW92ZSB0aGUgc2VsZWN0aW9uLiBBcyBzdGF0ZWQgYWJvdmUsIHNldHRpbmcgXCJtaW5TaXplXCIgdG8gMCB3aWxsXG5kZXN0cm95IHRoaXMgYmVoYXZpb3IuXG5cblRoZSBwbHVnaW4gYWxsc28gYWRkcyB0aGUgZm9sbG93aW5nIG1ldGhvZHMgdG8gdGhlIHBsb3Qgb2JqZWN0OlxuXG4tIHNldFNlbGVjdGlvbiggcmFuZ2VzLCBwcmV2ZW50RXZlbnQgKVxuXG4gIFNldCB0aGUgc2VsZWN0aW9uIHJlY3RhbmdsZS4gVGhlIHBhc3NlZCBpbiByYW5nZXMgaXMgb24gdGhlIHNhbWUgZm9ybSBhc1xuICByZXR1cm5lZCBpbiB0aGUgXCJwbG90c2VsZWN0ZWRcIiBldmVudC4gSWYgdGhlIHNlbGVjdGlvbiBtb2RlIGlzIFwieFwiLCB5b3VcbiAgc2hvdWxkIHB1dCBpbiBlaXRoZXIgYW4geGF4aXMgcmFuZ2UsIGlmIHRoZSBtb2RlIGlzIFwieVwiIHlvdSBuZWVkIHRvIHB1dCBpblxuICBhbiB5YXhpcyByYW5nZSBhbmQgYm90aCB4YXhpcyBhbmQgeWF4aXMgaWYgdGhlIHNlbGVjdGlvbiBtb2RlIGlzIFwieHlcIiwgbGlrZVxuICB0aGlzOlxuXG4gICAgc2V0U2VsZWN0aW9uKHsgeGF4aXM6IHsgZnJvbTogMCwgdG86IDEwIH0sIHlheGlzOiB7IGZyb206IDQwLCB0bzogNjAgfSB9KTtcblxuICBzZXRTZWxlY3Rpb24gd2lsbCB0cmlnZ2VyIHRoZSBcInBsb3RzZWxlY3RlZFwiIGV2ZW50IHdoZW4gY2FsbGVkLiBJZiB5b3UgZG9uJ3RcbiAgd2FudCB0aGF0IHRvIGhhcHBlbiwgZS5nLiBpZiB5b3UncmUgaW5zaWRlIGEgXCJwbG90c2VsZWN0ZWRcIiBoYW5kbGVyLCBwYXNzXG4gIHRydWUgYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIuIElmIHlvdSBhcmUgdXNpbmcgbXVsdGlwbGUgYXhlcywgeW91IGNhblxuICBzcGVjaWZ5IHRoZSByYW5nZXMgb24gYW55IG9mIHRob3NlLCBlLmcuIGFzIHgyYXhpcy94M2F4aXMvLi4uIGluc3RlYWQgb2ZcbiAgeGF4aXMsIHRoZSBwbHVnaW4gcGlja3MgdGhlIGZpcnN0IG9uZSBpdCBzZWVzLlxuXG4tIGNsZWFyU2VsZWN0aW9uKCBwcmV2ZW50RXZlbnQgKVxuXG4gIENsZWFyIHRoZSBzZWxlY3Rpb24gcmVjdGFuZ2xlLiBQYXNzIGluIHRydWUgdG8gYXZvaWQgZ2V0dGluZyBhXG4gIFwicGxvdHVuc2VsZWN0ZWRcIiBldmVudC5cblxuLSBnZXRTZWxlY3Rpb24oKVxuXG4gIFJldHVybnMgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGluIHRoZSBzYW1lIGZvcm1hdCBhcyB0aGUgXCJwbG90c2VsZWN0ZWRcIlxuICBldmVudC4gSWYgdGhlcmUncyBjdXJyZW50bHkgbm8gc2VsZWN0aW9uLCB0aGUgZnVuY3Rpb24gcmV0dXJucyBudWxsLlxuXG4qL1xuXG4oZnVuY3Rpb24gKCQpIHtcbiAgICBmdW5jdGlvbiBpbml0KHBsb3QpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHtcbiAgICAgICAgICAgIGZpcnN0OiB7eDogLTEsIHk6IC0xfSxcbiAgICAgICAgICAgIHNlY29uZDoge3g6IC0xLCB5OiAtMX0sXG4gICAgICAgICAgICBzaG93OiBmYWxzZSxcbiAgICAgICAgICAgIGN1cnJlbnRNb2RlOiAneHknLFxuICAgICAgICAgICAgYWN0aXZlOiBmYWxzZVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBTTkFQUElOR19DT05TVEFOVCA9ICQucGxvdC51aUNvbnN0YW50cy5TTkFQUElOR19DT05TVEFOVDtcblxuICAgICAgICAvLyBGSVhNRTogVGhlIGRyYWcgaGFuZGxpbmcgaW1wbGVtZW50ZWQgaGVyZSBzaG91bGQgYmVcbiAgICAgICAgLy8gYWJzdHJhY3RlZCBvdXQsIHRoZXJlJ3Mgc29tZSBzaW1pbGFyIGNvZGUgZnJvbSBhIGxpYnJhcnkgaW5cbiAgICAgICAgLy8gdGhlIG5hdmlnYXRpb24gcGx1Z2luLCB0aGlzIHNob3VsZCBiZSBtYXNzYWdlZCBhIGJpdCB0byBmaXRcbiAgICAgICAgLy8gdGhlIEZsb3QgY2FzZXMgaGVyZSBiZXR0ZXIgYW5kIHJldXNlZC4gRG9pbmcgdGhpcyB3b3VsZFxuICAgICAgICAvLyBtYWtlIHRoaXMgcGx1Z2luIG11Y2ggc2xpbW1lci5cbiAgICAgICAgdmFyIHNhdmVkaGFuZGxlcnMgPSB7fTtcblxuICAgICAgICBmdW5jdGlvbiBvbkRyYWcoZSkge1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVTZWxlY3Rpb24oZSk7XG5cbiAgICAgICAgICAgICAgICBwbG90LmdldFBsYWNlaG9sZGVyKCkudHJpZ2dlcihcInBsb3RzZWxlY3RpbmdcIiwgWyBnZXRTZWxlY3Rpb24oKSBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG9uRHJhZ1N0YXJ0KGUpIHtcbiAgICAgICAgICAgIHZhciBvID0gcGxvdC5nZXRPcHRpb25zKCk7XG4gICAgICAgICAgICAvLyBvbmx5IGFjY2VwdCBsZWZ0LWNsaWNrXG4gICAgICAgICAgICBpZiAoZS53aGljaCAhPT0gMSB8fCBvLnNlbGVjdGlvbi5tb2RlID09PSBudWxsKSByZXR1cm47XG5cbiAgICAgICAgICAgIC8vIHJlaW5pdGlhbGl6ZSBjdXJyZW50TW9kZVxuICAgICAgICAgICAgc2VsZWN0aW9uLmN1cnJlbnRNb2RlID0gJ3h5JztcblxuICAgICAgICAgICAgLy8gY2FuY2VsIG91dCBhbnkgdGV4dCBzZWxlY3Rpb25zXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmZvY3VzKCk7XG5cbiAgICAgICAgICAgIC8vIHByZXZlbnQgdGV4dCBzZWxlY3Rpb24gYW5kIGRyYWcgaW4gb2xkLXNjaG9vbCBicm93c2Vyc1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50Lm9uc2VsZWN0c3RhcnQgIT09IHVuZGVmaW5lZCAmJiBzYXZlZGhhbmRsZXJzLm9uc2VsZWN0c3RhcnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHNhdmVkaGFuZGxlcnMub25zZWxlY3RzdGFydCA9IGRvY3VtZW50Lm9uc2VsZWN0c3RhcnQ7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQub25zZWxlY3RzdGFydCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRvY3VtZW50Lm9uZHJhZyAhPT0gdW5kZWZpbmVkICYmIHNhdmVkaGFuZGxlcnMub25kcmFnID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzYXZlZGhhbmRsZXJzLm9uZHJhZyA9IGRvY3VtZW50Lm9uZHJhZztcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5vbmRyYWcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2V0U2VsZWN0aW9uUG9zKHNlbGVjdGlvbi5maXJzdCwgZSk7XG5cbiAgICAgICAgICAgIHNlbGVjdGlvbi5hY3RpdmUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gb25EcmFnRW5kKGUpIHtcbiAgICAgICAgICAgIC8vIHJldmVydCBkcmFnIHN0dWZmIGZvciBvbGQtc2Nob29sIGJyb3dzZXJzXG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQub25zZWxlY3RzdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQub25zZWxlY3RzdGFydCA9IHNhdmVkaGFuZGxlcnMub25zZWxlY3RzdGFydDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRvY3VtZW50Lm9uZHJhZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQub25kcmFnID0gc2F2ZWRoYW5kbGVycy5vbmRyYWc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG5vIG1vcmUgZHJhZ2dpbmdcbiAgICAgICAgICAgIHNlbGVjdGlvbi5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHVwZGF0ZVNlbGVjdGlvbihlKTtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbklzU2FuZSgpKSB7XG4gICAgICAgICAgICAgICAgdHJpZ2dlclNlbGVjdGVkRXZlbnQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjb3VudHMgYXMgYSBjbGVhclxuICAgICAgICAgICAgICAgIHBsb3QuZ2V0UGxhY2Vob2xkZXIoKS50cmlnZ2VyKFwicGxvdHVuc2VsZWN0ZWRcIiwgWyBdKTtcbiAgICAgICAgICAgICAgICBwbG90LmdldFBsYWNlaG9sZGVyKCkudHJpZ2dlcihcInBsb3RzZWxlY3RpbmdcIiwgWyBudWxsIF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRTZWxlY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIXNlbGVjdGlvbklzU2FuZSgpKSByZXR1cm4gbnVsbDtcblxuICAgICAgICAgICAgaWYgKCFzZWxlY3Rpb24uc2hvdykgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICAgIHZhciByID0ge30sXG4gICAgICAgICAgICAgICAgYzEgPSB7eDogc2VsZWN0aW9uLmZpcnN0LngsIHk6IHNlbGVjdGlvbi5maXJzdC55fSxcbiAgICAgICAgICAgICAgICBjMiA9IHt4OiBzZWxlY3Rpb24uc2Vjb25kLngsIHk6IHNlbGVjdGlvbi5zZWNvbmQueX07XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb25EaXJlY3Rpb24ocGxvdCkgPT09ICd4Jykge1xuICAgICAgICAgICAgICAgIGMxLnkgPSAwO1xuICAgICAgICAgICAgICAgIGMyLnkgPSBwbG90LmhlaWdodCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uRGlyZWN0aW9uKHBsb3QpID09PSAneScpIHtcbiAgICAgICAgICAgICAgICBjMS54ID0gMDtcbiAgICAgICAgICAgICAgICBjMi54ID0gcGxvdC53aWR0aCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAkLmVhY2gocGxvdC5nZXRBeGVzKCksIGZ1bmN0aW9uIChuYW1lLCBheGlzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF4aXMudXNlZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcDEgPSBheGlzLmMycChjMVtheGlzLmRpcmVjdGlvbl0pLCBwMiA9IGF4aXMuYzJwKGMyW2F4aXMuZGlyZWN0aW9uXSk7XG4gICAgICAgICAgICAgICAgICAgIHJbbmFtZV0gPSB7IGZyb206IE1hdGgubWluKHAxLCBwMiksIHRvOiBNYXRoLm1heChwMSwgcDIpIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHRyaWdnZXJTZWxlY3RlZEV2ZW50KCkge1xuICAgICAgICAgICAgdmFyIHIgPSBnZXRTZWxlY3Rpb24oKTtcblxuICAgICAgICAgICAgcGxvdC5nZXRQbGFjZWhvbGRlcigpLnRyaWdnZXIoXCJwbG90c2VsZWN0ZWRcIiwgWyByIF0pO1xuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMtY29tcGF0IHN0dWZmLCB0byBiZSByZW1vdmVkIGluIGZ1dHVyZVxuICAgICAgICAgICAgaWYgKHIueGF4aXMgJiYgci55YXhpcykge1xuICAgICAgICAgICAgICAgIHBsb3QuZ2V0UGxhY2Vob2xkZXIoKS50cmlnZ2VyKFwic2VsZWN0ZWRcIiwgWyB7IHgxOiByLnhheGlzLmZyb20sIHkxOiByLnlheGlzLmZyb20sIHgyOiByLnhheGlzLnRvLCB5Mjogci55YXhpcy50byB9IF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY2xhbXAobWluLCB2YWx1ZSwgbWF4KSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPCBtaW4gPyBtaW4gOiAodmFsdWUgPiBtYXggPyBtYXggOiB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzZWxlY3Rpb25EaXJlY3Rpb24ocGxvdCkge1xuICAgICAgICAgICAgdmFyIG8gPSBwbG90LmdldE9wdGlvbnMoKTtcblxuICAgICAgICAgICAgaWYgKG8uc2VsZWN0aW9uLm1vZGUgPT09ICdzbWFydCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0aW9uLmN1cnJlbnRNb2RlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gby5zZWxlY3Rpb24ubW9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZU1vZGUocG9zKSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uLmZpcnN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlbHRhID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiBwb3MueCAtIHNlbGVjdGlvbi5maXJzdC54LFxuICAgICAgICAgICAgICAgICAgICB5OiBwb3MueSAtIHNlbGVjdGlvbi5maXJzdC55XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhkZWx0YS54KSA8IFNOQVBQSU5HX0NPTlNUQU5UKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5jdXJyZW50TW9kZSA9ICd5JztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGRlbHRhLnkpIDwgU05BUFBJTkdfQ09OU1RBTlQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uLmN1cnJlbnRNb2RlID0gJ3gnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5jdXJyZW50TW9kZSA9ICd4eSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc2V0U2VsZWN0aW9uUG9zKHBvcywgZSkge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHBsb3QuZ2V0UGxhY2Vob2xkZXIoKS5vZmZzZXQoKTtcbiAgICAgICAgICAgIHZhciBwbG90T2Zmc2V0ID0gcGxvdC5nZXRQbG90T2Zmc2V0KCk7XG4gICAgICAgICAgICBwb3MueCA9IGNsYW1wKDAsIGUucGFnZVggLSBvZmZzZXQubGVmdCAtIHBsb3RPZmZzZXQubGVmdCwgcGxvdC53aWR0aCgpKTtcbiAgICAgICAgICAgIHBvcy55ID0gY2xhbXAoMCwgZS5wYWdlWSAtIG9mZnNldC50b3AgLSBwbG90T2Zmc2V0LnRvcCwgcGxvdC5oZWlnaHQoKSk7XG5cbiAgICAgICAgICAgIGlmIChwb3MgIT09IHNlbGVjdGlvbi5maXJzdCkgdXBkYXRlTW9kZShwb3MpO1xuXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uRGlyZWN0aW9uKHBsb3QpID09PSBcInlcIikge1xuICAgICAgICAgICAgICAgIHBvcy54ID0gcG9zID09PSBzZWxlY3Rpb24uZmlyc3QgPyAwIDogcGxvdC53aWR0aCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uRGlyZWN0aW9uKHBsb3QpID09PSBcInhcIikge1xuICAgICAgICAgICAgICAgIHBvcy55ID0gcG9zID09PSBzZWxlY3Rpb24uZmlyc3QgPyAwIDogcGxvdC5oZWlnaHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVNlbGVjdGlvbihwb3MpIHtcbiAgICAgICAgICAgIGlmIChwb3MucGFnZVggPT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgICAgICAgICBzZXRTZWxlY3Rpb25Qb3Moc2VsZWN0aW9uLnNlY29uZCwgcG9zKTtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb25Jc1NhbmUoKSkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5zaG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwbG90LnRyaWdnZXJSZWRyYXdPdmVybGF5KCk7XG4gICAgICAgICAgICB9IGVsc2UgY2xlYXJTZWxlY3Rpb24odHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjbGVhclNlbGVjdGlvbihwcmV2ZW50RXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24uc2hvdykge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5zaG93ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLmN1cnJlbnRNb2RlID0gJyc7XG4gICAgICAgICAgICAgICAgcGxvdC50cmlnZ2VyUmVkcmF3T3ZlcmxheSgpO1xuICAgICAgICAgICAgICAgIGlmICghcHJldmVudEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHBsb3QuZ2V0UGxhY2Vob2xkZXIoKS50cmlnZ2VyKFwicGxvdHVuc2VsZWN0ZWRcIiwgWyBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmdW5jdGlvbiB0YWtlbiBmcm9tIG1hcmtpbmdzIHN1cHBvcnQgaW4gRmxvdFxuICAgICAgICBmdW5jdGlvbiBleHRyYWN0UmFuZ2UocmFuZ2VzLCBjb29yZCkge1xuICAgICAgICAgICAgdmFyIGF4aXMsIGZyb20sIHRvLCBrZXksIGF4ZXMgPSBwbG90LmdldEF4ZXMoKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBheGVzKSB7XG4gICAgICAgICAgICAgICAgYXhpcyA9IGF4ZXNba107XG4gICAgICAgICAgICAgICAgaWYgKGF4aXMuZGlyZWN0aW9uID09PSBjb29yZCkge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBjb29yZCArIGF4aXMubiArIFwiYXhpc1wiO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJhbmdlc1trZXldICYmIGF4aXMubiA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3VwcG9ydCB4MWF4aXMgYXMgeGF4aXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IGNvb3JkICsgXCJheGlzXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2VzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gPSByYW5nZXNba2V5XS5mcm9tO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG8gPSByYW5nZXNba2V5XS50bztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMtY29tcGF0IHN0dWZmIC0gdG8gYmUgcmVtb3ZlZCBpbiBmdXR1cmVcbiAgICAgICAgICAgIGlmICghcmFuZ2VzW2tleV0pIHtcbiAgICAgICAgICAgICAgICBheGlzID0gY29vcmQgPT09IFwieFwiID8gcGxvdC5nZXRYQXhlcygpWzBdIDogcGxvdC5nZXRZQXhlcygpWzBdO1xuICAgICAgICAgICAgICAgIGZyb20gPSByYW5nZXNbY29vcmQgKyBcIjFcIl07XG4gICAgICAgICAgICAgICAgdG8gPSByYW5nZXNbY29vcmQgKyBcIjJcIl07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGF1dG8tcmV2ZXJzZSBhcyBhbiBhZGRlZCBib251c1xuICAgICAgICAgICAgaWYgKGZyb20gIT0gbnVsbCAmJiB0byAhPSBudWxsICYmIGZyb20gPiB0bykge1xuICAgICAgICAgICAgICAgIHZhciB0bXAgPSBmcm9tO1xuICAgICAgICAgICAgICAgIGZyb20gPSB0bztcbiAgICAgICAgICAgICAgICB0byA9IHRtcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogZnJvbSwgdG86IHRvLCBheGlzOiBheGlzIH07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzZXRTZWxlY3Rpb24ocmFuZ2VzLCBwcmV2ZW50RXZlbnQpIHtcbiAgICAgICAgICAgIHZhciByYW5nZTtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbkRpcmVjdGlvbihwbG90KSA9PT0gXCJ5XCIpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24uZmlyc3QueCA9IDA7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLnNlY29uZC54ID0gcGxvdC53aWR0aCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByYW5nZSA9IGV4dHJhY3RSYW5nZShyYW5nZXMsIFwieFwiKTtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24uZmlyc3QueCA9IHJhbmdlLmF4aXMucDJjKHJhbmdlLmZyb20pO1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5zZWNvbmQueCA9IHJhbmdlLmF4aXMucDJjKHJhbmdlLnRvKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbkRpcmVjdGlvbihwbG90KSA9PT0gXCJ4XCIpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24uZmlyc3QueSA9IDA7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLnNlY29uZC55ID0gcGxvdC5oZWlnaHQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBleHRyYWN0UmFuZ2UocmFuZ2VzLCBcInlcIik7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLmZpcnN0LnkgPSByYW5nZS5heGlzLnAyYyhyYW5nZS5mcm9tKTtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24uc2Vjb25kLnkgPSByYW5nZS5heGlzLnAyYyhyYW5nZS50byk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGVjdGlvbi5zaG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIHBsb3QudHJpZ2dlclJlZHJhd092ZXJsYXkoKTtcbiAgICAgICAgICAgIGlmICghcHJldmVudEV2ZW50ICYmIHNlbGVjdGlvbklzU2FuZSgpKSB7XG4gICAgICAgICAgICAgICAgdHJpZ2dlclNlbGVjdGVkRXZlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNlbGVjdGlvbklzU2FuZSgpIHtcbiAgICAgICAgICAgIHZhciBtaW5TaXplID0gcGxvdC5nZXRPcHRpb25zKCkuc2VsZWN0aW9uLm1pblNpemU7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMoc2VsZWN0aW9uLnNlY29uZC54IC0gc2VsZWN0aW9uLmZpcnN0LngpID49IG1pblNpemUgJiZcbiAgICAgICAgICAgICAgICBNYXRoLmFicyhzZWxlY3Rpb24uc2Vjb25kLnkgLSBzZWxlY3Rpb24uZmlyc3QueSkgPj0gbWluU2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBsb3QuY2xlYXJTZWxlY3Rpb24gPSBjbGVhclNlbGVjdGlvbjtcbiAgICAgICAgcGxvdC5zZXRTZWxlY3Rpb24gPSBzZXRTZWxlY3Rpb247XG4gICAgICAgIHBsb3QuZ2V0U2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uO1xuXG4gICAgICAgIHBsb3QuaG9va3MuYmluZEV2ZW50cy5wdXNoKGZ1bmN0aW9uKHBsb3QsIGV2ZW50SG9sZGVyKSB7XG4gICAgICAgICAgICB2YXIgbyA9IHBsb3QuZ2V0T3B0aW9ucygpO1xuICAgICAgICAgICAgaWYgKG8uc2VsZWN0aW9uLm1vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBsb3QuYWRkRXZlbnRIYW5kbGVyKFwiZHJhZ3N0YXJ0XCIsIG9uRHJhZ1N0YXJ0LCBldmVudEhvbGRlciwgMCk7XG4gICAgICAgICAgICAgICAgcGxvdC5hZGRFdmVudEhhbmRsZXIoXCJkcmFnXCIsIG9uRHJhZywgZXZlbnRIb2xkZXIsIDApO1xuICAgICAgICAgICAgICAgIHBsb3QuYWRkRXZlbnRIYW5kbGVyKFwiZHJhZ2VuZFwiLCBvbkRyYWdFbmQsIGV2ZW50SG9sZGVyLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZnVuY3Rpb24gZHJhd1NlbGVjdGlvbkRlY29yYXRpb25zKGN0eCwgeCwgeSwgdywgaCwgb1gsIG9ZLCBtb2RlKSB7XG4gICAgICAgICAgICB2YXIgc3BhY2luZyA9IDM7XG4gICAgICAgICAgICB2YXIgZnVsbEVhcldpZHRoID0gMTU7XG4gICAgICAgICAgICB2YXIgZWFyV2lkdGggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihmdWxsRWFyV2lkdGgsIHcgLyAyIC0gMiwgaCAvIDIgLSAyKSk7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJyNmZmZmZmYnO1xuXG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gJ3h5Jykge1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHgsIHkgKyBlYXJXaWR0aCk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4IC0gMywgeSArIGVhcldpZHRoKTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHggLSAzLCB5IC0gMyk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgZWFyV2lkdGgsIHkgLSAzKTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHggKyBlYXJXaWR0aCwgeSk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG5cbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHgsIHkgKyBoIC0gZWFyV2lkdGgpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeCAtIDMsIHkgKyBoIC0gZWFyV2lkdGgpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeCAtIDMsIHkgKyBoICsgMyk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgZWFyV2lkdGgsIHkgKyBoICsgMyk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgZWFyV2lkdGgsIHkgKyBoKTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHgsIHkgKyBoKTtcbiAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG5cbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHggKyB3LCB5ICsgZWFyV2lkdGgpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIHcgKyAzLCB5ICsgZWFyV2lkdGgpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIHcgKyAzLCB5IC0gMyk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgdyAtIGVhcldpZHRoLCB5IC0gMyk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgdyAtIGVhcldpZHRoLCB5KTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHggKyB3LCB5KTtcbiAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG5cbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHggKyB3LCB5ICsgaCAtIGVhcldpZHRoKTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHggKyB3ICsgMywgeSArIGggLSBlYXJXaWR0aCk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgdyArIDMsIHkgKyBoICsgMyk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgdyAtIGVhcldpZHRoLCB5ICsgaCArIDMpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIHcgLSBlYXJXaWR0aCwgeSArIGgpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIHcsIHkgKyBoKTtcbiAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG5cbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgeCA9IG9YO1xuICAgICAgICAgICAgeSA9IG9ZO1xuXG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gJ3gnKSB7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSArIGZ1bGxFYXJXaWR0aCk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5IC0gZnVsbEVhcldpZHRoKTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHggLSBzcGFjaW5nLCB5IC0gZnVsbEVhcldpZHRoKTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHggLSBzcGFjaW5nLCB5ICsgZnVsbEVhcldpZHRoKTtcbiAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG5cbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHggKyB3LCB5ICsgZnVsbEVhcldpZHRoKTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHggKyB3LCB5IC0gZnVsbEVhcldpZHRoKTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHggKyB3ICsgc3BhY2luZywgeSAtIGZ1bGxFYXJXaWR0aCk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgdyArIHNwYWNpbmcsIHkgKyBmdWxsRWFyV2lkdGgpO1xuICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1vZGUgPT09ICd5Jykge1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCAtIGZ1bGxFYXJXaWR0aCwgeSk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgZnVsbEVhcldpZHRoLCB5KTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHggKyBmdWxsRWFyV2lkdGgsIHkgLSBzcGFjaW5nKTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHggLSBmdWxsRWFyV2lkdGgsIHkgLSBzcGFjaW5nKTtcbiAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG5cbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHggLSBmdWxsRWFyV2lkdGgsIHkgKyBoKTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHggKyBmdWxsRWFyV2lkdGgsIHkgKyBoKTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHggKyBmdWxsRWFyV2lkdGgsIHkgKyBoICsgc3BhY2luZyk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4IC0gZnVsbEVhcldpZHRoLCB5ICsgaCArIHNwYWNpbmcpO1xuICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHBsb3QuaG9va3MuZHJhd092ZXJsYXkucHVzaChmdW5jdGlvbiAocGxvdCwgY3R4KSB7XG4gICAgICAgICAgICAvLyBkcmF3IHNlbGVjdGlvblxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi5zaG93ICYmIHNlbGVjdGlvbklzU2FuZSgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBsb3RPZmZzZXQgPSBwbG90LmdldFBsb3RPZmZzZXQoKTtcbiAgICAgICAgICAgICAgICB2YXIgbyA9IHBsb3QuZ2V0T3B0aW9ucygpO1xuXG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKHBsb3RPZmZzZXQubGVmdCwgcGxvdE9mZnNldC50b3ApO1xuXG4gICAgICAgICAgICAgICAgdmFyIGMgPSAkLmNvbG9yLnBhcnNlKG8uc2VsZWN0aW9uLmNvbG9yKTtcbiAgICAgICAgICAgICAgICB2YXIgdmlzdWFsaXphdGlvbiA9IG8uc2VsZWN0aW9uLnZpc3VhbGl6YXRpb247XG4gICAgICAgICAgICAgICAgdmFyIGRpc3BsYXlTZWxlY3Rpb25EZWNvcmF0aW9ucyA9IG8uc2VsZWN0aW9uLmRpc3BsYXlTZWxlY3Rpb25EZWNvcmF0aW9ucztcblxuICAgICAgICAgICAgICAgIHZhciBzY2FsaW5nRmFjdG9yID0gMTtcblxuICAgICAgICAgICAgICAgIC8vIHVzZSBhIGRpbW1lciBzY2FsaW5nIGZhY3RvciBpZiB2aXN1YWxpemF0aW9uIGlzIFwiZmlsbFwiXG4gICAgICAgICAgICAgICAgaWYgKHZpc3VhbGl6YXRpb24gPT09IFwiZmlsbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjYWxpbmdGYWN0b3IgPSAwLjg7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gYy5zY2FsZSgnYScsIHNjYWxpbmdGYWN0b3IpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVKb2luID0gby5zZWxlY3Rpb24uc2hhcGU7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGMuc2NhbGUoJ2EnLCAwLjQpLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgeCA9IE1hdGgubWluKHNlbGVjdGlvbi5maXJzdC54LCBzZWxlY3Rpb24uc2Vjb25kLngpICsgMC41LFxuICAgICAgICAgICAgICAgICAgICBvWCA9IHgsXG4gICAgICAgICAgICAgICAgICAgIHkgPSBNYXRoLm1pbihzZWxlY3Rpb24uZmlyc3QueSwgc2VsZWN0aW9uLnNlY29uZC55KSArIDAuNSxcbiAgICAgICAgICAgICAgICAgICAgb1kgPSB5LFxuICAgICAgICAgICAgICAgICAgICB3ID0gTWF0aC5hYnMoc2VsZWN0aW9uLnNlY29uZC54IC0gc2VsZWN0aW9uLmZpcnN0LngpIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgaCA9IE1hdGguYWJzKHNlbGVjdGlvbi5zZWNvbmQueSAtIHNlbGVjdGlvbi5maXJzdC55KSAtIDE7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uRGlyZWN0aW9uKHBsb3QpID09PSAneCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaCArPSB5O1xuICAgICAgICAgICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uRGlyZWN0aW9uKHBsb3QpID09PSAneScpIHtcbiAgICAgICAgICAgICAgICAgICAgdyArPSB4O1xuICAgICAgICAgICAgICAgICAgICB4ID0gMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodmlzdWFsaXphdGlvbiA9PT0gXCJmaWxsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlUmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgcGxvdC53aWR0aCgpLCBwbG90LmhlaWdodCgpKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmNsZWFyUmVjdCh4LCB5LCB3LCBoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzcGxheVNlbGVjdGlvbkRlY29yYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3U2VsZWN0aW9uRGVjb3JhdGlvbnMoY3R4LCB4LCB5LCB3LCBoLCBvWCwgb1ksIHNlbGVjdGlvbkRpcmVjdGlvbihwbG90KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBwbG90Lmhvb2tzLnNodXRkb3duLnB1c2goZnVuY3Rpb24gKHBsb3QsIGV2ZW50SG9sZGVyKSB7XG4gICAgICAgICAgICBldmVudEhvbGRlci51bmJpbmQoXCJkcmFnc3RhcnRcIiwgb25EcmFnU3RhcnQpO1xuICAgICAgICAgICAgZXZlbnRIb2xkZXIudW5iaW5kKFwiZHJhZ1wiLCBvbkRyYWcpO1xuICAgICAgICAgICAgZXZlbnRIb2xkZXIudW5iaW5kKFwiZHJhZ2VuZFwiLCBvbkRyYWdFbmQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAkLnBsb3QucGx1Z2lucy5wdXNoKHtcbiAgICAgICAgaW5pdDogaW5pdCxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgc2VsZWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgbW9kZTogbnVsbCwgLy8gb25lIG9mIG51bGwsIFwieFwiLCBcInlcIiBvciBcInh5XCJcbiAgICAgICAgICAgICAgICB2aXN1YWxpemF0aW9uOiBcImZvY3VzXCIsIC8vIFwiZm9jdXNcIiBvciBcImZpbGxcIlxuICAgICAgICAgICAgICAgIGRpc3BsYXlTZWxlY3Rpb25EZWNvcmF0aW9uczogdHJ1ZSwgLy8gdHJ1ZSBvciBmYWxzZSAoY3VycmVudGx5IG9ubHkgcmVsZXZhbnQgZm9yIHRoZSBmb2N1cyB2aXN1YWxpemF0aW9uKVxuICAgICAgICAgICAgICAgIGNvbG9yOiBcIiM4ODg4ODhcIixcbiAgICAgICAgICAgICAgICBzaGFwZTogXCJyb3VuZFwiLCAvLyBvbmUgb2YgXCJyb3VuZFwiLCBcIm1pdGVyXCIsIG9yIFwiYmV2ZWxcIlxuICAgICAgICAgICAgICAgIG1pblNpemU6IDUgLy8gbWluaW11bSBudW1iZXIgb2YgcGl4ZWxzXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG5hbWU6ICdzZWxlY3Rpb24nLFxuICAgICAgICB2ZXJzaW9uOiAnMS4xJ1xuICAgIH0pO1xufSkoalF1ZXJ5KTtcbiIsIi8qIEZsb3QgcGx1Z2luIGZvciBzdGFja2luZyBkYXRhIHNldHMgcmF0aGVyIHRoYW4gb3ZlcmxheWluZyB0aGVtLlxuXG5Db3B5cmlnaHQgKGMpIDIwMDctMjAxNCBJT0xBIGFuZCBPbGUgTGF1cnNlbi5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuVGhlIHBsdWdpbiBhc3N1bWVzIHRoZSBkYXRhIGlzIHNvcnRlZCBvbiB4IChvciB5IGlmIHN0YWNraW5nIGhvcml6b250YWxseSkuXG5Gb3IgbGluZSBjaGFydHMsIGl0IGlzIGFzc3VtZWQgdGhhdCBpZiBhIGxpbmUgaGFzIGFuIHVuZGVmaW5lZCBnYXAgKGZyb20gYVxubnVsbCBwb2ludCksIHRoZW4gdGhlIGxpbmUgYWJvdmUgaXQgc2hvdWxkIGhhdmUgdGhlIHNhbWUgZ2FwIC0gaW5zZXJ0IHplcm9zXG5pbnN0ZWFkIG9mIFwibnVsbFwiIGlmIHlvdSB3YW50IGFub3RoZXIgYmVoYXZpb3VyLiBUaGlzIGFsc28gaG9sZHMgZm9yIHRoZSBzdGFydFxuYW5kIGVuZCBvZiB0aGUgY2hhcnQuIE5vdGUgdGhhdCBzdGFja2luZyBhIG1peCBvZiBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgdmFsdWVzXG5pbiBtb3N0IGluc3RhbmNlcyBkb2Vzbid0IG1ha2Ugc2Vuc2UgKHNvIGl0IGxvb2tzIHdlaXJkKS5cblxuVHdvIG9yIG1vcmUgc2VyaWVzIGFyZSBzdGFja2VkIHdoZW4gdGhlaXIgXCJzdGFja1wiIGF0dHJpYnV0ZSBpcyBzZXQgdG8gdGhlIHNhbWVcbmtleSAod2hpY2ggY2FuIGJlIGFueSBudW1iZXIgb3Igc3RyaW5nIG9yIGp1c3QgXCJ0cnVlXCIpLiBUbyBzcGVjaWZ5IHRoZSBkZWZhdWx0XG5zdGFjaywgeW91IGNhbiBzZXQgdGhlIHN0YWNrIG9wdGlvbiBsaWtlIHRoaXM6XG5cbiAgICBzZXJpZXM6IHtcbiAgICAgICAgc3RhY2s6IG51bGwvZmFsc2UsIHRydWUsIG9yIGEga2V5IChudW1iZXIvc3RyaW5nKVxuICAgIH1cblxuWW91IGNhbiBhbHNvIHNwZWNpZnkgaXQgZm9yIGEgc2luZ2xlIHNlcmllcywgbGlrZSB0aGlzOlxuXG4gICAgJC5wbG90KCAkKFwiI3BsYWNlaG9sZGVyXCIpLCBbe1xuICAgICAgICBkYXRhOiBbIC4uLiBdLFxuICAgICAgICBzdGFjazogdHJ1ZVxuICAgIH1dKVxuXG5UaGUgc3RhY2tpbmcgb3JkZXIgaXMgZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgb2YgdGhlIGRhdGEgc2VyaWVzIGluIHRoZSBhcnJheVxuKGxhdGVyIHNlcmllcyBlbmQgdXAgb24gdG9wIG9mIHRoZSBwcmV2aW91cykuXG5cbkludGVybmFsbHksIHRoZSBwbHVnaW4gbW9kaWZpZXMgdGhlIGRhdGFwb2ludHMgaW4gZWFjaCBzZXJpZXMsIGFkZGluZyBhblxub2Zmc2V0IHRvIHRoZSB5IHZhbHVlLiBGb3IgbGluZSBzZXJpZXMsIGV4dHJhIGRhdGEgcG9pbnRzIGFyZSBpbnNlcnRlZCB0aHJvdWdoXG5pbnRlcnBvbGF0aW9uLiBJZiB0aGVyZSdzIGEgc2Vjb25kIHkgdmFsdWUsIGl0J3MgYWxzbyBhZGp1c3RlZCAoZS5nIGZvciBiYXJcbmNoYXJ0cyBvciBmaWxsZWQgYXJlYXMpLlxuXG4qL1xuXG4oZnVuY3Rpb24gKCQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgc2VyaWVzOiB7IHN0YWNrOiBudWxsIH0gLy8gb3IgbnVtYmVyL3N0cmluZ1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpbml0KHBsb3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZmluZE1hdGNoaW5nU2VyaWVzKHMsIGFsbHNlcmllcykge1xuICAgICAgICAgICAgdmFyIHJlcyA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbHNlcmllcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChzID09PSBhbGxzZXJpZXNbaV0pIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFsbHNlcmllc1tpXS5zdGFjayA9PT0gcy5zdGFjaykge1xuICAgICAgICAgICAgICAgICAgICByZXMgPSBhbGxzZXJpZXNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYWRkQm90dG9tUG9pbnRzIChzLCBkYXRhcG9pbnRzKSB7XG4gICAgICAgICAgICB2YXIgZm9ybWF0dGVkUG9pbnRzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFwb2ludHMucG9pbnRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkUG9pbnRzLnB1c2goZGF0YXBvaW50cy5wb2ludHNbaV0pO1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlZFBvaW50cy5wdXNoKGRhdGFwb2ludHMucG9pbnRzW2kgKyAxXSk7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkUG9pbnRzLnB1c2goMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGFwb2ludHMuZm9ybWF0LnB1c2goe1xuICAgICAgICAgICAgICAgIHg6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHk6IHRydWUsXG4gICAgICAgICAgICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb21wdXRlUmFuZ2U6IHMueWF4aXMub3B0aW9ucy5hdXRvU2NhbGUgIT09ICdub25lJyxcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6IDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGF0YXBvaW50cy5wb2ludHMgPSBmb3JtYXR0ZWRQb2ludHM7XG4gICAgICAgICAgICBkYXRhcG9pbnRzLnBvaW50c2l6ZSA9IDM7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzdGFja0RhdGEocGxvdCwgcywgZGF0YXBvaW50cykge1xuICAgICAgICAgICAgaWYgKHMuc3RhY2sgPT0gbnVsbCB8fCBzLnN0YWNrID09PSBmYWxzZSkgcmV0dXJuO1xuXG4gICAgICAgICAgICB2YXIgbmVlZHNCb3R0b20gPSBzLmJhcnMuc2hvdyB8fCAocy5saW5lcy5zaG93ICYmIHMubGluZXMuZmlsbCk7XG4gICAgICAgICAgICB2YXIgaGFzQm90dG9tID0gZGF0YXBvaW50cy5wb2ludHNpemUgPiAyICYmIChzLmJhcnMuaG9yaXpvbnRhbCA/IGRhdGFwb2ludHMuZm9ybWF0WzJdLnggOiBkYXRhcG9pbnRzLmZvcm1hdFsyXS55KTtcbiAgICAgICAgICAgIC8vIFNlcmllcyBkYXRhIGlzIG1pc3NpbmcgYm90dG9tIHBvaW50cyAtIG5lZWQgdG8gZm9ybWF0XG4gICAgICAgICAgICBpZiAobmVlZHNCb3R0b20gJiYgIWhhc0JvdHRvbSkge1xuICAgICAgICAgICAgICAgIGFkZEJvdHRvbVBvaW50cyhzLCBkYXRhcG9pbnRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG90aGVyID0gZmluZE1hdGNoaW5nU2VyaWVzKHMsIHBsb3QuZ2V0RGF0YSgpKTtcbiAgICAgICAgICAgIGlmICghb3RoZXIpIHJldHVybjtcblxuICAgICAgICAgICAgdmFyIHBzID0gZGF0YXBvaW50cy5wb2ludHNpemUsXG4gICAgICAgICAgICAgICAgcG9pbnRzID0gZGF0YXBvaW50cy5wb2ludHMsXG4gICAgICAgICAgICAgICAgb3RoZXJwcyA9IG90aGVyLmRhdGFwb2ludHMucG9pbnRzaXplLFxuICAgICAgICAgICAgICAgIG90aGVycG9pbnRzID0gb3RoZXIuZGF0YXBvaW50cy5wb2ludHMsXG4gICAgICAgICAgICAgICAgbmV3cG9pbnRzID0gW10sXG4gICAgICAgICAgICAgICAgcHgsIHB5LCBpbnRlcnksIHF4LCBxeSwgYm90dG9tLFxuICAgICAgICAgICAgICAgIHdpdGhsaW5lcyA9IHMubGluZXMuc2hvdyxcbiAgICAgICAgICAgICAgICBob3Jpem9udGFsID0gcy5iYXJzLmhvcml6b250YWwsXG4gICAgICAgICAgICAgICAgd2l0aHN0ZXBzID0gd2l0aGxpbmVzICYmIHMubGluZXMuc3RlcHMsXG4gICAgICAgICAgICAgICAgZnJvbWdhcCA9IHRydWUsXG4gICAgICAgICAgICAgICAga2V5T2Zmc2V0ID0gaG9yaXpvbnRhbCA/IDEgOiAwLFxuICAgICAgICAgICAgICAgIGFjY3VtdWxhdGVPZmZzZXQgPSBob3Jpem9udGFsID8gMCA6IDEsXG4gICAgICAgICAgICAgICAgaSA9IDAsIGogPSAwLCBsLCBtO1xuXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChpID49IHBvaW50cy5sZW5ndGgpIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgbCA9IG5ld3BvaW50cy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBpZiAocG9pbnRzW2ldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29weSBnYXBzXG4gICAgICAgICAgICAgICAgICAgIGZvciAobSA9IDA7IG0gPCBwczsgKyttKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdwb2ludHMucHVzaChwb2ludHNbaSArIG1dKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGkgKz0gcHM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChqID49IG90aGVycG9pbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgbGluZXMsIHdlIGNhbid0IHVzZSB0aGUgcmVzdCBvZiB0aGUgcG9pbnRzXG4gICAgICAgICAgICAgICAgICAgIGlmICghd2l0aGxpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKG0gPSAwOyBtIDwgcHM7ICsrbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld3BvaW50cy5wdXNoKHBvaW50c1tpICsgbV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaSArPSBwcztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG90aGVycG9pbnRzW2pdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb29wcywgZ290IGEgZ2FwXG4gICAgICAgICAgICAgICAgICAgIGZvciAobSA9IDA7IG0gPCBwczsgKyttKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdwb2ludHMucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZyb21nYXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBqICs9IG90aGVycHM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FzZXMgd2hlcmUgd2UgYWN0dWFsbHkgZ290IHR3byBwb2ludHNcbiAgICAgICAgICAgICAgICAgICAgcHggPSBwb2ludHNbaSArIGtleU9mZnNldF07XG4gICAgICAgICAgICAgICAgICAgIHB5ID0gcG9pbnRzW2kgKyBhY2N1bXVsYXRlT2Zmc2V0XTtcbiAgICAgICAgICAgICAgICAgICAgcXggPSBvdGhlcnBvaW50c1tqICsga2V5T2Zmc2V0XTtcbiAgICAgICAgICAgICAgICAgICAgcXkgPSBvdGhlcnBvaW50c1tqICsgYWNjdW11bGF0ZU9mZnNldF07XG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbSA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHB4ID09PSBxeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChtID0gMDsgbSA8IHBzOyArK20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdwb2ludHMucHVzaChwb2ludHNbaSArIG1dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3cG9pbnRzW2wgKyBhY2N1bXVsYXRlT2Zmc2V0XSArPSBxeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbSA9IHF5O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IHBzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaiArPSBvdGhlcnBzO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHB4ID4gcXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGdvdCBwYXN0IHBvaW50IGJlbG93LCBtaWdodCBuZWVkIHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnNlcnQgaW50ZXJwb2xhdGVkIGV4dHJhIHBvaW50XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod2l0aGxpbmVzICYmIGkgPiAwICYmIHBvaW50c1tpIC0gcHNdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnkgPSBweSArIChwb2ludHNbaSAtIHBzICsgYWNjdW11bGF0ZU9mZnNldF0gLSBweSkgKiAocXggLSBweCkgLyAocG9pbnRzW2kgLSBwcyArIGtleU9mZnNldF0gLSBweCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3cG9pbnRzLnB1c2gocXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld3BvaW50cy5wdXNoKGludGVyeSArIHF5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKG0gPSAyOyBtIDwgcHM7ICsrbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdwb2ludHMucHVzaChwb2ludHNbaSArIG1dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3R0b20gPSBxeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaiArPSBvdGhlcnBzO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBweCA8IHF4XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbWdhcCAmJiB3aXRobGluZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBjb21lIGZyb20gYSBnYXAsIHdlIGp1c3Qgc2tpcCB0aGlzIHBvaW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSArPSBwcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChtID0gMDsgbSA8IHBzOyArK20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdwb2ludHMucHVzaChwb2ludHNbaSArIG1dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgbWlnaHQgYmUgYWJsZSB0byBpbnRlcnBvbGF0ZSBhIHBvaW50IGJlbG93LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBjYW4gZ2l2ZSB1cyBhIGJldHRlciB5XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod2l0aGxpbmVzICYmIGogPiAwICYmIG90aGVycG9pbnRzW2ogLSBvdGhlcnBzXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tID0gcXkgKyAob3RoZXJwb2ludHNbaiAtIG90aGVycHMgKyBhY2N1bXVsYXRlT2Zmc2V0XSAtIHF5KSAqIChweCAtIHF4KSAvIChvdGhlcnBvaW50c1tqIC0gb3RoZXJwcyArIGtleU9mZnNldF0gLSBxeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld3BvaW50c1tsICsgYWNjdW11bGF0ZU9mZnNldF0gKz0gYm90dG9tO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IHBzO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZnJvbWdhcCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChsICE9PSBuZXdwb2ludHMubGVuZ3RoICYmIG5lZWRzQm90dG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdwb2ludHNbbCArIDJdICs9IGJvdHRvbTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG1haW50YWluIHRoZSBsaW5lIHN0ZXBzIGludmFyaWFudFxuICAgICAgICAgICAgICAgIGlmICh3aXRoc3RlcHMgJiYgbCAhPT0gbmV3cG9pbnRzLmxlbmd0aCAmJiBsID4gMCAmJlxuICAgICAgICAgICAgICAgICAgICBuZXdwb2ludHNbbF0gIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgbmV3cG9pbnRzW2xdICE9PSBuZXdwb2ludHNbbCAtIHBzXSAmJlxuICAgICAgICAgICAgICAgICAgICBuZXdwb2ludHNbbCArIDFdICE9PSBuZXdwb2ludHNbbCAtIHBzICsgMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChtID0gMDsgbSA8IHBzOyArK20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld3BvaW50c1tsICsgcHMgKyBtXSA9IG5ld3BvaW50c1tsICsgbV07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBuZXdwb2ludHNbbCArIDFdID0gbmV3cG9pbnRzW2wgLSBwcyArIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGF0YXBvaW50cy5wb2ludHMgPSBuZXdwb2ludHM7XG4gICAgICAgIH1cblxuICAgICAgICBwbG90Lmhvb2tzLnByb2Nlc3NEYXRhcG9pbnRzLnB1c2goc3RhY2tEYXRhKTtcbiAgICB9XG5cbiAgICAkLnBsb3QucGx1Z2lucy5wdXNoKHtcbiAgICAgICAgaW5pdDogaW5pdCxcbiAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgbmFtZTogJ3N0YWNrJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMidcbiAgICB9KTtcbn0pKGpRdWVyeSk7XG4iLCIvKiBGbG90IHBsdWdpbiB0aGF0IGFkZHMgc29tZSBleHRyYSBzeW1ib2xzIGZvciBwbG90dGluZyBwb2ludHMuXG5cbkNvcHlyaWdodCAoYykgMjAwNy0yMDE0IElPTEEgYW5kIE9sZSBMYXVyc2VuLlxuTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXG5UaGUgc3ltYm9scyBhcmUgYWNjZXNzZWQgYXMgc3RyaW5ncyB0aHJvdWdoIHRoZSBzdGFuZGFyZCBzeW1ib2wgb3B0aW9uczpcblxuICAgIHNlcmllczoge1xuICAgICAgICBwb2ludHM6IHtcbiAgICAgICAgICAgIHN5bWJvbDogXCJzcXVhcmVcIiAvLyBvciBcImRpYW1vbmRcIiwgXCJ0cmlhbmdsZVwiLCBcImNyb3NzXCIsIFwicGx1c1wiLCBcImVsbGlwc2VcIiwgXCJyZWN0YW5nbGVcIlxuICAgICAgICB9XG4gICAgfVxuXG4qL1xuXG4oZnVuY3Rpb24gKCQpIHtcbiAgICAvLyB3ZSBub3JtYWxpemUgdGhlIGFyZWEgb2YgZWFjaCBzeW1ib2wgc28gaXQgaXMgYXBwcm94aW1hdGVseSB0aGVcbiAgICAvLyBzYW1lIGFzIGEgY2lyY2xlIG9mIHRoZSBnaXZlbiByYWRpdXNcblxuICAgIHZhciBzcXVhcmUgPSBmdW5jdGlvbiAoY3R4LCB4LCB5LCByYWRpdXMsIHNoYWRvdykge1xuICAgICAgICAgICAgLy8gcGkgKiByXjIgPSAoMnMpXjIgID0+ICBzID0gciAqIHNxcnQocGkpLzJcbiAgICAgICAgICAgIHZhciBzaXplID0gcmFkaXVzICogTWF0aC5zcXJ0KE1hdGguUEkpIC8gMjtcbiAgICAgICAgICAgIGN0eC5yZWN0KHggLSBzaXplLCB5IC0gc2l6ZSwgc2l6ZSArIHNpemUsIHNpemUgKyBzaXplKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVjdGFuZ2xlID0gZnVuY3Rpb24gKGN0eCwgeCwgeSwgcmFkaXVzLCBzaGFkb3cpIHtcbiAgICAgICAgICAgIC8vIHBpICogcl4yID0gKDJzKV4yICA9PiAgcyA9IHIgKiBzcXJ0KHBpKS8yXG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHJhZGl1cyAqIE1hdGguc3FydChNYXRoLlBJKSAvIDI7XG4gICAgICAgICAgICBjdHgucmVjdCh4IC0gc2l6ZSwgeSAtIHNpemUsIHNpemUgKyBzaXplLCBzaXplICsgc2l6ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRpYW1vbmQgPSBmdW5jdGlvbiAoY3R4LCB4LCB5LCByYWRpdXMsIHNoYWRvdykge1xuICAgICAgICAgICAgLy8gcGkgKiByXjIgPSAyc14yICA9PiAgcyA9IHIgKiBzcXJ0KHBpLzIpXG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHJhZGl1cyAqIE1hdGguc3FydChNYXRoLlBJIC8gMik7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHggLSBzaXplLCB5KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSAtIHNpemUpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgc2l6ZSwgeSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHgsIHkgKyBzaXplKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCAtIHNpemUsIHkpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5IC0gc2l6ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRyaWFuZ2xlID0gZnVuY3Rpb24gKGN0eCwgeCwgeSwgcmFkaXVzLCBzaGFkb3cpIHtcbiAgICAgICAgICAgIC8vIHBpICogcl4yID0gMS8yICogc14yICogc2luIChwaSAvIDMpICA9PiAgcyA9IHIgKiBzcXJ0KDIgKiBwaSAvIHNpbihwaSAvIDMpKVxuICAgICAgICAgICAgdmFyIHNpemUgPSByYWRpdXMgKiBNYXRoLnNxcnQoMiAqIE1hdGguUEkgLyBNYXRoLnNpbihNYXRoLlBJIC8gMykpO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHNpemUgKiBNYXRoLnNpbihNYXRoLlBJIC8gMyk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHggLSBzaXplIC8gMiwgeSArIGhlaWdodCAvIDIpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgc2l6ZSAvIDIsIHkgKyBoZWlnaHQgLyAyKTtcbiAgICAgICAgICAgIGlmICghc2hhZG93KSB7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5IC0gaGVpZ2h0IC8gMik7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4IC0gc2l6ZSAvIDIsIHkgKyBoZWlnaHQgLyAyKTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHggKyBzaXplIC8gMiwgeSArIGhlaWdodCAvIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjcm9zcyA9IGZ1bmN0aW9uIChjdHgsIHgsIHksIHJhZGl1cywgc2hhZG93KSB7XG4gICAgICAgICAgICAvLyBwaSAqIHJeMiA9ICgycyleMiAgPT4gIHMgPSByICogc3FydChwaSkvMlxuICAgICAgICAgICAgdmFyIHNpemUgPSByYWRpdXMgKiBNYXRoLnNxcnQoTWF0aC5QSSkgLyAyO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4IC0gc2l6ZSwgeSAtIHNpemUpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgc2l6ZSwgeSArIHNpemUpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4IC0gc2l6ZSwgeSArIHNpemUpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgc2l6ZSwgeSAtIHNpemUpO1xuICAgICAgICB9LFxuICAgICAgICBlbGxpcHNlID0gZnVuY3Rpb24oY3R4LCB4LCB5LCByYWRpdXMsIHNoYWRvdywgZmlsbCkge1xuICAgICAgICAgICAgaWYgKCFzaGFkb3cpIHtcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHggKyByYWRpdXMsIHkpO1xuICAgICAgICAgICAgICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwbHVzID0gZnVuY3Rpb24gKGN0eCwgeCwgeSwgcmFkaXVzLCBzaGFkb3cpIHtcbiAgICAgICAgICAgIHZhciBzaXplID0gcmFkaXVzICogTWF0aC5zcXJ0KE1hdGguUEkgLyAyKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCAtIHNpemUsIHkpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgc2l6ZSwgeSk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHgsIHkgKyBzaXplKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSAtIHNpemUpO1xuICAgICAgICB9LFxuICAgICAgICBoYW5kbGVycyA9IHtcbiAgICAgICAgICAgIHNxdWFyZTogc3F1YXJlLFxuICAgICAgICAgICAgcmVjdGFuZ2xlOiByZWN0YW5nbGUsXG4gICAgICAgICAgICBkaWFtb25kOiBkaWFtb25kLFxuICAgICAgICAgICAgdHJpYW5nbGU6IHRyaWFuZ2xlLFxuICAgICAgICAgICAgY3Jvc3M6IGNyb3NzLFxuICAgICAgICAgICAgZWxsaXBzZTogZWxsaXBzZSxcbiAgICAgICAgICAgIHBsdXM6IHBsdXNcbiAgICAgICAgfTtcblxuICAgIHNxdWFyZS5maWxsID0gdHJ1ZTtcbiAgICByZWN0YW5nbGUuZmlsbCA9IHRydWU7XG4gICAgZGlhbW9uZC5maWxsID0gdHJ1ZTtcbiAgICB0cmlhbmdsZS5maWxsID0gdHJ1ZTtcbiAgICBlbGxpcHNlLmZpbGwgPSB0cnVlO1xuXG4gICAgZnVuY3Rpb24gaW5pdChwbG90KSB7XG4gICAgICAgIHBsb3QuZHJhd1N5bWJvbCA9IGhhbmRsZXJzO1xuICAgIH1cblxuICAgICQucGxvdC5wbHVnaW5zLnB1c2goe1xuICAgICAgICBpbml0OiBpbml0LFxuICAgICAgICBuYW1lOiAnc3ltYm9scycsXG4gICAgICAgIHZlcnNpb246ICcxLjAnXG4gICAgfSk7XG59KShqUXVlcnkpO1xuIiwiLyogRmxvdCBwbHVnaW4gZm9yIHRocmVzaG9sZGluZyBkYXRhLlxuXG5Db3B5cmlnaHQgKGMpIDIwMDctMjAxNCBJT0xBIGFuZCBPbGUgTGF1cnNlbi5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuVGhlIHBsdWdpbiBzdXBwb3J0cyB0aGVzZSBvcHRpb25zOlxuXG4gICAgc2VyaWVzOiB7XG4gICAgICAgIHRocmVzaG9sZDoge1xuICAgICAgICAgICAgYmVsb3c6IG51bWJlclxuICAgICAgICAgICAgY29sb3I6IGNvbG9yc3BlY1xuICAgICAgICB9XG4gICAgfVxuXG5JdCBjYW4gYWxzbyBiZSBhcHBsaWVkIHRvIGEgc2luZ2xlIHNlcmllcywgbGlrZSB0aGlzOlxuXG4gICAgJC5wbG90KCAkKFwiI3BsYWNlaG9sZGVyXCIpLCBbe1xuICAgICAgICBkYXRhOiBbIC4uLiBdLFxuICAgICAgICB0aHJlc2hvbGQ6IHsgLi4uIH1cbiAgICB9XSlcblxuQW4gYXJyYXkgY2FuIGJlIHBhc3NlZCBmb3IgbXVsdGlwbGUgdGhyZXNob2xkaW5nLCBsaWtlIHRoaXM6XG5cbiAgICB0aHJlc2hvbGQ6IFt7XG4gICAgICAgIGJlbG93OiBudW1iZXIxXG4gICAgICAgIGNvbG9yOiBjb2xvcjFcbiAgICB9LHtcbiAgICAgICAgYmVsb3c6IG51bWJlcjJcbiAgICAgICAgY29sb3I6IGNvbG9yMlxuICAgIH1dXG5cblRoZXNlIG11bHRpcGxlIHRocmVzaG9sZCBvYmplY3RzIGNhbiBiZSBwYXNzZWQgaW4gYW55IG9yZGVyIHNpbmNlIHRoZXkgYXJlXG5zb3J0ZWQgYnkgdGhlIHByb2Nlc3NpbmcgZnVuY3Rpb24uXG5cblRoZSBkYXRhIHBvaW50cyBiZWxvdyBcImJlbG93XCIgYXJlIGRyYXduIHdpdGggdGhlIHNwZWNpZmllZCBjb2xvci4gVGhpcyBtYWtlc1xuaXQgZWFzeSB0byBtYXJrIHBvaW50cyBiZWxvdyAwLCBlLmcuIGZvciBidWRnZXQgZGF0YS5cblxuSW50ZXJuYWxseSwgdGhlIHBsdWdpbiB3b3JrcyBieSBzcGxpdHRpbmcgdGhlIGRhdGEgaW50byB0d28gc2VyaWVzLCBhYm92ZSBhbmRcbmJlbG93IHRoZSB0aHJlc2hvbGQuIFRoZSBleHRyYSBzZXJpZXMgYmVsb3cgdGhlIHRocmVzaG9sZCB3aWxsIGhhdmUgaXRzIGxhYmVsXG5jbGVhcmVkIGFuZCB0aGUgc3BlY2lhbCBcIm9yaWdpblNlcmllc1wiIGF0dHJpYnV0ZSBzZXQgdG8gdGhlIG9yaWdpbmFsIHNlcmllcy5cbllvdSBtYXkgbmVlZCB0byBjaGVjayBmb3IgdGhpcyBpbiBob3ZlciBldmVudHMuXG5cbiovXG5cbihmdW5jdGlvbiAoJCkge1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBzZXJpZXM6IHsgdGhyZXNob2xkOiBudWxsIH0gLy8gb3IgeyBiZWxvdzogbnVtYmVyLCBjb2xvcjogY29sb3Igc3BlY31cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaW5pdChwbG90KSB7XG4gICAgICAgIGZ1bmN0aW9uIHRocmVzaG9sZERhdGEocGxvdCwgcywgZGF0YXBvaW50cywgYmVsb3csIGNvbG9yKSB7XG4gICAgICAgICAgICB2YXIgcHMgPSBkYXRhcG9pbnRzLnBvaW50c2l6ZSwgaSwgeCwgeSwgcCwgcHJldnAsXG4gICAgICAgICAgICAgICAgdGhyZXNob2xkZWQgPSAkLmV4dGVuZCh7fSwgcyk7IC8vIG5vdGU6IHNoYWxsb3cgY29weVxuXG4gICAgICAgICAgICB0aHJlc2hvbGRlZC5kYXRhcG9pbnRzID0geyBwb2ludHM6IFtdLCBwb2ludHNpemU6IHBzLCBmb3JtYXQ6IGRhdGFwb2ludHMuZm9ybWF0IH07XG4gICAgICAgICAgICB0aHJlc2hvbGRlZC5sYWJlbCA9IG51bGw7XG4gICAgICAgICAgICB0aHJlc2hvbGRlZC5jb2xvciA9IGNvbG9yO1xuICAgICAgICAgICAgdGhyZXNob2xkZWQudGhyZXNob2xkID0gbnVsbDtcbiAgICAgICAgICAgIHRocmVzaG9sZGVkLm9yaWdpblNlcmllcyA9IHM7XG4gICAgICAgICAgICB0aHJlc2hvbGRlZC5kYXRhID0gW107XG5cbiAgICAgICAgICAgIHZhciBvcmlncG9pbnRzID0gZGF0YXBvaW50cy5wb2ludHMsXG4gICAgICAgICAgICAgICAgYWRkQ3Jvc3NpbmdQb2ludHMgPSBzLmxpbmVzLnNob3c7XG5cbiAgICAgICAgICAgIHZhciB0aHJlc3BvaW50cyA9IFtdO1xuICAgICAgICAgICAgdmFyIG5ld3BvaW50cyA9IFtdO1xuICAgICAgICAgICAgdmFyIG07XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBvcmlncG9pbnRzLmxlbmd0aDsgaSArPSBwcykge1xuICAgICAgICAgICAgICAgIHggPSBvcmlncG9pbnRzW2ldO1xuICAgICAgICAgICAgICAgIHkgPSBvcmlncG9pbnRzW2kgKyAxXTtcblxuICAgICAgICAgICAgICAgIHByZXZwID0gcDtcbiAgICAgICAgICAgICAgICBpZiAoeSA8IGJlbG93KSBwID0gdGhyZXNwb2ludHM7XG4gICAgICAgICAgICAgICAgZWxzZSBwID0gbmV3cG9pbnRzO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFkZENyb3NzaW5nUG9pbnRzICYmIHByZXZwICE9PSBwICYmXG4gICAgICAgICAgICAgICAgICAgIHggIT09IG51bGwgJiYgaSA+IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgb3JpZ3BvaW50c1tpIC0gcHNdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGludGVyeCA9IHggKyAoYmVsb3cgLSB5KSAqICh4IC0gb3JpZ3BvaW50c1tpIC0gcHNdKSAvICh5IC0gb3JpZ3BvaW50c1tpIC0gcHMgKyAxXSk7XG4gICAgICAgICAgICAgICAgICAgIHByZXZwLnB1c2goaW50ZXJ4KTtcbiAgICAgICAgICAgICAgICAgICAgcHJldnAucHVzaChiZWxvdyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobSA9IDI7IG0gPCBwczsgKyttKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2cC5wdXNoKG9yaWdwb2ludHNbaSArIG1dKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHAucHVzaChudWxsKTsgLy8gc3RhcnQgbmV3IHNlZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgcC5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKG0gPSAyOyBtIDwgcHM7ICsrbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5wdXNoKG9yaWdwb2ludHNbaSArIG1dKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHAucHVzaChpbnRlcngpO1xuICAgICAgICAgICAgICAgICAgICBwLnB1c2goYmVsb3cpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKG0gPSAyOyBtIDwgcHM7ICsrbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5wdXNoKG9yaWdwb2ludHNbaSArIG1dKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHAucHVzaCh4KTtcbiAgICAgICAgICAgICAgICBwLnB1c2goeSk7XG4gICAgICAgICAgICAgICAgZm9yIChtID0gMjsgbSA8IHBzOyArK20pIHtcbiAgICAgICAgICAgICAgICAgICAgcC5wdXNoKG9yaWdwb2ludHNbaSArIG1dKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGFwb2ludHMucG9pbnRzID0gbmV3cG9pbnRzO1xuICAgICAgICAgICAgdGhyZXNob2xkZWQuZGF0YXBvaW50cy5wb2ludHMgPSB0aHJlc3BvaW50cztcblxuICAgICAgICAgICAgaWYgKHRocmVzaG9sZGVkLmRhdGFwb2ludHMucG9pbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ0luZGV4ID0gJC5pbkFycmF5KHMsIHBsb3QuZ2V0RGF0YSgpKTtcbiAgICAgICAgICAgICAgICAvLyBJbnNlcnQgbmV3bHktZ2VuZXJhdGVkIHNlcmllcyByaWdodCBhZnRlciBvcmlnaW5hbCBvbmUgKHRvIHByZXZlbnQgaXQgZnJvbSBiZWNvbWluZyB0b3AtbW9zdClcbiAgICAgICAgICAgICAgICBwbG90LmdldERhdGEoKS5zcGxpY2Uob3JpZ0luZGV4ICsgMSwgMCwgdGhyZXNob2xkZWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGSVhNRTogdGhlcmUgYXJlIHByb2JhYmx5IHNvbWUgZWRnZSBjYXNlcyBsZWZ0IGluIGJhcnNcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHByb2Nlc3NUaHJlc2hvbGRzKHBsb3QsIHMsIGRhdGFwb2ludHMpIHtcbiAgICAgICAgICAgIGlmICghcy50aHJlc2hvbGQpIHJldHVybjtcbiAgICAgICAgICAgIGlmIChzLnRocmVzaG9sZCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgcy50aHJlc2hvbGQuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhLmJlbG93IC0gYi5iZWxvdztcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICQocy50aHJlc2hvbGQpLmVhY2goZnVuY3Rpb24oaSwgdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyZXNob2xkRGF0YShwbG90LCBzLCBkYXRhcG9pbnRzLCB0aC5iZWxvdywgdGguY29sb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJlc2hvbGREYXRhKHBsb3QsIHMsIGRhdGFwb2ludHMsIHMudGhyZXNob2xkLmJlbG93LCBzLnRocmVzaG9sZC5jb2xvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwbG90Lmhvb2tzLnByb2Nlc3NEYXRhcG9pbnRzLnB1c2gocHJvY2Vzc1RocmVzaG9sZHMpO1xuICAgIH1cblxuICAgICQucGxvdC5wbHVnaW5zLnB1c2goe1xuICAgICAgICBpbml0OiBpbml0LFxuICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICBuYW1lOiAndGhyZXNob2xkJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMidcbiAgICB9KTtcbn0pKGpRdWVyeSk7XG4iLCIvKiBQcmV0dHkgaGFuZGxpbmcgb2YgdGltZSBheGVzLlxuXG5Db3B5cmlnaHQgKGMpIDIwMDctMjAxNCBJT0xBIGFuZCBPbGUgTGF1cnNlbi5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuU2V0IGF4aXMubW9kZSB0byBcInRpbWVcIiB0byBlbmFibGUuIFNlZSB0aGUgc2VjdGlvbiBcIlRpbWUgc2VyaWVzIGRhdGFcIiBpblxuQVBJLnR4dCBmb3IgZGV0YWlscy5cbiovXG5cbihmdW5jdGlvbigkKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIHhheGlzOiB7XG4gICAgICAgICAgICB0aW1lem9uZTogbnVsbCwgLy8gXCJicm93c2VyXCIgZm9yIGxvY2FsIHRvIHRoZSBjbGllbnQgb3IgdGltZXpvbmUgZm9yIHRpbWV6b25lLWpzXG4gICAgICAgICAgICB0aW1lZm9ybWF0OiBudWxsLCAvLyBmb3JtYXQgc3RyaW5nIHRvIHVzZVxuICAgICAgICAgICAgdHdlbHZlSG91ckNsb2NrOiBmYWxzZSwgLy8gMTIgb3IgMjQgdGltZSBpbiB0aW1lIG1vZGVcbiAgICAgICAgICAgIG1vbnRoTmFtZXM6IG51bGwsIC8vIGxpc3Qgb2YgbmFtZXMgb2YgbW9udGhzXG4gICAgICAgICAgICB0aW1lQmFzZTogJ3NlY29uZHMnIC8vIGFyZSB0aGUgdmFsdWVzIGluIGdpdmVuIGluIG1pcmNvc2Vjb25kcywgbWlsbGlzZWNvbmRzIG9yIHNlY29uZHNcbiAgICAgICAgfSxcbiAgICAgICAgeWF4aXM6IHtcbiAgICAgICAgICAgIHRpbWVCYXNlOiAnc2Vjb25kcydcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZmxvb3JJbkJhc2UgPSAkLnBsb3Quc2F0dXJhdGVkLmZsb29ySW5CYXNlO1xuXG4gICAgLy8gTWV0aG9kIHRvIHByb3ZpZGUgbWljcm9zZWNvbmQgc3VwcG9ydCB0byBEYXRlIGxpa2UgY2xhc3Nlcy5cbiAgICB2YXIgQ3JlYXRlTWljcm9TZWNvbmREYXRlID0gZnVuY3Rpb24oRGF0ZVR5cGUsIG1pY3JvRXBvY2gpIHtcbiAgICAgICAgdmFyIG5ld0RhdGUgPSBuZXcgRGF0ZVR5cGUobWljcm9FcG9jaCk7XG5cbiAgICAgICAgdmFyIG9sZFNldFRpbWUgPSBuZXdEYXRlLnNldFRpbWUuYmluZChuZXdEYXRlKTtcbiAgICAgICAgbmV3RGF0ZS51cGRhdGUgPSBmdW5jdGlvbihtaWNyb0Vwb2NoKSB7XG4gICAgICAgICAgICBvbGRTZXRUaW1lKG1pY3JvRXBvY2gpO1xuXG4gICAgICAgICAgICAvLyBSb3VuZCBlcG9jaCB0byAzIGRlY2ltYWwgYWNjdXJhY3lcbiAgICAgICAgICAgIG1pY3JvRXBvY2ggPSBNYXRoLnJvdW5kKG1pY3JvRXBvY2ggKiAxMDAwKSAvIDEwMDA7XG5cbiAgICAgICAgICAgIC8vIE1pY3Jvc2Vjb25kcyBhcmUgc3RvcmVkIGFzIGludGVnZXJzXG4gICAgICAgICAgICB0aGlzLm1pY3Jvc2Vjb25kcyA9IDEwMDAgKiAobWljcm9FcG9jaCAtIE1hdGguZmxvb3IobWljcm9FcG9jaCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBvbGRHZXRUaW1lID0gbmV3RGF0ZS5nZXRUaW1lLmJpbmQobmV3RGF0ZSk7XG4gICAgICAgIG5ld0RhdGUuZ2V0VGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtaWNyb0Vwb2NoID0gb2xkR2V0VGltZSgpICsgdGhpcy5taWNyb3NlY29uZHMgLyAxMDAwO1xuICAgICAgICAgICAgcmV0dXJuIG1pY3JvRXBvY2g7XG4gICAgICAgIH07XG5cbiAgICAgICAgbmV3RGF0ZS5zZXRUaW1lID0gZnVuY3Rpb24gKG1pY3JvRXBvY2gpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKG1pY3JvRXBvY2gpO1xuICAgICAgICB9O1xuXG4gICAgICAgIG5ld0RhdGUuZ2V0TWljcm9zZWNvbmRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5taWNyb3NlY29uZHM7XG4gICAgICAgIH07XG5cbiAgICAgICAgbmV3RGF0ZS5zZXRNaWNyb3NlY29uZHMgPSBmdW5jdGlvbihtaWNyb3NlY29uZHMpIHtcbiAgICAgICAgICAgIHZhciBlcG9jaFdpdGhvdXRNaWNyb3NlY29uZHMgPSBvbGRHZXRUaW1lKCk7XG4gICAgICAgICAgICB2YXIgbmV3RXBvY2ggPSBlcG9jaFdpdGhvdXRNaWNyb3NlY29uZHMgKyBtaWNyb3NlY29uZHMgLyAxMDAwO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUobmV3RXBvY2gpO1xuICAgICAgICB9O1xuXG4gICAgICAgIG5ld0RhdGUuc2V0VVRDTWljcm9zZWNvbmRzID0gZnVuY3Rpb24obWljcm9zZWNvbmRzKSB7IHRoaXMuc2V0TWljcm9zZWNvbmRzKG1pY3Jvc2Vjb25kcyk7IH1cblxuICAgICAgICBuZXdEYXRlLmdldFVUQ01pY3Jvc2Vjb25kcyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5nZXRNaWNyb3NlY29uZHMoKTsgfVxuXG4gICAgICAgIG5ld0RhdGUubWljcm9zZWNvbmRzID0gbnVsbDtcbiAgICAgICAgbmV3RGF0ZS5taWNyb0Vwb2NoID0gbnVsbDtcbiAgICAgICAgbmV3RGF0ZS51cGRhdGUobWljcm9FcG9jaCk7XG4gICAgICAgIHJldHVybiBuZXdEYXRlO1xuICAgIH1cblxuICAgIC8vIFJldHVybnMgYSBzdHJpbmcgd2l0aCB0aGUgZGF0ZSBkIGZvcm1hdHRlZCBhY2NvcmRpbmcgdG8gZm10LlxuICAgIC8vIEEgc3Vic2V0IG9mIHRoZSBPcGVuIEdyb3VwJ3Mgc3RyZnRpbWUgZm9ybWF0IGlzIHN1cHBvcnRlZC5cblxuICAgIGZ1bmN0aW9uIGZvcm1hdERhdGUoZCwgZm10LCBtb250aE5hbWVzLCBkYXlOYW1lcykge1xuICAgICAgICBpZiAodHlwZW9mIGQuc3RyZnRpbWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIGQuc3RyZnRpbWUoZm10KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZWZ0UGFkID0gZnVuY3Rpb24obiwgcGFkKSB7XG4gICAgICAgICAgICBuID0gXCJcIiArIG47XG4gICAgICAgICAgICBwYWQgPSBcIlwiICsgKHBhZCA9PSBudWxsID8gXCIwXCIgOiBwYWQpO1xuICAgICAgICAgICAgcmV0dXJuIG4ubGVuZ3RoID09PSAxID8gcGFkICsgbiA6IG47XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGZvcm1hdFN1YlNlY29uZHMgPSBmdW5jdGlvbihtaWxsaXNlY29uZHMsIG1pY3Jvc2Vjb25kcywgbnVtYmVyRGVjaW1hbFBsYWNlcykge1xuICAgICAgICAgICAgdmFyIHRvdGFsTWljcm9zZWNvbmRzID0gbWlsbGlzZWNvbmRzICogMTAwMCArIG1pY3Jvc2Vjb25kcztcbiAgICAgICAgICAgIHZhciBmb3JtYXR0ZWRTdHJpbmc7XG4gICAgICAgICAgICBpZiAobnVtYmVyRGVjaW1hbFBsYWNlcyA8IDYgJiYgbnVtYmVyRGVjaW1hbFBsYWNlcyA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFnbml0dWRlID0gcGFyc2VGbG9hdCgnMWUnICsgKG51bWJlckRlY2ltYWxQbGFjZXMgLSA2KSk7XG4gICAgICAgICAgICAgICAgdG90YWxNaWNyb3NlY29uZHMgPSBNYXRoLnJvdW5kKE1hdGgucm91bmQodG90YWxNaWNyb3NlY29uZHMgKiBtYWduaXR1ZGUpIC8gbWFnbml0dWRlKTtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRTdHJpbmcgPSAoJzAwMDAwJyArIHRvdGFsTWljcm9zZWNvbmRzKS5zbGljZSgtNiwgLSg2IC0gbnVtYmVyRGVjaW1hbFBsYWNlcykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b3RhbE1pY3Jvc2Vjb25kcyA9IE1hdGgucm91bmQodG90YWxNaWNyb3NlY29uZHMpXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkU3RyaW5nID0gKCcwMDAwMCcgKyB0b3RhbE1pY3Jvc2Vjb25kcykuc2xpY2UoLTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHRlZFN0cmluZztcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgciA9IFtdO1xuICAgICAgICB2YXIgZXNjYXBlID0gZmFsc2U7XG4gICAgICAgIHZhciBob3VycyA9IGQuZ2V0SG91cnMoKTtcbiAgICAgICAgdmFyIGlzQU0gPSBob3VycyA8IDEyO1xuXG4gICAgICAgIGlmICghbW9udGhOYW1lcykge1xuICAgICAgICAgICAgbW9udGhOYW1lcyA9IFtcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGF5TmFtZXMpIHtcbiAgICAgICAgICAgIGRheU5hbWVzID0gW1wiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCJdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhvdXJzMTI7XG4gICAgICAgIGlmIChob3VycyA+IDEyKSB7XG4gICAgICAgICAgICBob3VyczEyID0gaG91cnMgLSAxMjtcbiAgICAgICAgfSBlbHNlIGlmIChob3VycyA9PT0gMCkge1xuICAgICAgICAgICAgaG91cnMxMiA9IDEyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaG91cnMxMiA9IGhvdXJzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlY2ltYWxzID0gLTE7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm10Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgYyA9IGZtdC5jaGFyQXQoaSk7XG5cbiAgICAgICAgICAgIGlmICghaXNOYU4oTnVtYmVyKGMpKSAmJiBOdW1iZXIoYykgPiAwKSB7XG4gICAgICAgICAgICAgICAgZGVjaW1hbHMgPSBOdW1iZXIoYyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVzY2FwZSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdhJzogYyA9IFwiXCIgKyBkYXlOYW1lc1tkLmdldERheSgpXTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2InOiBjID0gXCJcIiArIG1vbnRoTmFtZXNbZC5nZXRNb250aCgpXTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2QnOiBjID0gbGVmdFBhZChkLmdldERhdGUoKSk7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdlJzogYyA9IGxlZnRQYWQoZC5nZXREYXRlKCksIFwiIFwiKTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2gnOiAvLyBGb3IgYmFjay1jb21wYXQgd2l0aCAwLjc7IHJlbW92ZSBpbiAxLjBcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnSCc6IGMgPSBsZWZ0UGFkKGhvdXJzKTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0knOiBjID0gbGVmdFBhZChob3VyczEyKTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2wnOiBjID0gbGVmdFBhZChob3VyczEyLCBcIiBcIik7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdtJzogYyA9IGxlZnRQYWQoZC5nZXRNb250aCgpICsgMSk7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdNJzogYyA9IGxlZnRQYWQoZC5nZXRNaW51dGVzKCkpOyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgLy8gcXVhcnRlcnMgbm90IGluIE9wZW4gR3JvdXAncyBzdHJmdGltZSBzcGVjaWZpY2F0aW9uXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IFwiXCIgKyAoTWF0aC5mbG9vcihkLmdldE1vbnRoKCkgLyAzKSArIDEpOyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnUyc6IGMgPSBsZWZ0UGFkKGQuZ2V0U2Vjb25kcygpKTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3MnOiBjID0gXCJcIiArIGZvcm1hdFN1YlNlY29uZHMoZC5nZXRNaWxsaXNlY29uZHMoKSwgZC5nZXRNaWNyb3NlY29uZHMoKSwgZGVjaW1hbHMpOyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAneSc6IGMgPSBsZWZ0UGFkKGQuZ2V0RnVsbFllYXIoKSAlIDEwMCk7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdZJzogYyA9IFwiXCIgKyBkLmdldEZ1bGxZZWFyKCk7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdwJzogYyA9IChpc0FNKSA/IChcIlwiICsgXCJhbVwiKSA6IChcIlwiICsgXCJwbVwiKTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1AnOiBjID0gKGlzQU0pID8gKFwiXCIgKyBcIkFNXCIpIDogKFwiXCIgKyBcIlBNXCIpOyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndyc6IGMgPSBcIlwiICsgZC5nZXREYXkoKTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHIucHVzaChjKTtcbiAgICAgICAgICAgICAgICBlc2NhcGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGMgPT09IFwiJVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGVzY2FwZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgci5wdXNoKGMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByLmpvaW4oXCJcIik7XG4gICAgfVxuXG4gICAgLy8gVG8gaGF2ZSBhIGNvbnNpc3RlbnQgdmlldyBvZiB0aW1lLWJhc2VkIGRhdGEgaW5kZXBlbmRlbnQgb2Ygd2hpY2ggdGltZVxuICAgIC8vIHpvbmUgdGhlIGNsaWVudCBoYXBwZW5zIHRvIGJlIGluIHdlIG5lZWQgYSBkYXRlLWxpa2Ugb2JqZWN0IGluZGVwZW5kZW50XG4gICAgLy8gb2YgdGltZSB6b25lcy4gIFRoaXMgaXMgZG9uZSB0aHJvdWdoIGEgd3JhcHBlciB0aGF0IG9ubHkgY2FsbHMgdGhlIFVUQ1xuICAgIC8vIHZlcnNpb25zIG9mIHRoZSBhY2Nlc3NvciBtZXRob2RzLlxuXG4gICAgZnVuY3Rpb24gbWFrZVV0Y1dyYXBwZXIoZCkge1xuICAgICAgICBmdW5jdGlvbiBhZGRQcm94eU1ldGhvZChzb3VyY2VPYmosIHNvdXJjZU1ldGhvZCwgdGFyZ2V0T2JqLCB0YXJnZXRNZXRob2QpIHtcbiAgICAgICAgICAgIHNvdXJjZU9ialtzb3VyY2VNZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldE9ialt0YXJnZXRNZXRob2RdLmFwcGx5KHRhcmdldE9iaiwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdXRjID0ge1xuICAgICAgICAgICAgZGF0ZTogZFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHN1cHBvcnQgc3RyZnRpbWUsIGlmIGZvdW5kXG4gICAgICAgIGlmIChkLnN0cmZ0aW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFkZFByb3h5TWV0aG9kKHV0YywgXCJzdHJmdGltZVwiLCBkLCBcInN0cmZ0aW1lXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYWRkUHJveHlNZXRob2QodXRjLCBcImdldFRpbWVcIiwgZCwgXCJnZXRUaW1lXCIpO1xuICAgICAgICBhZGRQcm94eU1ldGhvZCh1dGMsIFwic2V0VGltZVwiLCBkLCBcInNldFRpbWVcIik7XG5cbiAgICAgICAgdmFyIHByb3BzID0gW1wiRGF0ZVwiLCBcIkRheVwiLCBcIkZ1bGxZZWFyXCIsIFwiSG91cnNcIiwgXCJNaW51dGVzXCIsIFwiTW9udGhcIiwgXCJTZWNvbmRzXCIsIFwiTWlsbGlzZWNvbmRzXCIsIFwiTWljcm9zZWNvbmRzXCJdO1xuXG4gICAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgcHJvcHMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIGFkZFByb3h5TWV0aG9kKHV0YywgXCJnZXRcIiArIHByb3BzW3BdLCBkLCBcImdldFVUQ1wiICsgcHJvcHNbcF0pO1xuICAgICAgICAgICAgYWRkUHJveHlNZXRob2QodXRjLCBcInNldFwiICsgcHJvcHNbcF0sIGQsIFwic2V0VVRDXCIgKyBwcm9wc1twXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdXRjO1xuICAgIH1cblxuICAgIC8vIHNlbGVjdCB0aW1lIHpvbmUgc3RyYXRlZ3kuICBUaGlzIHJldHVybnMgYSBkYXRlLWxpa2Ugb2JqZWN0IHRpZWQgdG8gdGhlXG4gICAgLy8gZGVzaXJlZCB0aW1lem9uZVxuICAgIGZ1bmN0aW9uIGRhdGVHZW5lcmF0b3IodHMsIG9wdHMpIHtcbiAgICAgICAgdmFyIG1heERhdGVWYWx1ZSA9IDg2NDAwMDAwMDAwMDAwMDA7XG5cbiAgICAgICAgaWYgKG9wdHMgJiYgb3B0cy50aW1lQmFzZSA9PT0gJ3NlY29uZHMnKSB7XG4gICAgICAgICAgICB0cyAqPSAxMDAwO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdHMudGltZUJhc2UgPT09ICdtaWNyb3NlY29uZHMnKSB7XG4gICAgICAgICAgICB0cyAvPSAxMDAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRzID4gbWF4RGF0ZVZhbHVlKSB7XG4gICAgICAgICAgICB0cyA9IG1heERhdGVWYWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0cyA8IC1tYXhEYXRlVmFsdWUpIHtcbiAgICAgICAgICAgIHRzID0gLW1heERhdGVWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRzLnRpbWV6b25lID09PSBcImJyb3dzZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuIENyZWF0ZU1pY3JvU2Vjb25kRGF0ZShEYXRlLCB0cyk7XG4gICAgICAgIH0gZWxzZSBpZiAoIW9wdHMudGltZXpvbmUgfHwgb3B0cy50aW1lem9uZSA9PT0gXCJ1dGNcIikge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2VVdGNXcmFwcGVyKENyZWF0ZU1pY3JvU2Vjb25kRGF0ZShEYXRlLCB0cykpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aW1lem9uZUpTICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB0aW1lem9uZUpTLkRhdGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHZhciBkID0gQ3JlYXRlTWljcm9TZWNvbmREYXRlKHRpbWV6b25lSlMuRGF0ZSwgdHMpO1xuICAgICAgICAgICAgLy8gdGltZXpvbmUtanMgaXMgZmlja2xlLCBzbyBiZSBzdXJlIHRvIHNldCB0aGUgdGltZSB6b25lIGJlZm9yZVxuICAgICAgICAgICAgLy8gc2V0dGluZyB0aGUgdGltZS5cbiAgICAgICAgICAgIGQuc2V0VGltZXpvbmUob3B0cy50aW1lem9uZSk7XG4gICAgICAgICAgICBkLnNldFRpbWUodHMpO1xuICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZVV0Y1dyYXBwZXIoQ3JlYXRlTWljcm9TZWNvbmREYXRlKERhdGUsIHRzKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBtYXAgb2YgYXBwLiBzaXplIG9mIHRpbWUgdW5pdHMgaW4gc2Vjb25kc1xuICAgIHZhciB0aW1lVW5pdFNpemVTZWNvbmRzID0ge1xuICAgICAgICBcIm1pY3Jvc2Vjb25kXCI6IDAuMDAwMDAxLFxuICAgICAgICBcIm1pbGxpc2Vjb25kXCI6IDAuMDAxLFxuICAgICAgICBcInNlY29uZFwiOiAxLFxuICAgICAgICBcIm1pbnV0ZVwiOiA2MCxcbiAgICAgICAgXCJob3VyXCI6IDYwICogNjAsXG4gICAgICAgIFwiZGF5XCI6IDI0ICogNjAgKiA2MCxcbiAgICAgICAgXCJtb250aFwiOiAzMCAqIDI0ICogNjAgKiA2MCxcbiAgICAgICAgXCJxdWFydGVyXCI6IDMgKiAzMCAqIDI0ICogNjAgKiA2MCxcbiAgICAgICAgXCJ5ZWFyXCI6IDM2NS4yNDI1ICogMjQgKiA2MCAqIDYwXG4gICAgfTtcblxuICAgIC8vIG1hcCBvZiBhcHAuIHNpemUgb2YgdGltZSB1bml0cyBpbiBtaWxsaXNlY29uZHNcbiAgICB2YXIgdGltZVVuaXRTaXplTWlsbGlzZWNvbmRzID0ge1xuICAgICAgICBcIm1pY3Jvc2Vjb25kXCI6IDAuMDAxLFxuICAgICAgICBcIm1pbGxpc2Vjb25kXCI6IDEsXG4gICAgICAgIFwic2Vjb25kXCI6IDEwMDAsXG4gICAgICAgIFwibWludXRlXCI6IDYwICogMTAwMCxcbiAgICAgICAgXCJob3VyXCI6IDYwICogNjAgKiAxMDAwLFxuICAgICAgICBcImRheVwiOiAyNCAqIDYwICogNjAgKiAxMDAwLFxuICAgICAgICBcIm1vbnRoXCI6IDMwICogMjQgKiA2MCAqIDYwICogMTAwMCxcbiAgICAgICAgXCJxdWFydGVyXCI6IDMgKiAzMCAqIDI0ICogNjAgKiA2MCAqIDEwMDAsXG4gICAgICAgIFwieWVhclwiOiAzNjUuMjQyNSAqIDI0ICogNjAgKiA2MCAqIDEwMDBcbiAgICB9O1xuXG4gICAgLy8gbWFwIG9mIGFwcC4gc2l6ZSBvZiB0aW1lIHVuaXRzIGluIG1pY3Jvc2Vjb25kc1xuICAgIHZhciB0aW1lVW5pdFNpemVNaWNyb3NlY29uZHMgPSB7XG4gICAgICAgIFwibWljcm9zZWNvbmRcIjogMSxcbiAgICAgICAgXCJtaWxsaXNlY29uZFwiOiAxMDAwLFxuICAgICAgICBcInNlY29uZFwiOiAxMDAwMDAwLFxuICAgICAgICBcIm1pbnV0ZVwiOiA2MCAqIDEwMDAwMDAsXG4gICAgICAgIFwiaG91clwiOiA2MCAqIDYwICogMTAwMDAwMCxcbiAgICAgICAgXCJkYXlcIjogMjQgKiA2MCAqIDYwICogMTAwMDAwMCxcbiAgICAgICAgXCJtb250aFwiOiAzMCAqIDI0ICogNjAgKiA2MCAqIDEwMDAwMDAsXG4gICAgICAgIFwicXVhcnRlclwiOiAzICogMzAgKiAyNCAqIDYwICogNjAgKiAxMDAwMDAwLFxuICAgICAgICBcInllYXJcIjogMzY1LjI0MjUgKiAyNCAqIDYwICogNjAgKiAxMDAwMDAwXG4gICAgfTtcblxuICAgIC8vIHRoZSBhbGxvd2VkIHRpY2sgc2l6ZXMsIGFmdGVyIDEgeWVhciB3ZSB1c2VcbiAgICAvLyBhbiBpbnRlZ2VyIGFsZ29yaXRobVxuXG4gICAgdmFyIGJhc2VTcGVjID0gW1xuICAgICAgICBbMSwgXCJtaWNyb3NlY29uZFwiXSwgWzIsIFwibWljcm9zZWNvbmRcIl0sIFs1LCBcIm1pY3Jvc2Vjb25kXCJdLCBbMTAsIFwibWljcm9zZWNvbmRcIl0sXG4gICAgICAgIFsyNSwgXCJtaWNyb3NlY29uZFwiXSwgWzUwLCBcIm1pY3Jvc2Vjb25kXCJdLCBbMTAwLCBcIm1pY3Jvc2Vjb25kXCJdLCBbMjUwLCBcIm1pY3Jvc2Vjb25kXCJdLCBbNTAwLCBcIm1pY3Jvc2Vjb25kXCJdLFxuICAgICAgICBbMSwgXCJtaWxsaXNlY29uZFwiXSwgWzIsIFwibWlsbGlzZWNvbmRcIl0sIFs1LCBcIm1pbGxpc2Vjb25kXCJdLCBbMTAsIFwibWlsbGlzZWNvbmRcIl0sXG4gICAgICAgIFsyNSwgXCJtaWxsaXNlY29uZFwiXSwgWzUwLCBcIm1pbGxpc2Vjb25kXCJdLCBbMTAwLCBcIm1pbGxpc2Vjb25kXCJdLCBbMjUwLCBcIm1pbGxpc2Vjb25kXCJdLCBbNTAwLCBcIm1pbGxpc2Vjb25kXCJdLFxuICAgICAgICBbMSwgXCJzZWNvbmRcIl0sIFsyLCBcInNlY29uZFwiXSwgWzUsIFwic2Vjb25kXCJdLCBbMTAsIFwic2Vjb25kXCJdLFxuICAgICAgICBbMzAsIFwic2Vjb25kXCJdLFxuICAgICAgICBbMSwgXCJtaW51dGVcIl0sIFsyLCBcIm1pbnV0ZVwiXSwgWzUsIFwibWludXRlXCJdLCBbMTAsIFwibWludXRlXCJdLFxuICAgICAgICBbMzAsIFwibWludXRlXCJdLFxuICAgICAgICBbMSwgXCJob3VyXCJdLCBbMiwgXCJob3VyXCJdLCBbNCwgXCJob3VyXCJdLFxuICAgICAgICBbOCwgXCJob3VyXCJdLCBbMTIsIFwiaG91clwiXSxcbiAgICAgICAgWzEsIFwiZGF5XCJdLCBbMiwgXCJkYXlcIl0sIFszLCBcImRheVwiXSxcbiAgICAgICAgWzAuMjUsIFwibW9udGhcIl0sIFswLjUsIFwibW9udGhcIl0sIFsxLCBcIm1vbnRoXCJdLFxuICAgICAgICBbMiwgXCJtb250aFwiXVxuICAgIF07XG5cbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIHZhcmlhbnQocykgd2UnbGwgbmVlZCB5ZXQsIGJ1dCBnZW5lcmF0aW5nIGJvdGggaXNcbiAgICAvLyBjaGVhcFxuXG4gICAgdmFyIHNwZWNNb250aHMgPSBiYXNlU3BlYy5jb25jYXQoW1szLCBcIm1vbnRoXCJdLCBbNiwgXCJtb250aFwiXSxcbiAgICAgICAgWzEsIFwieWVhclwiXV0pO1xuICAgIHZhciBzcGVjUXVhcnRlcnMgPSBiYXNlU3BlYy5jb25jYXQoW1sxLCBcInF1YXJ0ZXJcIl0sIFsyLCBcInF1YXJ0ZXJcIl0sXG4gICAgICAgIFsxLCBcInllYXJcIl1dKTtcblxuICAgIGZ1bmN0aW9uIGRhdGVUaWNrR2VuZXJhdG9yKGF4aXMpIHtcbiAgICAgICAgdmFyIG9wdHMgPSBheGlzLm9wdGlvbnMsXG4gICAgICAgICAgICB0aWNrcyA9IFtdLFxuICAgICAgICAgICAgZCA9IGRhdGVHZW5lcmF0b3IoYXhpcy5taW4sIG9wdHMpLFxuICAgICAgICAgICAgbWluU2l6ZSA9IDA7XG5cbiAgICAgICAgLy8gbWFrZSBxdWFydGVyIHVzZSBhIHBvc3NpYmlsaXR5IGlmIHF1YXJ0ZXJzIGFyZVxuICAgICAgICAvLyBtZW50aW9uZWQgaW4gZWl0aGVyIG9mIHRoZXNlIG9wdGlvbnNcbiAgICAgICAgdmFyIHNwZWMgPSAob3B0cy50aWNrU2l6ZSAmJiBvcHRzLnRpY2tTaXplWzFdID09PVxuICAgICAgICAgICAgXCJxdWFydGVyXCIpIHx8XG4gICAgICAgICAgICAob3B0cy5taW5UaWNrU2l6ZSAmJiBvcHRzLm1pblRpY2tTaXplWzFdID09PVxuICAgICAgICAgICAgXCJxdWFydGVyXCIpID8gc3BlY1F1YXJ0ZXJzIDogc3BlY01vbnRocztcblxuICAgICAgICB2YXIgdGltZVVuaXRTaXplO1xuICAgICAgICBpZiAob3B0cy50aW1lQmFzZSA9PT0gJ3NlY29uZHMnKSB7XG4gICAgICAgICAgICB0aW1lVW5pdFNpemUgPSB0aW1lVW5pdFNpemVTZWNvbmRzO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdHMudGltZUJhc2UgPT09ICdtaWNyb3NlY29uZHMnKSB7XG4gICAgICAgICAgICB0aW1lVW5pdFNpemUgPSB0aW1lVW5pdFNpemVNaWNyb3NlY29uZHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aW1lVW5pdFNpemUgPSB0aW1lVW5pdFNpemVNaWxsaXNlY29uZHM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0cy5taW5UaWNrU2l6ZSAhPT0gbnVsbCAmJiBvcHRzLm1pblRpY2tTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0cy50aWNrU2l6ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIG1pblNpemUgPSBvcHRzLnRpY2tTaXplO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtaW5TaXplID0gb3B0cy5taW5UaWNrU2l6ZVswXSAqIHRpbWVVbml0U2l6ZVtvcHRzLm1pblRpY2tTaXplWzFdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BlYy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChheGlzLmRlbHRhIDwgKHNwZWNbaV1bMF0gKiB0aW1lVW5pdFNpemVbc3BlY1tpXVsxXV0gK1xuICAgICAgICAgICAgICAgIHNwZWNbaSArIDFdWzBdICogdGltZVVuaXRTaXplW3NwZWNbaSArIDFdWzFdXSkgLyAyICYmXG4gICAgICAgICAgICAgICAgc3BlY1tpXVswXSAqIHRpbWVVbml0U2l6ZVtzcGVjW2ldWzFdXSA+PSBtaW5TaXplKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2l6ZSA9IHNwZWNbaV1bMF07XG4gICAgICAgIHZhciB1bml0ID0gc3BlY1tpXVsxXTtcbiAgICAgICAgLy8gc3BlY2lhbC1jYXNlIHRoZSBwb3NzaWJpbGl0eSBvZiBzZXZlcmFsIHllYXJzXG4gICAgICAgIGlmICh1bml0ID09PSBcInllYXJcIikge1xuICAgICAgICAgICAgLy8gaWYgZ2l2ZW4gYSBtaW5UaWNrU2l6ZSBpbiB5ZWFycywganVzdCB1c2UgaXQsXG4gICAgICAgICAgICAvLyBlbnN1cmluZyB0aGF0IGl0J3MgYW4gaW50ZWdlclxuXG4gICAgICAgICAgICBpZiAob3B0cy5taW5UaWNrU2l6ZSAhPT0gbnVsbCAmJiBvcHRzLm1pblRpY2tTaXplICE9PSB1bmRlZmluZWQgJiYgb3B0cy5taW5UaWNrU2l6ZVsxXSA9PT0gXCJ5ZWFyXCIpIHtcbiAgICAgICAgICAgICAgICBzaXplID0gTWF0aC5mbG9vcihvcHRzLm1pblRpY2tTaXplWzBdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hZ24gPSBwYXJzZUZsb2F0KCcxZScgKyBNYXRoLmZsb29yKE1hdGgubG9nKGF4aXMuZGVsdGEgLyB0aW1lVW5pdFNpemUueWVhcikgLyBNYXRoLkxOMTApKTtcbiAgICAgICAgICAgICAgICB2YXIgbm9ybSA9IChheGlzLmRlbHRhIC8gdGltZVVuaXRTaXplLnllYXIpIC8gbWFnbjtcblxuICAgICAgICAgICAgICAgIGlmIChub3JtIDwgMS41KSB7XG4gICAgICAgICAgICAgICAgICAgIHNpemUgPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobm9ybSA8IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IDI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub3JtIDwgNy41KSB7XG4gICAgICAgICAgICAgICAgICAgIHNpemUgPSA1O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNpemUgPSAxMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzaXplICo9IG1hZ247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG1pbmltdW0gc2l6ZSBmb3IgeWVhcnMgaXMgMVxuXG4gICAgICAgICAgICBpZiAoc2l6ZSA8IDEpIHtcbiAgICAgICAgICAgICAgICBzaXplID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGF4aXMudGlja1NpemUgPSBvcHRzLnRpY2tTaXplIHx8IFtzaXplLCB1bml0XTtcbiAgICAgICAgdmFyIHRpY2tTaXplID0gYXhpcy50aWNrU2l6ZVswXTtcbiAgICAgICAgdW5pdCA9IGF4aXMudGlja1NpemVbMV07XG5cbiAgICAgICAgdmFyIHN0ZXAgPSB0aWNrU2l6ZSAqIHRpbWVVbml0U2l6ZVt1bml0XTtcblxuICAgICAgICBpZiAodW5pdCA9PT0gXCJtaWNyb3NlY29uZFwiKSB7XG4gICAgICAgICAgICBkLnNldE1pY3Jvc2Vjb25kcyhmbG9vckluQmFzZShkLmdldE1pY3Jvc2Vjb25kcygpLCB0aWNrU2l6ZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKHVuaXQgPT09IFwibWlsbGlzZWNvbmRcIikge1xuICAgICAgICAgICAgZC5zZXRNaWxsaXNlY29uZHMoZmxvb3JJbkJhc2UoZC5nZXRNaWxsaXNlY29uZHMoKSwgdGlja1NpemUpKTtcbiAgICAgICAgfSBlbHNlIGlmICh1bml0ID09PSBcInNlY29uZFwiKSB7XG4gICAgICAgICAgICBkLnNldFNlY29uZHMoZmxvb3JJbkJhc2UoZC5nZXRTZWNvbmRzKCksIHRpY2tTaXplKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodW5pdCA9PT0gXCJtaW51dGVcIikge1xuICAgICAgICAgICAgZC5zZXRNaW51dGVzKGZsb29ySW5CYXNlKGQuZ2V0TWludXRlcygpLCB0aWNrU2l6ZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKHVuaXQgPT09IFwiaG91clwiKSB7XG4gICAgICAgICAgICBkLnNldEhvdXJzKGZsb29ySW5CYXNlKGQuZ2V0SG91cnMoKSwgdGlja1NpemUpKTtcbiAgICAgICAgfSBlbHNlIGlmICh1bml0ID09PSBcIm1vbnRoXCIpIHtcbiAgICAgICAgICAgIGQuc2V0TW9udGgoZmxvb3JJbkJhc2UoZC5nZXRNb250aCgpLCB0aWNrU2l6ZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKHVuaXQgPT09IFwicXVhcnRlclwiKSB7XG4gICAgICAgICAgICBkLnNldE1vbnRoKDMgKiBmbG9vckluQmFzZShkLmdldE1vbnRoKCkgLyAzLFxuICAgICAgICAgICAgICAgIHRpY2tTaXplKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodW5pdCA9PT0gXCJ5ZWFyXCIpIHtcbiAgICAgICAgICAgIGQuc2V0RnVsbFllYXIoZmxvb3JJbkJhc2UoZC5nZXRGdWxsWWVhcigpLCB0aWNrU2l6ZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVzZXQgc21hbGxlciBjb21wb25lbnRzXG5cbiAgICAgICAgaWYgKHN0ZXAgPj0gdGltZVVuaXRTaXplLm1pbGxpc2Vjb25kKSB7XG4gICAgICAgICAgICBpZiAoc3RlcCA+PSB0aW1lVW5pdFNpemUuc2Vjb25kKSB7XG4gICAgICAgICAgICAgICAgZC5zZXRNaWNyb3NlY29uZHMoMCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGQuc2V0TWljcm9zZWNvbmRzKGQuZ2V0TWlsbGlzZWNvbmRzKCkgKiAxMDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RlcCA+PSB0aW1lVW5pdFNpemUubWludXRlKSB7XG4gICAgICAgICAgICBkLnNldFNlY29uZHMoMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0ZXAgPj0gdGltZVVuaXRTaXplLmhvdXIpIHtcbiAgICAgICAgICAgIGQuc2V0TWludXRlcygwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RlcCA+PSB0aW1lVW5pdFNpemUuZGF5KSB7XG4gICAgICAgICAgICBkLnNldEhvdXJzKDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGVwID49IHRpbWVVbml0U2l6ZS5kYXkgKiA0KSB7XG4gICAgICAgICAgICBkLnNldERhdGUoMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0ZXAgPj0gdGltZVVuaXRTaXplLm1vbnRoICogMikge1xuICAgICAgICAgICAgZC5zZXRNb250aChmbG9vckluQmFzZShkLmdldE1vbnRoKCksIDMpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RlcCA+PSB0aW1lVW5pdFNpemUucXVhcnRlciAqIDIpIHtcbiAgICAgICAgICAgIGQuc2V0TW9udGgoZmxvb3JJbkJhc2UoZC5nZXRNb250aCgpLCA2KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0ZXAgPj0gdGltZVVuaXRTaXplLnllYXIpIHtcbiAgICAgICAgICAgIGQuc2V0TW9udGgoMCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2FycnkgPSAwO1xuICAgICAgICB2YXIgdiA9IE51bWJlci5OYU47XG4gICAgICAgIHZhciB2MTAwMDtcbiAgICAgICAgdmFyIHByZXY7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHByZXYgPSB2O1xuICAgICAgICAgICAgdjEwMDAgPSBkLmdldFRpbWUoKTtcbiAgICAgICAgICAgIGlmIChvcHRzICYmIG9wdHMudGltZUJhc2UgPT09ICdzZWNvbmRzJykge1xuICAgICAgICAgICAgICAgIHYgPSB2MTAwMCAvIDEwMDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdHMgJiYgb3B0cy50aW1lQmFzZSA9PT0gJ21pY3Jvc2Vjb25kcycpIHtcbiAgICAgICAgICAgICAgICB2ID0gdjEwMDAgKiAxMDAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2ID0gdjEwMDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRpY2tzLnB1c2godik7XG5cbiAgICAgICAgICAgIGlmICh1bml0ID09PSBcIm1vbnRoXCIgfHwgdW5pdCA9PT0gXCJxdWFydGVyXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGlja1NpemUgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGEgYml0IGNvbXBsaWNhdGVkIC0gd2UnbGwgZGl2aWRlIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBtb250aC9xdWFydGVyIHVwIGJ1dCB3ZSBuZWVkIHRvIHRha2VcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FyZSBvZiBmcmFjdGlvbnMgc28gd2UgZG9uJ3QgZW5kIHVwIGluXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBtaWRkbGUgb2YgYSBkYXlcbiAgICAgICAgICAgICAgICAgICAgZC5zZXREYXRlKDEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBkLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICAgICAgZC5zZXRNb250aChkLmdldE1vbnRoKCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHVuaXQgPT09IFwicXVhcnRlclwiID8gMyA6IDEpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuZCA9IGQuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgICAgICBkLnNldFRpbWUoKHYgKyBjYXJyeSAqIHRpbWVVbml0U2l6ZS5ob3VyICsgKGVuZCAtIHN0YXJ0KSAqIHRpY2tTaXplKSk7XG4gICAgICAgICAgICAgICAgICAgIGNhcnJ5ID0gZC5nZXRIb3VycygpO1xuICAgICAgICAgICAgICAgICAgICBkLnNldEhvdXJzKDApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGQuc2V0TW9udGgoZC5nZXRNb250aCgpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpY2tTaXplICogKHVuaXQgPT09IFwicXVhcnRlclwiID8gMyA6IDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHVuaXQgPT09IFwieWVhclwiKSB7XG4gICAgICAgICAgICAgICAgZC5zZXRGdWxsWWVhcihkLmdldEZ1bGxZZWFyKCkgKyB0aWNrU2l6ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLnRpbWVCYXNlID09PSAnc2Vjb25kcycpIHtcbiAgICAgICAgICAgICAgICAgICAgZC5zZXRUaW1lKCh2ICsgc3RlcCkgKiAxMDAwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wdHMudGltZUJhc2UgPT09ICdtaWNyb3NlY29uZHMnKSB7XG4gICAgICAgICAgICAgICAgICAgIGQuc2V0VGltZSgodiArIHN0ZXApIC8gMTAwMCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZC5zZXRUaW1lKHYgKyBzdGVwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKHYgPCBheGlzLm1heCAmJiB2ICE9PSBwcmV2KTtcblxuICAgICAgICByZXR1cm4gdGlja3M7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGluaXQocGxvdCkge1xuICAgICAgICBwbG90Lmhvb2tzLnByb2Nlc3NPcHRpb25zLnB1c2goZnVuY3Rpb24gKHBsb3QpIHtcbiAgICAgICAgICAgICQuZWFjaChwbG90LmdldEF4ZXMoKSwgZnVuY3Rpb24oYXhpc05hbWUsIGF4aXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0cyA9IGF4aXMub3B0aW9ucztcbiAgICAgICAgICAgICAgICBpZiAob3B0cy5tb2RlID09PSBcInRpbWVcIikge1xuICAgICAgICAgICAgICAgICAgICBheGlzLnRpY2tHZW5lcmF0b3IgPSBkYXRlVGlja0dlbmVyYXRvcjtcblxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBhIHRpY2sgZm9ybWF0dGVyIGlzIGFscmVhZHkgcHJvdmlkZWQgZG8gbm90IG92ZXJ3cml0ZSBpdFxuICAgICAgICAgICAgICAgICAgICBpZiAoJ3RpY2tGb3JtYXR0ZXInIGluIG9wdHMgJiYgdHlwZW9mIG9wdHMudGlja0Zvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgICAgIGF4aXMudGlja0Zvcm1hdHRlciA9IGZ1bmN0aW9uICh2LCBheGlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IGRhdGVHZW5lcmF0b3IodiwgYXhpcy5vcHRpb25zKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmlyc3QgY2hlY2sgZ2xvYmFsIGZvcm1hdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdHMudGltZWZvcm1hdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdERhdGUoZCwgb3B0cy50aW1lZm9ybWF0LCBvcHRzLm1vbnRoTmFtZXMsIG9wdHMuZGF5TmFtZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwb3NzaWJseSB1c2UgcXVhcnRlcnMgaWYgcXVhcnRlcnMgYXJlIG1lbnRpb25lZCBpblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW55IG9mIHRoZXNlIHBsYWNlc1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVzZVF1YXJ0ZXJzID0gKGF4aXMub3B0aW9ucy50aWNrU2l6ZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBheGlzLm9wdGlvbnMudGlja1NpemVbMV0gPT09IFwicXVhcnRlclwiKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChheGlzLm9wdGlvbnMubWluVGlja1NpemUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXhpcy5vcHRpb25zLm1pblRpY2tTaXplWzFdID09PSBcInF1YXJ0ZXJcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lVW5pdFNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0cy50aW1lQmFzZSA9PT0gJ3NlY29uZHMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZVVuaXRTaXplID0gdGltZVVuaXRTaXplU2Vjb25kcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0cy50aW1lQmFzZSA9PT0gJ21pY3Jvc2Vjb25kcycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lVW5pdFNpemUgPSB0aW1lVW5pdFNpemVNaWNyb3NlY29uZHM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVVbml0U2l6ZSA9IHRpbWVVbml0U2l6ZU1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBheGlzLnRpY2tTaXplWzBdICogdGltZVVuaXRTaXplW2F4aXMudGlja1NpemVbMV1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNwYW4gPSBheGlzLm1heCAtIGF4aXMubWluO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1ZmZpeCA9IChvcHRzLnR3ZWx2ZUhvdXJDbG9jaykgPyBcIiAlcFwiIDogXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBob3VyQ29kZSA9IChvcHRzLnR3ZWx2ZUhvdXJDbG9jaykgPyBcIiVJXCIgOiBcIiVIXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmFjdG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZtdDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdHMudGltZUJhc2UgPT09ICdzZWNvbmRzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhY3RvciA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wdHMudGltZUJhc2UgPT09ICdtaWNyb3NlY29uZHMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9yID0gMTAwMDAwMFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3IgPSAxMDAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodCA8IHRpbWVVbml0U2l6ZS5zZWNvbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVjaW1hbHMgPSAtTWF0aC5mbG9vcihNYXRoLmxvZzEwKHQgLyBmYWN0b3IpKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHR3by1hbmQtaGFsdmVzIHJlcXVpcmUgYW4gYWRkaXRpb25hbCBkZWNpbWFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFN0cmluZyh0KS5pbmRleE9mKCcyNScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjaW1hbHMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbXQgPSBcIiVTLiVcIiArIGRlY2ltYWxzICsgXCJzXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0IDwgdGltZVVuaXRTaXplLm1pbnV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZtdCA9IGhvdXJDb2RlICsgXCI6JU06JVNcIiArIHN1ZmZpeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodCA8IHRpbWVVbml0U2l6ZS5kYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3BhbiA8IDIgKiB0aW1lVW5pdFNpemUuZGF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZtdCA9IGhvdXJDb2RlICsgXCI6JU1cIiArIHN1ZmZpeDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbXQgPSBcIiViICVkIFwiICsgaG91ckNvZGUgKyBcIjolTVwiICsgc3VmZml4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodCA8IHRpbWVVbml0U2l6ZS5tb250aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZtdCA9IFwiJWIgJWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKHVzZVF1YXJ0ZXJzICYmIHQgPCB0aW1lVW5pdFNpemUucXVhcnRlcikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIXVzZVF1YXJ0ZXJzICYmIHQgPCB0aW1lVW5pdFNpemUueWVhcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3BhbiA8IHRpbWVVbml0U2l6ZS55ZWFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZtdCA9IFwiJWJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbXQgPSBcIiViICVZXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh1c2VRdWFydGVycyAmJiB0IDwgdGltZVVuaXRTaXplLnllYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3BhbiA8IHRpbWVVbml0U2l6ZS55ZWFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZtdCA9IFwiUSVxXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm10ID0gXCJRJXEgJVlcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZtdCA9IFwiJVlcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJ0ID0gZm9ybWF0RGF0ZShkLCBmbXQsIG9wdHMubW9udGhOYW1lcywgb3B0cy5kYXlOYW1lcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBydDtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgJC5wbG90LnBsdWdpbnMucHVzaCh7XG4gICAgICAgIGluaXQ6IGluaXQsXG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgIG5hbWU6ICd0aW1lJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMCdcbiAgICB9KTtcblxuICAgIC8vIFRpbWUtYXhpcyBzdXBwb3J0IHVzZWQgdG8gYmUgaW4gRmxvdCBjb3JlLCB3aGljaCBleHBvc2VkIHRoZVxuICAgIC8vIGZvcm1hdERhdGUgZnVuY3Rpb24gb24gdGhlIHBsb3Qgb2JqZWN0LiAgVmFyaW91cyBwbHVnaW5zIGRlcGVuZFxuICAgIC8vIG9uIHRoZSBmdW5jdGlvbiwgc28gd2UgbmVlZCB0byByZS1leHBvc2UgaXQgaGVyZS5cblxuICAgICQucGxvdC5mb3JtYXREYXRlID0gZm9ybWF0RGF0ZTtcbiAgICAkLnBsb3QuZGF0ZUdlbmVyYXRvciA9IGRhdGVHZW5lcmF0b3I7XG4gICAgJC5wbG90LmRhdGVUaWNrR2VuZXJhdG9yID0gZGF0ZVRpY2tHZW5lcmF0b3I7XG4gICAgJC5wbG90Lm1ha2VVdGNXcmFwcGVyID0gbWFrZVV0Y1dyYXBwZXI7XG59KShqUXVlcnkpO1xuIiwiXG4vKiBnbG9iYWwgalF1ZXJ5ICovXG5cbihmdW5jdGlvbigkKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIHByb3BhZ2F0ZVN1cHBvcnRlZEdlc3R1cmU6IGZhbHNlXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGluaXQocGxvdCkge1xuICAgICAgICBwbG90Lmhvb2tzLnByb2Nlc3NPcHRpb25zLnB1c2goaW5pdFRvdWNoTmF2aWdhdGlvbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5pdFRvdWNoTmF2aWdhdGlvbihwbG90LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBnZXN0dXJlU3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgdHdvVG91Y2hlczogZmFsc2UsXG4gICAgICAgICAgICAgICAgY3VycmVudFRhcFN0YXJ0OiB7IHg6IDAsIHk6IDAgfSxcbiAgICAgICAgICAgICAgICBjdXJyZW50VGFwRW5kOiB7IHg6IDAsIHk6IDAgfSxcbiAgICAgICAgICAgICAgICBwcmV2VGFwOiB7IHg6IDAsIHk6IDAgfSxcbiAgICAgICAgICAgICAgICBjdXJyZW50VGFwOiB7IHg6IDAsIHk6IDAgfSxcbiAgICAgICAgICAgICAgICBpbnRlcmNlcHRlZExvbmdUYXA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzVW5zdXBwb3J0ZWRHZXN0dXJlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBwcmV2VGFwVGltZTogbnVsbCxcbiAgICAgICAgICAgICAgICB0YXBTdGFydFRpbWU6IG51bGwsXG4gICAgICAgICAgICAgICAgbG9uZ1RhcFRyaWdnZXJJZDogbnVsbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1heERpc3RhbmNlQmV0d2VlblRhcHMgPSAyMCxcbiAgICAgICAgICAgIG1heEludGVydmFsQmV0d2VlblRhcHMgPSA1MDAsXG4gICAgICAgICAgICBtYXhMb25nVGFwRGlzdGFuY2UgPSAyMCxcbiAgICAgICAgICAgIG1pbkxvbmdUYXBEdXJhdGlvbiA9IDE1MDAsXG4gICAgICAgICAgICBwcmVzc2VkVGFwRHVyYXRpb24gPSAxMjUsXG4gICAgICAgICAgICBtYWluRXZlbnRIb2xkZXI7XG5cbiAgICAgICAgZnVuY3Rpb24gaW50ZXJwcmV0R2VzdHVyZXMoZSkge1xuICAgICAgICAgICAgdmFyIG8gPSBwbG90LmdldE9wdGlvbnMoKTtcblxuICAgICAgICAgICAgaWYgKCFvLnBhbi5hY3RpdmUgJiYgIW8uem9vbS5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHVwZGF0ZU9uTXVsdGlwbGVUb3VjaGVzKGUpO1xuICAgICAgICAgICAgbWFpbkV2ZW50SG9sZGVyLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCd0b3VjaGV2ZW50JywgeyBkZXRhaWw6IGUgfSkpO1xuXG4gICAgICAgICAgICBpZiAoaXNQaW5jaEV2ZW50KGUpKSB7XG4gICAgICAgICAgICAgICAgZXhlY3V0ZUFjdGlvbihlLCAncGluY2gnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXhlY3V0ZUFjdGlvbihlLCAncGFuJyk7XG4gICAgICAgICAgICAgICAgaWYgKCF3YXNQaW5jaEV2ZW50KGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0RvdWJsZVRhcChlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZUFjdGlvbihlLCAnZG91YmxlVGFwJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZUFjdGlvbihlLCAndGFwJyk7XG4gICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVBY3Rpb24oZSwgJ2xvbmdUYXAnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBleGVjdXRlQWN0aW9uKGUsIGdlc3R1cmUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZ2VzdHVyZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3Bhbic6XG4gICAgICAgICAgICAgICAgICAgIHBhbltlLnR5cGVdKGUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdwaW5jaCc6XG4gICAgICAgICAgICAgICAgICAgIHBpbmNoW2UudHlwZV0oZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RvdWJsZVRhcCc6XG4gICAgICAgICAgICAgICAgICAgIGRvdWJsZVRhcC5vbkRvdWJsZVRhcChlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbG9uZ1RhcCc6XG4gICAgICAgICAgICAgICAgICAgIGxvbmdUYXBbZS50eXBlXShlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndGFwJzpcbiAgICAgICAgICAgICAgICAgICAgdGFwW2UudHlwZV0oZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYmluZEV2ZW50cyhwbG90LCBldmVudEhvbGRlcikge1xuICAgICAgICAgICAgbWFpbkV2ZW50SG9sZGVyID0gZXZlbnRIb2xkZXJbMF07XG4gICAgICAgICAgICBldmVudEhvbGRlclswXS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgaW50ZXJwcmV0R2VzdHVyZXMsIGZhbHNlKTtcbiAgICAgICAgICAgIGV2ZW50SG9sZGVyWzBdLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIGludGVycHJldEdlc3R1cmVzLCBmYWxzZSk7XG4gICAgICAgICAgICBldmVudEhvbGRlclswXS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIGludGVycHJldEdlc3R1cmVzLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzaHV0ZG93bihwbG90LCBldmVudEhvbGRlcikge1xuICAgICAgICAgICAgZXZlbnRIb2xkZXJbMF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGludGVycHJldEdlc3R1cmVzKTtcbiAgICAgICAgICAgIGV2ZW50SG9sZGVyWzBdLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIGludGVycHJldEdlc3R1cmVzKTtcbiAgICAgICAgICAgIGV2ZW50SG9sZGVyWzBdLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgaW50ZXJwcmV0R2VzdHVyZXMpO1xuICAgICAgICAgICAgaWYgKGdlc3R1cmVTdGF0ZS5sb25nVGFwVHJpZ2dlcklkKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGdlc3R1cmVTdGF0ZS5sb25nVGFwVHJpZ2dlcklkKTtcbiAgICAgICAgICAgICAgICBnZXN0dXJlU3RhdGUubG9uZ1RhcFRyaWdnZXJJZCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFuID0ge1xuICAgICAgICAgICAgdG91Y2hzdGFydDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZVByZXZGb3JEb3VibGVUYXAoKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVDdXJyZW50Rm9yRG91YmxlVGFwKGUpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZVN0YXRlRm9yTG9uZ1RhcFN0YXJ0KGUpO1xuXG4gICAgICAgICAgICAgICAgbWFpbkV2ZW50SG9sZGVyLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdwYW5zdGFydCcsIHsgZGV0YWlsOiBlIH0pKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHRvdWNobW92ZTogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIHByZXZlbnRFdmVudEJlaGF2aW9ycyhlKTtcblxuICAgICAgICAgICAgICAgIHVwZGF0ZUN1cnJlbnRGb3JEb3VibGVUYXAoZSk7XG4gICAgICAgICAgICAgICAgdXBkYXRlU3RhdGVGb3JMb25nVGFwRW5kKGUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFnZXN0dXJlU3RhdGUuaXNVbnN1cHBvcnRlZEdlc3R1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbkV2ZW50SG9sZGVyLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdwYW5kcmFnJywgeyBkZXRhaWw6IGUgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHRvdWNoZW5kOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgcHJldmVudEV2ZW50QmVoYXZpb3JzKGUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHdhc1BpbmNoRXZlbnQoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbkV2ZW50SG9sZGVyLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdwaW5jaGVuZCcsIHsgZGV0YWlsOiBlIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgbWFpbkV2ZW50SG9sZGVyLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdwYW5zdGFydCcsIHsgZGV0YWlsOiBlIH0pKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5vVG91Y2hBY3RpdmUoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbkV2ZW50SG9sZGVyLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdwYW5lbmQnLCB7IGRldGFpbDogZSB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBwaW5jaCA9IHtcbiAgICAgICAgICAgIHRvdWNoc3RhcnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBtYWluRXZlbnRIb2xkZXIuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3BpbmNoc3RhcnQnLCB7IGRldGFpbDogZSB9KSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB0b3VjaG1vdmU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBwcmV2ZW50RXZlbnRCZWhhdmlvcnMoZSk7XG4gICAgICAgICAgICAgICAgZ2VzdHVyZVN0YXRlLnR3b1RvdWNoZXMgPSBpc1BpbmNoRXZlbnQoZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFnZXN0dXJlU3RhdGUuaXNVbnN1cHBvcnRlZEdlc3R1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbkV2ZW50SG9sZGVyLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdwaW5jaGRyYWcnLCB7IGRldGFpbDogZSB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgdG91Y2hlbmQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBwcmV2ZW50RXZlbnRCZWhhdmlvcnMoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGRvdWJsZVRhcCA9IHtcbiAgICAgICAgICAgIG9uRG91YmxlVGFwOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgcHJldmVudEV2ZW50QmVoYXZpb3JzKGUpO1xuICAgICAgICAgICAgICAgIG1haW5FdmVudEhvbGRlci5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnZG91YmxldGFwJywgeyBkZXRhaWw6IGUgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBsb25nVGFwID0ge1xuICAgICAgICAgICAgdG91Y2hzdGFydDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGxvbmdUYXAud2FpdEZvckxvbmdUYXAoZSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB0b3VjaG1vdmU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHRvdWNoZW5kOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdlc3R1cmVTdGF0ZS5sb25nVGFwVHJpZ2dlcklkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChnZXN0dXJlU3RhdGUubG9uZ1RhcFRyaWdnZXJJZCk7XG4gICAgICAgICAgICAgICAgICAgIGdlc3R1cmVTdGF0ZS5sb25nVGFwVHJpZ2dlcklkID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBpc0xvbmdUYXA6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgdGFwRHVyYXRpb24gPSBjdXJyZW50VGltZSAtIGdlc3R1cmVTdGF0ZS50YXBTdGFydFRpbWU7XG4gICAgICAgICAgICAgICAgaWYgKHRhcER1cmF0aW9uID49IG1pbkxvbmdUYXBEdXJhdGlvbiAmJiAhZ2VzdHVyZVN0YXRlLmludGVyY2VwdGVkTG9uZ1RhcCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UoZ2VzdHVyZVN0YXRlLmN1cnJlbnRUYXBTdGFydC54LCBnZXN0dXJlU3RhdGUuY3VycmVudFRhcFN0YXJ0LnksIGdlc3R1cmVTdGF0ZS5jdXJyZW50VGFwRW5kLngsIGdlc3R1cmVTdGF0ZS5jdXJyZW50VGFwRW5kLnkpIDwgbWF4TG9uZ1RhcERpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXN0dXJlU3RhdGUuaW50ZXJjZXB0ZWRMb25nVGFwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHdhaXRGb3JMb25nVGFwOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxvbmdUYXBUcmlnZ2VyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb25nVGFwLmlzTG9uZ1RhcChlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFpbkV2ZW50SG9sZGVyLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdsb25ndGFwJywgeyBkZXRhaWw6IGUgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGdlc3R1cmVTdGF0ZS5sb25nVGFwVHJpZ2dlcklkID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmICghZ2VzdHVyZVN0YXRlLmxvbmdUYXBUcmlnZ2VySWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VzdHVyZVN0YXRlLmxvbmdUYXBUcmlnZ2VySWQgPSBzZXRUaW1lb3V0KGxvbmdUYXBUcmlnZ2VyLCBtaW5Mb25nVGFwRHVyYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdGFwID0ge1xuICAgICAgICAgICAgdG91Y2hzdGFydDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGdlc3R1cmVTdGF0ZS50YXBTdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHRvdWNobW92ZTogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgdG91Y2hlbmQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFwLmlzVGFwKGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1haW5FdmVudEhvbGRlci5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgndGFwJywgeyBkZXRhaWw6IGUgfSkpO1xuICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RXZlbnRCZWhhdmlvcnMoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaXNUYXA6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgdGFwRHVyYXRpb24gPSBjdXJyZW50VGltZSAtIGdlc3R1cmVTdGF0ZS50YXBTdGFydFRpbWU7XG4gICAgICAgICAgICAgICAgaWYgKHRhcER1cmF0aW9uIDw9IHByZXNzZWRUYXBEdXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UoZ2VzdHVyZVN0YXRlLmN1cnJlbnRUYXBTdGFydC54LCBnZXN0dXJlU3RhdGUuY3VycmVudFRhcFN0YXJ0LnksIGdlc3R1cmVTdGF0ZS5jdXJyZW50VGFwRW5kLngsIGdlc3R1cmVTdGF0ZS5jdXJyZW50VGFwRW5kLnkpIDwgbWF4TG9uZ1RhcERpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG9wdGlvbnMucGFuLmVuYWJsZVRvdWNoID09PSB0cnVlIHx8IG9wdGlvbnMuem9vbS5lbmFibGVUb3VjaCkge1xuICAgICAgICAgICAgcGxvdC5ob29rcy5iaW5kRXZlbnRzLnB1c2goYmluZEV2ZW50cyk7XG4gICAgICAgICAgICBwbG90Lmhvb2tzLnNodXRkb3duLnB1c2goc2h1dGRvd24pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVByZXZGb3JEb3VibGVUYXAoKSB7XG4gICAgICAgICAgICBnZXN0dXJlU3RhdGUucHJldlRhcCA9IHtcbiAgICAgICAgICAgICAgICB4OiBnZXN0dXJlU3RhdGUuY3VycmVudFRhcC54LFxuICAgICAgICAgICAgICAgIHk6IGdlc3R1cmVTdGF0ZS5jdXJyZW50VGFwLnlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlQ3VycmVudEZvckRvdWJsZVRhcChlKSB7XG4gICAgICAgICAgICBnZXN0dXJlU3RhdGUuY3VycmVudFRhcCA9IHtcbiAgICAgICAgICAgICAgICB4OiBlLnRvdWNoZXNbMF0ucGFnZVgsXG4gICAgICAgICAgICAgICAgeTogZS50b3VjaGVzWzBdLnBhZ2VZXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlU3RhdGVGb3JMb25nVGFwU3RhcnQoZSkge1xuICAgICAgICAgICAgZ2VzdHVyZVN0YXRlLnRhcFN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgZ2VzdHVyZVN0YXRlLmludGVyY2VwdGVkTG9uZ1RhcCA9IGZhbHNlO1xuICAgICAgICAgICAgZ2VzdHVyZVN0YXRlLmN1cnJlbnRUYXBTdGFydCA9IHtcbiAgICAgICAgICAgICAgICB4OiBlLnRvdWNoZXNbMF0ucGFnZVgsXG4gICAgICAgICAgICAgICAgeTogZS50b3VjaGVzWzBdLnBhZ2VZXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2VzdHVyZVN0YXRlLmN1cnJlbnRUYXBFbmQgPSB7XG4gICAgICAgICAgICAgICAgeDogZS50b3VjaGVzWzBdLnBhZ2VYLFxuICAgICAgICAgICAgICAgIHk6IGUudG91Y2hlc1swXS5wYWdlWVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVTdGF0ZUZvckxvbmdUYXBFbmQoZSkge1xuICAgICAgICAgICAgZ2VzdHVyZVN0YXRlLmN1cnJlbnRUYXBFbmQgPSB7XG4gICAgICAgICAgICAgICAgeDogZS50b3VjaGVzWzBdLnBhZ2VYLFxuICAgICAgICAgICAgICAgIHk6IGUudG91Y2hlc1swXS5wYWdlWVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBpc0RvdWJsZVRhcChlKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcbiAgICAgICAgICAgICAgICBpbnRlcnZhbEJldHdlZW5UYXBzID0gY3VycmVudFRpbWUgLSBnZXN0dXJlU3RhdGUucHJldlRhcFRpbWU7XG5cbiAgICAgICAgICAgIGlmIChpbnRlcnZhbEJldHdlZW5UYXBzID49IDAgJiYgaW50ZXJ2YWxCZXR3ZWVuVGFwcyA8IG1heEludGVydmFsQmV0d2VlblRhcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UoZ2VzdHVyZVN0YXRlLnByZXZUYXAueCwgZ2VzdHVyZVN0YXRlLnByZXZUYXAueSwgZ2VzdHVyZVN0YXRlLmN1cnJlbnRUYXAueCwgZ2VzdHVyZVN0YXRlLmN1cnJlbnRUYXAueSkgPCBtYXhEaXN0YW5jZUJldHdlZW5UYXBzKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuZmlyc3RUb3VjaCA9IGdlc3R1cmVTdGF0ZS5wcmV2VGFwO1xuICAgICAgICAgICAgICAgICAgICBlLnNlY29uZFRvdWNoID0gZ2VzdHVyZVN0YXRlLmN1cnJlbnRUYXA7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdlc3R1cmVTdGF0ZS5wcmV2VGFwVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcHJldmVudEV2ZW50QmVoYXZpb3JzKGUpIHtcbiAgICAgICAgICAgIGlmICghZ2VzdHVyZVN0YXRlLmlzVW5zdXBwb3J0ZWRHZXN0dXJlKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGlmICghcGxvdC5nZXRPcHRpb25zKCkucHJvcGFnYXRlU3VwcG9ydGVkR2VzdHVyZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGRpc3RhbmNlKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KCh4MSAtIHgyKSAqICh4MSAtIHgyKSArICh5MSAtIHkyKSAqICh5MSAtIHkyKSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBub1RvdWNoQWN0aXZlKGUpIHtcbiAgICAgICAgICAgIHJldHVybiAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPT09IDApO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gd2FzUGluY2hFdmVudChlKSB7XG4gICAgICAgICAgICByZXR1cm4gKGdlc3R1cmVTdGF0ZS50d29Ub3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPT09IDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlT25NdWx0aXBsZVRvdWNoZXMoZSkge1xuICAgICAgICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPj0gMykge1xuICAgICAgICAgICAgICAgIGdlc3R1cmVTdGF0ZS5pc1Vuc3VwcG9ydGVkR2VzdHVyZSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdlc3R1cmVTdGF0ZS5pc1Vuc3VwcG9ydGVkR2VzdHVyZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaXNQaW5jaEV2ZW50KGUpIHtcbiAgICAgICAgICAgIGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUudG91Y2hlc1swXS50YXJnZXQgPT09IHBsb3QuZ2V0RXZlbnRIb2xkZXIoKSAmJlxuICAgICAgICAgICAgICAgICAgICBlLnRvdWNoZXNbMV0udGFyZ2V0ID09PSBwbG90LmdldEV2ZW50SG9sZGVyKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgJC5wbG90LnBsdWdpbnMucHVzaCh7XG4gICAgICAgIGluaXQ6IGluaXQsXG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgIG5hbWU6ICduYXZpZ2F0ZVRvdWNoJyxcbiAgICAgICAgdmVyc2lvbjogJzAuMydcbiAgICB9KTtcbn0pKGpRdWVyeSk7XG4iLCIvKiBnbG9iYWwgalF1ZXJ5ICovXG5cbihmdW5jdGlvbigkKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIHpvb206IHtcbiAgICAgICAgICAgIGVuYWJsZVRvdWNoOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBwYW46IHtcbiAgICAgICAgICAgIGVuYWJsZVRvdWNoOiBmYWxzZSxcbiAgICAgICAgICAgIHRvdWNoTW9kZTogJ21hbnVhbCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVjZW50ZXI6IHtcbiAgICAgICAgICAgIGVuYWJsZVRvdWNoOiB0cnVlXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIFpPT01fRElTVEFOQ0VfTUFSR0lOID0gJC5wbG90LnVpQ29uc3RhbnRzLlpPT01fRElTVEFOQ0VfTUFSR0lOO1xuXG4gICAgZnVuY3Rpb24gaW5pdChwbG90KSB7XG4gICAgICAgIHBsb3QuaG9va3MucHJvY2Vzc09wdGlvbnMucHVzaChpbml0VG91Y2hOYXZpZ2F0aW9uKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0VG91Y2hOYXZpZ2F0aW9uKHBsb3QsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGdlc3R1cmVTdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICB6b29tRW5hYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBwcmV2RGlzdGFuY2U6IG51bGwsXG4gICAgICAgICAgICAgICAgcHJldlRhcFRpbWU6IDAsXG4gICAgICAgICAgICAgICAgcHJldlBhblBvc2l0aW9uOiB7IHg6IDAsIHk6IDAgfSxcbiAgICAgICAgICAgICAgICBwcmV2VGFwUG9zaXRpb246IHsgeDogMCwgeTogMCB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmF2aWdhdGlvblN0YXRlID0ge1xuICAgICAgICAgICAgICAgIHByZXZUb3VjaGVkQXhpczogJ25vbmUnLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRUb3VjaGVkQXhpczogJ25vbmUnLFxuICAgICAgICAgICAgICAgIHRvdWNoZWRBeGlzOiBudWxsLFxuICAgICAgICAgICAgICAgIG5hdmlnYXRpb25Db25zdHJhaW50OiAndW5jb25zdHJhaW5lZCcsXG4gICAgICAgICAgICAgICAgaW5pdGlhbFN0YXRlOiBudWxsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXNlTWFudWFsUGFuID0gb3B0aW9ucy5wYW4uaW50ZXJhY3RpdmUgJiYgb3B0aW9ucy5wYW4udG91Y2hNb2RlID09PSAnbWFudWFsJyxcbiAgICAgICAgICAgIHNtYXJ0UGFuTG9jayA9IG9wdGlvbnMucGFuLnRvdWNoTW9kZSA9PT0gJ3NtYXJ0TG9jaycsXG4gICAgICAgICAgICB1c2VTbWFydFBhbiA9IG9wdGlvbnMucGFuLmludGVyYWN0aXZlICYmIChzbWFydFBhbkxvY2sgfHwgb3B0aW9ucy5wYW4udG91Y2hNb2RlID09PSAnc21hcnQnKSxcbiAgICAgICAgICAgIHBhbiwgcGluY2gsIGRvdWJsZVRhcDtcblxuICAgICAgICBmdW5jdGlvbiBiaW5kRXZlbnRzKHBsb3QsIGV2ZW50SG9sZGVyKSB7XG4gICAgICAgICAgICB2YXIgbyA9IHBsb3QuZ2V0T3B0aW9ucygpO1xuXG4gICAgICAgICAgICBpZiAoby56b29tLmludGVyYWN0aXZlICYmIG8uem9vbS5lbmFibGVUb3VjaCkge1xuICAgICAgICAgICAgICAgIGV2ZW50SG9sZGVyWzBdLmFkZEV2ZW50TGlzdGVuZXIoJ3BpbmNoc3RhcnQnLCBwaW5jaC5zdGFydCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGV2ZW50SG9sZGVyWzBdLmFkZEV2ZW50TGlzdGVuZXIoJ3BpbmNoZHJhZycsIHBpbmNoLmRyYWcsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBldmVudEhvbGRlclswXS5hZGRFdmVudExpc3RlbmVyKCdwaW5jaGVuZCcsIHBpbmNoLmVuZCwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoby5wYW4uaW50ZXJhY3RpdmUgJiYgby5wYW4uZW5hYmxlVG91Y2gpIHtcbiAgICAgICAgICAgICAgICBldmVudEhvbGRlclswXS5hZGRFdmVudExpc3RlbmVyKCdwYW5zdGFydCcsIHBhbi5zdGFydCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGV2ZW50SG9sZGVyWzBdLmFkZEV2ZW50TGlzdGVuZXIoJ3BhbmRyYWcnLCBwYW4uZHJhZywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGV2ZW50SG9sZGVyWzBdLmFkZEV2ZW50TGlzdGVuZXIoJ3BhbmVuZCcsIHBhbi5lbmQsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKChvLnJlY2VudGVyLmludGVyYWN0aXZlICYmIG8ucmVjZW50ZXIuZW5hYmxlVG91Y2gpKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRIb2xkZXJbMF0uYWRkRXZlbnRMaXN0ZW5lcignZG91YmxldGFwJywgZG91YmxlVGFwLnJlY2VudGVyUGxvdCwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc2h1dGRvd24ocGxvdCwgZXZlbnRIb2xkZXIpIHtcbiAgICAgICAgICAgIGV2ZW50SG9sZGVyWzBdLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BhbnN0YXJ0JywgcGFuLnN0YXJ0KTtcbiAgICAgICAgICAgIGV2ZW50SG9sZGVyWzBdLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BhbmRyYWcnLCBwYW4uZHJhZyk7XG4gICAgICAgICAgICBldmVudEhvbGRlclswXS5yZW1vdmVFdmVudExpc3RlbmVyKCdwYW5lbmQnLCBwYW4uZW5kKTtcbiAgICAgICAgICAgIGV2ZW50SG9sZGVyWzBdLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BpbmNoc3RhcnQnLCBwaW5jaC5zdGFydCk7XG4gICAgICAgICAgICBldmVudEhvbGRlclswXS5yZW1vdmVFdmVudExpc3RlbmVyKCdwaW5jaGRyYWcnLCBwaW5jaC5kcmFnKTtcbiAgICAgICAgICAgIGV2ZW50SG9sZGVyWzBdLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BpbmNoZW5kJywgcGluY2guZW5kKTtcbiAgICAgICAgICAgIGV2ZW50SG9sZGVyWzBdLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RvdWJsZXRhcCcsIGRvdWJsZVRhcC5yZWNlbnRlclBsb3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFuID0ge1xuICAgICAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBwcmVzZXROYXZpZ2F0aW9uU3RhdGUoZSwgJ3BhbicsIGdlc3R1cmVTdGF0ZSk7XG4gICAgICAgICAgICAgICAgdXBkYXRlRGF0YShlLCAncGFuJywgZ2VzdHVyZVN0YXRlLCBuYXZpZ2F0aW9uU3RhdGUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHVzZVNtYXJ0UGFuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IGdldFBvaW50KGUsICdwYW4nKTtcbiAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGlvblN0YXRlLmluaXRpYWxTdGF0ZSA9IHBsb3QubmF2aWdhdGlvblN0YXRlKHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGRyYWc6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBwcmVzZXROYXZpZ2F0aW9uU3RhdGUoZSwgJ3BhbicsIGdlc3R1cmVTdGF0ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodXNlU21hcnRQYW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50ID0gZ2V0UG9pbnQoZSwgJ3BhbicpO1xuICAgICAgICAgICAgICAgICAgICBwbG90LnNtYXJ0UGFuKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IG5hdmlnYXRpb25TdGF0ZS5pbml0aWFsU3RhdGUuc3RhcnRQYWdlWCAtIHBvaW50LngsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBuYXZpZ2F0aW9uU3RhdGUuaW5pdGlhbFN0YXRlLnN0YXJ0UGFnZVkgLSBwb2ludC55XG4gICAgICAgICAgICAgICAgICAgIH0sIG5hdmlnYXRpb25TdGF0ZS5pbml0aWFsU3RhdGUsIG5hdmlnYXRpb25TdGF0ZS50b3VjaGVkQXhpcywgZmFsc2UsIHNtYXJ0UGFuTG9jayk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh1c2VNYW51YWxQYW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcGxvdC5wYW4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogLWRlbHRhKGUsICdwYW4nLCBnZXN0dXJlU3RhdGUpLngsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IC1kZWx0YShlLCAncGFuJywgZ2VzdHVyZVN0YXRlKS55LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXhlczogbmF2aWdhdGlvblN0YXRlLnRvdWNoZWRBeGlzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVQcmV2UGFuUG9zaXRpb24oZSwgJ3BhbicsIGdlc3R1cmVTdGF0ZSwgbmF2aWdhdGlvblN0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBlbmQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBwcmVzZXROYXZpZ2F0aW9uU3RhdGUoZSwgJ3BhbicsIGdlc3R1cmVTdGF0ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodXNlU21hcnRQYW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcGxvdC5zbWFydFBhbi5lbmQoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAod2FzUGluY2hFdmVudChlLCBnZXN0dXJlU3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZXByZXZQYW5Qb3NpdGlvbihlLCAncGFuJywgZ2VzdHVyZVN0YXRlLCBuYXZpZ2F0aW9uU3RhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcGluY2hEcmFnVGltZW91dDtcbiAgICAgICAgcGluY2ggPSB7XG4gICAgICAgICAgICBzdGFydDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGlmIChwaW5jaERyYWdUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChwaW5jaERyYWdUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgcGluY2hEcmFnVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXNldE5hdmlnYXRpb25TdGF0ZShlLCAncGluY2gnLCBnZXN0dXJlU3RhdGUpO1xuICAgICAgICAgICAgICAgIHNldFByZXZEaXN0YW5jZShlLCBnZXN0dXJlU3RhdGUpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZURhdGEoZSwgJ3BpbmNoJywgZ2VzdHVyZVN0YXRlLCBuYXZpZ2F0aW9uU3RhdGUpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZHJhZzogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGlmIChwaW5jaERyYWdUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGluY2hEcmFnVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXNldE5hdmlnYXRpb25TdGF0ZShlLCAncGluY2gnLCBnZXN0dXJlU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBwbG90LnBhbih7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiAtZGVsdGEoZSwgJ3BpbmNoJywgZ2VzdHVyZVN0YXRlKS54LFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiAtZGVsdGEoZSwgJ3BpbmNoJywgZ2VzdHVyZVN0YXRlKS55LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXhlczogbmF2aWdhdGlvblN0YXRlLnRvdWNoZWRBeGlzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVQcmV2UGFuUG9zaXRpb24oZSwgJ3BpbmNoJywgZ2VzdHVyZVN0YXRlLCBuYXZpZ2F0aW9uU3RhdGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXN0ID0gcGluY2hEaXN0YW5jZShlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZ2VzdHVyZVN0YXRlLnpvb21FbmFibGUgfHwgTWF0aC5hYnMoZGlzdCAtIGdlc3R1cmVTdGF0ZS5wcmV2RGlzdGFuY2UpID4gWk9PTV9ESVNUQU5DRV9NQVJHSU4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHpvb21QbG90KHBsb3QsIGUsIGdlc3R1cmVTdGF0ZSwgbmF2aWdhdGlvblN0YXRlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9hY3RpdmF0ZSB6b29tIG1vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlc3R1cmVTdGF0ZS56b29tRW5hYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwaW5jaERyYWdUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9LCAxMDAwIC8gNjApO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZW5kOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBpbmNoRHJhZ1RpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHBpbmNoRHJhZ1RpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICBwaW5jaERyYWdUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJlc2V0TmF2aWdhdGlvblN0YXRlKGUsICdwaW5jaCcsIGdlc3R1cmVTdGF0ZSk7XG4gICAgICAgICAgICAgICAgZ2VzdHVyZVN0YXRlLnByZXZEaXN0YW5jZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZG91YmxlVGFwID0ge1xuICAgICAgICAgICAgcmVjZW50ZXJQbG90OiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUgJiYgZS5kZXRhaWwgJiYgZS5kZXRhaWwudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgZG8gbm90IHJlY2VudGVyIGZvciB0b3VjaCBzdGFydDtcbiAgICAgICAgICAgICAgICAgICAgcmVjZW50ZXJQbG90T25Eb3VibGVUYXAocGxvdCwgZSwgZ2VzdHVyZVN0YXRlLCBuYXZpZ2F0aW9uU3RhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAob3B0aW9ucy5wYW4uZW5hYmxlVG91Y2ggPT09IHRydWUgfHwgb3B0aW9ucy56b29tLmVuYWJsZVRvdWNoID09PSB0cnVlKSB7XG4gICAgICAgICAgICBwbG90Lmhvb2tzLmJpbmRFdmVudHMucHVzaChiaW5kRXZlbnRzKTtcbiAgICAgICAgICAgIHBsb3QuaG9va3Muc2h1dGRvd24ucHVzaChzaHV0ZG93bik7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwcmVzZXROYXZpZ2F0aW9uU3RhdGUoZSwgZ2VzdHVyZSwgZ2VzdHVyZVN0YXRlKSB7XG4gICAgICAgICAgICBuYXZpZ2F0aW9uU3RhdGUudG91Y2hlZEF4aXMgPSBnZXRBeGlzKHBsb3QsIGUsIGdlc3R1cmUsIG5hdmlnYXRpb25TdGF0ZSk7XG4gICAgICAgICAgICBpZiAobm9BeGlzVG91Y2hlZChuYXZpZ2F0aW9uU3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgbmF2aWdhdGlvblN0YXRlLm5hdmlnYXRpb25Db25zdHJhaW50ID0gJ3VuY29uc3RyYWluZWQnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuYXZpZ2F0aW9uU3RhdGUubmF2aWdhdGlvbkNvbnN0cmFpbnQgPSAnYXhpc0NvbnN0cmFpbmVkJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgICQucGxvdC5wbHVnaW5zLnB1c2goe1xuICAgICAgICBpbml0OiBpbml0LFxuICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICBuYW1lOiAnbmF2aWdhdGVUb3VjaCcsXG4gICAgICAgIHZlcnNpb246ICcwLjMnXG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiByZWNlbnRlclBsb3RPbkRvdWJsZVRhcChwbG90LCBlLCBnZXN0dXJlU3RhdGUsIG5hdmlnYXRpb25TdGF0ZSkge1xuICAgICAgICBjaGVja0F4ZXNGb3JEb3VibGVUYXAocGxvdCwgZSwgbmF2aWdhdGlvblN0YXRlKTtcbiAgICAgICAgaWYgKChuYXZpZ2F0aW9uU3RhdGUuY3VycmVudFRvdWNoZWRBeGlzID09PSAneCcgJiYgbmF2aWdhdGlvblN0YXRlLnByZXZUb3VjaGVkQXhpcyA9PT0gJ3gnKSB8fFxuICAgICAgICAgICAgKG5hdmlnYXRpb25TdGF0ZS5jdXJyZW50VG91Y2hlZEF4aXMgPT09ICd5JyAmJiBuYXZpZ2F0aW9uU3RhdGUucHJldlRvdWNoZWRBeGlzID09PSAneScpIHx8XG4gICAgICAgICAgICAobmF2aWdhdGlvblN0YXRlLmN1cnJlbnRUb3VjaGVkQXhpcyA9PT0gJ25vbmUnICYmIG5hdmlnYXRpb25TdGF0ZS5wcmV2VG91Y2hlZEF4aXMgPT09ICdub25lJykpIHtcbiAgICAgICAgICAgIHZhciBldmVudDtcblxuICAgICAgICAgICAgcGxvdC5yZWNlbnRlcih7IGF4ZXM6IG5hdmlnYXRpb25TdGF0ZS50b3VjaGVkQXhpcyB9KTtcblxuICAgICAgICAgICAgaWYgKG5hdmlnYXRpb25TdGF0ZS50b3VjaGVkQXhpcykge1xuICAgICAgICAgICAgICAgIGV2ZW50ID0gbmV3ICQuRXZlbnQoJ3JlLWNlbnRlcicsIHsgZGV0YWlsOiB7IGF4aXNUb3VjaGVkOiBuYXZpZ2F0aW9uU3RhdGUudG91Y2hlZEF4aXMgfSB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSBuZXcgJC5FdmVudCgncmUtY2VudGVyJywgeyBkZXRhaWw6IGUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwbG90LmdldFBsYWNlaG9sZGVyKCkudHJpZ2dlcihldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja0F4ZXNGb3JEb3VibGVUYXAocGxvdCwgZSwgbmF2aWdhdGlvblN0YXRlKSB7XG4gICAgICAgIHZhciBheGlzID0gcGxvdC5nZXRUb3VjaGVkQXhpcyhlLmRldGFpbC5maXJzdFRvdWNoLngsIGUuZGV0YWlsLmZpcnN0VG91Y2gueSk7XG4gICAgICAgIGlmIChheGlzWzBdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5hdmlnYXRpb25TdGF0ZS5wcmV2VG91Y2hlZEF4aXMgPSBheGlzWzBdLmRpcmVjdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGF4aXMgPSBwbG90LmdldFRvdWNoZWRBeGlzKGUuZGV0YWlsLnNlY29uZFRvdWNoLngsIGUuZGV0YWlsLnNlY29uZFRvdWNoLnkpO1xuICAgICAgICBpZiAoYXhpc1swXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuYXZpZ2F0aW9uU3RhdGUudG91Y2hlZEF4aXMgPSBheGlzO1xuICAgICAgICAgICAgbmF2aWdhdGlvblN0YXRlLmN1cnJlbnRUb3VjaGVkQXhpcyA9IGF4aXNbMF0uZGlyZWN0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vQXhpc1RvdWNoZWQobmF2aWdhdGlvblN0YXRlKSkge1xuICAgICAgICAgICAgbmF2aWdhdGlvblN0YXRlLnRvdWNoZWRBeGlzID0gbnVsbDtcbiAgICAgICAgICAgIG5hdmlnYXRpb25TdGF0ZS5wcmV2VG91Y2hlZEF4aXMgPSAnbm9uZSc7XG4gICAgICAgICAgICBuYXZpZ2F0aW9uU3RhdGUuY3VycmVudFRvdWNoZWRBeGlzID0gJ25vbmUnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gem9vbVBsb3QocGxvdCwgZSwgZ2VzdHVyZVN0YXRlLCBuYXZpZ2F0aW9uU3RhdGUpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHBsb3Qub2Zmc2V0KCksXG4gICAgICAgICAgICBjZW50ZXIgPSB7XG4gICAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgICAgICB0b3A6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB6b29tQW1vdW50ID0gcGluY2hEaXN0YW5jZShlKSAvIGdlc3R1cmVTdGF0ZS5wcmV2RGlzdGFuY2UsXG4gICAgICAgICAgICBkaXN0ID0gcGluY2hEaXN0YW5jZShlKTtcblxuICAgICAgICBjZW50ZXIubGVmdCA9IGdldFBvaW50KGUsICdwaW5jaCcpLnggLSBvZmZzZXQubGVmdDtcbiAgICAgICAgY2VudGVyLnRvcCA9IGdldFBvaW50KGUsICdwaW5jaCcpLnkgLSBvZmZzZXQudG9wO1xuXG4gICAgICAgIC8vIHNlbmQgdGhlIGNvbXB1dGVkIHRvdWNoZWQgYXhpcyB0byB0aGUgem9vbSBmdW5jdGlvbiBzbyB0aGF0IGl0IG9ubHkgem9vbXMgb24gdGhhdCBvbmVcbiAgICAgICAgcGxvdC56b29tKHtcbiAgICAgICAgICAgIGNlbnRlcjogY2VudGVyLFxuICAgICAgICAgICAgYW1vdW50OiB6b29tQW1vdW50LFxuICAgICAgICAgICAgYXhlczogbmF2aWdhdGlvblN0YXRlLnRvdWNoZWRBeGlzXG4gICAgICAgIH0pO1xuICAgICAgICBnZXN0dXJlU3RhdGUucHJldkRpc3RhbmNlID0gZGlzdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3YXNQaW5jaEV2ZW50KGUsIGdlc3R1cmVTdGF0ZSkge1xuICAgICAgICByZXR1cm4gKGdlc3R1cmVTdGF0ZS56b29tRW5hYmxlICYmIGUuZGV0YWlsLnRvdWNoZXMubGVuZ3RoID09PSAxKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRBeGlzKHBsb3QsIGUsIGdlc3R1cmUsIG5hdmlnYXRpb25TdGF0ZSkge1xuICAgICAgICBpZiAoZS50eXBlID09PSAncGluY2hzdGFydCcpIHtcbiAgICAgICAgICAgIHZhciBheGlzVG91Y2gxID0gcGxvdC5nZXRUb3VjaGVkQXhpcyhlLmRldGFpbC50b3VjaGVzWzBdLnBhZ2VYLCBlLmRldGFpbC50b3VjaGVzWzBdLnBhZ2VZKTtcbiAgICAgICAgICAgIHZhciBheGlzVG91Y2gyID0gcGxvdC5nZXRUb3VjaGVkQXhpcyhlLmRldGFpbC50b3VjaGVzWzFdLnBhZ2VYLCBlLmRldGFpbC50b3VjaGVzWzFdLnBhZ2VZKTtcblxuICAgICAgICAgICAgaWYgKGF4aXNUb3VjaDEubGVuZ3RoID09PSBheGlzVG91Y2gyLmxlbmd0aCAmJiBheGlzVG91Y2gxLnRvU3RyaW5nKCkgPT09IGF4aXNUb3VjaDIudG9TdHJpbmcoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBheGlzVG91Y2gxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGUudHlwZSA9PT0gJ3BhbnN0YXJ0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHBsb3QuZ2V0VG91Y2hlZEF4aXMoZS5kZXRhaWwudG91Y2hlc1swXS5wYWdlWCwgZS5kZXRhaWwudG91Y2hlc1swXS5wYWdlWSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZS50eXBlID09PSAncGluY2hlbmQnKSB7XG4gICAgICAgICAgICAvL3VwZGF0ZSBheGlzIHNpbmNlIGluc3RlYWQgb24gcGluY2gsIGEgcGFuIGV2ZW50IGlzIG1hZGVcbiAgICAgICAgICAgIHJldHVybiBwbG90LmdldFRvdWNoZWRBeGlzKGUuZGV0YWlsLnRvdWNoZXNbMF0ucGFnZVgsIGUuZGV0YWlsLnRvdWNoZXNbMF0ucGFnZVkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5hdmlnYXRpb25TdGF0ZS50b3VjaGVkQXhpcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vQXhpc1RvdWNoZWQobmF2aWdhdGlvblN0YXRlKSB7XG4gICAgICAgIHJldHVybiAoIW5hdmlnYXRpb25TdGF0ZS50b3VjaGVkQXhpcyB8fCBuYXZpZ2F0aW9uU3RhdGUudG91Y2hlZEF4aXMubGVuZ3RoID09PSAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRQcmV2RGlzdGFuY2UoZSwgZ2VzdHVyZVN0YXRlKSB7XG4gICAgICAgIGdlc3R1cmVTdGF0ZS5wcmV2RGlzdGFuY2UgPSBwaW5jaERpc3RhbmNlKGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZURhdGEoZSwgZ2VzdHVyZSwgZ2VzdHVyZVN0YXRlLCBuYXZpZ2F0aW9uU3RhdGUpIHtcbiAgICAgICAgdmFyIGF4aXNEaXIsXG4gICAgICAgICAgICBwb2ludCA9IGdldFBvaW50KGUsIGdlc3R1cmUpO1xuXG4gICAgICAgIHN3aXRjaCAobmF2aWdhdGlvblN0YXRlLm5hdmlnYXRpb25Db25zdHJhaW50KSB7XG4gICAgICAgICAgICBjYXNlICd1bmNvbnN0cmFpbmVkJzpcbiAgICAgICAgICAgICAgICBuYXZpZ2F0aW9uU3RhdGUudG91Y2hlZEF4aXMgPSBudWxsO1xuICAgICAgICAgICAgICAgIGdlc3R1cmVTdGF0ZS5wcmV2VGFwUG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGdlc3R1cmVTdGF0ZS5wcmV2UGFuUG9zaXRpb24ueCxcbiAgICAgICAgICAgICAgICAgICAgeTogZ2VzdHVyZVN0YXRlLnByZXZQYW5Qb3NpdGlvbi55XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBnZXN0dXJlU3RhdGUucHJldlBhblBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiBwb2ludC54LFxuICAgICAgICAgICAgICAgICAgICB5OiBwb2ludC55XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2F4aXNDb25zdHJhaW5lZCc6XG4gICAgICAgICAgICAgICAgYXhpc0RpciA9IG5hdmlnYXRpb25TdGF0ZS50b3VjaGVkQXhpc1swXS5kaXJlY3Rpb247XG4gICAgICAgICAgICAgICAgbmF2aWdhdGlvblN0YXRlLmN1cnJlbnRUb3VjaGVkQXhpcyA9IGF4aXNEaXI7XG4gICAgICAgICAgICAgICAgZ2VzdHVyZVN0YXRlLnByZXZUYXBQb3NpdGlvbltheGlzRGlyXSA9IGdlc3R1cmVTdGF0ZS5wcmV2UGFuUG9zaXRpb25bYXhpc0Rpcl07XG4gICAgICAgICAgICAgICAgZ2VzdHVyZVN0YXRlLnByZXZQYW5Qb3NpdGlvbltheGlzRGlyXSA9IHBvaW50W2F4aXNEaXJdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpc3RhbmNlKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoKHgxIC0geDIpICogKHgxIC0geDIpICsgKHkxIC0geTIpICogKHkxIC0geTIpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwaW5jaERpc3RhbmNlKGUpIHtcbiAgICAgICAgdmFyIHQxID0gZS5kZXRhaWwudG91Y2hlc1swXSxcbiAgICAgICAgICAgIHQyID0gZS5kZXRhaWwudG91Y2hlc1sxXTtcbiAgICAgICAgcmV0dXJuIGRpc3RhbmNlKHQxLnBhZ2VYLCB0MS5wYWdlWSwgdDIucGFnZVgsIHQyLnBhZ2VZKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVQcmV2UGFuUG9zaXRpb24oZSwgZ2VzdHVyZSwgZ2VzdHVyZVN0YXRlLCBuYXZpZ2F0aW9uU3RhdGUpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gZ2V0UG9pbnQoZSwgZ2VzdHVyZSk7XG5cbiAgICAgICAgc3dpdGNoIChuYXZpZ2F0aW9uU3RhdGUubmF2aWdhdGlvbkNvbnN0cmFpbnQpIHtcbiAgICAgICAgICAgIGNhc2UgJ3VuY29uc3RyYWluZWQnOlxuICAgICAgICAgICAgICAgIGdlc3R1cmVTdGF0ZS5wcmV2UGFuUG9zaXRpb24ueCA9IHBvaW50Lng7XG4gICAgICAgICAgICAgICAgZ2VzdHVyZVN0YXRlLnByZXZQYW5Qb3NpdGlvbi55ID0gcG9pbnQueTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2F4aXNDb25zdHJhaW5lZCc6XG4gICAgICAgICAgICAgICAgZ2VzdHVyZVN0YXRlLnByZXZQYW5Qb3NpdGlvbltuYXZpZ2F0aW9uU3RhdGUuY3VycmVudFRvdWNoZWRBeGlzXSA9XG4gICAgICAgICAgICAgICAgcG9pbnRbbmF2aWdhdGlvblN0YXRlLmN1cnJlbnRUb3VjaGVkQXhpc107XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVsdGEoZSwgZ2VzdHVyZSwgZ2VzdHVyZVN0YXRlKSB7XG4gICAgICAgIHZhciBwb2ludCA9IGdldFBvaW50KGUsIGdlc3R1cmUpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBwb2ludC54IC0gZ2VzdHVyZVN0YXRlLnByZXZQYW5Qb3NpdGlvbi54LFxuICAgICAgICAgICAgeTogcG9pbnQueSAtIGdlc3R1cmVTdGF0ZS5wcmV2UGFuUG9zaXRpb24ueVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UG9pbnQoZSwgZ2VzdHVyZSkge1xuICAgICAgICBpZiAoZ2VzdHVyZSA9PT0gJ3BpbmNoJykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiAoZS5kZXRhaWwudG91Y2hlc1swXS5wYWdlWCArIGUuZGV0YWlsLnRvdWNoZXNbMV0ucGFnZVgpIC8gMixcbiAgICAgICAgICAgICAgICB5OiAoZS5kZXRhaWwudG91Y2hlc1swXS5wYWdlWSArIGUuZGV0YWlsLnRvdWNoZXNbMV0ucGFnZVkpIC8gMlxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiBlLmRldGFpbC50b3VjaGVzWzBdLnBhZ2VYLFxuICAgICAgICAgICAgICAgIHk6IGUuZGV0YWlsLnRvdWNoZXNbMF0ucGFnZVlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pKGpRdWVyeSk7XG4iLCIoZnVuY3Rpb24gKCQpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgJC5wbG90LnVpQ29uc3RhbnRzID0ge1xuICAgICAgICBTTkFQUElOR19DT05TVEFOVDogMjAsXG4gICAgICAgIFBBTkhJTlRfTEVOR1RIX0NPTlNUQU5UOiAxMCxcbiAgICAgICAgTUlOT1JfVElDS1NfQ09VTlRfQ09OU1RBTlQ6IDQsXG4gICAgICAgIFRJQ0tfTEVOR1RIX0NPTlNUQU5UOiAxMCxcbiAgICAgICAgWk9PTV9ESVNUQU5DRV9NQVJHSU46IDI1XG4gICAgfTtcbn0pKGpRdWVyeSk7XG4iXSwic291cmNlUm9vdCI6IiJ9